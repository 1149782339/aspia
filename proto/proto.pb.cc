// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "proto.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace aspia {
namespace proto {

void protobuf_ShutdownFile_proto_2eproto() {
  PowerControl_default_instance_.Shutdown();
  KeyEvent_default_instance_.Shutdown();
  PointerEvent_default_instance_.Shutdown();
  Clipboard_default_instance_.Shutdown();
  ClipboardControl_default_instance_.Shutdown();
  CursorShape_default_instance_.Shutdown();
  BellEvent_default_instance_.Shutdown();
  HostToClient_default_instance_.Shutdown();
  Control_default_instance_.Shutdown();
  ClientToHost_default_instance_.Shutdown();
}

void protobuf_InitDefaults_proto_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::aspia::proto::protobuf_InitDefaults_auth_2eproto();
  ::aspia::proto::protobuf_InitDefaults_video_2eproto();
  PowerControl_default_instance_.DefaultConstruct();
  KeyEvent_default_instance_.DefaultConstruct();
  PointerEvent_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  Clipboard_default_instance_.DefaultConstruct();
  ClipboardControl_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  CursorShape_default_instance_.DefaultConstruct();
  BellEvent_default_instance_.DefaultConstruct();
  HostToClient_default_instance_.DefaultConstruct();
  Control_default_instance_.DefaultConstruct();
  ClientToHost_default_instance_.DefaultConstruct();
  PowerControl_default_instance_.get_mutable()->InitAsDefaultInstance();
  KeyEvent_default_instance_.get_mutable()->InitAsDefaultInstance();
  PointerEvent_default_instance_.get_mutable()->InitAsDefaultInstance();
  Clipboard_default_instance_.get_mutable()->InitAsDefaultInstance();
  ClipboardControl_default_instance_.get_mutable()->InitAsDefaultInstance();
  CursorShape_default_instance_.get_mutable()->InitAsDefaultInstance();
  BellEvent_default_instance_.get_mutable()->InitAsDefaultInstance();
  HostToClient_default_instance_.get_mutable()->InitAsDefaultInstance();
  Control_default_instance_.get_mutable()->InitAsDefaultInstance();
  ClientToHost_default_instance_.get_mutable()->InitAsDefaultInstance();
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_InitDefaults_proto_2eproto_once_);
void protobuf_InitDefaults_proto_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_InitDefaults_proto_2eproto_once_,
                 &protobuf_InitDefaults_proto_2eproto_impl);
}
void protobuf_AddDesc_proto_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  protobuf_InitDefaults_proto_2eproto();
  ::aspia::proto::protobuf_AddDesc_auth_2eproto();
  ::aspia::proto::protobuf_AddDesc_video_2eproto();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_proto_2eproto);
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_proto_2eproto_once_);
void protobuf_AddDesc_proto_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_proto_2eproto_once_,
                 &protobuf_AddDesc_proto_2eproto_impl);
}
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_proto_2eproto {
  StaticDescriptorInitializer_proto_2eproto() {
    protobuf_AddDesc_proto_2eproto();
  }
} static_descriptor_initializer_proto_2eproto_;
#endif  // GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
bool ClipboardEncoding_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool CursorShapeEncoding_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD GOOGLE_ATTRIBUTE_NORETURN;
static void MergeFromFail(int line) {
  ::google::protobuf::internal::MergeFromFail(__FILE__, line);
}

}  // namespace


// ===================================================================

bool PowerControl_Action_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const PowerControl_Action PowerControl::SHUTDOWN;
const PowerControl_Action PowerControl::REBOOT;
const PowerControl_Action PowerControl::HIBERNATE;
const PowerControl_Action PowerControl::SUSPEND;
const PowerControl_Action PowerControl::LOGOFF;
const PowerControl_Action PowerControl::Action_MIN;
const PowerControl_Action PowerControl::Action_MAX;
const int PowerControl::Action_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PowerControl::kActionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PowerControl::PowerControl()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_proto_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.PowerControl)
}

void PowerControl::InitAsDefaultInstance() {
}

PowerControl::PowerControl(const PowerControl& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.PowerControl)
}

void PowerControl::SharedCtor() {
  action_ = 0;
  _cached_size_ = 0;
}

PowerControl::~PowerControl() {
  // @@protoc_insertion_point(destructor:aspia.proto.PowerControl)
  SharedDtor();
}

void PowerControl::SharedDtor() {
}

void PowerControl::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PowerControl& PowerControl::default_instance() {
  protobuf_InitDefaults_proto_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<PowerControl> PowerControl_default_instance_;

PowerControl* PowerControl::New(::google::protobuf::Arena* arena) const {
  PowerControl* n = new PowerControl;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PowerControl::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.PowerControl)
  action_ = 0;
}

bool PowerControl::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.PowerControl)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aspia.proto.PowerControl.Action action = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_action(static_cast< ::aspia::proto::PowerControl_Action >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.PowerControl)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.PowerControl)
  return false;
#undef DO_
}

void PowerControl::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.PowerControl)
  // optional .aspia.proto.PowerControl.Action action = 1;
  if (this->action() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->action(), output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.PowerControl)
}

size_t PowerControl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.PowerControl)
  size_t total_size = 0;

  // optional .aspia.proto.PowerControl.Action action = 1;
  if (this->action() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->action());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PowerControl::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PowerControl*>(&from));
}

void PowerControl::MergeFrom(const PowerControl& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.PowerControl)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void PowerControl::UnsafeMergeFrom(const PowerControl& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.action() != 0) {
    set_action(from.action());
  }
}

void PowerControl::CopyFrom(const PowerControl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.PowerControl)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool PowerControl::IsInitialized() const {

  return true;
}

void PowerControl::Swap(PowerControl* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PowerControl::InternalSwap(PowerControl* other) {
  std::swap(action_, other->action_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PowerControl::GetTypeName() const {
  return "aspia.proto.PowerControl";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PowerControl

// optional .aspia.proto.PowerControl.Action action = 1;
void PowerControl::clear_action() {
  action_ = 0;
}
::aspia::proto::PowerControl_Action PowerControl::action() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerControl.action)
  return static_cast< ::aspia::proto::PowerControl_Action >(action_);
}
void PowerControl::set_action(::aspia::proto::PowerControl_Action value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerControl.action)
}

inline const PowerControl* PowerControl::internal_default_instance() {
  return &PowerControl_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

bool KeyEvent_Flags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const KeyEvent_Flags KeyEvent::UNKNOWN;
const KeyEvent_Flags KeyEvent::CAPSLOCK;
const KeyEvent_Flags KeyEvent::NUMLOCK;
const KeyEvent_Flags KeyEvent::EXTENDED;
const KeyEvent_Flags KeyEvent::PRESSED;
const KeyEvent_Flags KeyEvent::Flags_MIN;
const KeyEvent_Flags KeyEvent::Flags_MAX;
const int KeyEvent::Flags_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int KeyEvent::kKeycodeFieldNumber;
const int KeyEvent::kFlagsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

KeyEvent::KeyEvent()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_proto_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.KeyEvent)
}

void KeyEvent::InitAsDefaultInstance() {
}

KeyEvent::KeyEvent(const KeyEvent& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.KeyEvent)
}

void KeyEvent::SharedCtor() {
  ::memset(&keycode_, 0, reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&keycode_) + sizeof(flags_));
  _cached_size_ = 0;
}

KeyEvent::~KeyEvent() {
  // @@protoc_insertion_point(destructor:aspia.proto.KeyEvent)
  SharedDtor();
}

void KeyEvent::SharedDtor() {
}

void KeyEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const KeyEvent& KeyEvent::default_instance() {
  protobuf_InitDefaults_proto_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<KeyEvent> KeyEvent_default_instance_;

KeyEvent* KeyEvent::New(::google::protobuf::Arena* arena) const {
  KeyEvent* n = new KeyEvent;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void KeyEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.KeyEvent)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(KeyEvent, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<KeyEvent*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(keycode_, flags_);

#undef ZR_HELPER_
#undef ZR_

}

bool KeyEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.KeyEvent)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 keycode = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &keycode_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_flags;
        break;
      }

      // optional uint32 flags = 2;
      case 2: {
        if (tag == 16) {
         parse_flags:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.KeyEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.KeyEvent)
  return false;
#undef DO_
}

void KeyEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.KeyEvent)
  // optional uint32 keycode = 1;
  if (this->keycode() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->keycode(), output);
  }

  // optional uint32 flags = 2;
  if (this->flags() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->flags(), output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.KeyEvent)
}

size_t KeyEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.KeyEvent)
  size_t total_size = 0;

  // optional uint32 keycode = 1;
  if (this->keycode() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->keycode());
  }

  // optional uint32 flags = 2;
  if (this->flags() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->flags());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const KeyEvent*>(&from));
}

void KeyEvent::MergeFrom(const KeyEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.KeyEvent)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void KeyEvent::UnsafeMergeFrom(const KeyEvent& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.keycode() != 0) {
    set_keycode(from.keycode());
  }
  if (from.flags() != 0) {
    set_flags(from.flags());
  }
}

void KeyEvent::CopyFrom(const KeyEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.KeyEvent)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool KeyEvent::IsInitialized() const {

  return true;
}

void KeyEvent::Swap(KeyEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void KeyEvent::InternalSwap(KeyEvent* other) {
  std::swap(keycode_, other->keycode_);
  std::swap(flags_, other->flags_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string KeyEvent::GetTypeName() const {
  return "aspia.proto.KeyEvent";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// KeyEvent

// optional uint32 keycode = 1;
void KeyEvent::clear_keycode() {
  keycode_ = 0u;
}
::google::protobuf::uint32 KeyEvent::keycode() const {
  // @@protoc_insertion_point(field_get:aspia.proto.KeyEvent.keycode)
  return keycode_;
}
void KeyEvent::set_keycode(::google::protobuf::uint32 value) {
  
  keycode_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.KeyEvent.keycode)
}

// optional uint32 flags = 2;
void KeyEvent::clear_flags() {
  flags_ = 0u;
}
::google::protobuf::uint32 KeyEvent::flags() const {
  // @@protoc_insertion_point(field_get:aspia.proto.KeyEvent.flags)
  return flags_;
}
void KeyEvent::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.KeyEvent.flags)
}

inline const KeyEvent* KeyEvent::internal_default_instance() {
  return &KeyEvent_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

bool PointerEvent_ButtonMask_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const PointerEvent_ButtonMask PointerEvent::EMPTY;
const PointerEvent_ButtonMask PointerEvent::LEFT_BUTTON;
const PointerEvent_ButtonMask PointerEvent::MIDDLE_BUTTON;
const PointerEvent_ButtonMask PointerEvent::RIGHT_BUTTON;
const PointerEvent_ButtonMask PointerEvent::WHEEL_UP;
const PointerEvent_ButtonMask PointerEvent::WHEEL_DOWN;
const PointerEvent_ButtonMask PointerEvent::ButtonMask_MIN;
const PointerEvent_ButtonMask PointerEvent::ButtonMask_MAX;
const int PointerEvent::ButtonMask_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PointerEvent::kMaskFieldNumber;
const int PointerEvent::kXFieldNumber;
const int PointerEvent::kYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PointerEvent::PointerEvent()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_proto_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.PointerEvent)
}

void PointerEvent::InitAsDefaultInstance() {
}

PointerEvent::PointerEvent(const PointerEvent& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.PointerEvent)
}

void PointerEvent::SharedCtor() {
  ::memset(&mask_, 0, reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&mask_) + sizeof(y_));
  _cached_size_ = 0;
}

PointerEvent::~PointerEvent() {
  // @@protoc_insertion_point(destructor:aspia.proto.PointerEvent)
  SharedDtor();
}

void PointerEvent::SharedDtor() {
}

void PointerEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PointerEvent& PointerEvent::default_instance() {
  protobuf_InitDefaults_proto_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<PointerEvent> PointerEvent_default_instance_;

PointerEvent* PointerEvent::New(::google::protobuf::Arena* arena) const {
  PointerEvent* n = new PointerEvent;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PointerEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.PointerEvent)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(PointerEvent, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<PointerEvent*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(mask_, y_);

#undef ZR_HELPER_
#undef ZR_

}

bool PointerEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.PointerEvent)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 mask = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mask_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // optional int32 x = 2;
      case 2: {
        if (tag == 16) {
         parse_x:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // optional int32 y = 3;
      case 3: {
        if (tag == 24) {
         parse_y:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.PointerEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.PointerEvent)
  return false;
#undef DO_
}

void PointerEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.PointerEvent)
  // optional uint32 mask = 1;
  if (this->mask() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->mask(), output);
  }

  // optional int32 x = 2;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // optional int32 y = 3;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.PointerEvent)
}

size_t PointerEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.PointerEvent)
  size_t total_size = 0;

  // optional uint32 mask = 1;
  if (this->mask() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->mask());
  }

  // optional int32 x = 2;
  if (this->x() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  // optional int32 y = 3;
  if (this->y() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PointerEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PointerEvent*>(&from));
}

void PointerEvent::MergeFrom(const PointerEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.PointerEvent)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void PointerEvent::UnsafeMergeFrom(const PointerEvent& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.mask() != 0) {
    set_mask(from.mask());
  }
  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
}

void PointerEvent::CopyFrom(const PointerEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.PointerEvent)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool PointerEvent::IsInitialized() const {

  return true;
}

void PointerEvent::Swap(PointerEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PointerEvent::InternalSwap(PointerEvent* other) {
  std::swap(mask_, other->mask_);
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PointerEvent::GetTypeName() const {
  return "aspia.proto.PointerEvent";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PointerEvent

// optional uint32 mask = 1;
void PointerEvent::clear_mask() {
  mask_ = 0u;
}
::google::protobuf::uint32 PointerEvent::mask() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PointerEvent.mask)
  return mask_;
}
void PointerEvent::set_mask(::google::protobuf::uint32 value) {
  
  mask_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PointerEvent.mask)
}

// optional int32 x = 2;
void PointerEvent::clear_x() {
  x_ = 0;
}
::google::protobuf::int32 PointerEvent::x() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PointerEvent.x)
  return x_;
}
void PointerEvent::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PointerEvent.x)
}

// optional int32 y = 3;
void PointerEvent::clear_y() {
  y_ = 0;
}
::google::protobuf::int32 PointerEvent::y() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PointerEvent.y)
  return y_;
}
void PointerEvent::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PointerEvent.y)
}

inline const PointerEvent* PointerEvent::internal_default_instance() {
  return &PointerEvent_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Clipboard::kEncodingFieldNumber;
const int Clipboard::kMimeTypeFieldNumber;
const int Clipboard::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Clipboard::Clipboard()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_proto_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.Clipboard)
}

void Clipboard::InitAsDefaultInstance() {
}

Clipboard::Clipboard(const Clipboard& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.Clipboard)
}

void Clipboard::SharedCtor() {
  mime_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  encoding_ = 0;
  _cached_size_ = 0;
}

Clipboard::~Clipboard() {
  // @@protoc_insertion_point(destructor:aspia.proto.Clipboard)
  SharedDtor();
}

void Clipboard::SharedDtor() {
  mime_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Clipboard::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Clipboard& Clipboard::default_instance() {
  protobuf_InitDefaults_proto_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Clipboard> Clipboard_default_instance_;

Clipboard* Clipboard::New(::google::protobuf::Arena* arena) const {
  Clipboard* n = new Clipboard;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Clipboard::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.Clipboard)
  encoding_ = 0;
  mime_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Clipboard::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.Clipboard)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aspia.proto.ClipboardEncoding encoding = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_encoding(static_cast< ::aspia::proto::ClipboardEncoding >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_mime_type;
        break;
      }

      // optional string mime_type = 2;
      case 2: {
        if (tag == 18) {
         parse_mime_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mime_type()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->mime_type().data(), this->mime_type().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.Clipboard.mime_type"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // optional bytes data = 3;
      case 3: {
        if (tag == 26) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.Clipboard)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.Clipboard)
  return false;
#undef DO_
}

void Clipboard::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.Clipboard)
  // optional .aspia.proto.ClipboardEncoding encoding = 1;
  if (this->encoding() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->encoding(), output);
  }

  // optional string mime_type = 2;
  if (this->mime_type().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->mime_type().data(), this->mime_type().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.Clipboard.mime_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->mime_type(), output);
  }

  // optional bytes data = 3;
  if (this->data().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.Clipboard)
}

size_t Clipboard::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.Clipboard)
  size_t total_size = 0;

  // optional .aspia.proto.ClipboardEncoding encoding = 1;
  if (this->encoding() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->encoding());
  }

  // optional string mime_type = 2;
  if (this->mime_type().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->mime_type());
  }

  // optional bytes data = 3;
  if (this->data().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Clipboard::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Clipboard*>(&from));
}

void Clipboard::MergeFrom(const Clipboard& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.Clipboard)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Clipboard::UnsafeMergeFrom(const Clipboard& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.encoding() != 0) {
    set_encoding(from.encoding());
  }
  if (from.mime_type().size() > 0) {

    mime_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mime_type_);
  }
  if (from.data().size() > 0) {

    data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
}

void Clipboard::CopyFrom(const Clipboard& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.Clipboard)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Clipboard::IsInitialized() const {

  return true;
}

void Clipboard::Swap(Clipboard* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Clipboard::InternalSwap(Clipboard* other) {
  std::swap(encoding_, other->encoding_);
  mime_type_.Swap(&other->mime_type_);
  data_.Swap(&other->data_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Clipboard::GetTypeName() const {
  return "aspia.proto.Clipboard";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Clipboard

// optional .aspia.proto.ClipboardEncoding encoding = 1;
void Clipboard::clear_encoding() {
  encoding_ = 0;
}
::aspia::proto::ClipboardEncoding Clipboard::encoding() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Clipboard.encoding)
  return static_cast< ::aspia::proto::ClipboardEncoding >(encoding_);
}
void Clipboard::set_encoding(::aspia::proto::ClipboardEncoding value) {
  
  encoding_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Clipboard.encoding)
}

// optional string mime_type = 2;
void Clipboard::clear_mime_type() {
  mime_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Clipboard::mime_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Clipboard.mime_type)
  return mime_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Clipboard::set_mime_type(const ::std::string& value) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Clipboard.mime_type)
}
void Clipboard::set_mime_type(const char* value) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Clipboard.mime_type)
}
void Clipboard::set_mime_type(const char* value, size_t size) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Clipboard.mime_type)
}
::std::string* Clipboard::mutable_mime_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Clipboard.mime_type)
  return mime_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Clipboard::release_mime_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.Clipboard.mime_type)
  
  return mime_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Clipboard::set_allocated_mime_type(::std::string* mime_type) {
  if (mime_type != NULL) {
    
  } else {
    
  }
  mime_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mime_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Clipboard.mime_type)
}

// optional bytes data = 3;
void Clipboard::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Clipboard::data() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Clipboard.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Clipboard::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Clipboard.data)
}
void Clipboard::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Clipboard.data)
}
void Clipboard::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Clipboard.data)
}
::std::string* Clipboard::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Clipboard.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Clipboard::release_data() {
  // @@protoc_insertion_point(field_release:aspia.proto.Clipboard.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Clipboard::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Clipboard.data)
}

inline const Clipboard* Clipboard::internal_default_instance() {
  return &Clipboard_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

bool ClipboardControl_Flags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ClipboardControl_Flags ClipboardControl::DISABLE_AUTOSEND;
const ClipboardControl_Flags ClipboardControl::ENABLE_AUTOSEND;
const ClipboardControl_Flags ClipboardControl::REQUESTED;
const ClipboardControl_Flags ClipboardControl::Flags_MIN;
const ClipboardControl_Flags ClipboardControl::Flags_MAX;
const int ClipboardControl::Flags_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClipboardControl::kFlagsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClipboardControl::ClipboardControl()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_proto_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.ClipboardControl)
}

void ClipboardControl::InitAsDefaultInstance() {
}

ClipboardControl::ClipboardControl(const ClipboardControl& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.ClipboardControl)
}

void ClipboardControl::SharedCtor() {
  flags_ = 0u;
  _cached_size_ = 0;
}

ClipboardControl::~ClipboardControl() {
  // @@protoc_insertion_point(destructor:aspia.proto.ClipboardControl)
  SharedDtor();
}

void ClipboardControl::SharedDtor() {
}

void ClipboardControl::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClipboardControl& ClipboardControl::default_instance() {
  protobuf_InitDefaults_proto_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<ClipboardControl> ClipboardControl_default_instance_;

ClipboardControl* ClipboardControl::New(::google::protobuf::Arena* arena) const {
  ClipboardControl* n = new ClipboardControl;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClipboardControl::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.ClipboardControl)
  flags_ = 0u;
}

bool ClipboardControl::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.ClipboardControl)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 flags = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.ClipboardControl)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.ClipboardControl)
  return false;
#undef DO_
}

void ClipboardControl::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.ClipboardControl)
  // optional uint32 flags = 1;
  if (this->flags() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->flags(), output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.ClipboardControl)
}

size_t ClipboardControl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.ClipboardControl)
  size_t total_size = 0;

  // optional uint32 flags = 1;
  if (this->flags() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->flags());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClipboardControl::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClipboardControl*>(&from));
}

void ClipboardControl::MergeFrom(const ClipboardControl& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.ClipboardControl)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void ClipboardControl::UnsafeMergeFrom(const ClipboardControl& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.flags() != 0) {
    set_flags(from.flags());
  }
}

void ClipboardControl::CopyFrom(const ClipboardControl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.ClipboardControl)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool ClipboardControl::IsInitialized() const {

  return true;
}

void ClipboardControl::Swap(ClipboardControl* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClipboardControl::InternalSwap(ClipboardControl* other) {
  std::swap(flags_, other->flags_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ClipboardControl::GetTypeName() const {
  return "aspia.proto.ClipboardControl";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClipboardControl

// optional uint32 flags = 1;
void ClipboardControl::clear_flags() {
  flags_ = 0u;
}
::google::protobuf::uint32 ClipboardControl::flags() const {
  // @@protoc_insertion_point(field_get:aspia.proto.ClipboardControl.flags)
  return flags_;
}
void ClipboardControl::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.ClipboardControl.flags)
}

inline const ClipboardControl* ClipboardControl::internal_default_instance() {
  return &ClipboardControl_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CursorShape::kEncodingFieldNumber;
const int CursorShape::kWidthFieldNumber;
const int CursorShape::kHeightFieldNumber;
const int CursorShape::kHotspotXFieldNumber;
const int CursorShape::kHotspotYFieldNumber;
const int CursorShape::kDataFieldNumber;
const int CursorShape::kCacheIndexFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CursorShape::CursorShape()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_proto_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.CursorShape)
}

void CursorShape::InitAsDefaultInstance() {
}

CursorShape::CursorShape(const CursorShape& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.CursorShape)
}

void CursorShape::SharedCtor() {
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&encoding_, 0, reinterpret_cast<char*>(&cache_index_) -
    reinterpret_cast<char*>(&encoding_) + sizeof(cache_index_));
  _cached_size_ = 0;
}

CursorShape::~CursorShape() {
  // @@protoc_insertion_point(destructor:aspia.proto.CursorShape)
  SharedDtor();
}

void CursorShape::SharedDtor() {
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void CursorShape::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CursorShape& CursorShape::default_instance() {
  protobuf_InitDefaults_proto_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<CursorShape> CursorShape_default_instance_;

CursorShape* CursorShape::New(::google::protobuf::Arena* arena) const {
  CursorShape* n = new CursorShape;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CursorShape::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.CursorShape)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(CursorShape, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CursorShape*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(encoding_, cache_index_);
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool CursorShape::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.CursorShape)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aspia.proto.CursorShapeEncoding encoding = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_encoding(static_cast< ::aspia::proto::CursorShapeEncoding >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_width;
        break;
      }

      // optional int32 width = 2;
      case 2: {
        if (tag == 16) {
         parse_width:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_height;
        break;
      }

      // optional int32 height = 3;
      case 3: {
        if (tag == 24) {
         parse_height:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_hotspot_x;
        break;
      }

      // optional int32 hotspot_x = 4;
      case 4: {
        if (tag == 32) {
         parse_hotspot_x:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hotspot_x_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_hotspot_y;
        break;
      }

      // optional int32 hotspot_y = 5;
      case 5: {
        if (tag == 40) {
         parse_hotspot_y:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hotspot_y_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_data;
        break;
      }

      // optional bytes data = 6;
      case 6: {
        if (tag == 50) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_cache_index;
        break;
      }

      // optional int32 cache_index = 7;
      case 7: {
        if (tag == 56) {
         parse_cache_index:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cache_index_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.CursorShape)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.CursorShape)
  return false;
#undef DO_
}

void CursorShape::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.CursorShape)
  // optional .aspia.proto.CursorShapeEncoding encoding = 1;
  if (this->encoding() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->encoding(), output);
  }

  // optional int32 width = 2;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->width(), output);
  }

  // optional int32 height = 3;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->height(), output);
  }

  // optional int32 hotspot_x = 4;
  if (this->hotspot_x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->hotspot_x(), output);
  }

  // optional int32 hotspot_y = 5;
  if (this->hotspot_y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->hotspot_y(), output);
  }

  // optional bytes data = 6;
  if (this->data().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->data(), output);
  }

  // optional int32 cache_index = 7;
  if (this->cache_index() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->cache_index(), output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.CursorShape)
}

size_t CursorShape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.CursorShape)
  size_t total_size = 0;

  // optional .aspia.proto.CursorShapeEncoding encoding = 1;
  if (this->encoding() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->encoding());
  }

  // optional int32 width = 2;
  if (this->width() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->width());
  }

  // optional int32 height = 3;
  if (this->height() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->height());
  }

  // optional int32 hotspot_x = 4;
  if (this->hotspot_x() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->hotspot_x());
  }

  // optional int32 hotspot_y = 5;
  if (this->hotspot_y() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->hotspot_y());
  }

  // optional bytes data = 6;
  if (this->data().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());
  }

  // optional int32 cache_index = 7;
  if (this->cache_index() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->cache_index());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CursorShape::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CursorShape*>(&from));
}

void CursorShape::MergeFrom(const CursorShape& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.CursorShape)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void CursorShape::UnsafeMergeFrom(const CursorShape& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.encoding() != 0) {
    set_encoding(from.encoding());
  }
  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
  if (from.hotspot_x() != 0) {
    set_hotspot_x(from.hotspot_x());
  }
  if (from.hotspot_y() != 0) {
    set_hotspot_y(from.hotspot_y());
  }
  if (from.data().size() > 0) {

    data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
  if (from.cache_index() != 0) {
    set_cache_index(from.cache_index());
  }
}

void CursorShape::CopyFrom(const CursorShape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.CursorShape)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool CursorShape::IsInitialized() const {

  return true;
}

void CursorShape::Swap(CursorShape* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CursorShape::InternalSwap(CursorShape* other) {
  std::swap(encoding_, other->encoding_);
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  std::swap(hotspot_x_, other->hotspot_x_);
  std::swap(hotspot_y_, other->hotspot_y_);
  data_.Swap(&other->data_);
  std::swap(cache_index_, other->cache_index_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string CursorShape::GetTypeName() const {
  return "aspia.proto.CursorShape";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CursorShape

// optional .aspia.proto.CursorShapeEncoding encoding = 1;
void CursorShape::clear_encoding() {
  encoding_ = 0;
}
::aspia::proto::CursorShapeEncoding CursorShape::encoding() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.encoding)
  return static_cast< ::aspia::proto::CursorShapeEncoding >(encoding_);
}
void CursorShape::set_encoding(::aspia::proto::CursorShapeEncoding value) {
  
  encoding_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.encoding)
}

// optional int32 width = 2;
void CursorShape::clear_width() {
  width_ = 0;
}
::google::protobuf::int32 CursorShape::width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.width)
  return width_;
}
void CursorShape::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.width)
}

// optional int32 height = 3;
void CursorShape::clear_height() {
  height_ = 0;
}
::google::protobuf::int32 CursorShape::height() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.height)
  return height_;
}
void CursorShape::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.height)
}

// optional int32 hotspot_x = 4;
void CursorShape::clear_hotspot_x() {
  hotspot_x_ = 0;
}
::google::protobuf::int32 CursorShape::hotspot_x() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.hotspot_x)
  return hotspot_x_;
}
void CursorShape::set_hotspot_x(::google::protobuf::int32 value) {
  
  hotspot_x_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.hotspot_x)
}

// optional int32 hotspot_y = 5;
void CursorShape::clear_hotspot_y() {
  hotspot_y_ = 0;
}
::google::protobuf::int32 CursorShape::hotspot_y() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.hotspot_y)
  return hotspot_y_;
}
void CursorShape::set_hotspot_y(::google::protobuf::int32 value) {
  
  hotspot_y_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.hotspot_y)
}

// optional bytes data = 6;
void CursorShape::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& CursorShape::data() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void CursorShape::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.data)
}
void CursorShape::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.CursorShape.data)
}
void CursorShape::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.CursorShape.data)
}
::std::string* CursorShape::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.CursorShape.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* CursorShape::release_data() {
  // @@protoc_insertion_point(field_release:aspia.proto.CursorShape.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void CursorShape::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.CursorShape.data)
}

// optional int32 cache_index = 7;
void CursorShape::clear_cache_index() {
  cache_index_ = 0;
}
::google::protobuf::int32 CursorShape::cache_index() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.cache_index)
  return cache_index_;
}
void CursorShape::set_cache_index(::google::protobuf::int32 value) {
  
  cache_index_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.cache_index)
}

inline const CursorShape* CursorShape::internal_default_instance() {
  return &CursorShape_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BellEvent::kFlagsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BellEvent::BellEvent()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_proto_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.BellEvent)
}

void BellEvent::InitAsDefaultInstance() {
}

BellEvent::BellEvent(const BellEvent& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.BellEvent)
}

void BellEvent::SharedCtor() {
  flags_ = 0u;
  _cached_size_ = 0;
}

BellEvent::~BellEvent() {
  // @@protoc_insertion_point(destructor:aspia.proto.BellEvent)
  SharedDtor();
}

void BellEvent::SharedDtor() {
}

void BellEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BellEvent& BellEvent::default_instance() {
  protobuf_InitDefaults_proto_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<BellEvent> BellEvent_default_instance_;

BellEvent* BellEvent::New(::google::protobuf::Arena* arena) const {
  BellEvent* n = new BellEvent;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BellEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.BellEvent)
  flags_ = 0u;
}

bool BellEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.BellEvent)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 flags = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.BellEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.BellEvent)
  return false;
#undef DO_
}

void BellEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.BellEvent)
  // optional uint32 flags = 1;
  if (this->flags() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->flags(), output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.BellEvent)
}

size_t BellEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.BellEvent)
  size_t total_size = 0;

  // optional uint32 flags = 1;
  if (this->flags() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->flags());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BellEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BellEvent*>(&from));
}

void BellEvent::MergeFrom(const BellEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.BellEvent)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void BellEvent::UnsafeMergeFrom(const BellEvent& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.flags() != 0) {
    set_flags(from.flags());
  }
}

void BellEvent::CopyFrom(const BellEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.BellEvent)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool BellEvent::IsInitialized() const {

  return true;
}

void BellEvent::Swap(BellEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BellEvent::InternalSwap(BellEvent* other) {
  std::swap(flags_, other->flags_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string BellEvent::GetTypeName() const {
  return "aspia.proto.BellEvent";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BellEvent

// optional uint32 flags = 1;
void BellEvent::clear_flags() {
  flags_ = 0u;
}
::google::protobuf::uint32 BellEvent::flags() const {
  // @@protoc_insertion_point(field_get:aspia.proto.BellEvent.flags)
  return flags_;
}
void BellEvent::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.BellEvent.flags)
}

inline const BellEvent* BellEvent::internal_default_instance() {
  return &BellEvent_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HostToClient::kVideoPacketFieldNumber;
const int HostToClient::kCursorFieldNumber;
const int HostToClient::kClipboardFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HostToClient::HostToClient()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_proto_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.HostToClient)
}

void HostToClient::InitAsDefaultInstance() {
  video_packet_ = const_cast< ::aspia::proto::VideoPacket*>(
      ::aspia::proto::VideoPacket::internal_default_instance());
  cursor_ = const_cast< ::aspia::proto::CursorShape*>(
      ::aspia::proto::CursorShape::internal_default_instance());
  clipboard_ = const_cast< ::aspia::proto::Clipboard*>(
      ::aspia::proto::Clipboard::internal_default_instance());
}

HostToClient::HostToClient(const HostToClient& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.HostToClient)
}

void HostToClient::SharedCtor() {
  video_packet_ = NULL;
  cursor_ = NULL;
  clipboard_ = NULL;
  _cached_size_ = 0;
}

HostToClient::~HostToClient() {
  // @@protoc_insertion_point(destructor:aspia.proto.HostToClient)
  SharedDtor();
}

void HostToClient::SharedDtor() {
  if (this != &HostToClient_default_instance_.get()) {
    delete video_packet_;
    delete cursor_;
    delete clipboard_;
  }
}

void HostToClient::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HostToClient& HostToClient::default_instance() {
  protobuf_InitDefaults_proto_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<HostToClient> HostToClient_default_instance_;

HostToClient* HostToClient::New(::google::protobuf::Arena* arena) const {
  HostToClient* n = new HostToClient;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HostToClient::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.HostToClient)
  if (GetArenaNoVirtual() == NULL && video_packet_ != NULL) delete video_packet_;
  video_packet_ = NULL;
  if (GetArenaNoVirtual() == NULL && cursor_ != NULL) delete cursor_;
  cursor_ = NULL;
  if (GetArenaNoVirtual() == NULL && clipboard_ != NULL) delete clipboard_;
  clipboard_ = NULL;
}

bool HostToClient::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.HostToClient)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aspia.proto.VideoPacket video_packet = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_video_packet()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_cursor;
        break;
      }

      // optional .aspia.proto.CursorShape cursor = 2;
      case 2: {
        if (tag == 18) {
         parse_cursor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cursor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_clipboard;
        break;
      }

      // optional .aspia.proto.Clipboard clipboard = 3;
      case 3: {
        if (tag == 26) {
         parse_clipboard:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_clipboard()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.HostToClient)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.HostToClient)
  return false;
#undef DO_
}

void HostToClient::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.HostToClient)
  // optional .aspia.proto.VideoPacket video_packet = 1;
  if (this->has_video_packet()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->video_packet_, output);
  }

  // optional .aspia.proto.CursorShape cursor = 2;
  if (this->has_cursor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->cursor_, output);
  }

  // optional .aspia.proto.Clipboard clipboard = 3;
  if (this->has_clipboard()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->clipboard_, output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.HostToClient)
}

size_t HostToClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.HostToClient)
  size_t total_size = 0;

  // optional .aspia.proto.VideoPacket video_packet = 1;
  if (this->has_video_packet()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->video_packet_);
  }

  // optional .aspia.proto.CursorShape cursor = 2;
  if (this->has_cursor()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->cursor_);
  }

  // optional .aspia.proto.Clipboard clipboard = 3;
  if (this->has_clipboard()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->clipboard_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HostToClient::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HostToClient*>(&from));
}

void HostToClient::MergeFrom(const HostToClient& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.HostToClient)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void HostToClient::UnsafeMergeFrom(const HostToClient& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.has_video_packet()) {
    mutable_video_packet()->::aspia::proto::VideoPacket::MergeFrom(from.video_packet());
  }
  if (from.has_cursor()) {
    mutable_cursor()->::aspia::proto::CursorShape::MergeFrom(from.cursor());
  }
  if (from.has_clipboard()) {
    mutable_clipboard()->::aspia::proto::Clipboard::MergeFrom(from.clipboard());
  }
}

void HostToClient::CopyFrom(const HostToClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.HostToClient)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool HostToClient::IsInitialized() const {

  return true;
}

void HostToClient::Swap(HostToClient* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HostToClient::InternalSwap(HostToClient* other) {
  std::swap(video_packet_, other->video_packet_);
  std::swap(cursor_, other->cursor_);
  std::swap(clipboard_, other->clipboard_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string HostToClient::GetTypeName() const {
  return "aspia.proto.HostToClient";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HostToClient

// optional .aspia.proto.VideoPacket video_packet = 1;
bool HostToClient::has_video_packet() const {
  return this != internal_default_instance() && video_packet_ != NULL;
}
void HostToClient::clear_video_packet() {
  if (GetArenaNoVirtual() == NULL && video_packet_ != NULL) delete video_packet_;
  video_packet_ = NULL;
}
const ::aspia::proto::VideoPacket& HostToClient::video_packet() const {
  // @@protoc_insertion_point(field_get:aspia.proto.HostToClient.video_packet)
  return video_packet_ != NULL ? *video_packet_
                         : *::aspia::proto::VideoPacket::internal_default_instance();
}
::aspia::proto::VideoPacket* HostToClient::mutable_video_packet() {
  
  if (video_packet_ == NULL) {
    video_packet_ = new ::aspia::proto::VideoPacket;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.HostToClient.video_packet)
  return video_packet_;
}
::aspia::proto::VideoPacket* HostToClient::release_video_packet() {
  // @@protoc_insertion_point(field_release:aspia.proto.HostToClient.video_packet)
  
  ::aspia::proto::VideoPacket* temp = video_packet_;
  video_packet_ = NULL;
  return temp;
}
void HostToClient::set_allocated_video_packet(::aspia::proto::VideoPacket* video_packet) {
  delete video_packet_;
  video_packet_ = video_packet;
  if (video_packet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.HostToClient.video_packet)
}

// optional .aspia.proto.CursorShape cursor = 2;
bool HostToClient::has_cursor() const {
  return this != internal_default_instance() && cursor_ != NULL;
}
void HostToClient::clear_cursor() {
  if (GetArenaNoVirtual() == NULL && cursor_ != NULL) delete cursor_;
  cursor_ = NULL;
}
const ::aspia::proto::CursorShape& HostToClient::cursor() const {
  // @@protoc_insertion_point(field_get:aspia.proto.HostToClient.cursor)
  return cursor_ != NULL ? *cursor_
                         : *::aspia::proto::CursorShape::internal_default_instance();
}
::aspia::proto::CursorShape* HostToClient::mutable_cursor() {
  
  if (cursor_ == NULL) {
    cursor_ = new ::aspia::proto::CursorShape;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.HostToClient.cursor)
  return cursor_;
}
::aspia::proto::CursorShape* HostToClient::release_cursor() {
  // @@protoc_insertion_point(field_release:aspia.proto.HostToClient.cursor)
  
  ::aspia::proto::CursorShape* temp = cursor_;
  cursor_ = NULL;
  return temp;
}
void HostToClient::set_allocated_cursor(::aspia::proto::CursorShape* cursor) {
  delete cursor_;
  cursor_ = cursor;
  if (cursor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.HostToClient.cursor)
}

// optional .aspia.proto.Clipboard clipboard = 3;
bool HostToClient::has_clipboard() const {
  return this != internal_default_instance() && clipboard_ != NULL;
}
void HostToClient::clear_clipboard() {
  if (GetArenaNoVirtual() == NULL && clipboard_ != NULL) delete clipboard_;
  clipboard_ = NULL;
}
const ::aspia::proto::Clipboard& HostToClient::clipboard() const {
  // @@protoc_insertion_point(field_get:aspia.proto.HostToClient.clipboard)
  return clipboard_ != NULL ? *clipboard_
                         : *::aspia::proto::Clipboard::internal_default_instance();
}
::aspia::proto::Clipboard* HostToClient::mutable_clipboard() {
  
  if (clipboard_ == NULL) {
    clipboard_ = new ::aspia::proto::Clipboard;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.HostToClient.clipboard)
  return clipboard_;
}
::aspia::proto::Clipboard* HostToClient::release_clipboard() {
  // @@protoc_insertion_point(field_release:aspia.proto.HostToClient.clipboard)
  
  ::aspia::proto::Clipboard* temp = clipboard_;
  clipboard_ = NULL;
  return temp;
}
void HostToClient::set_allocated_clipboard(::aspia::proto::Clipboard* clipboard) {
  delete clipboard_;
  clipboard_ = clipboard;
  if (clipboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.HostToClient.clipboard)
}

inline const HostToClient* HostToClient::internal_default_instance() {
  return &HostToClient_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Control::kVideoFieldNumber;
const int Control::kClipboardFieldNumber;
const int Control::kPowerFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Control::Control()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_proto_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.Control)
}

void Control::InitAsDefaultInstance() {
  video_ = const_cast< ::aspia::proto::VideoControl*>(
      ::aspia::proto::VideoControl::internal_default_instance());
  clipboard_ = const_cast< ::aspia::proto::ClipboardControl*>(
      ::aspia::proto::ClipboardControl::internal_default_instance());
  power_ = const_cast< ::aspia::proto::PowerControl*>(
      ::aspia::proto::PowerControl::internal_default_instance());
}

Control::Control(const Control& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.Control)
}

void Control::SharedCtor() {
  video_ = NULL;
  clipboard_ = NULL;
  power_ = NULL;
  _cached_size_ = 0;
}

Control::~Control() {
  // @@protoc_insertion_point(destructor:aspia.proto.Control)
  SharedDtor();
}

void Control::SharedDtor() {
  if (this != &Control_default_instance_.get()) {
    delete video_;
    delete clipboard_;
    delete power_;
  }
}

void Control::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Control& Control::default_instance() {
  protobuf_InitDefaults_proto_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Control> Control_default_instance_;

Control* Control::New(::google::protobuf::Arena* arena) const {
  Control* n = new Control;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Control::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.Control)
  if (GetArenaNoVirtual() == NULL && video_ != NULL) delete video_;
  video_ = NULL;
  if (GetArenaNoVirtual() == NULL && clipboard_ != NULL) delete clipboard_;
  clipboard_ = NULL;
  if (GetArenaNoVirtual() == NULL && power_ != NULL) delete power_;
  power_ = NULL;
}

bool Control::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.Control)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aspia.proto.VideoControl video = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_video()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_clipboard;
        break;
      }

      // optional .aspia.proto.ClipboardControl clipboard = 2;
      case 2: {
        if (tag == 18) {
         parse_clipboard:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_clipboard()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_power;
        break;
      }

      // optional .aspia.proto.PowerControl power = 3;
      case 3: {
        if (tag == 26) {
         parse_power:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_power()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.Control)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.Control)
  return false;
#undef DO_
}

void Control::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.Control)
  // optional .aspia.proto.VideoControl video = 1;
  if (this->has_video()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->video_, output);
  }

  // optional .aspia.proto.ClipboardControl clipboard = 2;
  if (this->has_clipboard()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->clipboard_, output);
  }

  // optional .aspia.proto.PowerControl power = 3;
  if (this->has_power()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->power_, output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.Control)
}

size_t Control::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.Control)
  size_t total_size = 0;

  // optional .aspia.proto.VideoControl video = 1;
  if (this->has_video()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->video_);
  }

  // optional .aspia.proto.ClipboardControl clipboard = 2;
  if (this->has_clipboard()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->clipboard_);
  }

  // optional .aspia.proto.PowerControl power = 3;
  if (this->has_power()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->power_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Control::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Control*>(&from));
}

void Control::MergeFrom(const Control& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.Control)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Control::UnsafeMergeFrom(const Control& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.has_video()) {
    mutable_video()->::aspia::proto::VideoControl::MergeFrom(from.video());
  }
  if (from.has_clipboard()) {
    mutable_clipboard()->::aspia::proto::ClipboardControl::MergeFrom(from.clipboard());
  }
  if (from.has_power()) {
    mutable_power()->::aspia::proto::PowerControl::MergeFrom(from.power());
  }
}

void Control::CopyFrom(const Control& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.Control)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Control::IsInitialized() const {

  return true;
}

void Control::Swap(Control* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Control::InternalSwap(Control* other) {
  std::swap(video_, other->video_);
  std::swap(clipboard_, other->clipboard_);
  std::swap(power_, other->power_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Control::GetTypeName() const {
  return "aspia.proto.Control";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Control

// optional .aspia.proto.VideoControl video = 1;
bool Control::has_video() const {
  return this != internal_default_instance() && video_ != NULL;
}
void Control::clear_video() {
  if (GetArenaNoVirtual() == NULL && video_ != NULL) delete video_;
  video_ = NULL;
}
const ::aspia::proto::VideoControl& Control::video() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Control.video)
  return video_ != NULL ? *video_
                         : *::aspia::proto::VideoControl::internal_default_instance();
}
::aspia::proto::VideoControl* Control::mutable_video() {
  
  if (video_ == NULL) {
    video_ = new ::aspia::proto::VideoControl;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.Control.video)
  return video_;
}
::aspia::proto::VideoControl* Control::release_video() {
  // @@protoc_insertion_point(field_release:aspia.proto.Control.video)
  
  ::aspia::proto::VideoControl* temp = video_;
  video_ = NULL;
  return temp;
}
void Control::set_allocated_video(::aspia::proto::VideoControl* video) {
  delete video_;
  video_ = video;
  if (video) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Control.video)
}

// optional .aspia.proto.ClipboardControl clipboard = 2;
bool Control::has_clipboard() const {
  return this != internal_default_instance() && clipboard_ != NULL;
}
void Control::clear_clipboard() {
  if (GetArenaNoVirtual() == NULL && clipboard_ != NULL) delete clipboard_;
  clipboard_ = NULL;
}
const ::aspia::proto::ClipboardControl& Control::clipboard() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Control.clipboard)
  return clipboard_ != NULL ? *clipboard_
                         : *::aspia::proto::ClipboardControl::internal_default_instance();
}
::aspia::proto::ClipboardControl* Control::mutable_clipboard() {
  
  if (clipboard_ == NULL) {
    clipboard_ = new ::aspia::proto::ClipboardControl;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.Control.clipboard)
  return clipboard_;
}
::aspia::proto::ClipboardControl* Control::release_clipboard() {
  // @@protoc_insertion_point(field_release:aspia.proto.Control.clipboard)
  
  ::aspia::proto::ClipboardControl* temp = clipboard_;
  clipboard_ = NULL;
  return temp;
}
void Control::set_allocated_clipboard(::aspia::proto::ClipboardControl* clipboard) {
  delete clipboard_;
  clipboard_ = clipboard;
  if (clipboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Control.clipboard)
}

// optional .aspia.proto.PowerControl power = 3;
bool Control::has_power() const {
  return this != internal_default_instance() && power_ != NULL;
}
void Control::clear_power() {
  if (GetArenaNoVirtual() == NULL && power_ != NULL) delete power_;
  power_ = NULL;
}
const ::aspia::proto::PowerControl& Control::power() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Control.power)
  return power_ != NULL ? *power_
                         : *::aspia::proto::PowerControl::internal_default_instance();
}
::aspia::proto::PowerControl* Control::mutable_power() {
  
  if (power_ == NULL) {
    power_ = new ::aspia::proto::PowerControl;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.Control.power)
  return power_;
}
::aspia::proto::PowerControl* Control::release_power() {
  // @@protoc_insertion_point(field_release:aspia.proto.Control.power)
  
  ::aspia::proto::PowerControl* temp = power_;
  power_ = NULL;
  return temp;
}
void Control::set_allocated_power(::aspia::proto::PowerControl* power) {
  delete power_;
  power_ = power;
  if (power) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Control.power)
}

inline const Control* Control::internal_default_instance() {
  return &Control_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClientToHost::kPointerEventFieldNumber;
const int ClientToHost::kKeyEventFieldNumber;
const int ClientToHost::kBellEventFieldNumber;
const int ClientToHost::kClipboardFieldNumber;
const int ClientToHost::kControlFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClientToHost::ClientToHost()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_proto_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.ClientToHost)
}

void ClientToHost::InitAsDefaultInstance() {
  pointer_event_ = const_cast< ::aspia::proto::PointerEvent*>(
      ::aspia::proto::PointerEvent::internal_default_instance());
  key_event_ = const_cast< ::aspia::proto::KeyEvent*>(
      ::aspia::proto::KeyEvent::internal_default_instance());
  bell_event_ = const_cast< ::aspia::proto::BellEvent*>(
      ::aspia::proto::BellEvent::internal_default_instance());
  clipboard_ = const_cast< ::aspia::proto::Clipboard*>(
      ::aspia::proto::Clipboard::internal_default_instance());
  control_ = const_cast< ::aspia::proto::Control*>(
      ::aspia::proto::Control::internal_default_instance());
}

ClientToHost::ClientToHost(const ClientToHost& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.ClientToHost)
}

void ClientToHost::SharedCtor() {
  pointer_event_ = NULL;
  key_event_ = NULL;
  bell_event_ = NULL;
  clipboard_ = NULL;
  control_ = NULL;
  _cached_size_ = 0;
}

ClientToHost::~ClientToHost() {
  // @@protoc_insertion_point(destructor:aspia.proto.ClientToHost)
  SharedDtor();
}

void ClientToHost::SharedDtor() {
  if (this != &ClientToHost_default_instance_.get()) {
    delete pointer_event_;
    delete key_event_;
    delete bell_event_;
    delete clipboard_;
    delete control_;
  }
}

void ClientToHost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientToHost& ClientToHost::default_instance() {
  protobuf_InitDefaults_proto_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<ClientToHost> ClientToHost_default_instance_;

ClientToHost* ClientToHost::New(::google::protobuf::Arena* arena) const {
  ClientToHost* n = new ClientToHost;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClientToHost::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.ClientToHost)
  if (GetArenaNoVirtual() == NULL && pointer_event_ != NULL) delete pointer_event_;
  pointer_event_ = NULL;
  if (GetArenaNoVirtual() == NULL && key_event_ != NULL) delete key_event_;
  key_event_ = NULL;
  if (GetArenaNoVirtual() == NULL && bell_event_ != NULL) delete bell_event_;
  bell_event_ = NULL;
  if (GetArenaNoVirtual() == NULL && clipboard_ != NULL) delete clipboard_;
  clipboard_ = NULL;
  if (GetArenaNoVirtual() == NULL && control_ != NULL) delete control_;
  control_ = NULL;
}

bool ClientToHost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.ClientToHost)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aspia.proto.PointerEvent pointer_event = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pointer_event()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_key_event;
        break;
      }

      // optional .aspia.proto.KeyEvent key_event = 2;
      case 2: {
        if (tag == 18) {
         parse_key_event:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_key_event()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_bell_event;
        break;
      }

      // optional .aspia.proto.BellEvent bell_event = 3;
      case 3: {
        if (tag == 26) {
         parse_bell_event:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bell_event()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_clipboard;
        break;
      }

      // optional .aspia.proto.Clipboard clipboard = 4;
      case 4: {
        if (tag == 34) {
         parse_clipboard:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_clipboard()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_control;
        break;
      }

      // optional .aspia.proto.Control control = 5;
      case 5: {
        if (tag == 42) {
         parse_control:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_control()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.ClientToHost)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.ClientToHost)
  return false;
#undef DO_
}

void ClientToHost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.ClientToHost)
  // optional .aspia.proto.PointerEvent pointer_event = 1;
  if (this->has_pointer_event()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->pointer_event_, output);
  }

  // optional .aspia.proto.KeyEvent key_event = 2;
  if (this->has_key_event()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->key_event_, output);
  }

  // optional .aspia.proto.BellEvent bell_event = 3;
  if (this->has_bell_event()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->bell_event_, output);
  }

  // optional .aspia.proto.Clipboard clipboard = 4;
  if (this->has_clipboard()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->clipboard_, output);
  }

  // optional .aspia.proto.Control control = 5;
  if (this->has_control()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->control_, output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.ClientToHost)
}

size_t ClientToHost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.ClientToHost)
  size_t total_size = 0;

  // optional .aspia.proto.PointerEvent pointer_event = 1;
  if (this->has_pointer_event()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pointer_event_);
  }

  // optional .aspia.proto.KeyEvent key_event = 2;
  if (this->has_key_event()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->key_event_);
  }

  // optional .aspia.proto.BellEvent bell_event = 3;
  if (this->has_bell_event()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->bell_event_);
  }

  // optional .aspia.proto.Clipboard clipboard = 4;
  if (this->has_clipboard()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->clipboard_);
  }

  // optional .aspia.proto.Control control = 5;
  if (this->has_control()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->control_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientToHost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClientToHost*>(&from));
}

void ClientToHost::MergeFrom(const ClientToHost& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.ClientToHost)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void ClientToHost::UnsafeMergeFrom(const ClientToHost& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.has_pointer_event()) {
    mutable_pointer_event()->::aspia::proto::PointerEvent::MergeFrom(from.pointer_event());
  }
  if (from.has_key_event()) {
    mutable_key_event()->::aspia::proto::KeyEvent::MergeFrom(from.key_event());
  }
  if (from.has_bell_event()) {
    mutable_bell_event()->::aspia::proto::BellEvent::MergeFrom(from.bell_event());
  }
  if (from.has_clipboard()) {
    mutable_clipboard()->::aspia::proto::Clipboard::MergeFrom(from.clipboard());
  }
  if (from.has_control()) {
    mutable_control()->::aspia::proto::Control::MergeFrom(from.control());
  }
}

void ClientToHost::CopyFrom(const ClientToHost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.ClientToHost)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool ClientToHost::IsInitialized() const {

  return true;
}

void ClientToHost::Swap(ClientToHost* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClientToHost::InternalSwap(ClientToHost* other) {
  std::swap(pointer_event_, other->pointer_event_);
  std::swap(key_event_, other->key_event_);
  std::swap(bell_event_, other->bell_event_);
  std::swap(clipboard_, other->clipboard_);
  std::swap(control_, other->control_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ClientToHost::GetTypeName() const {
  return "aspia.proto.ClientToHost";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientToHost

// optional .aspia.proto.PointerEvent pointer_event = 1;
bool ClientToHost::has_pointer_event() const {
  return this != internal_default_instance() && pointer_event_ != NULL;
}
void ClientToHost::clear_pointer_event() {
  if (GetArenaNoVirtual() == NULL && pointer_event_ != NULL) delete pointer_event_;
  pointer_event_ = NULL;
}
const ::aspia::proto::PointerEvent& ClientToHost::pointer_event() const {
  // @@protoc_insertion_point(field_get:aspia.proto.ClientToHost.pointer_event)
  return pointer_event_ != NULL ? *pointer_event_
                         : *::aspia::proto::PointerEvent::internal_default_instance();
}
::aspia::proto::PointerEvent* ClientToHost::mutable_pointer_event() {
  
  if (pointer_event_ == NULL) {
    pointer_event_ = new ::aspia::proto::PointerEvent;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.ClientToHost.pointer_event)
  return pointer_event_;
}
::aspia::proto::PointerEvent* ClientToHost::release_pointer_event() {
  // @@protoc_insertion_point(field_release:aspia.proto.ClientToHost.pointer_event)
  
  ::aspia::proto::PointerEvent* temp = pointer_event_;
  pointer_event_ = NULL;
  return temp;
}
void ClientToHost::set_allocated_pointer_event(::aspia::proto::PointerEvent* pointer_event) {
  delete pointer_event_;
  pointer_event_ = pointer_event;
  if (pointer_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.ClientToHost.pointer_event)
}

// optional .aspia.proto.KeyEvent key_event = 2;
bool ClientToHost::has_key_event() const {
  return this != internal_default_instance() && key_event_ != NULL;
}
void ClientToHost::clear_key_event() {
  if (GetArenaNoVirtual() == NULL && key_event_ != NULL) delete key_event_;
  key_event_ = NULL;
}
const ::aspia::proto::KeyEvent& ClientToHost::key_event() const {
  // @@protoc_insertion_point(field_get:aspia.proto.ClientToHost.key_event)
  return key_event_ != NULL ? *key_event_
                         : *::aspia::proto::KeyEvent::internal_default_instance();
}
::aspia::proto::KeyEvent* ClientToHost::mutable_key_event() {
  
  if (key_event_ == NULL) {
    key_event_ = new ::aspia::proto::KeyEvent;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.ClientToHost.key_event)
  return key_event_;
}
::aspia::proto::KeyEvent* ClientToHost::release_key_event() {
  // @@protoc_insertion_point(field_release:aspia.proto.ClientToHost.key_event)
  
  ::aspia::proto::KeyEvent* temp = key_event_;
  key_event_ = NULL;
  return temp;
}
void ClientToHost::set_allocated_key_event(::aspia::proto::KeyEvent* key_event) {
  delete key_event_;
  key_event_ = key_event;
  if (key_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.ClientToHost.key_event)
}

// optional .aspia.proto.BellEvent bell_event = 3;
bool ClientToHost::has_bell_event() const {
  return this != internal_default_instance() && bell_event_ != NULL;
}
void ClientToHost::clear_bell_event() {
  if (GetArenaNoVirtual() == NULL && bell_event_ != NULL) delete bell_event_;
  bell_event_ = NULL;
}
const ::aspia::proto::BellEvent& ClientToHost::bell_event() const {
  // @@protoc_insertion_point(field_get:aspia.proto.ClientToHost.bell_event)
  return bell_event_ != NULL ? *bell_event_
                         : *::aspia::proto::BellEvent::internal_default_instance();
}
::aspia::proto::BellEvent* ClientToHost::mutable_bell_event() {
  
  if (bell_event_ == NULL) {
    bell_event_ = new ::aspia::proto::BellEvent;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.ClientToHost.bell_event)
  return bell_event_;
}
::aspia::proto::BellEvent* ClientToHost::release_bell_event() {
  // @@protoc_insertion_point(field_release:aspia.proto.ClientToHost.bell_event)
  
  ::aspia::proto::BellEvent* temp = bell_event_;
  bell_event_ = NULL;
  return temp;
}
void ClientToHost::set_allocated_bell_event(::aspia::proto::BellEvent* bell_event) {
  delete bell_event_;
  bell_event_ = bell_event;
  if (bell_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.ClientToHost.bell_event)
}

// optional .aspia.proto.Clipboard clipboard = 4;
bool ClientToHost::has_clipboard() const {
  return this != internal_default_instance() && clipboard_ != NULL;
}
void ClientToHost::clear_clipboard() {
  if (GetArenaNoVirtual() == NULL && clipboard_ != NULL) delete clipboard_;
  clipboard_ = NULL;
}
const ::aspia::proto::Clipboard& ClientToHost::clipboard() const {
  // @@protoc_insertion_point(field_get:aspia.proto.ClientToHost.clipboard)
  return clipboard_ != NULL ? *clipboard_
                         : *::aspia::proto::Clipboard::internal_default_instance();
}
::aspia::proto::Clipboard* ClientToHost::mutable_clipboard() {
  
  if (clipboard_ == NULL) {
    clipboard_ = new ::aspia::proto::Clipboard;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.ClientToHost.clipboard)
  return clipboard_;
}
::aspia::proto::Clipboard* ClientToHost::release_clipboard() {
  // @@protoc_insertion_point(field_release:aspia.proto.ClientToHost.clipboard)
  
  ::aspia::proto::Clipboard* temp = clipboard_;
  clipboard_ = NULL;
  return temp;
}
void ClientToHost::set_allocated_clipboard(::aspia::proto::Clipboard* clipboard) {
  delete clipboard_;
  clipboard_ = clipboard;
  if (clipboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.ClientToHost.clipboard)
}

// optional .aspia.proto.Control control = 5;
bool ClientToHost::has_control() const {
  return this != internal_default_instance() && control_ != NULL;
}
void ClientToHost::clear_control() {
  if (GetArenaNoVirtual() == NULL && control_ != NULL) delete control_;
  control_ = NULL;
}
const ::aspia::proto::Control& ClientToHost::control() const {
  // @@protoc_insertion_point(field_get:aspia.proto.ClientToHost.control)
  return control_ != NULL ? *control_
                         : *::aspia::proto::Control::internal_default_instance();
}
::aspia::proto::Control* ClientToHost::mutable_control() {
  
  if (control_ == NULL) {
    control_ = new ::aspia::proto::Control;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.ClientToHost.control)
  return control_;
}
::aspia::proto::Control* ClientToHost::release_control() {
  // @@protoc_insertion_point(field_release:aspia.proto.ClientToHost.control)
  
  ::aspia::proto::Control* temp = control_;
  control_ = NULL;
  return temp;
}
void ClientToHost::set_allocated_control(::aspia::proto::Control* control) {
  delete control_;
  control_ = control;
  if (control) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.ClientToHost.control)
}

inline const ClientToHost* ClientToHost::internal_default_instance() {
  return &ClientToHost_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace aspia

// @@protoc_insertion_point(global_scope)

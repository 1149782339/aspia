// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto.proto

#ifndef PROTOBUF_proto_2eproto__INCLUDED
#define PROTOBUF_proto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include "auth.pb.h"
#include "video.pb.h"
// @@protoc_insertion_point(includes)

namespace aspia {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_proto_2eproto();
void protobuf_InitDefaults_proto_2eproto();
void protobuf_AssignDesc_proto_2eproto();
void protobuf_ShutdownFile_proto_2eproto();

class BellEvent;
class ClientToHost;
class Clipboard;
class ClipboardControl;
class Control;
class CursorShape;
class HostToClient;
class KeyEvent;
class PointerEvent;
class PowerControl;

enum PowerControl_Action {
  PowerControl_Action_SHUTDOWN = 0,
  PowerControl_Action_REBOOT = 1,
  PowerControl_Action_HIBERNATE = 2,
  PowerControl_Action_SUSPEND = 3,
  PowerControl_Action_LOGOFF = 4,
  PowerControl_Action_PowerControl_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PowerControl_Action_PowerControl_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PowerControl_Action_IsValid(int value);
const PowerControl_Action PowerControl_Action_Action_MIN = PowerControl_Action_SHUTDOWN;
const PowerControl_Action PowerControl_Action_Action_MAX = PowerControl_Action_LOGOFF;
const int PowerControl_Action_Action_ARRAYSIZE = PowerControl_Action_Action_MAX + 1;

enum KeyEvent_Flags {
  KeyEvent_Flags_UNKNOWN = 0,
  KeyEvent_Flags_CAPSLOCK = 1,
  KeyEvent_Flags_NUMLOCK = 2,
  KeyEvent_Flags_EXTENDED = 4,
  KeyEvent_Flags_PRESSED = 8,
  KeyEvent_Flags_KeyEvent_Flags_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  KeyEvent_Flags_KeyEvent_Flags_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool KeyEvent_Flags_IsValid(int value);
const KeyEvent_Flags KeyEvent_Flags_Flags_MIN = KeyEvent_Flags_UNKNOWN;
const KeyEvent_Flags KeyEvent_Flags_Flags_MAX = KeyEvent_Flags_PRESSED;
const int KeyEvent_Flags_Flags_ARRAYSIZE = KeyEvent_Flags_Flags_MAX + 1;

enum PointerEvent_ButtonMask {
  PointerEvent_ButtonMask_EMPTY = 0,
  PointerEvent_ButtonMask_LEFT_BUTTON = 1,
  PointerEvent_ButtonMask_MIDDLE_BUTTON = 2,
  PointerEvent_ButtonMask_RIGHT_BUTTON = 4,
  PointerEvent_ButtonMask_WHEEL_UP = 8,
  PointerEvent_ButtonMask_WHEEL_DOWN = 16,
  PointerEvent_ButtonMask_PointerEvent_ButtonMask_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PointerEvent_ButtonMask_PointerEvent_ButtonMask_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PointerEvent_ButtonMask_IsValid(int value);
const PointerEvent_ButtonMask PointerEvent_ButtonMask_ButtonMask_MIN = PointerEvent_ButtonMask_EMPTY;
const PointerEvent_ButtonMask PointerEvent_ButtonMask_ButtonMask_MAX = PointerEvent_ButtonMask_WHEEL_DOWN;
const int PointerEvent_ButtonMask_ButtonMask_ARRAYSIZE = PointerEvent_ButtonMask_ButtonMask_MAX + 1;

enum ClipboardControl_Flags {
  ClipboardControl_Flags_DISABLE_AUTOSEND = 0,
  ClipboardControl_Flags_ENABLE_AUTOSEND = 1,
  ClipboardControl_Flags_REQUESTED = 2,
  ClipboardControl_Flags_ClipboardControl_Flags_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ClipboardControl_Flags_ClipboardControl_Flags_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ClipboardControl_Flags_IsValid(int value);
const ClipboardControl_Flags ClipboardControl_Flags_Flags_MIN = ClipboardControl_Flags_DISABLE_AUTOSEND;
const ClipboardControl_Flags ClipboardControl_Flags_Flags_MAX = ClipboardControl_Flags_REQUESTED;
const int ClipboardControl_Flags_Flags_ARRAYSIZE = ClipboardControl_Flags_Flags_MAX + 1;

enum ClipboardEncoding {
  CLIPBOARD_ENCODING_UNKNOWN = 0,
  CLIPBOARD_ENCODING_RAW = 1,
  CLIPBOARD_ENCODING_ZLIB = 2,
  ClipboardEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ClipboardEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ClipboardEncoding_IsValid(int value);
const ClipboardEncoding ClipboardEncoding_MIN = CLIPBOARD_ENCODING_UNKNOWN;
const ClipboardEncoding ClipboardEncoding_MAX = CLIPBOARD_ENCODING_ZLIB;
const int ClipboardEncoding_ARRAYSIZE = ClipboardEncoding_MAX + 1;

enum CursorShapeEncoding {
  CURSOR_SHAPE_ENCODING_UNKNOWN = 0,
  CURSOR_SHAPE_ENCODING_CACHE = 1,
  CURSOR_SHAPE_ENCODING_ZLIB = 2,
  CursorShapeEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CursorShapeEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CursorShapeEncoding_IsValid(int value);
const CursorShapeEncoding CursorShapeEncoding_MIN = CURSOR_SHAPE_ENCODING_UNKNOWN;
const CursorShapeEncoding CursorShapeEncoding_MAX = CURSOR_SHAPE_ENCODING_ZLIB;
const int CursorShapeEncoding_ARRAYSIZE = CursorShapeEncoding_MAX + 1;

// ===================================================================

class PowerControl : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.PowerControl) */ {
 public:
  PowerControl();
  virtual ~PowerControl();

  PowerControl(const PowerControl& from);

  inline PowerControl& operator=(const PowerControl& from) {
    CopyFrom(from);
    return *this;
  }

  static const PowerControl& default_instance();

  static const PowerControl* internal_default_instance();

  void Swap(PowerControl* other);

  // implements Message ----------------------------------------------

  inline PowerControl* New() const { return New(NULL); }

  PowerControl* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PowerControl& from);
  void MergeFrom(const PowerControl& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PowerControl* other);
  void UnsafeMergeFrom(const PowerControl& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PowerControl_Action Action;
  static const Action SHUTDOWN =
    PowerControl_Action_SHUTDOWN;
  static const Action REBOOT =
    PowerControl_Action_REBOOT;
  static const Action HIBERNATE =
    PowerControl_Action_HIBERNATE;
  static const Action SUSPEND =
    PowerControl_Action_SUSPEND;
  static const Action LOGOFF =
    PowerControl_Action_LOGOFF;
  static inline bool Action_IsValid(int value) {
    return PowerControl_Action_IsValid(value);
  }
  static const Action Action_MIN =
    PowerControl_Action_Action_MIN;
  static const Action Action_MAX =
    PowerControl_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    PowerControl_Action_Action_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .aspia.proto.PowerControl.Action action = 1;
  void clear_action();
  static const int kActionFieldNumber = 1;
  ::aspia::proto::PowerControl_Action action() const;
  void set_action(::aspia::proto::PowerControl_Action value);

  // @@protoc_insertion_point(class_scope:aspia.proto.PowerControl)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  int action_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_proto_2eproto_impl();
  friend void  protobuf_AddDesc_proto_2eproto_impl();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<PowerControl> PowerControl_default_instance_;

// -------------------------------------------------------------------

class KeyEvent : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.KeyEvent) */ {
 public:
  KeyEvent();
  virtual ~KeyEvent();

  KeyEvent(const KeyEvent& from);

  inline KeyEvent& operator=(const KeyEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const KeyEvent& default_instance();

  static const KeyEvent* internal_default_instance();

  void Swap(KeyEvent* other);

  // implements Message ----------------------------------------------

  inline KeyEvent* New() const { return New(NULL); }

  KeyEvent* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KeyEvent& from);
  void MergeFrom(const KeyEvent& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyEvent* other);
  void UnsafeMergeFrom(const KeyEvent& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef KeyEvent_Flags Flags;
  static const Flags UNKNOWN =
    KeyEvent_Flags_UNKNOWN;
  static const Flags CAPSLOCK =
    KeyEvent_Flags_CAPSLOCK;
  static const Flags NUMLOCK =
    KeyEvent_Flags_NUMLOCK;
  static const Flags EXTENDED =
    KeyEvent_Flags_EXTENDED;
  static const Flags PRESSED =
    KeyEvent_Flags_PRESSED;
  static inline bool Flags_IsValid(int value) {
    return KeyEvent_Flags_IsValid(value);
  }
  static const Flags Flags_MIN =
    KeyEvent_Flags_Flags_MIN;
  static const Flags Flags_MAX =
    KeyEvent_Flags_Flags_MAX;
  static const int Flags_ARRAYSIZE =
    KeyEvent_Flags_Flags_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 keycode = 1;
  void clear_keycode();
  static const int kKeycodeFieldNumber = 1;
  ::google::protobuf::uint32 keycode() const;
  void set_keycode(::google::protobuf::uint32 value);

  // optional uint32 flags = 2;
  void clear_flags();
  static const int kFlagsFieldNumber = 2;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.KeyEvent)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 keycode_;
  ::google::protobuf::uint32 flags_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_proto_2eproto_impl();
  friend void  protobuf_AddDesc_proto_2eproto_impl();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<KeyEvent> KeyEvent_default_instance_;

// -------------------------------------------------------------------

class PointerEvent : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.PointerEvent) */ {
 public:
  PointerEvent();
  virtual ~PointerEvent();

  PointerEvent(const PointerEvent& from);

  inline PointerEvent& operator=(const PointerEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const PointerEvent& default_instance();

  static const PointerEvent* internal_default_instance();

  void Swap(PointerEvent* other);

  // implements Message ----------------------------------------------

  inline PointerEvent* New() const { return New(NULL); }

  PointerEvent* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PointerEvent& from);
  void MergeFrom(const PointerEvent& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PointerEvent* other);
  void UnsafeMergeFrom(const PointerEvent& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PointerEvent_ButtonMask ButtonMask;
  static const ButtonMask EMPTY =
    PointerEvent_ButtonMask_EMPTY;
  static const ButtonMask LEFT_BUTTON =
    PointerEvent_ButtonMask_LEFT_BUTTON;
  static const ButtonMask MIDDLE_BUTTON =
    PointerEvent_ButtonMask_MIDDLE_BUTTON;
  static const ButtonMask RIGHT_BUTTON =
    PointerEvent_ButtonMask_RIGHT_BUTTON;
  static const ButtonMask WHEEL_UP =
    PointerEvent_ButtonMask_WHEEL_UP;
  static const ButtonMask WHEEL_DOWN =
    PointerEvent_ButtonMask_WHEEL_DOWN;
  static inline bool ButtonMask_IsValid(int value) {
    return PointerEvent_ButtonMask_IsValid(value);
  }
  static const ButtonMask ButtonMask_MIN =
    PointerEvent_ButtonMask_ButtonMask_MIN;
  static const ButtonMask ButtonMask_MAX =
    PointerEvent_ButtonMask_ButtonMask_MAX;
  static const int ButtonMask_ARRAYSIZE =
    PointerEvent_ButtonMask_ButtonMask_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 mask = 1;
  void clear_mask();
  static const int kMaskFieldNumber = 1;
  ::google::protobuf::uint32 mask() const;
  void set_mask(::google::protobuf::uint32 value);

  // optional int32 x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.PointerEvent)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 mask_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_proto_2eproto_impl();
  friend void  protobuf_AddDesc_proto_2eproto_impl();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<PointerEvent> PointerEvent_default_instance_;

// -------------------------------------------------------------------

class Clipboard : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Clipboard) */ {
 public:
  Clipboard();
  virtual ~Clipboard();

  Clipboard(const Clipboard& from);

  inline Clipboard& operator=(const Clipboard& from) {
    CopyFrom(from);
    return *this;
  }

  static const Clipboard& default_instance();

  static const Clipboard* internal_default_instance();

  void Swap(Clipboard* other);

  // implements Message ----------------------------------------------

  inline Clipboard* New() const { return New(NULL); }

  Clipboard* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Clipboard& from);
  void MergeFrom(const Clipboard& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Clipboard* other);
  void UnsafeMergeFrom(const Clipboard& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aspia.proto.ClipboardEncoding encoding = 1;
  void clear_encoding();
  static const int kEncodingFieldNumber = 1;
  ::aspia::proto::ClipboardEncoding encoding() const;
  void set_encoding(::aspia::proto::ClipboardEncoding value);

  // optional string mime_type = 2;
  void clear_mime_type();
  static const int kMimeTypeFieldNumber = 2;
  const ::std::string& mime_type() const;
  void set_mime_type(const ::std::string& value);
  void set_mime_type(const char* value);
  void set_mime_type(const char* value, size_t size);
  ::std::string* mutable_mime_type();
  ::std::string* release_mime_type();
  void set_allocated_mime_type(::std::string* mime_type);

  // optional bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:aspia.proto.Clipboard)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::internal::ArenaStringPtr mime_type_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  int encoding_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_proto_2eproto_impl();
  friend void  protobuf_AddDesc_proto_2eproto_impl();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Clipboard> Clipboard_default_instance_;

// -------------------------------------------------------------------

class ClipboardControl : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.ClipboardControl) */ {
 public:
  ClipboardControl();
  virtual ~ClipboardControl();

  ClipboardControl(const ClipboardControl& from);

  inline ClipboardControl& operator=(const ClipboardControl& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClipboardControl& default_instance();

  static const ClipboardControl* internal_default_instance();

  void Swap(ClipboardControl* other);

  // implements Message ----------------------------------------------

  inline ClipboardControl* New() const { return New(NULL); }

  ClipboardControl* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClipboardControl& from);
  void MergeFrom(const ClipboardControl& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClipboardControl* other);
  void UnsafeMergeFrom(const ClipboardControl& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClipboardControl_Flags Flags;
  static const Flags DISABLE_AUTOSEND =
    ClipboardControl_Flags_DISABLE_AUTOSEND;
  static const Flags ENABLE_AUTOSEND =
    ClipboardControl_Flags_ENABLE_AUTOSEND;
  static const Flags REQUESTED =
    ClipboardControl_Flags_REQUESTED;
  static inline bool Flags_IsValid(int value) {
    return ClipboardControl_Flags_IsValid(value);
  }
  static const Flags Flags_MIN =
    ClipboardControl_Flags_Flags_MIN;
  static const Flags Flags_MAX =
    ClipboardControl_Flags_Flags_MAX;
  static const int Flags_ARRAYSIZE =
    ClipboardControl_Flags_Flags_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 flags = 1;
  void clear_flags();
  static const int kFlagsFieldNumber = 1;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.ClipboardControl)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 flags_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_proto_2eproto_impl();
  friend void  protobuf_AddDesc_proto_2eproto_impl();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ClipboardControl> ClipboardControl_default_instance_;

// -------------------------------------------------------------------

class CursorShape : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.CursorShape) */ {
 public:
  CursorShape();
  virtual ~CursorShape();

  CursorShape(const CursorShape& from);

  inline CursorShape& operator=(const CursorShape& from) {
    CopyFrom(from);
    return *this;
  }

  static const CursorShape& default_instance();

  static const CursorShape* internal_default_instance();

  void Swap(CursorShape* other);

  // implements Message ----------------------------------------------

  inline CursorShape* New() const { return New(NULL); }

  CursorShape* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CursorShape& from);
  void MergeFrom(const CursorShape& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CursorShape* other);
  void UnsafeMergeFrom(const CursorShape& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aspia.proto.CursorShapeEncoding encoding = 1;
  void clear_encoding();
  static const int kEncodingFieldNumber = 1;
  ::aspia::proto::CursorShapeEncoding encoding() const;
  void set_encoding(::aspia::proto::CursorShapeEncoding value);

  // optional int32 width = 2;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // optional int32 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // optional int32 hotspot_x = 4;
  void clear_hotspot_x();
  static const int kHotspotXFieldNumber = 4;
  ::google::protobuf::int32 hotspot_x() const;
  void set_hotspot_x(::google::protobuf::int32 value);

  // optional int32 hotspot_y = 5;
  void clear_hotspot_y();
  static const int kHotspotYFieldNumber = 5;
  ::google::protobuf::int32 hotspot_y() const;
  void set_hotspot_y(::google::protobuf::int32 value);

  // optional bytes data = 6;
  void clear_data();
  static const int kDataFieldNumber = 6;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional int32 cache_index = 7;
  void clear_cache_index();
  static const int kCacheIndexFieldNumber = 7;
  ::google::protobuf::int32 cache_index() const;
  void set_cache_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.CursorShape)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::internal::ArenaStringPtr data_;
  int encoding_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 hotspot_x_;
  ::google::protobuf::int32 hotspot_y_;
  ::google::protobuf::int32 cache_index_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_proto_2eproto_impl();
  friend void  protobuf_AddDesc_proto_2eproto_impl();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CursorShape> CursorShape_default_instance_;

// -------------------------------------------------------------------

class BellEvent : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.BellEvent) */ {
 public:
  BellEvent();
  virtual ~BellEvent();

  BellEvent(const BellEvent& from);

  inline BellEvent& operator=(const BellEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const BellEvent& default_instance();

  static const BellEvent* internal_default_instance();

  void Swap(BellEvent* other);

  // implements Message ----------------------------------------------

  inline BellEvent* New() const { return New(NULL); }

  BellEvent* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BellEvent& from);
  void MergeFrom(const BellEvent& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BellEvent* other);
  void UnsafeMergeFrom(const BellEvent& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 flags = 1;
  void clear_flags();
  static const int kFlagsFieldNumber = 1;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.BellEvent)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 flags_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_proto_2eproto_impl();
  friend void  protobuf_AddDesc_proto_2eproto_impl();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<BellEvent> BellEvent_default_instance_;

// -------------------------------------------------------------------

class HostToClient : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.HostToClient) */ {
 public:
  HostToClient();
  virtual ~HostToClient();

  HostToClient(const HostToClient& from);

  inline HostToClient& operator=(const HostToClient& from) {
    CopyFrom(from);
    return *this;
  }

  static const HostToClient& default_instance();

  static const HostToClient* internal_default_instance();

  void Swap(HostToClient* other);

  // implements Message ----------------------------------------------

  inline HostToClient* New() const { return New(NULL); }

  HostToClient* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HostToClient& from);
  void MergeFrom(const HostToClient& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostToClient* other);
  void UnsafeMergeFrom(const HostToClient& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aspia.proto.VideoPacket video_packet = 1;
  bool has_video_packet() const;
  void clear_video_packet();
  static const int kVideoPacketFieldNumber = 1;
  const ::aspia::proto::VideoPacket& video_packet() const;
  ::aspia::proto::VideoPacket* mutable_video_packet();
  ::aspia::proto::VideoPacket* release_video_packet();
  void set_allocated_video_packet(::aspia::proto::VideoPacket* video_packet);

  // optional .aspia.proto.CursorShape cursor = 2;
  bool has_cursor() const;
  void clear_cursor();
  static const int kCursorFieldNumber = 2;
  const ::aspia::proto::CursorShape& cursor() const;
  ::aspia::proto::CursorShape* mutable_cursor();
  ::aspia::proto::CursorShape* release_cursor();
  void set_allocated_cursor(::aspia::proto::CursorShape* cursor);

  // optional .aspia.proto.Clipboard clipboard = 3;
  bool has_clipboard() const;
  void clear_clipboard();
  static const int kClipboardFieldNumber = 3;
  const ::aspia::proto::Clipboard& clipboard() const;
  ::aspia::proto::Clipboard* mutable_clipboard();
  ::aspia::proto::Clipboard* release_clipboard();
  void set_allocated_clipboard(::aspia::proto::Clipboard* clipboard);

  // @@protoc_insertion_point(class_scope:aspia.proto.HostToClient)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::aspia::proto::VideoPacket* video_packet_;
  ::aspia::proto::CursorShape* cursor_;
  ::aspia::proto::Clipboard* clipboard_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_proto_2eproto_impl();
  friend void  protobuf_AddDesc_proto_2eproto_impl();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<HostToClient> HostToClient_default_instance_;

// -------------------------------------------------------------------

class Control : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Control) */ {
 public:
  Control();
  virtual ~Control();

  Control(const Control& from);

  inline Control& operator=(const Control& from) {
    CopyFrom(from);
    return *this;
  }

  static const Control& default_instance();

  static const Control* internal_default_instance();

  void Swap(Control* other);

  // implements Message ----------------------------------------------

  inline Control* New() const { return New(NULL); }

  Control* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Control& from);
  void MergeFrom(const Control& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Control* other);
  void UnsafeMergeFrom(const Control& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aspia.proto.VideoControl video = 1;
  bool has_video() const;
  void clear_video();
  static const int kVideoFieldNumber = 1;
  const ::aspia::proto::VideoControl& video() const;
  ::aspia::proto::VideoControl* mutable_video();
  ::aspia::proto::VideoControl* release_video();
  void set_allocated_video(::aspia::proto::VideoControl* video);

  // optional .aspia.proto.ClipboardControl clipboard = 2;
  bool has_clipboard() const;
  void clear_clipboard();
  static const int kClipboardFieldNumber = 2;
  const ::aspia::proto::ClipboardControl& clipboard() const;
  ::aspia::proto::ClipboardControl* mutable_clipboard();
  ::aspia::proto::ClipboardControl* release_clipboard();
  void set_allocated_clipboard(::aspia::proto::ClipboardControl* clipboard);

  // optional .aspia.proto.PowerControl power = 3;
  bool has_power() const;
  void clear_power();
  static const int kPowerFieldNumber = 3;
  const ::aspia::proto::PowerControl& power() const;
  ::aspia::proto::PowerControl* mutable_power();
  ::aspia::proto::PowerControl* release_power();
  void set_allocated_power(::aspia::proto::PowerControl* power);

  // @@protoc_insertion_point(class_scope:aspia.proto.Control)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::aspia::proto::VideoControl* video_;
  ::aspia::proto::ClipboardControl* clipboard_;
  ::aspia::proto::PowerControl* power_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_proto_2eproto_impl();
  friend void  protobuf_AddDesc_proto_2eproto_impl();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Control> Control_default_instance_;

// -------------------------------------------------------------------

class ClientToHost : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.ClientToHost) */ {
 public:
  ClientToHost();
  virtual ~ClientToHost();

  ClientToHost(const ClientToHost& from);

  inline ClientToHost& operator=(const ClientToHost& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientToHost& default_instance();

  static const ClientToHost* internal_default_instance();

  void Swap(ClientToHost* other);

  // implements Message ----------------------------------------------

  inline ClientToHost* New() const { return New(NULL); }

  ClientToHost* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientToHost& from);
  void MergeFrom(const ClientToHost& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientToHost* other);
  void UnsafeMergeFrom(const ClientToHost& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .aspia.proto.PointerEvent pointer_event = 1;
  bool has_pointer_event() const;
  void clear_pointer_event();
  static const int kPointerEventFieldNumber = 1;
  const ::aspia::proto::PointerEvent& pointer_event() const;
  ::aspia::proto::PointerEvent* mutable_pointer_event();
  ::aspia::proto::PointerEvent* release_pointer_event();
  void set_allocated_pointer_event(::aspia::proto::PointerEvent* pointer_event);

  // optional .aspia.proto.KeyEvent key_event = 2;
  bool has_key_event() const;
  void clear_key_event();
  static const int kKeyEventFieldNumber = 2;
  const ::aspia::proto::KeyEvent& key_event() const;
  ::aspia::proto::KeyEvent* mutable_key_event();
  ::aspia::proto::KeyEvent* release_key_event();
  void set_allocated_key_event(::aspia::proto::KeyEvent* key_event);

  // optional .aspia.proto.BellEvent bell_event = 3;
  bool has_bell_event() const;
  void clear_bell_event();
  static const int kBellEventFieldNumber = 3;
  const ::aspia::proto::BellEvent& bell_event() const;
  ::aspia::proto::BellEvent* mutable_bell_event();
  ::aspia::proto::BellEvent* release_bell_event();
  void set_allocated_bell_event(::aspia::proto::BellEvent* bell_event);

  // optional .aspia.proto.Clipboard clipboard = 4;
  bool has_clipboard() const;
  void clear_clipboard();
  static const int kClipboardFieldNumber = 4;
  const ::aspia::proto::Clipboard& clipboard() const;
  ::aspia::proto::Clipboard* mutable_clipboard();
  ::aspia::proto::Clipboard* release_clipboard();
  void set_allocated_clipboard(::aspia::proto::Clipboard* clipboard);

  // optional .aspia.proto.Control control = 5;
  bool has_control() const;
  void clear_control();
  static const int kControlFieldNumber = 5;
  const ::aspia::proto::Control& control() const;
  ::aspia::proto::Control* mutable_control();
  ::aspia::proto::Control* release_control();
  void set_allocated_control(::aspia::proto::Control* control);

  // @@protoc_insertion_point(class_scope:aspia.proto.ClientToHost)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::aspia::proto::PointerEvent* pointer_event_;
  ::aspia::proto::KeyEvent* key_event_;
  ::aspia::proto::BellEvent* bell_event_;
  ::aspia::proto::Clipboard* clipboard_;
  ::aspia::proto::Control* control_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_proto_2eproto_impl();
  friend void  protobuf_AddDesc_proto_2eproto_impl();
  friend void protobuf_AssignDesc_proto_2eproto();
  friend void protobuf_ShutdownFile_proto_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ClientToHost> ClientToHost_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PowerControl

// optional .aspia.proto.PowerControl.Action action = 1;
inline void PowerControl::clear_action() {
  action_ = 0;
}
inline ::aspia::proto::PowerControl_Action PowerControl::action() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerControl.action)
  return static_cast< ::aspia::proto::PowerControl_Action >(action_);
}
inline void PowerControl::set_action(::aspia::proto::PowerControl_Action value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerControl.action)
}

inline const PowerControl* PowerControl::internal_default_instance() {
  return &PowerControl_default_instance_.get();
}
// -------------------------------------------------------------------

// KeyEvent

// optional uint32 keycode = 1;
inline void KeyEvent::clear_keycode() {
  keycode_ = 0u;
}
inline ::google::protobuf::uint32 KeyEvent::keycode() const {
  // @@protoc_insertion_point(field_get:aspia.proto.KeyEvent.keycode)
  return keycode_;
}
inline void KeyEvent::set_keycode(::google::protobuf::uint32 value) {
  
  keycode_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.KeyEvent.keycode)
}

// optional uint32 flags = 2;
inline void KeyEvent::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 KeyEvent::flags() const {
  // @@protoc_insertion_point(field_get:aspia.proto.KeyEvent.flags)
  return flags_;
}
inline void KeyEvent::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.KeyEvent.flags)
}

inline const KeyEvent* KeyEvent::internal_default_instance() {
  return &KeyEvent_default_instance_.get();
}
// -------------------------------------------------------------------

// PointerEvent

// optional uint32 mask = 1;
inline void PointerEvent::clear_mask() {
  mask_ = 0u;
}
inline ::google::protobuf::uint32 PointerEvent::mask() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PointerEvent.mask)
  return mask_;
}
inline void PointerEvent::set_mask(::google::protobuf::uint32 value) {
  
  mask_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PointerEvent.mask)
}

// optional int32 x = 2;
inline void PointerEvent::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 PointerEvent::x() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PointerEvent.x)
  return x_;
}
inline void PointerEvent::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PointerEvent.x)
}

// optional int32 y = 3;
inline void PointerEvent::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 PointerEvent::y() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PointerEvent.y)
  return y_;
}
inline void PointerEvent::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PointerEvent.y)
}

inline const PointerEvent* PointerEvent::internal_default_instance() {
  return &PointerEvent_default_instance_.get();
}
// -------------------------------------------------------------------

// Clipboard

// optional .aspia.proto.ClipboardEncoding encoding = 1;
inline void Clipboard::clear_encoding() {
  encoding_ = 0;
}
inline ::aspia::proto::ClipboardEncoding Clipboard::encoding() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Clipboard.encoding)
  return static_cast< ::aspia::proto::ClipboardEncoding >(encoding_);
}
inline void Clipboard::set_encoding(::aspia::proto::ClipboardEncoding value) {
  
  encoding_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Clipboard.encoding)
}

// optional string mime_type = 2;
inline void Clipboard::clear_mime_type() {
  mime_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Clipboard::mime_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Clipboard.mime_type)
  return mime_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Clipboard::set_mime_type(const ::std::string& value) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Clipboard.mime_type)
}
inline void Clipboard::set_mime_type(const char* value) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Clipboard.mime_type)
}
inline void Clipboard::set_mime_type(const char* value, size_t size) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Clipboard.mime_type)
}
inline ::std::string* Clipboard::mutable_mime_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Clipboard.mime_type)
  return mime_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Clipboard::release_mime_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.Clipboard.mime_type)
  
  return mime_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Clipboard::set_allocated_mime_type(::std::string* mime_type) {
  if (mime_type != NULL) {
    
  } else {
    
  }
  mime_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mime_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Clipboard.mime_type)
}

// optional bytes data = 3;
inline void Clipboard::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Clipboard::data() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Clipboard.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Clipboard::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Clipboard.data)
}
inline void Clipboard::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Clipboard.data)
}
inline void Clipboard::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Clipboard.data)
}
inline ::std::string* Clipboard::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Clipboard.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Clipboard::release_data() {
  // @@protoc_insertion_point(field_release:aspia.proto.Clipboard.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Clipboard::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Clipboard.data)
}

inline const Clipboard* Clipboard::internal_default_instance() {
  return &Clipboard_default_instance_.get();
}
// -------------------------------------------------------------------

// ClipboardControl

// optional uint32 flags = 1;
inline void ClipboardControl::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 ClipboardControl::flags() const {
  // @@protoc_insertion_point(field_get:aspia.proto.ClipboardControl.flags)
  return flags_;
}
inline void ClipboardControl::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.ClipboardControl.flags)
}

inline const ClipboardControl* ClipboardControl::internal_default_instance() {
  return &ClipboardControl_default_instance_.get();
}
// -------------------------------------------------------------------

// CursorShape

// optional .aspia.proto.CursorShapeEncoding encoding = 1;
inline void CursorShape::clear_encoding() {
  encoding_ = 0;
}
inline ::aspia::proto::CursorShapeEncoding CursorShape::encoding() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.encoding)
  return static_cast< ::aspia::proto::CursorShapeEncoding >(encoding_);
}
inline void CursorShape::set_encoding(::aspia::proto::CursorShapeEncoding value) {
  
  encoding_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.encoding)
}

// optional int32 width = 2;
inline void CursorShape::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 CursorShape::width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.width)
  return width_;
}
inline void CursorShape::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.width)
}

// optional int32 height = 3;
inline void CursorShape::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 CursorShape::height() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.height)
  return height_;
}
inline void CursorShape::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.height)
}

// optional int32 hotspot_x = 4;
inline void CursorShape::clear_hotspot_x() {
  hotspot_x_ = 0;
}
inline ::google::protobuf::int32 CursorShape::hotspot_x() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.hotspot_x)
  return hotspot_x_;
}
inline void CursorShape::set_hotspot_x(::google::protobuf::int32 value) {
  
  hotspot_x_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.hotspot_x)
}

// optional int32 hotspot_y = 5;
inline void CursorShape::clear_hotspot_y() {
  hotspot_y_ = 0;
}
inline ::google::protobuf::int32 CursorShape::hotspot_y() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.hotspot_y)
  return hotspot_y_;
}
inline void CursorShape::set_hotspot_y(::google::protobuf::int32 value) {
  
  hotspot_y_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.hotspot_y)
}

// optional bytes data = 6;
inline void CursorShape::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CursorShape::data() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CursorShape::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.data)
}
inline void CursorShape::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.CursorShape.data)
}
inline void CursorShape::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.CursorShape.data)
}
inline ::std::string* CursorShape::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.CursorShape.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CursorShape::release_data() {
  // @@protoc_insertion_point(field_release:aspia.proto.CursorShape.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CursorShape::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.CursorShape.data)
}

// optional int32 cache_index = 7;
inline void CursorShape::clear_cache_index() {
  cache_index_ = 0;
}
inline ::google::protobuf::int32 CursorShape::cache_index() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CursorShape.cache_index)
  return cache_index_;
}
inline void CursorShape::set_cache_index(::google::protobuf::int32 value) {
  
  cache_index_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CursorShape.cache_index)
}

inline const CursorShape* CursorShape::internal_default_instance() {
  return &CursorShape_default_instance_.get();
}
// -------------------------------------------------------------------

// BellEvent

// optional uint32 flags = 1;
inline void BellEvent::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 BellEvent::flags() const {
  // @@protoc_insertion_point(field_get:aspia.proto.BellEvent.flags)
  return flags_;
}
inline void BellEvent::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.BellEvent.flags)
}

inline const BellEvent* BellEvent::internal_default_instance() {
  return &BellEvent_default_instance_.get();
}
// -------------------------------------------------------------------

// HostToClient

// optional .aspia.proto.VideoPacket video_packet = 1;
inline bool HostToClient::has_video_packet() const {
  return this != internal_default_instance() && video_packet_ != NULL;
}
inline void HostToClient::clear_video_packet() {
  if (GetArenaNoVirtual() == NULL && video_packet_ != NULL) delete video_packet_;
  video_packet_ = NULL;
}
inline const ::aspia::proto::VideoPacket& HostToClient::video_packet() const {
  // @@protoc_insertion_point(field_get:aspia.proto.HostToClient.video_packet)
  return video_packet_ != NULL ? *video_packet_
                         : *::aspia::proto::VideoPacket::internal_default_instance();
}
inline ::aspia::proto::VideoPacket* HostToClient::mutable_video_packet() {
  
  if (video_packet_ == NULL) {
    video_packet_ = new ::aspia::proto::VideoPacket;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.HostToClient.video_packet)
  return video_packet_;
}
inline ::aspia::proto::VideoPacket* HostToClient::release_video_packet() {
  // @@protoc_insertion_point(field_release:aspia.proto.HostToClient.video_packet)
  
  ::aspia::proto::VideoPacket* temp = video_packet_;
  video_packet_ = NULL;
  return temp;
}
inline void HostToClient::set_allocated_video_packet(::aspia::proto::VideoPacket* video_packet) {
  delete video_packet_;
  video_packet_ = video_packet;
  if (video_packet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.HostToClient.video_packet)
}

// optional .aspia.proto.CursorShape cursor = 2;
inline bool HostToClient::has_cursor() const {
  return this != internal_default_instance() && cursor_ != NULL;
}
inline void HostToClient::clear_cursor() {
  if (GetArenaNoVirtual() == NULL && cursor_ != NULL) delete cursor_;
  cursor_ = NULL;
}
inline const ::aspia::proto::CursorShape& HostToClient::cursor() const {
  // @@protoc_insertion_point(field_get:aspia.proto.HostToClient.cursor)
  return cursor_ != NULL ? *cursor_
                         : *::aspia::proto::CursorShape::internal_default_instance();
}
inline ::aspia::proto::CursorShape* HostToClient::mutable_cursor() {
  
  if (cursor_ == NULL) {
    cursor_ = new ::aspia::proto::CursorShape;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.HostToClient.cursor)
  return cursor_;
}
inline ::aspia::proto::CursorShape* HostToClient::release_cursor() {
  // @@protoc_insertion_point(field_release:aspia.proto.HostToClient.cursor)
  
  ::aspia::proto::CursorShape* temp = cursor_;
  cursor_ = NULL;
  return temp;
}
inline void HostToClient::set_allocated_cursor(::aspia::proto::CursorShape* cursor) {
  delete cursor_;
  cursor_ = cursor;
  if (cursor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.HostToClient.cursor)
}

// optional .aspia.proto.Clipboard clipboard = 3;
inline bool HostToClient::has_clipboard() const {
  return this != internal_default_instance() && clipboard_ != NULL;
}
inline void HostToClient::clear_clipboard() {
  if (GetArenaNoVirtual() == NULL && clipboard_ != NULL) delete clipboard_;
  clipboard_ = NULL;
}
inline const ::aspia::proto::Clipboard& HostToClient::clipboard() const {
  // @@protoc_insertion_point(field_get:aspia.proto.HostToClient.clipboard)
  return clipboard_ != NULL ? *clipboard_
                         : *::aspia::proto::Clipboard::internal_default_instance();
}
inline ::aspia::proto::Clipboard* HostToClient::mutable_clipboard() {
  
  if (clipboard_ == NULL) {
    clipboard_ = new ::aspia::proto::Clipboard;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.HostToClient.clipboard)
  return clipboard_;
}
inline ::aspia::proto::Clipboard* HostToClient::release_clipboard() {
  // @@protoc_insertion_point(field_release:aspia.proto.HostToClient.clipboard)
  
  ::aspia::proto::Clipboard* temp = clipboard_;
  clipboard_ = NULL;
  return temp;
}
inline void HostToClient::set_allocated_clipboard(::aspia::proto::Clipboard* clipboard) {
  delete clipboard_;
  clipboard_ = clipboard;
  if (clipboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.HostToClient.clipboard)
}

inline const HostToClient* HostToClient::internal_default_instance() {
  return &HostToClient_default_instance_.get();
}
// -------------------------------------------------------------------

// Control

// optional .aspia.proto.VideoControl video = 1;
inline bool Control::has_video() const {
  return this != internal_default_instance() && video_ != NULL;
}
inline void Control::clear_video() {
  if (GetArenaNoVirtual() == NULL && video_ != NULL) delete video_;
  video_ = NULL;
}
inline const ::aspia::proto::VideoControl& Control::video() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Control.video)
  return video_ != NULL ? *video_
                         : *::aspia::proto::VideoControl::internal_default_instance();
}
inline ::aspia::proto::VideoControl* Control::mutable_video() {
  
  if (video_ == NULL) {
    video_ = new ::aspia::proto::VideoControl;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.Control.video)
  return video_;
}
inline ::aspia::proto::VideoControl* Control::release_video() {
  // @@protoc_insertion_point(field_release:aspia.proto.Control.video)
  
  ::aspia::proto::VideoControl* temp = video_;
  video_ = NULL;
  return temp;
}
inline void Control::set_allocated_video(::aspia::proto::VideoControl* video) {
  delete video_;
  video_ = video;
  if (video) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Control.video)
}

// optional .aspia.proto.ClipboardControl clipboard = 2;
inline bool Control::has_clipboard() const {
  return this != internal_default_instance() && clipboard_ != NULL;
}
inline void Control::clear_clipboard() {
  if (GetArenaNoVirtual() == NULL && clipboard_ != NULL) delete clipboard_;
  clipboard_ = NULL;
}
inline const ::aspia::proto::ClipboardControl& Control::clipboard() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Control.clipboard)
  return clipboard_ != NULL ? *clipboard_
                         : *::aspia::proto::ClipboardControl::internal_default_instance();
}
inline ::aspia::proto::ClipboardControl* Control::mutable_clipboard() {
  
  if (clipboard_ == NULL) {
    clipboard_ = new ::aspia::proto::ClipboardControl;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.Control.clipboard)
  return clipboard_;
}
inline ::aspia::proto::ClipboardControl* Control::release_clipboard() {
  // @@protoc_insertion_point(field_release:aspia.proto.Control.clipboard)
  
  ::aspia::proto::ClipboardControl* temp = clipboard_;
  clipboard_ = NULL;
  return temp;
}
inline void Control::set_allocated_clipboard(::aspia::proto::ClipboardControl* clipboard) {
  delete clipboard_;
  clipboard_ = clipboard;
  if (clipboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Control.clipboard)
}

// optional .aspia.proto.PowerControl power = 3;
inline bool Control::has_power() const {
  return this != internal_default_instance() && power_ != NULL;
}
inline void Control::clear_power() {
  if (GetArenaNoVirtual() == NULL && power_ != NULL) delete power_;
  power_ = NULL;
}
inline const ::aspia::proto::PowerControl& Control::power() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Control.power)
  return power_ != NULL ? *power_
                         : *::aspia::proto::PowerControl::internal_default_instance();
}
inline ::aspia::proto::PowerControl* Control::mutable_power() {
  
  if (power_ == NULL) {
    power_ = new ::aspia::proto::PowerControl;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.Control.power)
  return power_;
}
inline ::aspia::proto::PowerControl* Control::release_power() {
  // @@protoc_insertion_point(field_release:aspia.proto.Control.power)
  
  ::aspia::proto::PowerControl* temp = power_;
  power_ = NULL;
  return temp;
}
inline void Control::set_allocated_power(::aspia::proto::PowerControl* power) {
  delete power_;
  power_ = power;
  if (power) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Control.power)
}

inline const Control* Control::internal_default_instance() {
  return &Control_default_instance_.get();
}
// -------------------------------------------------------------------

// ClientToHost

// optional .aspia.proto.PointerEvent pointer_event = 1;
inline bool ClientToHost::has_pointer_event() const {
  return this != internal_default_instance() && pointer_event_ != NULL;
}
inline void ClientToHost::clear_pointer_event() {
  if (GetArenaNoVirtual() == NULL && pointer_event_ != NULL) delete pointer_event_;
  pointer_event_ = NULL;
}
inline const ::aspia::proto::PointerEvent& ClientToHost::pointer_event() const {
  // @@protoc_insertion_point(field_get:aspia.proto.ClientToHost.pointer_event)
  return pointer_event_ != NULL ? *pointer_event_
                         : *::aspia::proto::PointerEvent::internal_default_instance();
}
inline ::aspia::proto::PointerEvent* ClientToHost::mutable_pointer_event() {
  
  if (pointer_event_ == NULL) {
    pointer_event_ = new ::aspia::proto::PointerEvent;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.ClientToHost.pointer_event)
  return pointer_event_;
}
inline ::aspia::proto::PointerEvent* ClientToHost::release_pointer_event() {
  // @@protoc_insertion_point(field_release:aspia.proto.ClientToHost.pointer_event)
  
  ::aspia::proto::PointerEvent* temp = pointer_event_;
  pointer_event_ = NULL;
  return temp;
}
inline void ClientToHost::set_allocated_pointer_event(::aspia::proto::PointerEvent* pointer_event) {
  delete pointer_event_;
  pointer_event_ = pointer_event;
  if (pointer_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.ClientToHost.pointer_event)
}

// optional .aspia.proto.KeyEvent key_event = 2;
inline bool ClientToHost::has_key_event() const {
  return this != internal_default_instance() && key_event_ != NULL;
}
inline void ClientToHost::clear_key_event() {
  if (GetArenaNoVirtual() == NULL && key_event_ != NULL) delete key_event_;
  key_event_ = NULL;
}
inline const ::aspia::proto::KeyEvent& ClientToHost::key_event() const {
  // @@protoc_insertion_point(field_get:aspia.proto.ClientToHost.key_event)
  return key_event_ != NULL ? *key_event_
                         : *::aspia::proto::KeyEvent::internal_default_instance();
}
inline ::aspia::proto::KeyEvent* ClientToHost::mutable_key_event() {
  
  if (key_event_ == NULL) {
    key_event_ = new ::aspia::proto::KeyEvent;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.ClientToHost.key_event)
  return key_event_;
}
inline ::aspia::proto::KeyEvent* ClientToHost::release_key_event() {
  // @@protoc_insertion_point(field_release:aspia.proto.ClientToHost.key_event)
  
  ::aspia::proto::KeyEvent* temp = key_event_;
  key_event_ = NULL;
  return temp;
}
inline void ClientToHost::set_allocated_key_event(::aspia::proto::KeyEvent* key_event) {
  delete key_event_;
  key_event_ = key_event;
  if (key_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.ClientToHost.key_event)
}

// optional .aspia.proto.BellEvent bell_event = 3;
inline bool ClientToHost::has_bell_event() const {
  return this != internal_default_instance() && bell_event_ != NULL;
}
inline void ClientToHost::clear_bell_event() {
  if (GetArenaNoVirtual() == NULL && bell_event_ != NULL) delete bell_event_;
  bell_event_ = NULL;
}
inline const ::aspia::proto::BellEvent& ClientToHost::bell_event() const {
  // @@protoc_insertion_point(field_get:aspia.proto.ClientToHost.bell_event)
  return bell_event_ != NULL ? *bell_event_
                         : *::aspia::proto::BellEvent::internal_default_instance();
}
inline ::aspia::proto::BellEvent* ClientToHost::mutable_bell_event() {
  
  if (bell_event_ == NULL) {
    bell_event_ = new ::aspia::proto::BellEvent;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.ClientToHost.bell_event)
  return bell_event_;
}
inline ::aspia::proto::BellEvent* ClientToHost::release_bell_event() {
  // @@protoc_insertion_point(field_release:aspia.proto.ClientToHost.bell_event)
  
  ::aspia::proto::BellEvent* temp = bell_event_;
  bell_event_ = NULL;
  return temp;
}
inline void ClientToHost::set_allocated_bell_event(::aspia::proto::BellEvent* bell_event) {
  delete bell_event_;
  bell_event_ = bell_event;
  if (bell_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.ClientToHost.bell_event)
}

// optional .aspia.proto.Clipboard clipboard = 4;
inline bool ClientToHost::has_clipboard() const {
  return this != internal_default_instance() && clipboard_ != NULL;
}
inline void ClientToHost::clear_clipboard() {
  if (GetArenaNoVirtual() == NULL && clipboard_ != NULL) delete clipboard_;
  clipboard_ = NULL;
}
inline const ::aspia::proto::Clipboard& ClientToHost::clipboard() const {
  // @@protoc_insertion_point(field_get:aspia.proto.ClientToHost.clipboard)
  return clipboard_ != NULL ? *clipboard_
                         : *::aspia::proto::Clipboard::internal_default_instance();
}
inline ::aspia::proto::Clipboard* ClientToHost::mutable_clipboard() {
  
  if (clipboard_ == NULL) {
    clipboard_ = new ::aspia::proto::Clipboard;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.ClientToHost.clipboard)
  return clipboard_;
}
inline ::aspia::proto::Clipboard* ClientToHost::release_clipboard() {
  // @@protoc_insertion_point(field_release:aspia.proto.ClientToHost.clipboard)
  
  ::aspia::proto::Clipboard* temp = clipboard_;
  clipboard_ = NULL;
  return temp;
}
inline void ClientToHost::set_allocated_clipboard(::aspia::proto::Clipboard* clipboard) {
  delete clipboard_;
  clipboard_ = clipboard;
  if (clipboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.ClientToHost.clipboard)
}

// optional .aspia.proto.Control control = 5;
inline bool ClientToHost::has_control() const {
  return this != internal_default_instance() && control_ != NULL;
}
inline void ClientToHost::clear_control() {
  if (GetArenaNoVirtual() == NULL && control_ != NULL) delete control_;
  control_ = NULL;
}
inline const ::aspia::proto::Control& ClientToHost::control() const {
  // @@protoc_insertion_point(field_get:aspia.proto.ClientToHost.control)
  return control_ != NULL ? *control_
                         : *::aspia::proto::Control::internal_default_instance();
}
inline ::aspia::proto::Control* ClientToHost::mutable_control() {
  
  if (control_ == NULL) {
    control_ = new ::aspia::proto::Control;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.ClientToHost.control)
  return control_;
}
inline ::aspia::proto::Control* ClientToHost::release_control() {
  // @@protoc_insertion_point(field_release:aspia.proto.ClientToHost.control)
  
  ::aspia::proto::Control* temp = control_;
  control_ = NULL;
  return temp;
}
inline void ClientToHost::set_allocated_control(::aspia::proto::Control* control) {
  delete control_;
  control_ = control;
  if (control) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.ClientToHost.control)
}

inline const ClientToHost* ClientToHost::internal_default_instance() {
  return &ClientToHost_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace aspia

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aspia::proto::PowerControl_Action> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::KeyEvent_Flags> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::PointerEvent_ButtonMask> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::ClipboardControl_Flags> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::ClipboardEncoding> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::CursorShapeEncoding> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2eproto__INCLUDED

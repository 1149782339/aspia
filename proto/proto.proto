syntax = "proto3";

option optimize_for = LITE_RUNTIME;
option cc_enable_arenas = true;

package proto;

//
// TODO: Протокол передачи файлов
//

//
// Описание взаимодействия сервера и клиента
//
// Установка соединения и авторизация.
// 1. Сервер отправляет клиенту сообщение AuthorizationRequest, которое содержит
//    список поддерживаемых способов авторизации.
// 2. Клиент выбирает метод авторизации и отправляет сообщение AuthorizationReply,
//    которое содержит идентификатор выбранного метода авторизации и учетные данные
//    для выбранного метода.
// 3. Сервер проверяет допустимость метода авторизации и проверяет учетные данные.
//    Если авторизация не пройдена, то клиенту отправляется сообщение AuthorizationResult,
//    в котором поле success установлено в false.
//    Если авторизация пройдена успешно, то клиенту отправляется сообщение AuthorizationResult,
//    в котором поле success установлено в true, а поле features содержит список возможностей
//    сессии.
// 4. Клиент получает сообщение AuthorizationResult. Если список возможнстей не совпадает с
//    требованиями клиента, то клиент в праве разорвать сессию или использовать
//    поддерживаемые (или разрешенные) возможности.
// 5. Сервер находится в ожидании команд от клиента. Сервер не должен без соответствующей
//    команды начинать пересылку видео, аудио или других пакетов.
//
// Передача видео-пакетов
// 1. Клиент отправляет серверу сообщение VideoControl с полем enable установленным в true.
//    Поле encoding (опционально) может указывать желаемую кодировку. Сервер может игнорировать
//    данное поле по своему усмотрению (например, не поддерживать указанную кодировку).
//    Поле pixel_format (опционально) может указывать формат пикселей, который используется
//    клиентом. Сервер может игнорировать данное поле по своему усмотрению (например, не
//    поддерживать указанный формат пикселей)
//    Поле rect не используется (игнорируется) при начале сессии передачи видео-пакетов.
// 2. Сервер должен проверить имеет ли текущая сессия возможность (разрешение) передачи видео-пакетов.
//    Если передача видео-пакетов не возможна, то сообщение VideoControl игнорируется.
//    Если передача видео-пакетов возможна, то сервер должен начать отправку видео-пакетов
//    (сообщение VideoPacket).
// 3. Клиент при получении сообщения VideoPacket должен проверить соответствия размеров
//    экрана, используемого метода кодирования, формата пикселей и при необходимости
//    произвести соответствующие инициализации или переинициализации.
// 4. Если размер видео-окна клиента меньше, чем реальный размер экрана сервера, то в
//    клиенте используются полосы прокрутки. Чтобы минимизировать трафик и не отправлять
//    области экрана, которые в данный момент не видны пользователю клиента, клиент
//    может (опционально) отправить серверу сообщение VideoControl, в котором указать в
//    поле rect область, которая реально видна пользователю (поле enable должно иметь значение
//    true).
//    Сервер не должен посылать области экрана, которые выходят за пределы указанного прямоугольника.
//    Сервер так же может проигнорировать данное сообщение.
// 5. Если клиент временно не нуждает в обновлениях экрана, то он может отправить сообщение
//    VideoControl с полем enable установленным в false. Для возобновления передачи видео-пакетов
//    клиент должен отправить данное сообщение с полем enable установленным в true.
//    Сервер может проигнорировать данное сообщение.
// 6. Если клиент хочет изменить метод кодирования пакетов или формат пикселей, то он должен
//    отправить сообщение VideoControl с указанием соответствующих параметров.
//    Поле enable должно быть установлено в true.
//    Сервер может проигнорировать данное сообщение.
//

enum AuthorizationMethod
{
    AUTH_UNKNOWN = 0;

    // Без запроса учетных данных
    AUTH_NONE = 1;

    // Срадставами протокола (имя пользователя, пароль)
    AUTH_PROTOCOL = 2;

    //
    // По временному паролю (генерируется на время сессии, пользователю сервера выводится
    // диалог c паролем, который он должен передать пользователю клиента).
    //
    AUTH_TEMP_PASS = 3;

    // Средствами Windows (домен, имя пользователя, пароль)
    AUTH_MS_LOGON = 4;
}

//
// Отправляется только от сервера к клиенту
//
message AuthorizationRequest
{
    //
    // Список методов авторизации, которые поддерживает сервер (или которые включены на сервере).
    //
    repeated AuthorizationMethod methods = 1;
}

//
// Отправляется только от клиента к серверу
//
message AuthorizationReply
{
    //
    // Метод с помощью которого производится авторизация.
    // Если сервер поддерживает метод NO_AUTH (без авторизации), то в сообщении используется
    // только это поле, все остальные игнорируются.
    //
    AuthorizationMethod method = 1;

    // Домен (используется при авторизации методом MS_LOGON_AUTH)
    string domain = 2;

    // Имя пользователя (не используется при методе TEMP_PASS_AUTH)
    string user_name = 3;

    // Пароль зашифрованный алгоритмом DES
    bytes password = 4;
}

//
// Возможности сессии
//
enum SessionFeature
{
    FEATURE_UNKNOWN = 0;
    FEATURE_DESKTOP_MANAGE = 1; // Управление рабочим столом
    FEATURE_DESKTOP_VIEW = 2;   // Просмотр рабочего стола
    FEATURE_POWER_MANAGE = 3;   // Управление питанием
    FEATURE_CLIPBOARD = 4;      // Управление буфером обмена
    FEATURE_FILE_TRANSFER = 5;  // Передача файлов
    FEATURE_BELL = 6;           // Звуковой вызов
    FEATURE_TEXT_CHAT = 7;      // Текстовый чат
}

//
// Отправляется только от сервера к клиенту
//
message AuthorizationResult
{
    //
    // Если авторизация прошла успешно, то поле имеет значение true,
    // если нет, то false.
    //
    bool success = 1;

    //
    // Список разрешений, которые применимы для данноЙ авторизации.
    // Если авторизация не пройдена, то данное после отсутствует.
    //
    repeated SessionFeature features = 2;
}

//
// Отправляется только от клиента к серверу
//
message PowerControl
{
    enum PowerAction
    {
        POWER_UNKNOWN = 0;
        POWER_SHUTDOWN = 1;  // ?
        POWER_REBOOT = 2;    // Перезагрузка оперционной системы, в которой запущен сервер
        POWER_POWEROFF = 3;  // ?
        POWER_HIBERNATE = 4; // Переход в режим гибернации
        POWER_SUSPEND = 5;   // Переход в режим сна
        POWER_LOGOFF = 6;    // Завершение сеанса текущего пользователя
    }

    PowerAction action = 1;
}

//
// Отправляется только от клиента к серверу
// Позволяет воспроизвести звуковой сигнал на сервере для привлечения внимания пользователя
//
message Bell
{
    // Продолжительность воспроизведения звукового вызова
    int32 duration = 1;
}

//
// Отправляется в обоих направлениях между сервером и клиентом
//
message TextChat
{
    string message = 1;
}

//
// Отправляется только от клиента к серверу
//
message KeyEvent
{
    uint32 keycode = 1; // Windows virtual key code
    uint32 extended = 2;
    bool pressed = 3;
}

//
// Отправляется только от клиента к серверу
//
message MouseEvent
{
    int32 x = 1;     // x position
    int32 y = 2;     // y position
    uint32 mask = 3; // Button mask
}

//
// Отправляется в обоих направлениях между сервером и клиентом
//
message Clipboard
{
    string mime_type = 1;
    bytes data = 2;
}

//
// Отправляется только от клиента к серверу
//
message ClipboardRequest
{
    // Параметру необходимо присводить любое значение
    bool dummy = 1;
}

//
// Отправляется только от клиента к серверу
//
message ClipboardControl
{
    //
    // Если поле установлено в true, то сервер должен автоматически отправлять содержимое буфера
    // обмена при его изменении.
    // Если поле установлено в false, то сервер не должен автоматически отправлять содержимое
    // буфера обмена.
    // Данное поле может быть проигнорировано сервером.
    //
    bool auto_send = 1;
}

//
// Отправляется только от сервера к клиенту.
//
message CursorShape
{
    // Width, height (in screen pixels) of the cursor.
    int32 width = 1;
    int32 height = 2;

    // X,Y coordinates (relative to upper-left corner) of the cursor hotspot.
    int32 hotspot_x = 3;
    int32 hotspot_y = 4;

    // Cursor pixmap data in 32-bit BGRA format.
    bytes data = 5;
}

message CursorShapeControl
{
    //
    // Если поле установлено в true, то сервер должен начать посылать изображение курсора (сообщение Cursor).
    // Если поле установлено в false, то сервер должен прекратить посылать изображение курсора.
    // Сервер не обязан подчиняться данной команде для приостановки передачи изображения курсора.
    //
    bool enable = 1;
}

message VideoRect
{
    int32 x = 1;
    int32 y = 2;
    int32 width = 3;
    int32 height = 4;
}

message VideoPixelFormat
{
    int32 bits_per_pixel = 1;

    int32 red_max = 2;
    int32 green_max = 3;
    int32 blue_max = 4;

    int32 red_shift = 5;
    int32 green_shift = 6;
    int32 blue_shift = 7;
}

// Identifies how the image was encoded.
enum VideoEncoding
{
    VIDEO_ENCODING_UNKNOWN = 0;
    VIDEO_ENCODING_RAW = 1;
    VIDEO_ENCODING_ZLIB = 2;
    VIDEO_ENCODING_VP8 = 3;
    VIDEO_ENCODING_VP9 = 4;
}

message VideoPacketFormat
{
    // Кодировка, которая используется при текущем обновлении.
    VideoEncoding encoding = 1;

    //
    // Текущая ширина и высота экрана на сервере. При приеме каждого видео
    // пакета клиент должен проверять не изменились ли эти величины. Если они
    // изменились, то клиент должен переинициализировать себя для работы с
    // новыми размерами.
    //
    int32 screen_width = 2;
    int32 screen_height = 3;

    //
    // Формат пикселей, в котором отправлено текущее обновление. При каждом приеме
    // видео-пакета клиент должен проверять не изменился ли формат и переинициализироваться
    // в соответствии с этим. Данный параметр опциональный и используется при кодировках
    // VIDEO_ENCODING_RAW и VIDEO_ENCODING_ZLIB.
    //
    VideoPixelFormat pixel_format = 4;
}

//
// Отправляется только от сервера к клиенту
//
message VideoPacket
{
    //
    // Энкодер может разбить одно обновление на несколько видео-пакетов
    // (например, каждый измененный прямоугольник (VideoRect) с использованием
    // VIDEO_ENCODER_ZLIB отправляется отдельным пакетом).
    // FIRST_PACKET - говорит о том, что пакет является первым.
    // LAST_PACKET - говорит о том, что пакет является последним.
    // Наличие обоих флагов (FIRST_PACKET и LAST_PACKET) говорит о том, что
    // пакет является единственным.
    // PARTITION_PACKET - говорит о том, что пакет является частью логического
    // обновления.
    // Поле format сообщения заполняется только если пакет имеет флаг FIRST_PACKET.
    //
    enum Flags
    {
        UNKNOWN_PACKET = 0;
        FIRST_PACKET = 1;
        LAST_PACKET = 2;
        PARTITION_PACKET = 4;
    }

    int32 flags = 1;

    VideoPacketFormat format = 2;

    // Список измененнившихся областей (прямоугольников).
    repeated VideoRect changed_rect = 3;

    // Закодированные данные
    bytes data = 4;
}

//
// Отправляется только от клиента к серверу.
//
message VideoControl
{
    //
    // Если параметр установлен в true, то клиент имеет потребность в видео-пакетах,
    // если параметр установлен в false, то сервер должен прекратить передавать видео-пакеты.
    // Может использоваться для приостановки получения видео-пакетов при сворачивании окна клиента.
    // Сервер не обязан подчиняться данной команде для приостановки передачи видео-пакетов.
    //
    bool enable = 1;

    //
    // Область экрана сервера в обновлениях которой нуждается клиент. Клиент может изменить
    // размер окна удаленного управления до размера, который меньше, чем размер экрана на сервере.
    // При этом появляются полосы прокрутки, а области, которые за пределами видимой части в
    // обновлениях не нуждаются.
    //
    VideoRect rect = 2;

    //
    // Устанавливает кодировку, которая будет использоваться для кодирования видео-пакетов.
    // Сервер не обязан подчиняться данной команде (может не поддерживать указанную кодировку).
    //
    VideoEncoding encoding = 3;

    //
    // Формат пикселей, который используется клиентом. Если формат клиента отличается от формата
    // сервера, то пиксели в изображении будут перекодированы в формат клиента.
    // Данный параметр применим для кодирования ENCODING_ZLIB и ENCODING_RAW, в остальных
    // случаях игнорируется.
    // Клиент не должен переинициалироваться после отправки данного параметра. Если сервер поддерживает
    // перекодировку в отправленный формат, то при следующем получении сообщения VideoPacket нужно
    // проверить, переключился ли сервер на новый формат и переинициализироваться при необходимости.
    // Сервер не обязан подчиняться данной команде (может не поддерживать указанный формат).
    //
    VideoPixelFormat pixel_format = 4;
}

enum AudioEncoding
{
    AUDIO_ENCODING_UNKNOWN = 0;
    AUDIO_ENCODING_VERBATIM = 1;
    AUDIO_ENCODING_OPUS = 2;
}

//
// Отправляется только от сервера к клиенту
//
message AudioPacket
{
    // Кодировка, которая используется при текущем обновлении
    AudioEncoding encoding = 1;

    // Закодированные данные
    bytes data = 2;
}

//
// Отправляется только от клиента к серверу
//
message AudioControl
{
    //
    // Если параметр установлен в true, то клиент имеет потребность в аудио-пакетах,
    // если параметр установлен в false, то сервер должен прекратить передавать аудио-пакеты.
    // Сервер не обязан подчиняться данной команде для приостановки передачи аудио-пакетов.
    //
    bool enable = 1;

    //
    // Устанавливает кодировку, которая будет использоваться для кодирования аудио-пакетов.
    // Сервер не обязан подчиняться данной команде (может не поддерживать указанную кодировку).
    //
    AudioEncoding encoding = 3;
}

//
// Сообщения, которые отправляются от сервера к клиенту
//
message ServerToClient
{
    VideoPacket video_packet = 1;
    AudioPacket audio_packet = 2;
    CursorShape cursor = 3;
    Clipboard clipboard = 4;
    TextChat text_chat = 5;
    AuthorizationRequest auth_request = 6;
    AuthorizationResult auth_result = 7;
}

//
// Сообщения, которые отправляются от клиента к серверу
//
message ClientToServer
{
    VideoControl video_control = 1;
    AudioControl audio_control = 2;
    CursorShapeControl cursor_shape_control = 3;
    ClipboardControl clipboard_control = 4;
    ClipboardRequest clipboard_request = 5;
    Clipboard clipboard = 6;
    MouseEvent mouse_event = 7;
    KeyEvent key_event = 8;
    Bell bell = 9;
    TextChat text_chat = 10;
    PowerControl power_control = 11;
    AuthorizationReply auth_reply = 12;
}

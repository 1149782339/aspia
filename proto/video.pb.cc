// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: video.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "video.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace aspia {
namespace proto {

void protobuf_ShutdownFile_video_2eproto() {
  VideoRect_default_instance_.Shutdown();
  VideoPixelFormat_default_instance_.Shutdown();
  VideoSize_default_instance_.Shutdown();
  VideoPacketFormat_default_instance_.Shutdown();
  VideoPacket_default_instance_.Shutdown();
  VideoControl_default_instance_.Shutdown();
}

void protobuf_InitDefaults_video_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  VideoRect_default_instance_.DefaultConstruct();
  VideoPixelFormat_default_instance_.DefaultConstruct();
  VideoSize_default_instance_.DefaultConstruct();
  VideoPacketFormat_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  VideoPacket_default_instance_.DefaultConstruct();
  VideoControl_default_instance_.DefaultConstruct();
  VideoRect_default_instance_.get_mutable()->InitAsDefaultInstance();
  VideoPixelFormat_default_instance_.get_mutable()->InitAsDefaultInstance();
  VideoSize_default_instance_.get_mutable()->InitAsDefaultInstance();
  VideoPacketFormat_default_instance_.get_mutable()->InitAsDefaultInstance();
  VideoPacket_default_instance_.get_mutable()->InitAsDefaultInstance();
  VideoControl_default_instance_.get_mutable()->InitAsDefaultInstance();
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_InitDefaults_video_2eproto_once_);
void protobuf_InitDefaults_video_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_InitDefaults_video_2eproto_once_,
                 &protobuf_InitDefaults_video_2eproto_impl);
}
void protobuf_AddDesc_video_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  protobuf_InitDefaults_video_2eproto();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_video_2eproto);
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_video_2eproto_once_);
void protobuf_AddDesc_video_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_video_2eproto_once_,
                 &protobuf_AddDesc_video_2eproto_impl);
}
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_video_2eproto {
  StaticDescriptorInitializer_video_2eproto() {
    protobuf_AddDesc_video_2eproto();
  }
} static_descriptor_initializer_video_2eproto_;
#endif  // GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
bool VideoEncoding_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD GOOGLE_ATTRIBUTE_NORETURN;
static void MergeFromFail(int line) {
  ::google::protobuf::internal::MergeFromFail(__FILE__, line);
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VideoRect::kXFieldNumber;
const int VideoRect::kYFieldNumber;
const int VideoRect::kWidthFieldNumber;
const int VideoRect::kHeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VideoRect::VideoRect()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_video_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.VideoRect)
}

void VideoRect::InitAsDefaultInstance() {
}

VideoRect::VideoRect(const VideoRect& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.VideoRect)
}

void VideoRect::SharedCtor() {
  ::memset(&x_, 0, reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&x_) + sizeof(height_));
  _cached_size_ = 0;
}

VideoRect::~VideoRect() {
  // @@protoc_insertion_point(destructor:aspia.proto.VideoRect)
  SharedDtor();
}

void VideoRect::SharedDtor() {
}

void VideoRect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VideoRect& VideoRect::default_instance() {
  protobuf_InitDefaults_video_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<VideoRect> VideoRect_default_instance_;

VideoRect* VideoRect::New(::google::protobuf::Arena* arena) const {
  VideoRect* n = new VideoRect;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VideoRect::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.VideoRect)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(VideoRect, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<VideoRect*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, height_);

#undef ZR_HELPER_
#undef ZR_

}

bool VideoRect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.VideoRect)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 x = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // optional int32 y = 2;
      case 2: {
        if (tag == 16) {
         parse_y:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_width;
        break;
      }

      // optional int32 width = 3;
      case 3: {
        if (tag == 24) {
         parse_width:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_height;
        break;
      }

      // optional int32 height = 4;
      case 4: {
        if (tag == 32) {
         parse_height:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.VideoRect)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.VideoRect)
  return false;
#undef DO_
}

void VideoRect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.VideoRect)
  // optional int32 x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // optional int32 y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  // optional int32 width = 3;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->width(), output);
  }

  // optional int32 height = 4;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->height(), output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.VideoRect)
}

size_t VideoRect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.VideoRect)
  size_t total_size = 0;

  // optional int32 x = 1;
  if (this->x() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->x());
  }

  // optional int32 y = 2;
  if (this->y() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->y());
  }

  // optional int32 width = 3;
  if (this->width() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->width());
  }

  // optional int32 height = 4;
  if (this->height() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->height());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VideoRect::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VideoRect*>(&from));
}

void VideoRect::MergeFrom(const VideoRect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.VideoRect)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void VideoRect::UnsafeMergeFrom(const VideoRect& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
}

void VideoRect::CopyFrom(const VideoRect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.VideoRect)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool VideoRect::IsInitialized() const {

  return true;
}

void VideoRect::Swap(VideoRect* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VideoRect::InternalSwap(VideoRect* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string VideoRect::GetTypeName() const {
  return "aspia.proto.VideoRect";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VideoRect

// optional int32 x = 1;
void VideoRect::clear_x() {
  x_ = 0;
}
::google::protobuf::int32 VideoRect::x() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoRect.x)
  return x_;
}
void VideoRect::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoRect.x)
}

// optional int32 y = 2;
void VideoRect::clear_y() {
  y_ = 0;
}
::google::protobuf::int32 VideoRect::y() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoRect.y)
  return y_;
}
void VideoRect::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoRect.y)
}

// optional int32 width = 3;
void VideoRect::clear_width() {
  width_ = 0;
}
::google::protobuf::int32 VideoRect::width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoRect.width)
  return width_;
}
void VideoRect::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoRect.width)
}

// optional int32 height = 4;
void VideoRect::clear_height() {
  height_ = 0;
}
::google::protobuf::int32 VideoRect::height() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoRect.height)
  return height_;
}
void VideoRect::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoRect.height)
}

inline const VideoRect* VideoRect::internal_default_instance() {
  return &VideoRect_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VideoPixelFormat::kBitsPerPixelFieldNumber;
const int VideoPixelFormat::kRedMaxFieldNumber;
const int VideoPixelFormat::kGreenMaxFieldNumber;
const int VideoPixelFormat::kBlueMaxFieldNumber;
const int VideoPixelFormat::kRedShiftFieldNumber;
const int VideoPixelFormat::kGreenShiftFieldNumber;
const int VideoPixelFormat::kBlueShiftFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VideoPixelFormat::VideoPixelFormat()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_video_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.VideoPixelFormat)
}

void VideoPixelFormat::InitAsDefaultInstance() {
}

VideoPixelFormat::VideoPixelFormat(const VideoPixelFormat& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.VideoPixelFormat)
}

void VideoPixelFormat::SharedCtor() {
  ::memset(&bits_per_pixel_, 0, reinterpret_cast<char*>(&blue_shift_) -
    reinterpret_cast<char*>(&bits_per_pixel_) + sizeof(blue_shift_));
  _cached_size_ = 0;
}

VideoPixelFormat::~VideoPixelFormat() {
  // @@protoc_insertion_point(destructor:aspia.proto.VideoPixelFormat)
  SharedDtor();
}

void VideoPixelFormat::SharedDtor() {
}

void VideoPixelFormat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VideoPixelFormat& VideoPixelFormat::default_instance() {
  protobuf_InitDefaults_video_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<VideoPixelFormat> VideoPixelFormat_default_instance_;

VideoPixelFormat* VideoPixelFormat::New(::google::protobuf::Arena* arena) const {
  VideoPixelFormat* n = new VideoPixelFormat;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VideoPixelFormat::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.VideoPixelFormat)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(VideoPixelFormat, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<VideoPixelFormat*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(bits_per_pixel_, blue_shift_);

#undef ZR_HELPER_
#undef ZR_

}

bool VideoPixelFormat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.VideoPixelFormat)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 bits_per_pixel = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bits_per_pixel_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_red_max;
        break;
      }

      // optional int32 red_max = 2;
      case 2: {
        if (tag == 16) {
         parse_red_max:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &red_max_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_green_max;
        break;
      }

      // optional int32 green_max = 3;
      case 3: {
        if (tag == 24) {
         parse_green_max:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &green_max_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_blue_max;
        break;
      }

      // optional int32 blue_max = 4;
      case 4: {
        if (tag == 32) {
         parse_blue_max:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &blue_max_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_red_shift;
        break;
      }

      // optional int32 red_shift = 5;
      case 5: {
        if (tag == 40) {
         parse_red_shift:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &red_shift_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_green_shift;
        break;
      }

      // optional int32 green_shift = 6;
      case 6: {
        if (tag == 48) {
         parse_green_shift:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &green_shift_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_blue_shift;
        break;
      }

      // optional int32 blue_shift = 7;
      case 7: {
        if (tag == 56) {
         parse_blue_shift:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &blue_shift_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.VideoPixelFormat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.VideoPixelFormat)
  return false;
#undef DO_
}

void VideoPixelFormat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.VideoPixelFormat)
  // optional int32 bits_per_pixel = 1;
  if (this->bits_per_pixel() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->bits_per_pixel(), output);
  }

  // optional int32 red_max = 2;
  if (this->red_max() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->red_max(), output);
  }

  // optional int32 green_max = 3;
  if (this->green_max() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->green_max(), output);
  }

  // optional int32 blue_max = 4;
  if (this->blue_max() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->blue_max(), output);
  }

  // optional int32 red_shift = 5;
  if (this->red_shift() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->red_shift(), output);
  }

  // optional int32 green_shift = 6;
  if (this->green_shift() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->green_shift(), output);
  }

  // optional int32 blue_shift = 7;
  if (this->blue_shift() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->blue_shift(), output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.VideoPixelFormat)
}

size_t VideoPixelFormat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.VideoPixelFormat)
  size_t total_size = 0;

  // optional int32 bits_per_pixel = 1;
  if (this->bits_per_pixel() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->bits_per_pixel());
  }

  // optional int32 red_max = 2;
  if (this->red_max() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->red_max());
  }

  // optional int32 green_max = 3;
  if (this->green_max() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->green_max());
  }

  // optional int32 blue_max = 4;
  if (this->blue_max() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->blue_max());
  }

  // optional int32 red_shift = 5;
  if (this->red_shift() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->red_shift());
  }

  // optional int32 green_shift = 6;
  if (this->green_shift() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->green_shift());
  }

  // optional int32 blue_shift = 7;
  if (this->blue_shift() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->blue_shift());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VideoPixelFormat::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VideoPixelFormat*>(&from));
}

void VideoPixelFormat::MergeFrom(const VideoPixelFormat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.VideoPixelFormat)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void VideoPixelFormat::UnsafeMergeFrom(const VideoPixelFormat& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.bits_per_pixel() != 0) {
    set_bits_per_pixel(from.bits_per_pixel());
  }
  if (from.red_max() != 0) {
    set_red_max(from.red_max());
  }
  if (from.green_max() != 0) {
    set_green_max(from.green_max());
  }
  if (from.blue_max() != 0) {
    set_blue_max(from.blue_max());
  }
  if (from.red_shift() != 0) {
    set_red_shift(from.red_shift());
  }
  if (from.green_shift() != 0) {
    set_green_shift(from.green_shift());
  }
  if (from.blue_shift() != 0) {
    set_blue_shift(from.blue_shift());
  }
}

void VideoPixelFormat::CopyFrom(const VideoPixelFormat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.VideoPixelFormat)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool VideoPixelFormat::IsInitialized() const {

  return true;
}

void VideoPixelFormat::Swap(VideoPixelFormat* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VideoPixelFormat::InternalSwap(VideoPixelFormat* other) {
  std::swap(bits_per_pixel_, other->bits_per_pixel_);
  std::swap(red_max_, other->red_max_);
  std::swap(green_max_, other->green_max_);
  std::swap(blue_max_, other->blue_max_);
  std::swap(red_shift_, other->red_shift_);
  std::swap(green_shift_, other->green_shift_);
  std::swap(blue_shift_, other->blue_shift_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string VideoPixelFormat::GetTypeName() const {
  return "aspia.proto.VideoPixelFormat";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VideoPixelFormat

// optional int32 bits_per_pixel = 1;
void VideoPixelFormat::clear_bits_per_pixel() {
  bits_per_pixel_ = 0;
}
::google::protobuf::int32 VideoPixelFormat::bits_per_pixel() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPixelFormat.bits_per_pixel)
  return bits_per_pixel_;
}
void VideoPixelFormat::set_bits_per_pixel(::google::protobuf::int32 value) {
  
  bits_per_pixel_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoPixelFormat.bits_per_pixel)
}

// optional int32 red_max = 2;
void VideoPixelFormat::clear_red_max() {
  red_max_ = 0;
}
::google::protobuf::int32 VideoPixelFormat::red_max() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPixelFormat.red_max)
  return red_max_;
}
void VideoPixelFormat::set_red_max(::google::protobuf::int32 value) {
  
  red_max_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoPixelFormat.red_max)
}

// optional int32 green_max = 3;
void VideoPixelFormat::clear_green_max() {
  green_max_ = 0;
}
::google::protobuf::int32 VideoPixelFormat::green_max() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPixelFormat.green_max)
  return green_max_;
}
void VideoPixelFormat::set_green_max(::google::protobuf::int32 value) {
  
  green_max_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoPixelFormat.green_max)
}

// optional int32 blue_max = 4;
void VideoPixelFormat::clear_blue_max() {
  blue_max_ = 0;
}
::google::protobuf::int32 VideoPixelFormat::blue_max() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPixelFormat.blue_max)
  return blue_max_;
}
void VideoPixelFormat::set_blue_max(::google::protobuf::int32 value) {
  
  blue_max_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoPixelFormat.blue_max)
}

// optional int32 red_shift = 5;
void VideoPixelFormat::clear_red_shift() {
  red_shift_ = 0;
}
::google::protobuf::int32 VideoPixelFormat::red_shift() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPixelFormat.red_shift)
  return red_shift_;
}
void VideoPixelFormat::set_red_shift(::google::protobuf::int32 value) {
  
  red_shift_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoPixelFormat.red_shift)
}

// optional int32 green_shift = 6;
void VideoPixelFormat::clear_green_shift() {
  green_shift_ = 0;
}
::google::protobuf::int32 VideoPixelFormat::green_shift() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPixelFormat.green_shift)
  return green_shift_;
}
void VideoPixelFormat::set_green_shift(::google::protobuf::int32 value) {
  
  green_shift_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoPixelFormat.green_shift)
}

// optional int32 blue_shift = 7;
void VideoPixelFormat::clear_blue_shift() {
  blue_shift_ = 0;
}
::google::protobuf::int32 VideoPixelFormat::blue_shift() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPixelFormat.blue_shift)
  return blue_shift_;
}
void VideoPixelFormat::set_blue_shift(::google::protobuf::int32 value) {
  
  blue_shift_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoPixelFormat.blue_shift)
}

inline const VideoPixelFormat* VideoPixelFormat::internal_default_instance() {
  return &VideoPixelFormat_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VideoSize::kWidthFieldNumber;
const int VideoSize::kHeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VideoSize::VideoSize()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_video_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.VideoSize)
}

void VideoSize::InitAsDefaultInstance() {
}

VideoSize::VideoSize(const VideoSize& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.VideoSize)
}

void VideoSize::SharedCtor() {
  ::memset(&width_, 0, reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_) + sizeof(height_));
  _cached_size_ = 0;
}

VideoSize::~VideoSize() {
  // @@protoc_insertion_point(destructor:aspia.proto.VideoSize)
  SharedDtor();
}

void VideoSize::SharedDtor() {
}

void VideoSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VideoSize& VideoSize::default_instance() {
  protobuf_InitDefaults_video_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<VideoSize> VideoSize_default_instance_;

VideoSize* VideoSize::New(::google::protobuf::Arena* arena) const {
  VideoSize* n = new VideoSize;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VideoSize::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.VideoSize)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(VideoSize, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<VideoSize*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(width_, height_);

#undef ZR_HELPER_
#undef ZR_

}

bool VideoSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.VideoSize)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 width = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_height;
        break;
      }

      // optional int32 height = 2;
      case 2: {
        if (tag == 16) {
         parse_height:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.VideoSize)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.VideoSize)
  return false;
#undef DO_
}

void VideoSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.VideoSize)
  // optional int32 width = 1;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->width(), output);
  }

  // optional int32 height = 2;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->height(), output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.VideoSize)
}

size_t VideoSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.VideoSize)
  size_t total_size = 0;

  // optional int32 width = 1;
  if (this->width() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->width());
  }

  // optional int32 height = 2;
  if (this->height() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->height());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VideoSize::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VideoSize*>(&from));
}

void VideoSize::MergeFrom(const VideoSize& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.VideoSize)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void VideoSize::UnsafeMergeFrom(const VideoSize& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
}

void VideoSize::CopyFrom(const VideoSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.VideoSize)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool VideoSize::IsInitialized() const {

  return true;
}

void VideoSize::Swap(VideoSize* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VideoSize::InternalSwap(VideoSize* other) {
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string VideoSize::GetTypeName() const {
  return "aspia.proto.VideoSize";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VideoSize

// optional int32 width = 1;
void VideoSize::clear_width() {
  width_ = 0;
}
::google::protobuf::int32 VideoSize::width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoSize.width)
  return width_;
}
void VideoSize::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoSize.width)
}

// optional int32 height = 2;
void VideoSize::clear_height() {
  height_ = 0;
}
::google::protobuf::int32 VideoSize::height() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoSize.height)
  return height_;
}
void VideoSize::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoSize.height)
}

inline const VideoSize* VideoSize::internal_default_instance() {
  return &VideoSize_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VideoPacketFormat::kEncodingFieldNumber;
const int VideoPacketFormat::kScreenSizeFieldNumber;
const int VideoPacketFormat::kPixelFormatFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VideoPacketFormat::VideoPacketFormat()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_video_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.VideoPacketFormat)
}

void VideoPacketFormat::InitAsDefaultInstance() {
  screen_size_ = const_cast< ::aspia::proto::VideoSize*>(
      ::aspia::proto::VideoSize::internal_default_instance());
  pixel_format_ = const_cast< ::aspia::proto::VideoPixelFormat*>(
      ::aspia::proto::VideoPixelFormat::internal_default_instance());
}

VideoPacketFormat::VideoPacketFormat(const VideoPacketFormat& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.VideoPacketFormat)
}

void VideoPacketFormat::SharedCtor() {
  screen_size_ = NULL;
  pixel_format_ = NULL;
  encoding_ = 0;
  _cached_size_ = 0;
}

VideoPacketFormat::~VideoPacketFormat() {
  // @@protoc_insertion_point(destructor:aspia.proto.VideoPacketFormat)
  SharedDtor();
}

void VideoPacketFormat::SharedDtor() {
  if (this != &VideoPacketFormat_default_instance_.get()) {
    delete screen_size_;
    delete pixel_format_;
  }
}

void VideoPacketFormat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VideoPacketFormat& VideoPacketFormat::default_instance() {
  protobuf_InitDefaults_video_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<VideoPacketFormat> VideoPacketFormat_default_instance_;

VideoPacketFormat* VideoPacketFormat::New(::google::protobuf::Arena* arena) const {
  VideoPacketFormat* n = new VideoPacketFormat;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VideoPacketFormat::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.VideoPacketFormat)
  encoding_ = 0;
  if (GetArenaNoVirtual() == NULL && screen_size_ != NULL) delete screen_size_;
  screen_size_ = NULL;
  if (GetArenaNoVirtual() == NULL && pixel_format_ != NULL) delete pixel_format_;
  pixel_format_ = NULL;
}

bool VideoPacketFormat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.VideoPacketFormat)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .aspia.proto.VideoEncoding encoding = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_encoding(static_cast< ::aspia::proto::VideoEncoding >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_screen_size;
        break;
      }

      // optional .aspia.proto.VideoSize screen_size = 2;
      case 2: {
        if (tag == 18) {
         parse_screen_size:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_screen_size()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_pixel_format;
        break;
      }

      // optional .aspia.proto.VideoPixelFormat pixel_format = 3;
      case 3: {
        if (tag == 26) {
         parse_pixel_format:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pixel_format()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.VideoPacketFormat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.VideoPacketFormat)
  return false;
#undef DO_
}

void VideoPacketFormat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.VideoPacketFormat)
  // optional .aspia.proto.VideoEncoding encoding = 1;
  if (this->encoding() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->encoding(), output);
  }

  // optional .aspia.proto.VideoSize screen_size = 2;
  if (this->has_screen_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->screen_size_, output);
  }

  // optional .aspia.proto.VideoPixelFormat pixel_format = 3;
  if (this->has_pixel_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->pixel_format_, output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.VideoPacketFormat)
}

size_t VideoPacketFormat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.VideoPacketFormat)
  size_t total_size = 0;

  // optional .aspia.proto.VideoEncoding encoding = 1;
  if (this->encoding() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->encoding());
  }

  // optional .aspia.proto.VideoSize screen_size = 2;
  if (this->has_screen_size()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->screen_size_);
  }

  // optional .aspia.proto.VideoPixelFormat pixel_format = 3;
  if (this->has_pixel_format()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pixel_format_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VideoPacketFormat::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VideoPacketFormat*>(&from));
}

void VideoPacketFormat::MergeFrom(const VideoPacketFormat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.VideoPacketFormat)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void VideoPacketFormat::UnsafeMergeFrom(const VideoPacketFormat& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.encoding() != 0) {
    set_encoding(from.encoding());
  }
  if (from.has_screen_size()) {
    mutable_screen_size()->::aspia::proto::VideoSize::MergeFrom(from.screen_size());
  }
  if (from.has_pixel_format()) {
    mutable_pixel_format()->::aspia::proto::VideoPixelFormat::MergeFrom(from.pixel_format());
  }
}

void VideoPacketFormat::CopyFrom(const VideoPacketFormat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.VideoPacketFormat)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool VideoPacketFormat::IsInitialized() const {

  return true;
}

void VideoPacketFormat::Swap(VideoPacketFormat* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VideoPacketFormat::InternalSwap(VideoPacketFormat* other) {
  std::swap(encoding_, other->encoding_);
  std::swap(screen_size_, other->screen_size_);
  std::swap(pixel_format_, other->pixel_format_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string VideoPacketFormat::GetTypeName() const {
  return "aspia.proto.VideoPacketFormat";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VideoPacketFormat

// optional .aspia.proto.VideoEncoding encoding = 1;
void VideoPacketFormat::clear_encoding() {
  encoding_ = 0;
}
::aspia::proto::VideoEncoding VideoPacketFormat::encoding() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPacketFormat.encoding)
  return static_cast< ::aspia::proto::VideoEncoding >(encoding_);
}
void VideoPacketFormat::set_encoding(::aspia::proto::VideoEncoding value) {
  
  encoding_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoPacketFormat.encoding)
}

// optional .aspia.proto.VideoSize screen_size = 2;
bool VideoPacketFormat::has_screen_size() const {
  return this != internal_default_instance() && screen_size_ != NULL;
}
void VideoPacketFormat::clear_screen_size() {
  if (GetArenaNoVirtual() == NULL && screen_size_ != NULL) delete screen_size_;
  screen_size_ = NULL;
}
const ::aspia::proto::VideoSize& VideoPacketFormat::screen_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPacketFormat.screen_size)
  return screen_size_ != NULL ? *screen_size_
                         : *::aspia::proto::VideoSize::internal_default_instance();
}
::aspia::proto::VideoSize* VideoPacketFormat::mutable_screen_size() {
  
  if (screen_size_ == NULL) {
    screen_size_ = new ::aspia::proto::VideoSize;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoPacketFormat.screen_size)
  return screen_size_;
}
::aspia::proto::VideoSize* VideoPacketFormat::release_screen_size() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoPacketFormat.screen_size)
  
  ::aspia::proto::VideoSize* temp = screen_size_;
  screen_size_ = NULL;
  return temp;
}
void VideoPacketFormat::set_allocated_screen_size(::aspia::proto::VideoSize* screen_size) {
  delete screen_size_;
  screen_size_ = screen_size;
  if (screen_size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoPacketFormat.screen_size)
}

// optional .aspia.proto.VideoPixelFormat pixel_format = 3;
bool VideoPacketFormat::has_pixel_format() const {
  return this != internal_default_instance() && pixel_format_ != NULL;
}
void VideoPacketFormat::clear_pixel_format() {
  if (GetArenaNoVirtual() == NULL && pixel_format_ != NULL) delete pixel_format_;
  pixel_format_ = NULL;
}
const ::aspia::proto::VideoPixelFormat& VideoPacketFormat::pixel_format() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPacketFormat.pixel_format)
  return pixel_format_ != NULL ? *pixel_format_
                         : *::aspia::proto::VideoPixelFormat::internal_default_instance();
}
::aspia::proto::VideoPixelFormat* VideoPacketFormat::mutable_pixel_format() {
  
  if (pixel_format_ == NULL) {
    pixel_format_ = new ::aspia::proto::VideoPixelFormat;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoPacketFormat.pixel_format)
  return pixel_format_;
}
::aspia::proto::VideoPixelFormat* VideoPacketFormat::release_pixel_format() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoPacketFormat.pixel_format)
  
  ::aspia::proto::VideoPixelFormat* temp = pixel_format_;
  pixel_format_ = NULL;
  return temp;
}
void VideoPacketFormat::set_allocated_pixel_format(::aspia::proto::VideoPixelFormat* pixel_format) {
  delete pixel_format_;
  pixel_format_ = pixel_format;
  if (pixel_format) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoPacketFormat.pixel_format)
}

inline const VideoPacketFormat* VideoPacketFormat::internal_default_instance() {
  return &VideoPacketFormat_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

bool VideoPacket_Flags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const VideoPacket_Flags VideoPacket::PARTITION_PACKET;
const VideoPacket_Flags VideoPacket::FIRST_PACKET;
const VideoPacket_Flags VideoPacket::LAST_PACKET;
const VideoPacket_Flags VideoPacket::Flags_MIN;
const VideoPacket_Flags VideoPacket::Flags_MAX;
const int VideoPacket::Flags_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VideoPacket::kFlagsFieldNumber;
const int VideoPacket::kFormatFieldNumber;
const int VideoPacket::kDirtyRectFieldNumber;
const int VideoPacket::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VideoPacket::VideoPacket()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_video_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.VideoPacket)
}

void VideoPacket::InitAsDefaultInstance() {
  format_ = const_cast< ::aspia::proto::VideoPacketFormat*>(
      ::aspia::proto::VideoPacketFormat::internal_default_instance());
}

VideoPacket::VideoPacket(const VideoPacket& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.VideoPacket)
}

void VideoPacket::SharedCtor() {
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  format_ = NULL;
  flags_ = 0u;
  _cached_size_ = 0;
}

VideoPacket::~VideoPacket() {
  // @@protoc_insertion_point(destructor:aspia.proto.VideoPacket)
  SharedDtor();
}

void VideoPacket::SharedDtor() {
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != &VideoPacket_default_instance_.get()) {
    delete format_;
  }
}

void VideoPacket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VideoPacket& VideoPacket::default_instance() {
  protobuf_InitDefaults_video_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<VideoPacket> VideoPacket_default_instance_;

VideoPacket* VideoPacket::New(::google::protobuf::Arena* arena) const {
  VideoPacket* n = new VideoPacket;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VideoPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.VideoPacket)
  flags_ = 0u;
  if (GetArenaNoVirtual() == NULL && format_ != NULL) delete format_;
  format_ = NULL;
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dirty_rect_.Clear();
}

bool VideoPacket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.VideoPacket)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 flags = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_format;
        break;
      }

      // optional .aspia.proto.VideoPacketFormat format = 2;
      case 2: {
        if (tag == 18) {
         parse_format:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_format()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_dirty_rect;
        break;
      }

      // repeated .aspia.proto.VideoRect dirty_rect = 3;
      case 3: {
        if (tag == 26) {
         parse_dirty_rect:
          DO_(input->IncrementRecursionDepth());
         parse_loop_dirty_rect:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_dirty_rect()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_dirty_rect;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }

      // optional bytes data = 4;
      case 4: {
        if (tag == 34) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.VideoPacket)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.VideoPacket)
  return false;
#undef DO_
}

void VideoPacket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.VideoPacket)
  // optional uint32 flags = 1;
  if (this->flags() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->flags(), output);
  }

  // optional .aspia.proto.VideoPacketFormat format = 2;
  if (this->has_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->format_, output);
  }

  // repeated .aspia.proto.VideoRect dirty_rect = 3;
  for (unsigned int i = 0, n = this->dirty_rect_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->dirty_rect(i), output);
  }

  // optional bytes data = 4;
  if (this->data().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->data(), output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.VideoPacket)
}

size_t VideoPacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.VideoPacket)
  size_t total_size = 0;

  // optional uint32 flags = 1;
  if (this->flags() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->flags());
  }

  // optional .aspia.proto.VideoPacketFormat format = 2;
  if (this->has_format()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->format_);
  }

  // optional bytes data = 4;
  if (this->data().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());
  }

  // repeated .aspia.proto.VideoRect dirty_rect = 3;
  {
    unsigned int count = this->dirty_rect_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dirty_rect(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VideoPacket::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VideoPacket*>(&from));
}

void VideoPacket::MergeFrom(const VideoPacket& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.VideoPacket)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void VideoPacket::UnsafeMergeFrom(const VideoPacket& from) {
  GOOGLE_DCHECK(&from != this);
  dirty_rect_.MergeFrom(from.dirty_rect_);
  if (from.flags() != 0) {
    set_flags(from.flags());
  }
  if (from.has_format()) {
    mutable_format()->::aspia::proto::VideoPacketFormat::MergeFrom(from.format());
  }
  if (from.data().size() > 0) {

    data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
}

void VideoPacket::CopyFrom(const VideoPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.VideoPacket)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool VideoPacket::IsInitialized() const {

  return true;
}

void VideoPacket::Swap(VideoPacket* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VideoPacket::InternalSwap(VideoPacket* other) {
  std::swap(flags_, other->flags_);
  std::swap(format_, other->format_);
  dirty_rect_.UnsafeArenaSwap(&other->dirty_rect_);
  data_.Swap(&other->data_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string VideoPacket::GetTypeName() const {
  return "aspia.proto.VideoPacket";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VideoPacket

// optional uint32 flags = 1;
void VideoPacket::clear_flags() {
  flags_ = 0u;
}
::google::protobuf::uint32 VideoPacket::flags() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPacket.flags)
  return flags_;
}
void VideoPacket::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoPacket.flags)
}

// optional .aspia.proto.VideoPacketFormat format = 2;
bool VideoPacket::has_format() const {
  return this != internal_default_instance() && format_ != NULL;
}
void VideoPacket::clear_format() {
  if (GetArenaNoVirtual() == NULL && format_ != NULL) delete format_;
  format_ = NULL;
}
const ::aspia::proto::VideoPacketFormat& VideoPacket::format() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPacket.format)
  return format_ != NULL ? *format_
                         : *::aspia::proto::VideoPacketFormat::internal_default_instance();
}
::aspia::proto::VideoPacketFormat* VideoPacket::mutable_format() {
  
  if (format_ == NULL) {
    format_ = new ::aspia::proto::VideoPacketFormat;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoPacket.format)
  return format_;
}
::aspia::proto::VideoPacketFormat* VideoPacket::release_format() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoPacket.format)
  
  ::aspia::proto::VideoPacketFormat* temp = format_;
  format_ = NULL;
  return temp;
}
void VideoPacket::set_allocated_format(::aspia::proto::VideoPacketFormat* format) {
  delete format_;
  format_ = format;
  if (format) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoPacket.format)
}

// repeated .aspia.proto.VideoRect dirty_rect = 3;
int VideoPacket::dirty_rect_size() const {
  return dirty_rect_.size();
}
void VideoPacket::clear_dirty_rect() {
  dirty_rect_.Clear();
}
const ::aspia::proto::VideoRect& VideoPacket::dirty_rect(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPacket.dirty_rect)
  return dirty_rect_.Get(index);
}
::aspia::proto::VideoRect* VideoPacket::mutable_dirty_rect(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoPacket.dirty_rect)
  return dirty_rect_.Mutable(index);
}
::aspia::proto::VideoRect* VideoPacket::add_dirty_rect() {
  // @@protoc_insertion_point(field_add:aspia.proto.VideoPacket.dirty_rect)
  return dirty_rect_.Add();
}
::google::protobuf::RepeatedPtrField< ::aspia::proto::VideoRect >*
VideoPacket::mutable_dirty_rect() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.VideoPacket.dirty_rect)
  return &dirty_rect_;
}
const ::google::protobuf::RepeatedPtrField< ::aspia::proto::VideoRect >&
VideoPacket::dirty_rect() const {
  // @@protoc_insertion_point(field_list:aspia.proto.VideoPacket.dirty_rect)
  return dirty_rect_;
}

// optional bytes data = 4;
void VideoPacket::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& VideoPacket::data() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoPacket.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void VideoPacket::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoPacket.data)
}
void VideoPacket::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoPacket.data)
}
void VideoPacket::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoPacket.data)
}
::std::string* VideoPacket::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoPacket.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* VideoPacket::release_data() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoPacket.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void VideoPacket::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoPacket.data)
}

inline const VideoPacket* VideoPacket::internal_default_instance() {
  return &VideoPacket_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

bool VideoControl_Flags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const VideoControl_Flags VideoControl::DISABLE_VIDEO;
const VideoControl_Flags VideoControl::ENABLE_VIDEO;
const VideoControl_Flags VideoControl::ENABLE_CURSOR_SHAPE;
const VideoControl_Flags VideoControl::DISABLE_DESKTOP_EFFECTS;
const VideoControl_Flags VideoControl::Flags_MIN;
const VideoControl_Flags VideoControl::Flags_MAX;
const int VideoControl::Flags_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VideoControl::kFlagsFieldNumber;
const int VideoControl::kEncodingFieldNumber;
const int VideoControl::kPixelFormatFieldNumber;
const int VideoControl::kUpdateIntervalFieldNumber;
const int VideoControl::kCompressRatioFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VideoControl::VideoControl()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_video_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.VideoControl)
}

void VideoControl::InitAsDefaultInstance() {
  pixel_format_ = const_cast< ::aspia::proto::VideoPixelFormat*>(
      ::aspia::proto::VideoPixelFormat::internal_default_instance());
}

VideoControl::VideoControl(const VideoControl& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:aspia.proto.VideoControl)
}

void VideoControl::SharedCtor() {
  pixel_format_ = NULL;
  ::memset(&flags_, 0, reinterpret_cast<char*>(&compress_ratio_) -
    reinterpret_cast<char*>(&flags_) + sizeof(compress_ratio_));
  _cached_size_ = 0;
}

VideoControl::~VideoControl() {
  // @@protoc_insertion_point(destructor:aspia.proto.VideoControl)
  SharedDtor();
}

void VideoControl::SharedDtor() {
  if (this != &VideoControl_default_instance_.get()) {
    delete pixel_format_;
  }
}

void VideoControl::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VideoControl& VideoControl::default_instance() {
  protobuf_InitDefaults_video_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<VideoControl> VideoControl_default_instance_;

VideoControl* VideoControl::New(::google::protobuf::Arena* arena) const {
  VideoControl* n = new VideoControl;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VideoControl::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.VideoControl)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(VideoControl, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<VideoControl*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(flags_, compress_ratio_);
  if (GetArenaNoVirtual() == NULL && pixel_format_ != NULL) delete pixel_format_;
  pixel_format_ = NULL;

#undef ZR_HELPER_
#undef ZR_

}

bool VideoControl::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:aspia.proto.VideoControl)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 flags = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_encoding;
        break;
      }

      // optional .aspia.proto.VideoEncoding encoding = 2;
      case 2: {
        if (tag == 16) {
         parse_encoding:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_encoding(static_cast< ::aspia::proto::VideoEncoding >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_pixel_format;
        break;
      }

      // optional .aspia.proto.VideoPixelFormat pixel_format = 3;
      case 3: {
        if (tag == 26) {
         parse_pixel_format:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pixel_format()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_update_interval;
        break;
      }

      // optional int32 update_interval = 4;
      case 4: {
        if (tag == 32) {
         parse_update_interval:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &update_interval_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_compress_ratio;
        break;
      }

      // optional int32 compress_ratio = 5;
      case 5: {
        if (tag == 40) {
         parse_compress_ratio:

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &compress_ratio_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.VideoControl)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.VideoControl)
  return false;
#undef DO_
}

void VideoControl::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.VideoControl)
  // optional uint32 flags = 1;
  if (this->flags() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->flags(), output);
  }

  // optional .aspia.proto.VideoEncoding encoding = 2;
  if (this->encoding() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->encoding(), output);
  }

  // optional .aspia.proto.VideoPixelFormat pixel_format = 3;
  if (this->has_pixel_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->pixel_format_, output);
  }

  // optional int32 update_interval = 4;
  if (this->update_interval() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->update_interval(), output);
  }

  // optional int32 compress_ratio = 5;
  if (this->compress_ratio() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->compress_ratio(), output);
  }

  // @@protoc_insertion_point(serialize_end:aspia.proto.VideoControl)
}

size_t VideoControl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.VideoControl)
  size_t total_size = 0;

  // optional uint32 flags = 1;
  if (this->flags() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->flags());
  }

  // optional .aspia.proto.VideoEncoding encoding = 2;
  if (this->encoding() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->encoding());
  }

  // optional .aspia.proto.VideoPixelFormat pixel_format = 3;
  if (this->has_pixel_format()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pixel_format_);
  }

  // optional int32 update_interval = 4;
  if (this->update_interval() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->update_interval());
  }

  // optional int32 compress_ratio = 5;
  if (this->compress_ratio() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->compress_ratio());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VideoControl::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VideoControl*>(&from));
}

void VideoControl::MergeFrom(const VideoControl& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.VideoControl)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void VideoControl::UnsafeMergeFrom(const VideoControl& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.flags() != 0) {
    set_flags(from.flags());
  }
  if (from.encoding() != 0) {
    set_encoding(from.encoding());
  }
  if (from.has_pixel_format()) {
    mutable_pixel_format()->::aspia::proto::VideoPixelFormat::MergeFrom(from.pixel_format());
  }
  if (from.update_interval() != 0) {
    set_update_interval(from.update_interval());
  }
  if (from.compress_ratio() != 0) {
    set_compress_ratio(from.compress_ratio());
  }
}

void VideoControl::CopyFrom(const VideoControl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.VideoControl)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool VideoControl::IsInitialized() const {

  return true;
}

void VideoControl::Swap(VideoControl* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VideoControl::InternalSwap(VideoControl* other) {
  std::swap(flags_, other->flags_);
  std::swap(encoding_, other->encoding_);
  std::swap(pixel_format_, other->pixel_format_);
  std::swap(update_interval_, other->update_interval_);
  std::swap(compress_ratio_, other->compress_ratio_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string VideoControl::GetTypeName() const {
  return "aspia.proto.VideoControl";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VideoControl

// optional uint32 flags = 1;
void VideoControl::clear_flags() {
  flags_ = 0u;
}
::google::protobuf::uint32 VideoControl::flags() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoControl.flags)
  return flags_;
}
void VideoControl::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoControl.flags)
}

// optional .aspia.proto.VideoEncoding encoding = 2;
void VideoControl::clear_encoding() {
  encoding_ = 0;
}
::aspia::proto::VideoEncoding VideoControl::encoding() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoControl.encoding)
  return static_cast< ::aspia::proto::VideoEncoding >(encoding_);
}
void VideoControl::set_encoding(::aspia::proto::VideoEncoding value) {
  
  encoding_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoControl.encoding)
}

// optional .aspia.proto.VideoPixelFormat pixel_format = 3;
bool VideoControl::has_pixel_format() const {
  return this != internal_default_instance() && pixel_format_ != NULL;
}
void VideoControl::clear_pixel_format() {
  if (GetArenaNoVirtual() == NULL && pixel_format_ != NULL) delete pixel_format_;
  pixel_format_ = NULL;
}
const ::aspia::proto::VideoPixelFormat& VideoControl::pixel_format() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoControl.pixel_format)
  return pixel_format_ != NULL ? *pixel_format_
                         : *::aspia::proto::VideoPixelFormat::internal_default_instance();
}
::aspia::proto::VideoPixelFormat* VideoControl::mutable_pixel_format() {
  
  if (pixel_format_ == NULL) {
    pixel_format_ = new ::aspia::proto::VideoPixelFormat;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoControl.pixel_format)
  return pixel_format_;
}
::aspia::proto::VideoPixelFormat* VideoControl::release_pixel_format() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoControl.pixel_format)
  
  ::aspia::proto::VideoPixelFormat* temp = pixel_format_;
  pixel_format_ = NULL;
  return temp;
}
void VideoControl::set_allocated_pixel_format(::aspia::proto::VideoPixelFormat* pixel_format) {
  delete pixel_format_;
  pixel_format_ = pixel_format;
  if (pixel_format) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoControl.pixel_format)
}

// optional int32 update_interval = 4;
void VideoControl::clear_update_interval() {
  update_interval_ = 0;
}
::google::protobuf::int32 VideoControl::update_interval() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoControl.update_interval)
  return update_interval_;
}
void VideoControl::set_update_interval(::google::protobuf::int32 value) {
  
  update_interval_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoControl.update_interval)
}

// optional int32 compress_ratio = 5;
void VideoControl::clear_compress_ratio() {
  compress_ratio_ = 0;
}
::google::protobuf::int32 VideoControl::compress_ratio() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoControl.compress_ratio)
  return compress_ratio_;
}
void VideoControl::set_compress_ratio(::google::protobuf::int32 value) {
  
  compress_ratio_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoControl.compress_ratio)
}

inline const VideoControl* VideoControl::internal_default_instance() {
  return &VideoControl_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace aspia

// @@protoc_insertion_point(global_scope)

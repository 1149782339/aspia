// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: category_dmi_bios.proto

#include "category_dmi_bios.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)
namespace aspia {
namespace proto {
class DmiBios_CharacteristicsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<DmiBios_Characteristics>
      _instance;
} _DmiBios_Characteristics_default_instance_;
class DmiBiosDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<DmiBios>
      _instance;
} _DmiBios_default_instance_;
}  // namespace proto
}  // namespace aspia
namespace protobuf_category_5fdmi_5fbios_2eproto {
void InitDefaultsDmiBios_CharacteristicsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::aspia::proto::_DmiBios_Characteristics_default_instance_;
    new (ptr) ::aspia::proto::DmiBios_Characteristics();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::DmiBios_Characteristics::InitAsDefaultInstance();
}

void InitDefaultsDmiBios_Characteristics() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsDmiBios_CharacteristicsImpl);
}

void InitDefaultsDmiBiosImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_category_5fdmi_5fbios_2eproto::InitDefaultsDmiBios_Characteristics();
  {
    void* ptr = &::aspia::proto::_DmiBios_default_instance_;
    new (ptr) ::aspia::proto::DmiBios();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::DmiBios::InitAsDefaultInstance();
}

void InitDefaultsDmiBios() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsDmiBiosImpl);
}

}  // namespace protobuf_category_5fdmi_5fbios_2eproto
namespace aspia {
namespace proto {

// ===================================================================

void DmiBios_Characteristics::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DmiBios_Characteristics::kHasIsaFieldNumber;
const int DmiBios_Characteristics::kHasMcaFieldNumber;
const int DmiBios_Characteristics::kHasEisaFieldNumber;
const int DmiBios_Characteristics::kHasPciFieldNumber;
const int DmiBios_Characteristics::kHasPcCardFieldNumber;
const int DmiBios_Characteristics::kHasPnpFieldNumber;
const int DmiBios_Characteristics::kHasApmFieldNumber;
const int DmiBios_Characteristics::kHasBiosUpgradeableFieldNumber;
const int DmiBios_Characteristics::kHasBiosShadowingFieldNumber;
const int DmiBios_Characteristics::kHasVlbFieldNumber;
const int DmiBios_Characteristics::kHasEscdFieldNumber;
const int DmiBios_Characteristics::kHasBootFromCdFieldNumber;
const int DmiBios_Characteristics::kHasSelectableBootFieldNumber;
const int DmiBios_Characteristics::kHasSocketedBootRomFieldNumber;
const int DmiBios_Characteristics::kHasBootFromPcCardFieldNumber;
const int DmiBios_Characteristics::kHasEddFieldNumber;
const int DmiBios_Characteristics::kHasJapaneseFloppyForNec9800FieldNumber;
const int DmiBios_Characteristics::kHasJapaneceFloppyForToshibaFieldNumber;
const int DmiBios_Characteristics::kHas525360KbFloppyFieldNumber;
const int DmiBios_Characteristics::kHas52512MbFloppyFieldNumber;
const int DmiBios_Characteristics::kHas35720KbFloppyFieldNumber;
const int DmiBios_Characteristics::kHas35288MbFloppyFieldNumber;
const int DmiBios_Characteristics::kHasPrintScreenFieldNumber;
const int DmiBios_Characteristics::kHas8042KeyboardFieldNumber;
const int DmiBios_Characteristics::kHasSerialFieldNumber;
const int DmiBios_Characteristics::kHasPrinterFieldNumber;
const int DmiBios_Characteristics::kHasCgaVideoFieldNumber;
const int DmiBios_Characteristics::kHasNecPc98FieldNumber;
const int DmiBios_Characteristics::kHasAcpiFieldNumber;
const int DmiBios_Characteristics::kHasUsbLegacyFieldNumber;
const int DmiBios_Characteristics::kHasAgpFieldNumber;
const int DmiBios_Characteristics::kHasI2OBootFieldNumber;
const int DmiBios_Characteristics::kHasLs120BootFieldNumber;
const int DmiBios_Characteristics::kHasAtapiZipDriveBootFieldNumber;
const int DmiBios_Characteristics::kHasIeee1394BootFieldNumber;
const int DmiBios_Characteristics::kHasSmartBatteryFieldNumber;
const int DmiBios_Characteristics::kHasBiosBootSpecificationFieldNumber;
const int DmiBios_Characteristics::kHasKeyInitNetworkBootFieldNumber;
const int DmiBios_Characteristics::kHasTargetedContentDistribFieldNumber;
const int DmiBios_Characteristics::kHasUefiFieldNumber;
const int DmiBios_Characteristics::kHasVirtualMachineFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DmiBios_Characteristics::DmiBios_Characteristics()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_category_5fdmi_5fbios_2eproto::InitDefaultsDmiBios_Characteristics();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.DmiBios.Characteristics)
}
DmiBios_Characteristics::DmiBios_Characteristics(const DmiBios_Characteristics& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&has_isa_, &from.has_isa_,
    static_cast<size_t>(reinterpret_cast<char*>(&has_virtual_machine_) -
    reinterpret_cast<char*>(&has_isa_)) + sizeof(has_virtual_machine_));
  // @@protoc_insertion_point(copy_constructor:aspia.proto.DmiBios.Characteristics)
}

void DmiBios_Characteristics::SharedCtor() {
  ::memset(&has_isa_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&has_virtual_machine_) -
      reinterpret_cast<char*>(&has_isa_)) + sizeof(has_virtual_machine_));
  _cached_size_ = 0;
}

DmiBios_Characteristics::~DmiBios_Characteristics() {
  // @@protoc_insertion_point(destructor:aspia.proto.DmiBios.Characteristics)
  SharedDtor();
}

void DmiBios_Characteristics::SharedDtor() {
}

void DmiBios_Characteristics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DmiBios_Characteristics& DmiBios_Characteristics::default_instance() {
  ::protobuf_category_5fdmi_5fbios_2eproto::InitDefaultsDmiBios_Characteristics();
  return *internal_default_instance();
}

DmiBios_Characteristics* DmiBios_Characteristics::New(::google::protobuf::Arena* arena) const {
  DmiBios_Characteristics* n = new DmiBios_Characteristics;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DmiBios_Characteristics::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.DmiBios.Characteristics)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&has_isa_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&has_virtual_machine_) -
      reinterpret_cast<char*>(&has_isa_)) + sizeof(has_virtual_machine_));
  _internal_metadata_.Clear();
}

bool DmiBios_Characteristics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.DmiBios.Characteristics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // bool has_isa = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_isa_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_mca = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_mca_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_eisa = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_eisa_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_pci = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_pci_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_pc_card = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_pc_card_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_pnp = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_pnp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_apm = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_apm_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_bios_upgradeable = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_bios_upgradeable_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_bios_shadowing = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_bios_shadowing_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_vlb = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u /* 80 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_vlb_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_escd = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u /* 88 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_escd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_boot_from_cd = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(96u /* 96 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_boot_from_cd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_selectable_boot = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(104u /* 104 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_selectable_boot_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_socketed_boot_rom = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(112u /* 112 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_socketed_boot_rom_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_boot_from_pc_card = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(120u /* 120 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_boot_from_pc_card_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_edd = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(128u /* 128 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_edd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_japanese_floppy_for_nec9800 = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(136u /* 136 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_japanese_floppy_for_nec9800_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_japanece_floppy_for_toshiba = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(144u /* 144 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_japanece_floppy_for_toshiba_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_525_360kb_floppy = 19;
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(152u /* 152 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_525_360kb_floppy_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_525_12mb_floppy = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(160u /* 160 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_525_12mb_floppy_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_35_720kb_floppy = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(168u /* 168 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_35_720kb_floppy_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_35_288mb_floppy = 22;
      case 22: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(176u /* 176 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_35_288mb_floppy_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_print_screen = 23;
      case 23: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(184u /* 184 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_print_screen_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_8042_keyboard = 24;
      case 24: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(192u /* 192 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_8042_keyboard_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_serial = 25;
      case 25: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(200u /* 200 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_serial_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_printer = 26;
      case 26: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(208u /* 208 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_printer_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_cga_video = 27;
      case 27: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(216u /* 216 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_cga_video_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_nec_pc98 = 28;
      case 28: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(224u /* 224 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_nec_pc98_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_acpi = 29;
      case 29: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(232u /* 232 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_acpi_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_usb_legacy = 30;
      case 30: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(240u /* 240 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_usb_legacy_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_agp = 31;
      case 31: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(248u /* 248 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_agp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_i2o_boot = 32;
      case 32: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(0u /* 256 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_i2o_boot_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_ls120_boot = 33;
      case 33: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 264 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_ls120_boot_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_atapi_zip_drive_boot = 34;
      case 34: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 272 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_atapi_zip_drive_boot_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_ieee1394_boot = 35;
      case 35: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 280 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_ieee1394_boot_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_smart_battery = 36;
      case 36: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 288 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_smart_battery_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_bios_boot_specification = 37;
      case 37: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 296 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_bios_boot_specification_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_key_init_network_boot = 38;
      case 38: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 304 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_key_init_network_boot_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_targeted_content_distrib = 39;
      case 39: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 312 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_targeted_content_distrib_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_uefi = 40;
      case 40: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 320 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_uefi_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_virtual_machine = 41;
      case 41: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 328 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_virtual_machine_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.DmiBios.Characteristics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.DmiBios.Characteristics)
  return false;
#undef DO_
}

void DmiBios_Characteristics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.DmiBios.Characteristics)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool has_isa = 1;
  if (this->has_isa() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->has_isa(), output);
  }

  // bool has_mca = 2;
  if (this->has_mca() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->has_mca(), output);
  }

  // bool has_eisa = 3;
  if (this->has_eisa() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->has_eisa(), output);
  }

  // bool has_pci = 4;
  if (this->has_pci() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->has_pci(), output);
  }

  // bool has_pc_card = 5;
  if (this->has_pc_card() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->has_pc_card(), output);
  }

  // bool has_pnp = 6;
  if (this->has_pnp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->has_pnp(), output);
  }

  // bool has_apm = 7;
  if (this->has_apm() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->has_apm(), output);
  }

  // bool has_bios_upgradeable = 8;
  if (this->has_bios_upgradeable() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->has_bios_upgradeable(), output);
  }

  // bool has_bios_shadowing = 9;
  if (this->has_bios_shadowing() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->has_bios_shadowing(), output);
  }

  // bool has_vlb = 10;
  if (this->has_vlb() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->has_vlb(), output);
  }

  // bool has_escd = 11;
  if (this->has_escd() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->has_escd(), output);
  }

  // bool has_boot_from_cd = 12;
  if (this->has_boot_from_cd() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->has_boot_from_cd(), output);
  }

  // bool has_selectable_boot = 13;
  if (this->has_selectable_boot() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->has_selectable_boot(), output);
  }

  // bool has_socketed_boot_rom = 14;
  if (this->has_socketed_boot_rom() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->has_socketed_boot_rom(), output);
  }

  // bool has_boot_from_pc_card = 15;
  if (this->has_boot_from_pc_card() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->has_boot_from_pc_card(), output);
  }

  // bool has_edd = 16;
  if (this->has_edd() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->has_edd(), output);
  }

  // bool has_japanese_floppy_for_nec9800 = 17;
  if (this->has_japanese_floppy_for_nec9800() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->has_japanese_floppy_for_nec9800(), output);
  }

  // bool has_japanece_floppy_for_toshiba = 18;
  if (this->has_japanece_floppy_for_toshiba() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(18, this->has_japanece_floppy_for_toshiba(), output);
  }

  // bool has_525_360kb_floppy = 19;
  if (this->has_525_360kb_floppy() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(19, this->has_525_360kb_floppy(), output);
  }

  // bool has_525_12mb_floppy = 20;
  if (this->has_525_12mb_floppy() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(20, this->has_525_12mb_floppy(), output);
  }

  // bool has_35_720kb_floppy = 21;
  if (this->has_35_720kb_floppy() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(21, this->has_35_720kb_floppy(), output);
  }

  // bool has_35_288mb_floppy = 22;
  if (this->has_35_288mb_floppy() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(22, this->has_35_288mb_floppy(), output);
  }

  // bool has_print_screen = 23;
  if (this->has_print_screen() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(23, this->has_print_screen(), output);
  }

  // bool has_8042_keyboard = 24;
  if (this->has_8042_keyboard() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(24, this->has_8042_keyboard(), output);
  }

  // bool has_serial = 25;
  if (this->has_serial() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(25, this->has_serial(), output);
  }

  // bool has_printer = 26;
  if (this->has_printer() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(26, this->has_printer(), output);
  }

  // bool has_cga_video = 27;
  if (this->has_cga_video() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(27, this->has_cga_video(), output);
  }

  // bool has_nec_pc98 = 28;
  if (this->has_nec_pc98() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(28, this->has_nec_pc98(), output);
  }

  // bool has_acpi = 29;
  if (this->has_acpi() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(29, this->has_acpi(), output);
  }

  // bool has_usb_legacy = 30;
  if (this->has_usb_legacy() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(30, this->has_usb_legacy(), output);
  }

  // bool has_agp = 31;
  if (this->has_agp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(31, this->has_agp(), output);
  }

  // bool has_i2o_boot = 32;
  if (this->has_i2o_boot() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(32, this->has_i2o_boot(), output);
  }

  // bool has_ls120_boot = 33;
  if (this->has_ls120_boot() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(33, this->has_ls120_boot(), output);
  }

  // bool has_atapi_zip_drive_boot = 34;
  if (this->has_atapi_zip_drive_boot() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(34, this->has_atapi_zip_drive_boot(), output);
  }

  // bool has_ieee1394_boot = 35;
  if (this->has_ieee1394_boot() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(35, this->has_ieee1394_boot(), output);
  }

  // bool has_smart_battery = 36;
  if (this->has_smart_battery() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(36, this->has_smart_battery(), output);
  }

  // bool has_bios_boot_specification = 37;
  if (this->has_bios_boot_specification() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(37, this->has_bios_boot_specification(), output);
  }

  // bool has_key_init_network_boot = 38;
  if (this->has_key_init_network_boot() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(38, this->has_key_init_network_boot(), output);
  }

  // bool has_targeted_content_distrib = 39;
  if (this->has_targeted_content_distrib() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(39, this->has_targeted_content_distrib(), output);
  }

  // bool has_uefi = 40;
  if (this->has_uefi() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(40, this->has_uefi(), output);
  }

  // bool has_virtual_machine = 41;
  if (this->has_virtual_machine() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(41, this->has_virtual_machine(), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.DmiBios.Characteristics)
}

size_t DmiBios_Characteristics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.DmiBios.Characteristics)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // bool has_isa = 1;
  if (this->has_isa() != 0) {
    total_size += 1 + 1;
  }

  // bool has_mca = 2;
  if (this->has_mca() != 0) {
    total_size += 1 + 1;
  }

  // bool has_eisa = 3;
  if (this->has_eisa() != 0) {
    total_size += 1 + 1;
  }

  // bool has_pci = 4;
  if (this->has_pci() != 0) {
    total_size += 1 + 1;
  }

  // bool has_pc_card = 5;
  if (this->has_pc_card() != 0) {
    total_size += 1 + 1;
  }

  // bool has_pnp = 6;
  if (this->has_pnp() != 0) {
    total_size += 1 + 1;
  }

  // bool has_apm = 7;
  if (this->has_apm() != 0) {
    total_size += 1 + 1;
  }

  // bool has_bios_upgradeable = 8;
  if (this->has_bios_upgradeable() != 0) {
    total_size += 1 + 1;
  }

  // bool has_bios_shadowing = 9;
  if (this->has_bios_shadowing() != 0) {
    total_size += 1 + 1;
  }

  // bool has_vlb = 10;
  if (this->has_vlb() != 0) {
    total_size += 1 + 1;
  }

  // bool has_escd = 11;
  if (this->has_escd() != 0) {
    total_size += 1 + 1;
  }

  // bool has_boot_from_cd = 12;
  if (this->has_boot_from_cd() != 0) {
    total_size += 1 + 1;
  }

  // bool has_selectable_boot = 13;
  if (this->has_selectable_boot() != 0) {
    total_size += 1 + 1;
  }

  // bool has_socketed_boot_rom = 14;
  if (this->has_socketed_boot_rom() != 0) {
    total_size += 1 + 1;
  }

  // bool has_boot_from_pc_card = 15;
  if (this->has_boot_from_pc_card() != 0) {
    total_size += 1 + 1;
  }

  // bool has_edd = 16;
  if (this->has_edd() != 0) {
    total_size += 2 + 1;
  }

  // bool has_japanese_floppy_for_nec9800 = 17;
  if (this->has_japanese_floppy_for_nec9800() != 0) {
    total_size += 2 + 1;
  }

  // bool has_japanece_floppy_for_toshiba = 18;
  if (this->has_japanece_floppy_for_toshiba() != 0) {
    total_size += 2 + 1;
  }

  // bool has_525_360kb_floppy = 19;
  if (this->has_525_360kb_floppy() != 0) {
    total_size += 2 + 1;
  }

  // bool has_525_12mb_floppy = 20;
  if (this->has_525_12mb_floppy() != 0) {
    total_size += 2 + 1;
  }

  // bool has_35_720kb_floppy = 21;
  if (this->has_35_720kb_floppy() != 0) {
    total_size += 2 + 1;
  }

  // bool has_35_288mb_floppy = 22;
  if (this->has_35_288mb_floppy() != 0) {
    total_size += 2 + 1;
  }

  // bool has_print_screen = 23;
  if (this->has_print_screen() != 0) {
    total_size += 2 + 1;
  }

  // bool has_8042_keyboard = 24;
  if (this->has_8042_keyboard() != 0) {
    total_size += 2 + 1;
  }

  // bool has_serial = 25;
  if (this->has_serial() != 0) {
    total_size += 2 + 1;
  }

  // bool has_printer = 26;
  if (this->has_printer() != 0) {
    total_size += 2 + 1;
  }

  // bool has_cga_video = 27;
  if (this->has_cga_video() != 0) {
    total_size += 2 + 1;
  }

  // bool has_nec_pc98 = 28;
  if (this->has_nec_pc98() != 0) {
    total_size += 2 + 1;
  }

  // bool has_acpi = 29;
  if (this->has_acpi() != 0) {
    total_size += 2 + 1;
  }

  // bool has_usb_legacy = 30;
  if (this->has_usb_legacy() != 0) {
    total_size += 2 + 1;
  }

  // bool has_agp = 31;
  if (this->has_agp() != 0) {
    total_size += 2 + 1;
  }

  // bool has_i2o_boot = 32;
  if (this->has_i2o_boot() != 0) {
    total_size += 2 + 1;
  }

  // bool has_ls120_boot = 33;
  if (this->has_ls120_boot() != 0) {
    total_size += 2 + 1;
  }

  // bool has_atapi_zip_drive_boot = 34;
  if (this->has_atapi_zip_drive_boot() != 0) {
    total_size += 2 + 1;
  }

  // bool has_ieee1394_boot = 35;
  if (this->has_ieee1394_boot() != 0) {
    total_size += 2 + 1;
  }

  // bool has_smart_battery = 36;
  if (this->has_smart_battery() != 0) {
    total_size += 2 + 1;
  }

  // bool has_bios_boot_specification = 37;
  if (this->has_bios_boot_specification() != 0) {
    total_size += 2 + 1;
  }

  // bool has_key_init_network_boot = 38;
  if (this->has_key_init_network_boot() != 0) {
    total_size += 2 + 1;
  }

  // bool has_targeted_content_distrib = 39;
  if (this->has_targeted_content_distrib() != 0) {
    total_size += 2 + 1;
  }

  // bool has_uefi = 40;
  if (this->has_uefi() != 0) {
    total_size += 2 + 1;
  }

  // bool has_virtual_machine = 41;
  if (this->has_virtual_machine() != 0) {
    total_size += 2 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DmiBios_Characteristics::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DmiBios_Characteristics*>(&from));
}

void DmiBios_Characteristics::MergeFrom(const DmiBios_Characteristics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.DmiBios.Characteristics)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_isa() != 0) {
    set_has_isa(from.has_isa());
  }
  if (from.has_mca() != 0) {
    set_has_mca(from.has_mca());
  }
  if (from.has_eisa() != 0) {
    set_has_eisa(from.has_eisa());
  }
  if (from.has_pci() != 0) {
    set_has_pci(from.has_pci());
  }
  if (from.has_pc_card() != 0) {
    set_has_pc_card(from.has_pc_card());
  }
  if (from.has_pnp() != 0) {
    set_has_pnp(from.has_pnp());
  }
  if (from.has_apm() != 0) {
    set_has_apm(from.has_apm());
  }
  if (from.has_bios_upgradeable() != 0) {
    set_has_bios_upgradeable(from.has_bios_upgradeable());
  }
  if (from.has_bios_shadowing() != 0) {
    set_has_bios_shadowing(from.has_bios_shadowing());
  }
  if (from.has_vlb() != 0) {
    set_has_vlb(from.has_vlb());
  }
  if (from.has_escd() != 0) {
    set_has_escd(from.has_escd());
  }
  if (from.has_boot_from_cd() != 0) {
    set_has_boot_from_cd(from.has_boot_from_cd());
  }
  if (from.has_selectable_boot() != 0) {
    set_has_selectable_boot(from.has_selectable_boot());
  }
  if (from.has_socketed_boot_rom() != 0) {
    set_has_socketed_boot_rom(from.has_socketed_boot_rom());
  }
  if (from.has_boot_from_pc_card() != 0) {
    set_has_boot_from_pc_card(from.has_boot_from_pc_card());
  }
  if (from.has_edd() != 0) {
    set_has_edd(from.has_edd());
  }
  if (from.has_japanese_floppy_for_nec9800() != 0) {
    set_has_japanese_floppy_for_nec9800(from.has_japanese_floppy_for_nec9800());
  }
  if (from.has_japanece_floppy_for_toshiba() != 0) {
    set_has_japanece_floppy_for_toshiba(from.has_japanece_floppy_for_toshiba());
  }
  if (from.has_525_360kb_floppy() != 0) {
    set_has_525_360kb_floppy(from.has_525_360kb_floppy());
  }
  if (from.has_525_12mb_floppy() != 0) {
    set_has_525_12mb_floppy(from.has_525_12mb_floppy());
  }
  if (from.has_35_720kb_floppy() != 0) {
    set_has_35_720kb_floppy(from.has_35_720kb_floppy());
  }
  if (from.has_35_288mb_floppy() != 0) {
    set_has_35_288mb_floppy(from.has_35_288mb_floppy());
  }
  if (from.has_print_screen() != 0) {
    set_has_print_screen(from.has_print_screen());
  }
  if (from.has_8042_keyboard() != 0) {
    set_has_8042_keyboard(from.has_8042_keyboard());
  }
  if (from.has_serial() != 0) {
    set_has_serial(from.has_serial());
  }
  if (from.has_printer() != 0) {
    set_has_printer(from.has_printer());
  }
  if (from.has_cga_video() != 0) {
    set_has_cga_video(from.has_cga_video());
  }
  if (from.has_nec_pc98() != 0) {
    set_has_nec_pc98(from.has_nec_pc98());
  }
  if (from.has_acpi() != 0) {
    set_has_acpi(from.has_acpi());
  }
  if (from.has_usb_legacy() != 0) {
    set_has_usb_legacy(from.has_usb_legacy());
  }
  if (from.has_agp() != 0) {
    set_has_agp(from.has_agp());
  }
  if (from.has_i2o_boot() != 0) {
    set_has_i2o_boot(from.has_i2o_boot());
  }
  if (from.has_ls120_boot() != 0) {
    set_has_ls120_boot(from.has_ls120_boot());
  }
  if (from.has_atapi_zip_drive_boot() != 0) {
    set_has_atapi_zip_drive_boot(from.has_atapi_zip_drive_boot());
  }
  if (from.has_ieee1394_boot() != 0) {
    set_has_ieee1394_boot(from.has_ieee1394_boot());
  }
  if (from.has_smart_battery() != 0) {
    set_has_smart_battery(from.has_smart_battery());
  }
  if (from.has_bios_boot_specification() != 0) {
    set_has_bios_boot_specification(from.has_bios_boot_specification());
  }
  if (from.has_key_init_network_boot() != 0) {
    set_has_key_init_network_boot(from.has_key_init_network_boot());
  }
  if (from.has_targeted_content_distrib() != 0) {
    set_has_targeted_content_distrib(from.has_targeted_content_distrib());
  }
  if (from.has_uefi() != 0) {
    set_has_uefi(from.has_uefi());
  }
  if (from.has_virtual_machine() != 0) {
    set_has_virtual_machine(from.has_virtual_machine());
  }
}

void DmiBios_Characteristics::CopyFrom(const DmiBios_Characteristics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.DmiBios.Characteristics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DmiBios_Characteristics::IsInitialized() const {
  return true;
}

void DmiBios_Characteristics::Swap(DmiBios_Characteristics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DmiBios_Characteristics::InternalSwap(DmiBios_Characteristics* other) {
  using std::swap;
  swap(has_isa_, other->has_isa_);
  swap(has_mca_, other->has_mca_);
  swap(has_eisa_, other->has_eisa_);
  swap(has_pci_, other->has_pci_);
  swap(has_pc_card_, other->has_pc_card_);
  swap(has_pnp_, other->has_pnp_);
  swap(has_apm_, other->has_apm_);
  swap(has_bios_upgradeable_, other->has_bios_upgradeable_);
  swap(has_bios_shadowing_, other->has_bios_shadowing_);
  swap(has_vlb_, other->has_vlb_);
  swap(has_escd_, other->has_escd_);
  swap(has_boot_from_cd_, other->has_boot_from_cd_);
  swap(has_selectable_boot_, other->has_selectable_boot_);
  swap(has_socketed_boot_rom_, other->has_socketed_boot_rom_);
  swap(has_boot_from_pc_card_, other->has_boot_from_pc_card_);
  swap(has_edd_, other->has_edd_);
  swap(has_japanese_floppy_for_nec9800_, other->has_japanese_floppy_for_nec9800_);
  swap(has_japanece_floppy_for_toshiba_, other->has_japanece_floppy_for_toshiba_);
  swap(has_525_360kb_floppy_, other->has_525_360kb_floppy_);
  swap(has_525_12mb_floppy_, other->has_525_12mb_floppy_);
  swap(has_35_720kb_floppy_, other->has_35_720kb_floppy_);
  swap(has_35_288mb_floppy_, other->has_35_288mb_floppy_);
  swap(has_print_screen_, other->has_print_screen_);
  swap(has_8042_keyboard_, other->has_8042_keyboard_);
  swap(has_serial_, other->has_serial_);
  swap(has_printer_, other->has_printer_);
  swap(has_cga_video_, other->has_cga_video_);
  swap(has_nec_pc98_, other->has_nec_pc98_);
  swap(has_acpi_, other->has_acpi_);
  swap(has_usb_legacy_, other->has_usb_legacy_);
  swap(has_agp_, other->has_agp_);
  swap(has_i2o_boot_, other->has_i2o_boot_);
  swap(has_ls120_boot_, other->has_ls120_boot_);
  swap(has_atapi_zip_drive_boot_, other->has_atapi_zip_drive_boot_);
  swap(has_ieee1394_boot_, other->has_ieee1394_boot_);
  swap(has_smart_battery_, other->has_smart_battery_);
  swap(has_bios_boot_specification_, other->has_bios_boot_specification_);
  swap(has_key_init_network_boot_, other->has_key_init_network_boot_);
  swap(has_targeted_content_distrib_, other->has_targeted_content_distrib_);
  swap(has_uefi_, other->has_uefi_);
  swap(has_virtual_machine_, other->has_virtual_machine_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string DmiBios_Characteristics::GetTypeName() const {
  return "aspia.proto.DmiBios.Characteristics";
}


// ===================================================================

void DmiBios::InitAsDefaultInstance() {
  ::aspia::proto::_DmiBios_default_instance_._instance.get_mutable()->characteristics_ = const_cast< ::aspia::proto::DmiBios_Characteristics*>(
      ::aspia::proto::DmiBios_Characteristics::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DmiBios::kManufacturerFieldNumber;
const int DmiBios::kVersionFieldNumber;
const int DmiBios::kDateFieldNumber;
const int DmiBios::kSizeFieldNumber;
const int DmiBios::kBiosRevisionFieldNumber;
const int DmiBios::kFirmwareRevisionFieldNumber;
const int DmiBios::kAddressFieldNumber;
const int DmiBios::kRuntimeSizeFieldNumber;
const int DmiBios::kCharacteristicsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DmiBios::DmiBios()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_category_5fdmi_5fbios_2eproto::InitDefaultsDmiBios();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.DmiBios)
}
DmiBios::DmiBios(const DmiBios& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  manufacturer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.manufacturer().size() > 0) {
    manufacturer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.manufacturer_);
  }
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.version().size() > 0) {
    version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  date_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.date().size() > 0) {
    date_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.date_);
  }
  bios_revision_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.bios_revision().size() > 0) {
    bios_revision_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bios_revision_);
  }
  firmware_revision_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.firmware_revision().size() > 0) {
    firmware_revision_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.firmware_revision_);
  }
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.address().size() > 0) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  if (from.has_characteristics()) {
    characteristics_ = new ::aspia::proto::DmiBios_Characteristics(*from.characteristics_);
  } else {
    characteristics_ = NULL;
  }
  ::memcpy(&size_, &from.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&runtime_size_) -
    reinterpret_cast<char*>(&size_)) + sizeof(runtime_size_));
  // @@protoc_insertion_point(copy_constructor:aspia.proto.DmiBios)
}

void DmiBios::SharedCtor() {
  manufacturer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  date_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bios_revision_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  firmware_revision_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&characteristics_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&runtime_size_) -
      reinterpret_cast<char*>(&characteristics_)) + sizeof(runtime_size_));
  _cached_size_ = 0;
}

DmiBios::~DmiBios() {
  // @@protoc_insertion_point(destructor:aspia.proto.DmiBios)
  SharedDtor();
}

void DmiBios::SharedDtor() {
  manufacturer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  date_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bios_revision_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  firmware_revision_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete characteristics_;
}

void DmiBios::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DmiBios& DmiBios::default_instance() {
  ::protobuf_category_5fdmi_5fbios_2eproto::InitDefaultsDmiBios();
  return *internal_default_instance();
}

DmiBios* DmiBios::New(::google::protobuf::Arena* arena) const {
  DmiBios* n = new DmiBios;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DmiBios::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.DmiBios)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bios_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  firmware_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && characteristics_ != NULL) {
    delete characteristics_;
  }
  characteristics_ = NULL;
  ::memset(&size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&runtime_size_) -
      reinterpret_cast<char*>(&size_)) + sizeof(runtime_size_));
  _internal_metadata_.Clear();
}

bool DmiBios::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.DmiBios)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string manufacturer = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->manufacturer().data(), static_cast<int>(this->manufacturer().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.DmiBios.manufacturer"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string version = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->version().data(), static_cast<int>(this->version().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.DmiBios.version"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string date = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_date()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->date().data(), static_cast<int>(this->date().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.DmiBios.date"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 size = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string bios_revision = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bios_revision()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->bios_revision().data(), static_cast<int>(this->bios_revision().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.DmiBios.bios_revision"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string firmware_revision = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_firmware_revision()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->firmware_revision().data(), static_cast<int>(this->firmware_revision().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.DmiBios.firmware_revision"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string address = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->address().data(), static_cast<int>(this->address().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.DmiBios.address"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 runtime_size = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &runtime_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .aspia.proto.DmiBios.Characteristics characteristics = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u /* 74 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_characteristics()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.DmiBios)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.DmiBios)
  return false;
#undef DO_
}

void DmiBios::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.DmiBios)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string manufacturer = 1;
  if (this->manufacturer().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->manufacturer().data(), static_cast<int>(this->manufacturer().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.DmiBios.manufacturer");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->manufacturer(), output);
  }

  // string version = 2;
  if (this->version().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->version().data(), static_cast<int>(this->version().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.DmiBios.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->version(), output);
  }

  // string date = 3;
  if (this->date().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->date().data(), static_cast<int>(this->date().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.DmiBios.date");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->date(), output);
  }

  // uint64 size = 4;
  if (this->size() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->size(), output);
  }

  // string bios_revision = 5;
  if (this->bios_revision().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->bios_revision().data(), static_cast<int>(this->bios_revision().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.DmiBios.bios_revision");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->bios_revision(), output);
  }

  // string firmware_revision = 6;
  if (this->firmware_revision().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->firmware_revision().data(), static_cast<int>(this->firmware_revision().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.DmiBios.firmware_revision");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->firmware_revision(), output);
  }

  // string address = 7;
  if (this->address().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->address().data(), static_cast<int>(this->address().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.DmiBios.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->address(), output);
  }

  // int32 runtime_size = 8;
  if (this->runtime_size() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->runtime_size(), output);
  }

  // .aspia.proto.DmiBios.Characteristics characteristics = 9;
  if (this->has_characteristics()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, *this->characteristics_, output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.DmiBios)
}

size_t DmiBios::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.DmiBios)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // string manufacturer = 1;
  if (this->manufacturer().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->manufacturer());
  }

  // string version = 2;
  if (this->version().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->version());
  }

  // string date = 3;
  if (this->date().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->date());
  }

  // string bios_revision = 5;
  if (this->bios_revision().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->bios_revision());
  }

  // string firmware_revision = 6;
  if (this->firmware_revision().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->firmware_revision());
  }

  // string address = 7;
  if (this->address().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->address());
  }

  // .aspia.proto.DmiBios.Characteristics characteristics = 9;
  if (this->has_characteristics()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->characteristics_);
  }

  // uint64 size = 4;
  if (this->size() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->size());
  }

  // int32 runtime_size = 8;
  if (this->runtime_size() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->runtime_size());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DmiBios::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DmiBios*>(&from));
}

void DmiBios::MergeFrom(const DmiBios& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.DmiBios)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.manufacturer().size() > 0) {

    manufacturer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.manufacturer_);
  }
  if (from.version().size() > 0) {

    version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  if (from.date().size() > 0) {

    date_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.date_);
  }
  if (from.bios_revision().size() > 0) {

    bios_revision_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bios_revision_);
  }
  if (from.firmware_revision().size() > 0) {

    firmware_revision_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.firmware_revision_);
  }
  if (from.address().size() > 0) {

    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  if (from.has_characteristics()) {
    mutable_characteristics()->::aspia::proto::DmiBios_Characteristics::MergeFrom(from.characteristics());
  }
  if (from.size() != 0) {
    set_size(from.size());
  }
  if (from.runtime_size() != 0) {
    set_runtime_size(from.runtime_size());
  }
}

void DmiBios::CopyFrom(const DmiBios& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.DmiBios)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DmiBios::IsInitialized() const {
  return true;
}

void DmiBios::Swap(DmiBios* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DmiBios::InternalSwap(DmiBios* other) {
  using std::swap;
  manufacturer_.Swap(&other->manufacturer_);
  version_.Swap(&other->version_);
  date_.Swap(&other->date_);
  bios_revision_.Swap(&other->bios_revision_);
  firmware_revision_.Swap(&other->firmware_revision_);
  address_.Swap(&other->address_);
  swap(characteristics_, other->characteristics_);
  swap(size_, other->size_);
  swap(runtime_size_, other->runtime_size_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string DmiBios::GetTypeName() const {
  return "aspia.proto.DmiBios";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace aspia

// @@protoc_insertion_point(global_scope)

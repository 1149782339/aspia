// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: category_task_scheduler.proto

#ifndef PROTOBUF_category_5ftask_5fscheduler_2eproto__INCLUDED
#define PROTOBUF_category_5ftask_5fscheduler_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace protobuf_category_5ftask_5fscheduler_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsTaskScheduler_ActionImpl();
void InitDefaultsTaskScheduler_Action();
void InitDefaultsTaskScheduler_Trigger_Event_NamedValueImpl();
void InitDefaultsTaskScheduler_Trigger_Event_NamedValue();
void InitDefaultsTaskScheduler_Trigger_EventImpl();
void InitDefaultsTaskScheduler_Trigger_Event();
void InitDefaultsTaskScheduler_Trigger_DailyImpl();
void InitDefaultsTaskScheduler_Trigger_Daily();
void InitDefaultsTaskScheduler_Trigger_WeeklyImpl();
void InitDefaultsTaskScheduler_Trigger_Weekly();
void InitDefaultsTaskScheduler_Trigger_MonthlyImpl();
void InitDefaultsTaskScheduler_Trigger_Monthly();
void InitDefaultsTaskScheduler_Trigger_MonthlyDowImpl();
void InitDefaultsTaskScheduler_Trigger_MonthlyDow();
void InitDefaultsTaskScheduler_Trigger_RegistrationImpl();
void InitDefaultsTaskScheduler_Trigger_Registration();
void InitDefaultsTaskScheduler_Trigger_BootImpl();
void InitDefaultsTaskScheduler_Trigger_Boot();
void InitDefaultsTaskScheduler_Trigger_LogonImpl();
void InitDefaultsTaskScheduler_Trigger_Logon();
void InitDefaultsTaskScheduler_Trigger_SessionStateChangeImpl();
void InitDefaultsTaskScheduler_Trigger_SessionStateChange();
void InitDefaultsTaskScheduler_Trigger_RepetitionImpl();
void InitDefaultsTaskScheduler_Trigger_Repetition();
void InitDefaultsTaskScheduler_TriggerImpl();
void InitDefaultsTaskScheduler_Trigger();
void InitDefaultsTaskScheduler_TaskImpl();
void InitDefaultsTaskScheduler_Task();
void InitDefaultsTaskSchedulerImpl();
void InitDefaultsTaskScheduler();
inline void InitDefaults() {
  InitDefaultsTaskScheduler_Action();
  InitDefaultsTaskScheduler_Trigger_Event_NamedValue();
  InitDefaultsTaskScheduler_Trigger_Event();
  InitDefaultsTaskScheduler_Trigger_Daily();
  InitDefaultsTaskScheduler_Trigger_Weekly();
  InitDefaultsTaskScheduler_Trigger_Monthly();
  InitDefaultsTaskScheduler_Trigger_MonthlyDow();
  InitDefaultsTaskScheduler_Trigger_Registration();
  InitDefaultsTaskScheduler_Trigger_Boot();
  InitDefaultsTaskScheduler_Trigger_Logon();
  InitDefaultsTaskScheduler_Trigger_SessionStateChange();
  InitDefaultsTaskScheduler_Trigger_Repetition();
  InitDefaultsTaskScheduler_Trigger();
  InitDefaultsTaskScheduler_Task();
  InitDefaultsTaskScheduler();
}
}  // namespace protobuf_category_5ftask_5fscheduler_2eproto
namespace aspia {
namespace proto {
class TaskScheduler;
class TaskSchedulerDefaultTypeInternal;
extern TaskSchedulerDefaultTypeInternal _TaskScheduler_default_instance_;
class TaskScheduler_Action;
class TaskScheduler_ActionDefaultTypeInternal;
extern TaskScheduler_ActionDefaultTypeInternal _TaskScheduler_Action_default_instance_;
class TaskScheduler_Task;
class TaskScheduler_TaskDefaultTypeInternal;
extern TaskScheduler_TaskDefaultTypeInternal _TaskScheduler_Task_default_instance_;
class TaskScheduler_Trigger;
class TaskScheduler_TriggerDefaultTypeInternal;
extern TaskScheduler_TriggerDefaultTypeInternal _TaskScheduler_Trigger_default_instance_;
class TaskScheduler_Trigger_Boot;
class TaskScheduler_Trigger_BootDefaultTypeInternal;
extern TaskScheduler_Trigger_BootDefaultTypeInternal _TaskScheduler_Trigger_Boot_default_instance_;
class TaskScheduler_Trigger_Daily;
class TaskScheduler_Trigger_DailyDefaultTypeInternal;
extern TaskScheduler_Trigger_DailyDefaultTypeInternal _TaskScheduler_Trigger_Daily_default_instance_;
class TaskScheduler_Trigger_Event;
class TaskScheduler_Trigger_EventDefaultTypeInternal;
extern TaskScheduler_Trigger_EventDefaultTypeInternal _TaskScheduler_Trigger_Event_default_instance_;
class TaskScheduler_Trigger_Event_NamedValue;
class TaskScheduler_Trigger_Event_NamedValueDefaultTypeInternal;
extern TaskScheduler_Trigger_Event_NamedValueDefaultTypeInternal _TaskScheduler_Trigger_Event_NamedValue_default_instance_;
class TaskScheduler_Trigger_Logon;
class TaskScheduler_Trigger_LogonDefaultTypeInternal;
extern TaskScheduler_Trigger_LogonDefaultTypeInternal _TaskScheduler_Trigger_Logon_default_instance_;
class TaskScheduler_Trigger_Monthly;
class TaskScheduler_Trigger_MonthlyDefaultTypeInternal;
extern TaskScheduler_Trigger_MonthlyDefaultTypeInternal _TaskScheduler_Trigger_Monthly_default_instance_;
class TaskScheduler_Trigger_MonthlyDow;
class TaskScheduler_Trigger_MonthlyDowDefaultTypeInternal;
extern TaskScheduler_Trigger_MonthlyDowDefaultTypeInternal _TaskScheduler_Trigger_MonthlyDow_default_instance_;
class TaskScheduler_Trigger_Registration;
class TaskScheduler_Trigger_RegistrationDefaultTypeInternal;
extern TaskScheduler_Trigger_RegistrationDefaultTypeInternal _TaskScheduler_Trigger_Registration_default_instance_;
class TaskScheduler_Trigger_Repetition;
class TaskScheduler_Trigger_RepetitionDefaultTypeInternal;
extern TaskScheduler_Trigger_RepetitionDefaultTypeInternal _TaskScheduler_Trigger_Repetition_default_instance_;
class TaskScheduler_Trigger_SessionStateChange;
class TaskScheduler_Trigger_SessionStateChangeDefaultTypeInternal;
extern TaskScheduler_Trigger_SessionStateChangeDefaultTypeInternal _TaskScheduler_Trigger_SessionStateChange_default_instance_;
class TaskScheduler_Trigger_Weekly;
class TaskScheduler_Trigger_WeeklyDefaultTypeInternal;
extern TaskScheduler_Trigger_WeeklyDefaultTypeInternal _TaskScheduler_Trigger_Weekly_default_instance_;
}  // namespace proto
}  // namespace aspia
namespace aspia {
namespace proto {

enum TaskScheduler_Trigger_SessionStateChange_ChangeType {
  TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_UNKNOWN = 0,
  TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_CONSOLE_CONNECT = 1,
  TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_CONSOLE_DISCONNECT = 2,
  TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_REMOTE_CONNECT = 3,
  TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_REMOTE_DISCONNECT = 4,
  TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_SESSION_LOCK = 5,
  TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_SESSION_UNLOCK = 6,
  TaskScheduler_Trigger_SessionStateChange_ChangeType_TaskScheduler_Trigger_SessionStateChange_ChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TaskScheduler_Trigger_SessionStateChange_ChangeType_TaskScheduler_Trigger_SessionStateChange_ChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TaskScheduler_Trigger_SessionStateChange_ChangeType_IsValid(int value);
const TaskScheduler_Trigger_SessionStateChange_ChangeType TaskScheduler_Trigger_SessionStateChange_ChangeType_ChangeType_MIN = TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_UNKNOWN;
const TaskScheduler_Trigger_SessionStateChange_ChangeType TaskScheduler_Trigger_SessionStateChange_ChangeType_ChangeType_MAX = TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_SESSION_UNLOCK;
const int TaskScheduler_Trigger_SessionStateChange_ChangeType_ChangeType_ARRAYSIZE = TaskScheduler_Trigger_SessionStateChange_ChangeType_ChangeType_MAX + 1;

enum TaskScheduler_Trigger_Type {
  TaskScheduler_Trigger_Type_TYPE_UNKNOWN = 0,
  TaskScheduler_Trigger_Type_TYPE_EVENT = 1,
  TaskScheduler_Trigger_Type_TYPE_TIME = 2,
  TaskScheduler_Trigger_Type_TYPE_DAILY = 3,
  TaskScheduler_Trigger_Type_TYPE_WEEKLY = 4,
  TaskScheduler_Trigger_Type_TYPE_MONTHLY = 5,
  TaskScheduler_Trigger_Type_TYPE_MONTHLYDOW = 6,
  TaskScheduler_Trigger_Type_TYPE_IDLE = 7,
  TaskScheduler_Trigger_Type_TYPE_REGISTRATION = 8,
  TaskScheduler_Trigger_Type_TYPE_BOOT = 9,
  TaskScheduler_Trigger_Type_TYPE_LOGON = 10,
  TaskScheduler_Trigger_Type_TYPE_SESSION_STATE_CHANGE = 11,
  TaskScheduler_Trigger_Type_TaskScheduler_Trigger_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TaskScheduler_Trigger_Type_TaskScheduler_Trigger_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TaskScheduler_Trigger_Type_IsValid(int value);
const TaskScheduler_Trigger_Type TaskScheduler_Trigger_Type_Type_MIN = TaskScheduler_Trigger_Type_TYPE_UNKNOWN;
const TaskScheduler_Trigger_Type TaskScheduler_Trigger_Type_Type_MAX = TaskScheduler_Trigger_Type_TYPE_SESSION_STATE_CHANGE;
const int TaskScheduler_Trigger_Type_Type_ARRAYSIZE = TaskScheduler_Trigger_Type_Type_MAX + 1;

enum TaskScheduler_Trigger_DayOfWeek {
  TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_UNKNOWN = 0,
  TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_SUNDAY = 1,
  TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_MONDAY = 2,
  TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_TUESDAY = 4,
  TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_WEDNESDAY = 8,
  TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_THURSDAY = 16,
  TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_FRIDAY = 32,
  TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_SATURDAY = 64,
  TaskScheduler_Trigger_DayOfWeek_TaskScheduler_Trigger_DayOfWeek_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TaskScheduler_Trigger_DayOfWeek_TaskScheduler_Trigger_DayOfWeek_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TaskScheduler_Trigger_DayOfWeek_IsValid(int value);
const TaskScheduler_Trigger_DayOfWeek TaskScheduler_Trigger_DayOfWeek_DayOfWeek_MIN = TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_UNKNOWN;
const TaskScheduler_Trigger_DayOfWeek TaskScheduler_Trigger_DayOfWeek_DayOfWeek_MAX = TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_SATURDAY;
const int TaskScheduler_Trigger_DayOfWeek_DayOfWeek_ARRAYSIZE = TaskScheduler_Trigger_DayOfWeek_DayOfWeek_MAX + 1;

enum TaskScheduler_Trigger_DayOfMonth {
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_UNKNOWN = 0,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_1 = 1,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_2 = 2,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_3 = 4,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_4 = 8,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_5 = 16,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_6 = 32,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_7 = 64,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_8 = 128,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_9 = 256,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_10 = 512,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_11 = 1024,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_12 = 2048,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_13 = 4096,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_14 = 8192,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_15 = 16384,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_16 = 32768,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_17 = 65536,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_18 = 131072,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_19 = 262144,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_20 = 524288,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_21 = 1048576,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_22 = 2097152,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_23 = 4194304,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_24 = 8388608,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_25 = 16777216,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_26 = 33554432,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_27 = 67108864,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_28 = 134217728,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_29 = 268435456,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_30 = 536870912,
  TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_31 = 1073741824,
  TaskScheduler_Trigger_DayOfMonth_TaskScheduler_Trigger_DayOfMonth_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TaskScheduler_Trigger_DayOfMonth_TaskScheduler_Trigger_DayOfMonth_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TaskScheduler_Trigger_DayOfMonth_IsValid(int value);
const TaskScheduler_Trigger_DayOfMonth TaskScheduler_Trigger_DayOfMonth_DayOfMonth_MIN = TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_UNKNOWN;
const TaskScheduler_Trigger_DayOfMonth TaskScheduler_Trigger_DayOfMonth_DayOfMonth_MAX = TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_31;
const int TaskScheduler_Trigger_DayOfMonth_DayOfMonth_ARRAYSIZE = TaskScheduler_Trigger_DayOfMonth_DayOfMonth_MAX + 1;

enum TaskScheduler_Trigger_Month {
  TaskScheduler_Trigger_Month_MONTH_UNKNOWN = 0,
  TaskScheduler_Trigger_Month_MONTH_JANUARY = 1,
  TaskScheduler_Trigger_Month_MONTH_FEBRUARY = 2,
  TaskScheduler_Trigger_Month_MONTH_MARCH = 4,
  TaskScheduler_Trigger_Month_MONTH_APRIL = 8,
  TaskScheduler_Trigger_Month_MONTH_MAY = 16,
  TaskScheduler_Trigger_Month_MONTH_JUNE = 32,
  TaskScheduler_Trigger_Month_MONTH_JULY = 64,
  TaskScheduler_Trigger_Month_MONTH_AUGUST = 128,
  TaskScheduler_Trigger_Month_MONTH_SEPTEMBER = 256,
  TaskScheduler_Trigger_Month_MONTH_OCTOBER = 512,
  TaskScheduler_Trigger_Month_MONTH_NOVEMBER = 1024,
  TaskScheduler_Trigger_Month_MONTH_DECEMBER = 2048,
  TaskScheduler_Trigger_Month_TaskScheduler_Trigger_Month_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TaskScheduler_Trigger_Month_TaskScheduler_Trigger_Month_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TaskScheduler_Trigger_Month_IsValid(int value);
const TaskScheduler_Trigger_Month TaskScheduler_Trigger_Month_Month_MIN = TaskScheduler_Trigger_Month_MONTH_UNKNOWN;
const TaskScheduler_Trigger_Month TaskScheduler_Trigger_Month_Month_MAX = TaskScheduler_Trigger_Month_MONTH_DECEMBER;
const int TaskScheduler_Trigger_Month_Month_ARRAYSIZE = TaskScheduler_Trigger_Month_Month_MAX + 1;

enum TaskScheduler_Trigger_WeekOfMonth {
  TaskScheduler_Trigger_WeekOfMonth_WEEK_OF_MONTH_UNKNOWN = 0,
  TaskScheduler_Trigger_WeekOfMonth_WEEK_OF_MONTH_FIRST = 1,
  TaskScheduler_Trigger_WeekOfMonth_WEEK_OF_MONTH_SECOND = 2,
  TaskScheduler_Trigger_WeekOfMonth_WEEK_OF_MONTH_THIRD = 3,
  TaskScheduler_Trigger_WeekOfMonth_WEEK_OF_MONTH_FOURTH = 4,
  TaskScheduler_Trigger_WeekOfMonth_TaskScheduler_Trigger_WeekOfMonth_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TaskScheduler_Trigger_WeekOfMonth_TaskScheduler_Trigger_WeekOfMonth_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TaskScheduler_Trigger_WeekOfMonth_IsValid(int value);
const TaskScheduler_Trigger_WeekOfMonth TaskScheduler_Trigger_WeekOfMonth_WeekOfMonth_MIN = TaskScheduler_Trigger_WeekOfMonth_WEEK_OF_MONTH_UNKNOWN;
const TaskScheduler_Trigger_WeekOfMonth TaskScheduler_Trigger_WeekOfMonth_WeekOfMonth_MAX = TaskScheduler_Trigger_WeekOfMonth_WEEK_OF_MONTH_FOURTH;
const int TaskScheduler_Trigger_WeekOfMonth_WeekOfMonth_ARRAYSIZE = TaskScheduler_Trigger_WeekOfMonth_WeekOfMonth_MAX + 1;

enum TaskScheduler_Task_Status {
  TaskScheduler_Task_Status_STATUS_UNKNOWN = 0,
  TaskScheduler_Task_Status_STATUS_DISABLED = 1,
  TaskScheduler_Task_Status_STATUS_QUEUED = 2,
  TaskScheduler_Task_Status_STATUS_READY = 3,
  TaskScheduler_Task_Status_STATUS_RUNNING = 4,
  TaskScheduler_Task_Status_TaskScheduler_Task_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TaskScheduler_Task_Status_TaskScheduler_Task_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TaskScheduler_Task_Status_IsValid(int value);
const TaskScheduler_Task_Status TaskScheduler_Task_Status_Status_MIN = TaskScheduler_Task_Status_STATUS_UNKNOWN;
const TaskScheduler_Task_Status TaskScheduler_Task_Status_Status_MAX = TaskScheduler_Task_Status_STATUS_RUNNING;
const int TaskScheduler_Task_Status_Status_ARRAYSIZE = TaskScheduler_Task_Status_Status_MAX + 1;

// ===================================================================

class TaskScheduler_Action : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Action) */ {
 public:
  TaskScheduler_Action();
  virtual ~TaskScheduler_Action();

  TaskScheduler_Action(const TaskScheduler_Action& from);

  inline TaskScheduler_Action& operator=(const TaskScheduler_Action& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Action(TaskScheduler_Action&& from) noexcept
    : TaskScheduler_Action() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Action& operator=(TaskScheduler_Action&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Action& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Action* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Action*>(
               &_TaskScheduler_Action_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TaskScheduler_Action* other);
  friend void swap(TaskScheduler_Action& a, TaskScheduler_Action& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Action* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Action* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Action& from);
  void MergeFrom(const TaskScheduler_Action& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Action* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string arguments = 2;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 2;
  const ::std::string& arguments() const;
  void set_arguments(const ::std::string& value);
  #if LANG_CXX11
  void set_arguments(::std::string&& value);
  #endif
  void set_arguments(const char* value);
  void set_arguments(const char* value, size_t size);
  ::std::string* mutable_arguments();
  ::std::string* release_arguments();
  void set_allocated_arguments(::std::string* arguments);

  // string working_directory = 3;
  void clear_working_directory();
  static const int kWorkingDirectoryFieldNumber = 3;
  const ::std::string& working_directory() const;
  void set_working_directory(const ::std::string& value);
  #if LANG_CXX11
  void set_working_directory(::std::string&& value);
  #endif
  void set_working_directory(const char* value);
  void set_working_directory(const char* value, size_t size);
  ::std::string* mutable_working_directory();
  ::std::string* release_working_directory();
  void set_allocated_working_directory(::std::string* working_directory);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Action)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr arguments_;
  ::google::protobuf::internal::ArenaStringPtr working_directory_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_ActionImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Trigger_Event_NamedValue : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Trigger.Event.NamedValue) */ {
 public:
  TaskScheduler_Trigger_Event_NamedValue();
  virtual ~TaskScheduler_Trigger_Event_NamedValue();

  TaskScheduler_Trigger_Event_NamedValue(const TaskScheduler_Trigger_Event_NamedValue& from);

  inline TaskScheduler_Trigger_Event_NamedValue& operator=(const TaskScheduler_Trigger_Event_NamedValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Trigger_Event_NamedValue(TaskScheduler_Trigger_Event_NamedValue&& from) noexcept
    : TaskScheduler_Trigger_Event_NamedValue() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Trigger_Event_NamedValue& operator=(TaskScheduler_Trigger_Event_NamedValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Trigger_Event_NamedValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Trigger_Event_NamedValue* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Trigger_Event_NamedValue*>(
               &_TaskScheduler_Trigger_Event_NamedValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TaskScheduler_Trigger_Event_NamedValue* other);
  friend void swap(TaskScheduler_Trigger_Event_NamedValue& a, TaskScheduler_Trigger_Event_NamedValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Trigger_Event_NamedValue* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Trigger_Event_NamedValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Trigger_Event_NamedValue& from);
  void MergeFrom(const TaskScheduler_Trigger_Event_NamedValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Trigger_Event_NamedValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Trigger.Event.NamedValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_Trigger_Event_NamedValueImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Trigger_Event : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Trigger.Event) */ {
 public:
  TaskScheduler_Trigger_Event();
  virtual ~TaskScheduler_Trigger_Event();

  TaskScheduler_Trigger_Event(const TaskScheduler_Trigger_Event& from);

  inline TaskScheduler_Trigger_Event& operator=(const TaskScheduler_Trigger_Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Trigger_Event(TaskScheduler_Trigger_Event&& from) noexcept
    : TaskScheduler_Trigger_Event() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Trigger_Event& operator=(TaskScheduler_Trigger_Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Trigger_Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Trigger_Event* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Trigger_Event*>(
               &_TaskScheduler_Trigger_Event_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TaskScheduler_Trigger_Event* other);
  friend void swap(TaskScheduler_Trigger_Event& a, TaskScheduler_Trigger_Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Trigger_Event* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Trigger_Event* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Trigger_Event& from);
  void MergeFrom(const TaskScheduler_Trigger_Event& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Trigger_Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TaskScheduler_Trigger_Event_NamedValue NamedValue;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.TaskScheduler.Trigger.Event.NamedValue named_value = 2;
  int named_value_size() const;
  void clear_named_value();
  static const int kNamedValueFieldNumber = 2;
  const ::aspia::proto::TaskScheduler_Trigger_Event_NamedValue& named_value(int index) const;
  ::aspia::proto::TaskScheduler_Trigger_Event_NamedValue* mutable_named_value(int index);
  ::aspia::proto::TaskScheduler_Trigger_Event_NamedValue* add_named_value();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Trigger_Event_NamedValue >*
      mutable_named_value();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Trigger_Event_NamedValue >&
      named_value() const;

  // string delay = 1;
  void clear_delay();
  static const int kDelayFieldNumber = 1;
  const ::std::string& delay() const;
  void set_delay(const ::std::string& value);
  #if LANG_CXX11
  void set_delay(::std::string&& value);
  #endif
  void set_delay(const char* value);
  void set_delay(const char* value, size_t size);
  ::std::string* mutable_delay();
  ::std::string* release_delay();
  void set_allocated_delay(::std::string* delay);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Trigger.Event)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Trigger_Event_NamedValue > named_value_;
  ::google::protobuf::internal::ArenaStringPtr delay_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_Trigger_EventImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Trigger_Daily : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Trigger.Daily) */ {
 public:
  TaskScheduler_Trigger_Daily();
  virtual ~TaskScheduler_Trigger_Daily();

  TaskScheduler_Trigger_Daily(const TaskScheduler_Trigger_Daily& from);

  inline TaskScheduler_Trigger_Daily& operator=(const TaskScheduler_Trigger_Daily& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Trigger_Daily(TaskScheduler_Trigger_Daily&& from) noexcept
    : TaskScheduler_Trigger_Daily() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Trigger_Daily& operator=(TaskScheduler_Trigger_Daily&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Trigger_Daily& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Trigger_Daily* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Trigger_Daily*>(
               &_TaskScheduler_Trigger_Daily_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TaskScheduler_Trigger_Daily* other);
  friend void swap(TaskScheduler_Trigger_Daily& a, TaskScheduler_Trigger_Daily& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Trigger_Daily* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Trigger_Daily* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Trigger_Daily& from);
  void MergeFrom(const TaskScheduler_Trigger_Daily& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Trigger_Daily* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 days_interval = 1;
  void clear_days_interval();
  static const int kDaysIntervalFieldNumber = 1;
  ::google::protobuf::int32 days_interval() const;
  void set_days_interval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Trigger.Daily)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int32 days_interval_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_Trigger_DailyImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Trigger_Weekly : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Trigger.Weekly) */ {
 public:
  TaskScheduler_Trigger_Weekly();
  virtual ~TaskScheduler_Trigger_Weekly();

  TaskScheduler_Trigger_Weekly(const TaskScheduler_Trigger_Weekly& from);

  inline TaskScheduler_Trigger_Weekly& operator=(const TaskScheduler_Trigger_Weekly& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Trigger_Weekly(TaskScheduler_Trigger_Weekly&& from) noexcept
    : TaskScheduler_Trigger_Weekly() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Trigger_Weekly& operator=(TaskScheduler_Trigger_Weekly&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Trigger_Weekly& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Trigger_Weekly* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Trigger_Weekly*>(
               &_TaskScheduler_Trigger_Weekly_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(TaskScheduler_Trigger_Weekly* other);
  friend void swap(TaskScheduler_Trigger_Weekly& a, TaskScheduler_Trigger_Weekly& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Trigger_Weekly* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Trigger_Weekly* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Trigger_Weekly& from);
  void MergeFrom(const TaskScheduler_Trigger_Weekly& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Trigger_Weekly* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 weeks_interval = 1;
  void clear_weeks_interval();
  static const int kWeeksIntervalFieldNumber = 1;
  ::google::protobuf::int32 weeks_interval() const;
  void set_weeks_interval(::google::protobuf::int32 value);

  // uint32 days_of_week = 2;
  void clear_days_of_week();
  static const int kDaysOfWeekFieldNumber = 2;
  ::google::protobuf::uint32 days_of_week() const;
  void set_days_of_week(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Trigger.Weekly)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int32 weeks_interval_;
  ::google::protobuf::uint32 days_of_week_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_Trigger_WeeklyImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Trigger_Monthly : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Trigger.Monthly) */ {
 public:
  TaskScheduler_Trigger_Monthly();
  virtual ~TaskScheduler_Trigger_Monthly();

  TaskScheduler_Trigger_Monthly(const TaskScheduler_Trigger_Monthly& from);

  inline TaskScheduler_Trigger_Monthly& operator=(const TaskScheduler_Trigger_Monthly& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Trigger_Monthly(TaskScheduler_Trigger_Monthly&& from) noexcept
    : TaskScheduler_Trigger_Monthly() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Trigger_Monthly& operator=(TaskScheduler_Trigger_Monthly&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Trigger_Monthly& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Trigger_Monthly* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Trigger_Monthly*>(
               &_TaskScheduler_Trigger_Monthly_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TaskScheduler_Trigger_Monthly* other);
  friend void swap(TaskScheduler_Trigger_Monthly& a, TaskScheduler_Trigger_Monthly& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Trigger_Monthly* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Trigger_Monthly* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Trigger_Monthly& from);
  void MergeFrom(const TaskScheduler_Trigger_Monthly& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Trigger_Monthly* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 days_of_month = 1;
  void clear_days_of_month();
  static const int kDaysOfMonthFieldNumber = 1;
  ::google::protobuf::uint32 days_of_month() const;
  void set_days_of_month(::google::protobuf::uint32 value);

  // uint32 months_of_year = 2;
  void clear_months_of_year();
  static const int kMonthsOfYearFieldNumber = 2;
  ::google::protobuf::uint32 months_of_year() const;
  void set_months_of_year(::google::protobuf::uint32 value);

  // bool last_day = 3;
  void clear_last_day();
  static const int kLastDayFieldNumber = 3;
  bool last_day() const;
  void set_last_day(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Trigger.Monthly)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 days_of_month_;
  ::google::protobuf::uint32 months_of_year_;
  bool last_day_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_Trigger_MonthlyImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Trigger_MonthlyDow : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Trigger.MonthlyDow) */ {
 public:
  TaskScheduler_Trigger_MonthlyDow();
  virtual ~TaskScheduler_Trigger_MonthlyDow();

  TaskScheduler_Trigger_MonthlyDow(const TaskScheduler_Trigger_MonthlyDow& from);

  inline TaskScheduler_Trigger_MonthlyDow& operator=(const TaskScheduler_Trigger_MonthlyDow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Trigger_MonthlyDow(TaskScheduler_Trigger_MonthlyDow&& from) noexcept
    : TaskScheduler_Trigger_MonthlyDow() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Trigger_MonthlyDow& operator=(TaskScheduler_Trigger_MonthlyDow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Trigger_MonthlyDow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Trigger_MonthlyDow* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Trigger_MonthlyDow*>(
               &_TaskScheduler_Trigger_MonthlyDow_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TaskScheduler_Trigger_MonthlyDow* other);
  friend void swap(TaskScheduler_Trigger_MonthlyDow& a, TaskScheduler_Trigger_MonthlyDow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Trigger_MonthlyDow* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Trigger_MonthlyDow* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Trigger_MonthlyDow& from);
  void MergeFrom(const TaskScheduler_Trigger_MonthlyDow& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Trigger_MonthlyDow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 days_of_week = 1;
  void clear_days_of_week();
  static const int kDaysOfWeekFieldNumber = 1;
  ::google::protobuf::uint32 days_of_week() const;
  void set_days_of_week(::google::protobuf::uint32 value);

  // uint32 months_of_year = 2;
  void clear_months_of_year();
  static const int kMonthsOfYearFieldNumber = 2;
  ::google::protobuf::uint32 months_of_year() const;
  void set_months_of_year(::google::protobuf::uint32 value);

  // bool last_week = 3;
  void clear_last_week();
  static const int kLastWeekFieldNumber = 3;
  bool last_week() const;
  void set_last_week(bool value);

  // uint32 weeks_of_month = 4;
  void clear_weeks_of_month();
  static const int kWeeksOfMonthFieldNumber = 4;
  ::google::protobuf::uint32 weeks_of_month() const;
  void set_weeks_of_month(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Trigger.MonthlyDow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 days_of_week_;
  ::google::protobuf::uint32 months_of_year_;
  bool last_week_;
  ::google::protobuf::uint32 weeks_of_month_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_Trigger_MonthlyDowImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Trigger_Registration : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Trigger.Registration) */ {
 public:
  TaskScheduler_Trigger_Registration();
  virtual ~TaskScheduler_Trigger_Registration();

  TaskScheduler_Trigger_Registration(const TaskScheduler_Trigger_Registration& from);

  inline TaskScheduler_Trigger_Registration& operator=(const TaskScheduler_Trigger_Registration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Trigger_Registration(TaskScheduler_Trigger_Registration&& from) noexcept
    : TaskScheduler_Trigger_Registration() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Trigger_Registration& operator=(TaskScheduler_Trigger_Registration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Trigger_Registration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Trigger_Registration* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Trigger_Registration*>(
               &_TaskScheduler_Trigger_Registration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(TaskScheduler_Trigger_Registration* other);
  friend void swap(TaskScheduler_Trigger_Registration& a, TaskScheduler_Trigger_Registration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Trigger_Registration* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Trigger_Registration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Trigger_Registration& from);
  void MergeFrom(const TaskScheduler_Trigger_Registration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Trigger_Registration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string delay = 1;
  void clear_delay();
  static const int kDelayFieldNumber = 1;
  const ::std::string& delay() const;
  void set_delay(const ::std::string& value);
  #if LANG_CXX11
  void set_delay(::std::string&& value);
  #endif
  void set_delay(const char* value);
  void set_delay(const char* value, size_t size);
  ::std::string* mutable_delay();
  ::std::string* release_delay();
  void set_allocated_delay(::std::string* delay);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Trigger.Registration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr delay_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_Trigger_RegistrationImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Trigger_Boot : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Trigger.Boot) */ {
 public:
  TaskScheduler_Trigger_Boot();
  virtual ~TaskScheduler_Trigger_Boot();

  TaskScheduler_Trigger_Boot(const TaskScheduler_Trigger_Boot& from);

  inline TaskScheduler_Trigger_Boot& operator=(const TaskScheduler_Trigger_Boot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Trigger_Boot(TaskScheduler_Trigger_Boot&& from) noexcept
    : TaskScheduler_Trigger_Boot() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Trigger_Boot& operator=(TaskScheduler_Trigger_Boot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Trigger_Boot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Trigger_Boot* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Trigger_Boot*>(
               &_TaskScheduler_Trigger_Boot_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(TaskScheduler_Trigger_Boot* other);
  friend void swap(TaskScheduler_Trigger_Boot& a, TaskScheduler_Trigger_Boot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Trigger_Boot* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Trigger_Boot* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Trigger_Boot& from);
  void MergeFrom(const TaskScheduler_Trigger_Boot& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Trigger_Boot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string delay = 1;
  void clear_delay();
  static const int kDelayFieldNumber = 1;
  const ::std::string& delay() const;
  void set_delay(const ::std::string& value);
  #if LANG_CXX11
  void set_delay(::std::string&& value);
  #endif
  void set_delay(const char* value);
  void set_delay(const char* value, size_t size);
  ::std::string* mutable_delay();
  ::std::string* release_delay();
  void set_allocated_delay(::std::string* delay);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Trigger.Boot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr delay_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_Trigger_BootImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Trigger_Logon : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Trigger.Logon) */ {
 public:
  TaskScheduler_Trigger_Logon();
  virtual ~TaskScheduler_Trigger_Logon();

  TaskScheduler_Trigger_Logon(const TaskScheduler_Trigger_Logon& from);

  inline TaskScheduler_Trigger_Logon& operator=(const TaskScheduler_Trigger_Logon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Trigger_Logon(TaskScheduler_Trigger_Logon&& from) noexcept
    : TaskScheduler_Trigger_Logon() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Trigger_Logon& operator=(TaskScheduler_Trigger_Logon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Trigger_Logon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Trigger_Logon* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Trigger_Logon*>(
               &_TaskScheduler_Trigger_Logon_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(TaskScheduler_Trigger_Logon* other);
  friend void swap(TaskScheduler_Trigger_Logon& a, TaskScheduler_Trigger_Logon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Trigger_Logon* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Trigger_Logon* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Trigger_Logon& from);
  void MergeFrom(const TaskScheduler_Trigger_Logon& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Trigger_Logon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_id = 1;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // string delay = 2;
  void clear_delay();
  static const int kDelayFieldNumber = 2;
  const ::std::string& delay() const;
  void set_delay(const ::std::string& value);
  #if LANG_CXX11
  void set_delay(::std::string&& value);
  #endif
  void set_delay(const char* value);
  void set_delay(const char* value, size_t size);
  ::std::string* mutable_delay();
  ::std::string* release_delay();
  void set_allocated_delay(::std::string* delay);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Trigger.Logon)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr delay_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_Trigger_LogonImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Trigger_SessionStateChange : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Trigger.SessionStateChange) */ {
 public:
  TaskScheduler_Trigger_SessionStateChange();
  virtual ~TaskScheduler_Trigger_SessionStateChange();

  TaskScheduler_Trigger_SessionStateChange(const TaskScheduler_Trigger_SessionStateChange& from);

  inline TaskScheduler_Trigger_SessionStateChange& operator=(const TaskScheduler_Trigger_SessionStateChange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Trigger_SessionStateChange(TaskScheduler_Trigger_SessionStateChange&& from) noexcept
    : TaskScheduler_Trigger_SessionStateChange() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Trigger_SessionStateChange& operator=(TaskScheduler_Trigger_SessionStateChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Trigger_SessionStateChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Trigger_SessionStateChange* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Trigger_SessionStateChange*>(
               &_TaskScheduler_Trigger_SessionStateChange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(TaskScheduler_Trigger_SessionStateChange* other);
  friend void swap(TaskScheduler_Trigger_SessionStateChange& a, TaskScheduler_Trigger_SessionStateChange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Trigger_SessionStateChange* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Trigger_SessionStateChange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Trigger_SessionStateChange& from);
  void MergeFrom(const TaskScheduler_Trigger_SessionStateChange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Trigger_SessionStateChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TaskScheduler_Trigger_SessionStateChange_ChangeType ChangeType;
  static const ChangeType CHANGE_TYPE_UNKNOWN =
    TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_UNKNOWN;
  static const ChangeType CHANGE_TYPE_CONSOLE_CONNECT =
    TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_CONSOLE_CONNECT;
  static const ChangeType CHANGE_TYPE_CONSOLE_DISCONNECT =
    TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_CONSOLE_DISCONNECT;
  static const ChangeType CHANGE_TYPE_REMOTE_CONNECT =
    TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_REMOTE_CONNECT;
  static const ChangeType CHANGE_TYPE_REMOTE_DISCONNECT =
    TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_REMOTE_DISCONNECT;
  static const ChangeType CHANGE_TYPE_SESSION_LOCK =
    TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_SESSION_LOCK;
  static const ChangeType CHANGE_TYPE_SESSION_UNLOCK =
    TaskScheduler_Trigger_SessionStateChange_ChangeType_CHANGE_TYPE_SESSION_UNLOCK;
  static inline bool ChangeType_IsValid(int value) {
    return TaskScheduler_Trigger_SessionStateChange_ChangeType_IsValid(value);
  }
  static const ChangeType ChangeType_MIN =
    TaskScheduler_Trigger_SessionStateChange_ChangeType_ChangeType_MIN;
  static const ChangeType ChangeType_MAX =
    TaskScheduler_Trigger_SessionStateChange_ChangeType_ChangeType_MAX;
  static const int ChangeType_ARRAYSIZE =
    TaskScheduler_Trigger_SessionStateChange_ChangeType_ChangeType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string user_id = 2;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // string delay = 3;
  void clear_delay();
  static const int kDelayFieldNumber = 3;
  const ::std::string& delay() const;
  void set_delay(const ::std::string& value);
  #if LANG_CXX11
  void set_delay(::std::string&& value);
  #endif
  void set_delay(const char* value);
  void set_delay(const char* value, size_t size);
  ::std::string* mutable_delay();
  ::std::string* release_delay();
  void set_allocated_delay(::std::string* delay);

  // .aspia.proto.TaskScheduler.Trigger.SessionStateChange.ChangeType change_type = 1;
  void clear_change_type();
  static const int kChangeTypeFieldNumber = 1;
  ::aspia::proto::TaskScheduler_Trigger_SessionStateChange_ChangeType change_type() const;
  void set_change_type(::aspia::proto::TaskScheduler_Trigger_SessionStateChange_ChangeType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Trigger.SessionStateChange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr delay_;
  int change_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_Trigger_SessionStateChangeImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Trigger_Repetition : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Trigger.Repetition) */ {
 public:
  TaskScheduler_Trigger_Repetition();
  virtual ~TaskScheduler_Trigger_Repetition();

  TaskScheduler_Trigger_Repetition(const TaskScheduler_Trigger_Repetition& from);

  inline TaskScheduler_Trigger_Repetition& operator=(const TaskScheduler_Trigger_Repetition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Trigger_Repetition(TaskScheduler_Trigger_Repetition&& from) noexcept
    : TaskScheduler_Trigger_Repetition() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Trigger_Repetition& operator=(TaskScheduler_Trigger_Repetition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Trigger_Repetition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Trigger_Repetition* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Trigger_Repetition*>(
               &_TaskScheduler_Trigger_Repetition_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(TaskScheduler_Trigger_Repetition* other);
  friend void swap(TaskScheduler_Trigger_Repetition& a, TaskScheduler_Trigger_Repetition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Trigger_Repetition* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Trigger_Repetition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Trigger_Repetition& from);
  void MergeFrom(const TaskScheduler_Trigger_Repetition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Trigger_Repetition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string duration = 1;
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  const ::std::string& duration() const;
  void set_duration(const ::std::string& value);
  #if LANG_CXX11
  void set_duration(::std::string&& value);
  #endif
  void set_duration(const char* value);
  void set_duration(const char* value, size_t size);
  ::std::string* mutable_duration();
  ::std::string* release_duration();
  void set_allocated_duration(::std::string* duration);

  // string interval = 2;
  void clear_interval();
  static const int kIntervalFieldNumber = 2;
  const ::std::string& interval() const;
  void set_interval(const ::std::string& value);
  #if LANG_CXX11
  void set_interval(::std::string&& value);
  #endif
  void set_interval(const char* value);
  void set_interval(const char* value, size_t size);
  ::std::string* mutable_interval();
  ::std::string* release_interval();
  void set_allocated_interval(::std::string* interval);

  // bool stop_at_duration_end = 3;
  void clear_stop_at_duration_end();
  static const int kStopAtDurationEndFieldNumber = 3;
  bool stop_at_duration_end() const;
  void set_stop_at_duration_end(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Trigger.Repetition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr duration_;
  ::google::protobuf::internal::ArenaStringPtr interval_;
  bool stop_at_duration_end_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_Trigger_RepetitionImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Trigger : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Trigger) */ {
 public:
  TaskScheduler_Trigger();
  virtual ~TaskScheduler_Trigger();

  TaskScheduler_Trigger(const TaskScheduler_Trigger& from);

  inline TaskScheduler_Trigger& operator=(const TaskScheduler_Trigger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Trigger(TaskScheduler_Trigger&& from) noexcept
    : TaskScheduler_Trigger() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Trigger& operator=(TaskScheduler_Trigger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Trigger& default_instance();

  enum TypeUnionCase {
    kEvent = 7,
    kDaily = 8,
    kWeekly = 9,
    kMonthly = 10,
    kMonthlyDow = 11,
    kRegistration = 12,
    kBoot = 13,
    kLogon = 14,
    kSessionStateChange = 15,
    TYPEUNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Trigger* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Trigger*>(
               &_TaskScheduler_Trigger_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(TaskScheduler_Trigger* other);
  friend void swap(TaskScheduler_Trigger& a, TaskScheduler_Trigger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Trigger* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Trigger* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Trigger& from);
  void MergeFrom(const TaskScheduler_Trigger& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TaskScheduler_Trigger_Event Event;
  typedef TaskScheduler_Trigger_Daily Daily;
  typedef TaskScheduler_Trigger_Weekly Weekly;
  typedef TaskScheduler_Trigger_Monthly Monthly;
  typedef TaskScheduler_Trigger_MonthlyDow MonthlyDow;
  typedef TaskScheduler_Trigger_Registration Registration;
  typedef TaskScheduler_Trigger_Boot Boot;
  typedef TaskScheduler_Trigger_Logon Logon;
  typedef TaskScheduler_Trigger_SessionStateChange SessionStateChange;
  typedef TaskScheduler_Trigger_Repetition Repetition;

  typedef TaskScheduler_Trigger_Type Type;
  static const Type TYPE_UNKNOWN =
    TaskScheduler_Trigger_Type_TYPE_UNKNOWN;
  static const Type TYPE_EVENT =
    TaskScheduler_Trigger_Type_TYPE_EVENT;
  static const Type TYPE_TIME =
    TaskScheduler_Trigger_Type_TYPE_TIME;
  static const Type TYPE_DAILY =
    TaskScheduler_Trigger_Type_TYPE_DAILY;
  static const Type TYPE_WEEKLY =
    TaskScheduler_Trigger_Type_TYPE_WEEKLY;
  static const Type TYPE_MONTHLY =
    TaskScheduler_Trigger_Type_TYPE_MONTHLY;
  static const Type TYPE_MONTHLYDOW =
    TaskScheduler_Trigger_Type_TYPE_MONTHLYDOW;
  static const Type TYPE_IDLE =
    TaskScheduler_Trigger_Type_TYPE_IDLE;
  static const Type TYPE_REGISTRATION =
    TaskScheduler_Trigger_Type_TYPE_REGISTRATION;
  static const Type TYPE_BOOT =
    TaskScheduler_Trigger_Type_TYPE_BOOT;
  static const Type TYPE_LOGON =
    TaskScheduler_Trigger_Type_TYPE_LOGON;
  static const Type TYPE_SESSION_STATE_CHANGE =
    TaskScheduler_Trigger_Type_TYPE_SESSION_STATE_CHANGE;
  static inline bool Type_IsValid(int value) {
    return TaskScheduler_Trigger_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TaskScheduler_Trigger_Type_Type_MIN;
  static const Type Type_MAX =
    TaskScheduler_Trigger_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TaskScheduler_Trigger_Type_Type_ARRAYSIZE;

  typedef TaskScheduler_Trigger_DayOfWeek DayOfWeek;
  static const DayOfWeek DAY_OF_WEEK_UNKNOWN =
    TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_UNKNOWN;
  static const DayOfWeek DAY_OF_WEEK_SUNDAY =
    TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_SUNDAY;
  static const DayOfWeek DAY_OF_WEEK_MONDAY =
    TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_MONDAY;
  static const DayOfWeek DAY_OF_WEEK_TUESDAY =
    TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_TUESDAY;
  static const DayOfWeek DAY_OF_WEEK_WEDNESDAY =
    TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_WEDNESDAY;
  static const DayOfWeek DAY_OF_WEEK_THURSDAY =
    TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_THURSDAY;
  static const DayOfWeek DAY_OF_WEEK_FRIDAY =
    TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_FRIDAY;
  static const DayOfWeek DAY_OF_WEEK_SATURDAY =
    TaskScheduler_Trigger_DayOfWeek_DAY_OF_WEEK_SATURDAY;
  static inline bool DayOfWeek_IsValid(int value) {
    return TaskScheduler_Trigger_DayOfWeek_IsValid(value);
  }
  static const DayOfWeek DayOfWeek_MIN =
    TaskScheduler_Trigger_DayOfWeek_DayOfWeek_MIN;
  static const DayOfWeek DayOfWeek_MAX =
    TaskScheduler_Trigger_DayOfWeek_DayOfWeek_MAX;
  static const int DayOfWeek_ARRAYSIZE =
    TaskScheduler_Trigger_DayOfWeek_DayOfWeek_ARRAYSIZE;

  typedef TaskScheduler_Trigger_DayOfMonth DayOfMonth;
  static const DayOfMonth DAY_OF_MONTH_UNKNOWN =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_UNKNOWN;
  static const DayOfMonth DAY_OF_MONTH_1 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_1;
  static const DayOfMonth DAY_OF_MONTH_2 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_2;
  static const DayOfMonth DAY_OF_MONTH_3 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_3;
  static const DayOfMonth DAY_OF_MONTH_4 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_4;
  static const DayOfMonth DAY_OF_MONTH_5 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_5;
  static const DayOfMonth DAY_OF_MONTH_6 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_6;
  static const DayOfMonth DAY_OF_MONTH_7 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_7;
  static const DayOfMonth DAY_OF_MONTH_8 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_8;
  static const DayOfMonth DAY_OF_MONTH_9 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_9;
  static const DayOfMonth DAY_OF_MONTH_10 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_10;
  static const DayOfMonth DAY_OF_MONTH_11 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_11;
  static const DayOfMonth DAY_OF_MONTH_12 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_12;
  static const DayOfMonth DAY_OF_MONTH_13 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_13;
  static const DayOfMonth DAY_OF_MONTH_14 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_14;
  static const DayOfMonth DAY_OF_MONTH_15 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_15;
  static const DayOfMonth DAY_OF_MONTH_16 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_16;
  static const DayOfMonth DAY_OF_MONTH_17 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_17;
  static const DayOfMonth DAY_OF_MONTH_18 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_18;
  static const DayOfMonth DAY_OF_MONTH_19 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_19;
  static const DayOfMonth DAY_OF_MONTH_20 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_20;
  static const DayOfMonth DAY_OF_MONTH_21 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_21;
  static const DayOfMonth DAY_OF_MONTH_22 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_22;
  static const DayOfMonth DAY_OF_MONTH_23 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_23;
  static const DayOfMonth DAY_OF_MONTH_24 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_24;
  static const DayOfMonth DAY_OF_MONTH_25 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_25;
  static const DayOfMonth DAY_OF_MONTH_26 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_26;
  static const DayOfMonth DAY_OF_MONTH_27 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_27;
  static const DayOfMonth DAY_OF_MONTH_28 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_28;
  static const DayOfMonth DAY_OF_MONTH_29 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_29;
  static const DayOfMonth DAY_OF_MONTH_30 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_30;
  static const DayOfMonth DAY_OF_MONTH_31 =
    TaskScheduler_Trigger_DayOfMonth_DAY_OF_MONTH_31;
  static inline bool DayOfMonth_IsValid(int value) {
    return TaskScheduler_Trigger_DayOfMonth_IsValid(value);
  }
  static const DayOfMonth DayOfMonth_MIN =
    TaskScheduler_Trigger_DayOfMonth_DayOfMonth_MIN;
  static const DayOfMonth DayOfMonth_MAX =
    TaskScheduler_Trigger_DayOfMonth_DayOfMonth_MAX;
  static const int DayOfMonth_ARRAYSIZE =
    TaskScheduler_Trigger_DayOfMonth_DayOfMonth_ARRAYSIZE;

  typedef TaskScheduler_Trigger_Month Month;
  static const Month MONTH_UNKNOWN =
    TaskScheduler_Trigger_Month_MONTH_UNKNOWN;
  static const Month MONTH_JANUARY =
    TaskScheduler_Trigger_Month_MONTH_JANUARY;
  static const Month MONTH_FEBRUARY =
    TaskScheduler_Trigger_Month_MONTH_FEBRUARY;
  static const Month MONTH_MARCH =
    TaskScheduler_Trigger_Month_MONTH_MARCH;
  static const Month MONTH_APRIL =
    TaskScheduler_Trigger_Month_MONTH_APRIL;
  static const Month MONTH_MAY =
    TaskScheduler_Trigger_Month_MONTH_MAY;
  static const Month MONTH_JUNE =
    TaskScheduler_Trigger_Month_MONTH_JUNE;
  static const Month MONTH_JULY =
    TaskScheduler_Trigger_Month_MONTH_JULY;
  static const Month MONTH_AUGUST =
    TaskScheduler_Trigger_Month_MONTH_AUGUST;
  static const Month MONTH_SEPTEMBER =
    TaskScheduler_Trigger_Month_MONTH_SEPTEMBER;
  static const Month MONTH_OCTOBER =
    TaskScheduler_Trigger_Month_MONTH_OCTOBER;
  static const Month MONTH_NOVEMBER =
    TaskScheduler_Trigger_Month_MONTH_NOVEMBER;
  static const Month MONTH_DECEMBER =
    TaskScheduler_Trigger_Month_MONTH_DECEMBER;
  static inline bool Month_IsValid(int value) {
    return TaskScheduler_Trigger_Month_IsValid(value);
  }
  static const Month Month_MIN =
    TaskScheduler_Trigger_Month_Month_MIN;
  static const Month Month_MAX =
    TaskScheduler_Trigger_Month_Month_MAX;
  static const int Month_ARRAYSIZE =
    TaskScheduler_Trigger_Month_Month_ARRAYSIZE;

  typedef TaskScheduler_Trigger_WeekOfMonth WeekOfMonth;
  static const WeekOfMonth WEEK_OF_MONTH_UNKNOWN =
    TaskScheduler_Trigger_WeekOfMonth_WEEK_OF_MONTH_UNKNOWN;
  static const WeekOfMonth WEEK_OF_MONTH_FIRST =
    TaskScheduler_Trigger_WeekOfMonth_WEEK_OF_MONTH_FIRST;
  static const WeekOfMonth WEEK_OF_MONTH_SECOND =
    TaskScheduler_Trigger_WeekOfMonth_WEEK_OF_MONTH_SECOND;
  static const WeekOfMonth WEEK_OF_MONTH_THIRD =
    TaskScheduler_Trigger_WeekOfMonth_WEEK_OF_MONTH_THIRD;
  static const WeekOfMonth WEEK_OF_MONTH_FOURTH =
    TaskScheduler_Trigger_WeekOfMonth_WEEK_OF_MONTH_FOURTH;
  static inline bool WeekOfMonth_IsValid(int value) {
    return TaskScheduler_Trigger_WeekOfMonth_IsValid(value);
  }
  static const WeekOfMonth WeekOfMonth_MIN =
    TaskScheduler_Trigger_WeekOfMonth_WeekOfMonth_MIN;
  static const WeekOfMonth WeekOfMonth_MAX =
    TaskScheduler_Trigger_WeekOfMonth_WeekOfMonth_MAX;
  static const int WeekOfMonth_ARRAYSIZE =
    TaskScheduler_Trigger_WeekOfMonth_WeekOfMonth_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string start_time = 3;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  const ::std::string& start_time() const;
  void set_start_time(const ::std::string& value);
  #if LANG_CXX11
  void set_start_time(::std::string&& value);
  #endif
  void set_start_time(const char* value);
  void set_start_time(const char* value, size_t size);
  ::std::string* mutable_start_time();
  ::std::string* release_start_time();
  void set_allocated_start_time(::std::string* start_time);

  // string end_time = 4;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 4;
  const ::std::string& end_time() const;
  void set_end_time(const ::std::string& value);
  #if LANG_CXX11
  void set_end_time(::std::string&& value);
  #endif
  void set_end_time(const char* value);
  void set_end_time(const char* value, size_t size);
  ::std::string* mutable_end_time();
  ::std::string* release_end_time();
  void set_allocated_end_time(::std::string* end_time);

  // string execution_time_limit = 5;
  void clear_execution_time_limit();
  static const int kExecutionTimeLimitFieldNumber = 5;
  const ::std::string& execution_time_limit() const;
  void set_execution_time_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_execution_time_limit(::std::string&& value);
  #endif
  void set_execution_time_limit(const char* value);
  void set_execution_time_limit(const char* value, size_t size);
  ::std::string* mutable_execution_time_limit();
  ::std::string* release_execution_time_limit();
  void set_allocated_execution_time_limit(::std::string* execution_time_limit);

  // .aspia.proto.TaskScheduler.Trigger.Repetition repetition = 6;
  bool has_repetition() const;
  void clear_repetition();
  static const int kRepetitionFieldNumber = 6;
  const ::aspia::proto::TaskScheduler_Trigger_Repetition& repetition() const;
  ::aspia::proto::TaskScheduler_Trigger_Repetition* release_repetition();
  ::aspia::proto::TaskScheduler_Trigger_Repetition* mutable_repetition();
  void set_allocated_repetition(::aspia::proto::TaskScheduler_Trigger_Repetition* repetition);

  // bool enabled = 1;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // .aspia.proto.TaskScheduler.Trigger.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::aspia::proto::TaskScheduler_Trigger_Type type() const;
  void set_type(::aspia::proto::TaskScheduler_Trigger_Type value);

  // .aspia.proto.TaskScheduler.Trigger.Event event = 7;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 7;
  const ::aspia::proto::TaskScheduler_Trigger_Event& event() const;
  ::aspia::proto::TaskScheduler_Trigger_Event* release_event();
  ::aspia::proto::TaskScheduler_Trigger_Event* mutable_event();
  void set_allocated_event(::aspia::proto::TaskScheduler_Trigger_Event* event);

  // .aspia.proto.TaskScheduler.Trigger.Daily daily = 8;
  bool has_daily() const;
  void clear_daily();
  static const int kDailyFieldNumber = 8;
  const ::aspia::proto::TaskScheduler_Trigger_Daily& daily() const;
  ::aspia::proto::TaskScheduler_Trigger_Daily* release_daily();
  ::aspia::proto::TaskScheduler_Trigger_Daily* mutable_daily();
  void set_allocated_daily(::aspia::proto::TaskScheduler_Trigger_Daily* daily);

  // .aspia.proto.TaskScheduler.Trigger.Weekly weekly = 9;
  bool has_weekly() const;
  void clear_weekly();
  static const int kWeeklyFieldNumber = 9;
  const ::aspia::proto::TaskScheduler_Trigger_Weekly& weekly() const;
  ::aspia::proto::TaskScheduler_Trigger_Weekly* release_weekly();
  ::aspia::proto::TaskScheduler_Trigger_Weekly* mutable_weekly();
  void set_allocated_weekly(::aspia::proto::TaskScheduler_Trigger_Weekly* weekly);

  // .aspia.proto.TaskScheduler.Trigger.Monthly monthly = 10;
  bool has_monthly() const;
  void clear_monthly();
  static const int kMonthlyFieldNumber = 10;
  const ::aspia::proto::TaskScheduler_Trigger_Monthly& monthly() const;
  ::aspia::proto::TaskScheduler_Trigger_Monthly* release_monthly();
  ::aspia::proto::TaskScheduler_Trigger_Monthly* mutable_monthly();
  void set_allocated_monthly(::aspia::proto::TaskScheduler_Trigger_Monthly* monthly);

  // .aspia.proto.TaskScheduler.Trigger.MonthlyDow monthly_dow = 11;
  bool has_monthly_dow() const;
  void clear_monthly_dow();
  static const int kMonthlyDowFieldNumber = 11;
  const ::aspia::proto::TaskScheduler_Trigger_MonthlyDow& monthly_dow() const;
  ::aspia::proto::TaskScheduler_Trigger_MonthlyDow* release_monthly_dow();
  ::aspia::proto::TaskScheduler_Trigger_MonthlyDow* mutable_monthly_dow();
  void set_allocated_monthly_dow(::aspia::proto::TaskScheduler_Trigger_MonthlyDow* monthly_dow);

  // .aspia.proto.TaskScheduler.Trigger.Registration registration = 12;
  bool has_registration() const;
  void clear_registration();
  static const int kRegistrationFieldNumber = 12;
  const ::aspia::proto::TaskScheduler_Trigger_Registration& registration() const;
  ::aspia::proto::TaskScheduler_Trigger_Registration* release_registration();
  ::aspia::proto::TaskScheduler_Trigger_Registration* mutable_registration();
  void set_allocated_registration(::aspia::proto::TaskScheduler_Trigger_Registration* registration);

  // .aspia.proto.TaskScheduler.Trigger.Boot boot = 13;
  bool has_boot() const;
  void clear_boot();
  static const int kBootFieldNumber = 13;
  const ::aspia::proto::TaskScheduler_Trigger_Boot& boot() const;
  ::aspia::proto::TaskScheduler_Trigger_Boot* release_boot();
  ::aspia::proto::TaskScheduler_Trigger_Boot* mutable_boot();
  void set_allocated_boot(::aspia::proto::TaskScheduler_Trigger_Boot* boot);

  // .aspia.proto.TaskScheduler.Trigger.Logon logon = 14;
  bool has_logon() const;
  void clear_logon();
  static const int kLogonFieldNumber = 14;
  const ::aspia::proto::TaskScheduler_Trigger_Logon& logon() const;
  ::aspia::proto::TaskScheduler_Trigger_Logon* release_logon();
  ::aspia::proto::TaskScheduler_Trigger_Logon* mutable_logon();
  void set_allocated_logon(::aspia::proto::TaskScheduler_Trigger_Logon* logon);

  // .aspia.proto.TaskScheduler.Trigger.SessionStateChange session_state_change = 15;
  bool has_session_state_change() const;
  void clear_session_state_change();
  static const int kSessionStateChangeFieldNumber = 15;
  const ::aspia::proto::TaskScheduler_Trigger_SessionStateChange& session_state_change() const;
  ::aspia::proto::TaskScheduler_Trigger_SessionStateChange* release_session_state_change();
  ::aspia::proto::TaskScheduler_Trigger_SessionStateChange* mutable_session_state_change();
  void set_allocated_session_state_change(::aspia::proto::TaskScheduler_Trigger_SessionStateChange* session_state_change);

  TypeUnionCase TypeUnion_case() const;
  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Trigger)
 private:
  void set_has_event();
  void set_has_daily();
  void set_has_weekly();
  void set_has_monthly();
  void set_has_monthly_dow();
  void set_has_registration();
  void set_has_boot();
  void set_has_logon();
  void set_has_session_state_change();

  inline bool has_TypeUnion() const;
  void clear_TypeUnion();
  inline void clear_has_TypeUnion();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_time_;
  ::google::protobuf::internal::ArenaStringPtr end_time_;
  ::google::protobuf::internal::ArenaStringPtr execution_time_limit_;
  ::aspia::proto::TaskScheduler_Trigger_Repetition* repetition_;
  bool enabled_;
  int type_;
  union TypeUnionUnion {
    TypeUnionUnion() {}
    ::aspia::proto::TaskScheduler_Trigger_Event* event_;
    ::aspia::proto::TaskScheduler_Trigger_Daily* daily_;
    ::aspia::proto::TaskScheduler_Trigger_Weekly* weekly_;
    ::aspia::proto::TaskScheduler_Trigger_Monthly* monthly_;
    ::aspia::proto::TaskScheduler_Trigger_MonthlyDow* monthly_dow_;
    ::aspia::proto::TaskScheduler_Trigger_Registration* registration_;
    ::aspia::proto::TaskScheduler_Trigger_Boot* boot_;
    ::aspia::proto::TaskScheduler_Trigger_Logon* logon_;
    ::aspia::proto::TaskScheduler_Trigger_SessionStateChange* session_state_change_;
  } TypeUnion_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_TriggerImpl();
};
// -------------------------------------------------------------------

class TaskScheduler_Task : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler.Task) */ {
 public:
  TaskScheduler_Task();
  virtual ~TaskScheduler_Task();

  TaskScheduler_Task(const TaskScheduler_Task& from);

  inline TaskScheduler_Task& operator=(const TaskScheduler_Task& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler_Task(TaskScheduler_Task&& from) noexcept
    : TaskScheduler_Task() {
    *this = ::std::move(from);
  }

  inline TaskScheduler_Task& operator=(TaskScheduler_Task&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler_Task& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler_Task* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler_Task*>(
               &_TaskScheduler_Task_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(TaskScheduler_Task* other);
  friend void swap(TaskScheduler_Task& a, TaskScheduler_Task& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler_Task* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler_Task* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler_Task& from);
  void MergeFrom(const TaskScheduler_Task& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler_Task* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TaskScheduler_Task_Status Status;
  static const Status STATUS_UNKNOWN =
    TaskScheduler_Task_Status_STATUS_UNKNOWN;
  static const Status STATUS_DISABLED =
    TaskScheduler_Task_Status_STATUS_DISABLED;
  static const Status STATUS_QUEUED =
    TaskScheduler_Task_Status_STATUS_QUEUED;
  static const Status STATUS_READY =
    TaskScheduler_Task_Status_STATUS_READY;
  static const Status STATUS_RUNNING =
    TaskScheduler_Task_Status_STATUS_RUNNING;
  static inline bool Status_IsValid(int value) {
    return TaskScheduler_Task_Status_IsValid(value);
  }
  static const Status Status_MIN =
    TaskScheduler_Task_Status_Status_MIN;
  static const Status Status_MAX =
    TaskScheduler_Task_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    TaskScheduler_Task_Status_Status_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.TaskScheduler.Action action = 10;
  int action_size() const;
  void clear_action();
  static const int kActionFieldNumber = 10;
  const ::aspia::proto::TaskScheduler_Action& action(int index) const;
  ::aspia::proto::TaskScheduler_Action* mutable_action(int index);
  ::aspia::proto::TaskScheduler_Action* add_action();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Action >*
      mutable_action();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Action >&
      action() const;

  // repeated .aspia.proto.TaskScheduler.Trigger trigger = 11;
  int trigger_size() const;
  void clear_trigger();
  static const int kTriggerFieldNumber = 11;
  const ::aspia::proto::TaskScheduler_Trigger& trigger(int index) const;
  ::aspia::proto::TaskScheduler_Trigger* mutable_trigger(int index);
  ::aspia::proto::TaskScheduler_Trigger* add_trigger();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Trigger >*
      mutable_trigger();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Trigger >&
      trigger() const;

  // string task_name = 1;
  void clear_task_name();
  static const int kTaskNameFieldNumber = 1;
  const ::std::string& task_name() const;
  void set_task_name(const ::std::string& value);
  #if LANG_CXX11
  void set_task_name(::std::string&& value);
  #endif
  void set_task_name(const char* value);
  void set_task_name(const char* value, size_t size);
  ::std::string* mutable_task_name();
  ::std::string* release_task_name();
  void set_allocated_task_name(::std::string* task_name);

  // string comment = 3;
  void clear_comment();
  static const int kCommentFieldNumber = 3;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // string account_name = 4;
  void clear_account_name();
  static const int kAccountNameFieldNumber = 4;
  const ::std::string& account_name() const;
  void set_account_name(const ::std::string& value);
  #if LANG_CXX11
  void set_account_name(::std::string&& value);
  #endif
  void set_account_name(const char* value);
  void set_account_name(const char* value, size_t size);
  ::std::string* mutable_account_name();
  ::std::string* release_account_name();
  void set_allocated_account_name(::std::string* account_name);

  // string creator = 5;
  void clear_creator();
  static const int kCreatorFieldNumber = 5;
  const ::std::string& creator() const;
  void set_creator(const ::std::string& value);
  #if LANG_CXX11
  void set_creator(::std::string&& value);
  #endif
  void set_creator(const char* value);
  void set_creator(const char* value, size_t size);
  ::std::string* mutable_creator();
  ::std::string* release_creator();
  void set_allocated_creator(::std::string* creator);

  // .aspia.proto.TaskScheduler.Task.Status status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::aspia::proto::TaskScheduler_Task_Status status() const;
  void set_status(::aspia::proto::TaskScheduler_Task_Status value);

  // uint32 number_of_missed_runs = 8;
  void clear_number_of_missed_runs();
  static const int kNumberOfMissedRunsFieldNumber = 8;
  ::google::protobuf::uint32 number_of_missed_runs() const;
  void set_number_of_missed_runs(::google::protobuf::uint32 value);

  // int64 last_run = 6;
  void clear_last_run();
  static const int kLastRunFieldNumber = 6;
  ::google::protobuf::int64 last_run() const;
  void set_last_run(::google::protobuf::int64 value);

  // int64 next_run = 7;
  void clear_next_run();
  static const int kNextRunFieldNumber = 7;
  ::google::protobuf::int64 next_run() const;
  void set_next_run(::google::protobuf::int64 value);

  // uint32 last_task_result = 9;
  void clear_last_task_result();
  static const int kLastTaskResultFieldNumber = 9;
  ::google::protobuf::uint32 last_task_result() const;
  void set_last_task_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler.Task)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Action > action_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Trigger > trigger_;
  ::google::protobuf::internal::ArenaStringPtr task_name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::google::protobuf::internal::ArenaStringPtr account_name_;
  ::google::protobuf::internal::ArenaStringPtr creator_;
  int status_;
  ::google::protobuf::uint32 number_of_missed_runs_;
  ::google::protobuf::int64 last_run_;
  ::google::protobuf::int64 next_run_;
  ::google::protobuf::uint32 last_task_result_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskScheduler_TaskImpl();
};
// -------------------------------------------------------------------

class TaskScheduler : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.TaskScheduler) */ {
 public:
  TaskScheduler();
  virtual ~TaskScheduler();

  TaskScheduler(const TaskScheduler& from);

  inline TaskScheduler& operator=(const TaskScheduler& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskScheduler(TaskScheduler&& from) noexcept
    : TaskScheduler() {
    *this = ::std::move(from);
  }

  inline TaskScheduler& operator=(TaskScheduler&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const TaskScheduler& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskScheduler* internal_default_instance() {
    return reinterpret_cast<const TaskScheduler*>(
               &_TaskScheduler_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(TaskScheduler* other);
  friend void swap(TaskScheduler& a, TaskScheduler& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskScheduler* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskScheduler* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const TaskScheduler& from);
  void MergeFrom(const TaskScheduler& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskScheduler* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TaskScheduler_Action Action;
  typedef TaskScheduler_Trigger Trigger;
  typedef TaskScheduler_Task Task;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.TaskScheduler.Task task = 1;
  int task_size() const;
  void clear_task();
  static const int kTaskFieldNumber = 1;
  const ::aspia::proto::TaskScheduler_Task& task(int index) const;
  ::aspia::proto::TaskScheduler_Task* mutable_task(int index);
  ::aspia::proto::TaskScheduler_Task* add_task();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Task >*
      mutable_task();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Task >&
      task() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.TaskScheduler)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Task > task_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5ftask_5fscheduler_2eproto::TableStruct;
  friend void ::protobuf_category_5ftask_5fscheduler_2eproto::InitDefaultsTaskSchedulerImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TaskScheduler_Action

// string path = 1;
inline void TaskScheduler_Action::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Action::path() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Action.path)
  return path_.GetNoArena();
}
inline void TaskScheduler_Action::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Action.path)
}
#if LANG_CXX11
inline void TaskScheduler_Action::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Action.path)
}
#endif
inline void TaskScheduler_Action::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Action.path)
}
inline void TaskScheduler_Action::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Action.path)
}
inline ::std::string* TaskScheduler_Action::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Action.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Action::release_path() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Action.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Action::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Action.path)
}

// string arguments = 2;
inline void TaskScheduler_Action::clear_arguments() {
  arguments_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Action::arguments() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Action.arguments)
  return arguments_.GetNoArena();
}
inline void TaskScheduler_Action::set_arguments(const ::std::string& value) {
  
  arguments_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Action.arguments)
}
#if LANG_CXX11
inline void TaskScheduler_Action::set_arguments(::std::string&& value) {
  
  arguments_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Action.arguments)
}
#endif
inline void TaskScheduler_Action::set_arguments(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  arguments_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Action.arguments)
}
inline void TaskScheduler_Action::set_arguments(const char* value, size_t size) {
  
  arguments_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Action.arguments)
}
inline ::std::string* TaskScheduler_Action::mutable_arguments() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Action.arguments)
  return arguments_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Action::release_arguments() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Action.arguments)
  
  return arguments_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Action::set_allocated_arguments(::std::string* arguments) {
  if (arguments != NULL) {
    
  } else {
    
  }
  arguments_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), arguments);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Action.arguments)
}

// string working_directory = 3;
inline void TaskScheduler_Action::clear_working_directory() {
  working_directory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Action::working_directory() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Action.working_directory)
  return working_directory_.GetNoArena();
}
inline void TaskScheduler_Action::set_working_directory(const ::std::string& value) {
  
  working_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Action.working_directory)
}
#if LANG_CXX11
inline void TaskScheduler_Action::set_working_directory(::std::string&& value) {
  
  working_directory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Action.working_directory)
}
#endif
inline void TaskScheduler_Action::set_working_directory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  working_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Action.working_directory)
}
inline void TaskScheduler_Action::set_working_directory(const char* value, size_t size) {
  
  working_directory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Action.working_directory)
}
inline ::std::string* TaskScheduler_Action::mutable_working_directory() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Action.working_directory)
  return working_directory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Action::release_working_directory() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Action.working_directory)
  
  return working_directory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Action::set_allocated_working_directory(::std::string* working_directory) {
  if (working_directory != NULL) {
    
  } else {
    
  }
  working_directory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), working_directory);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Action.working_directory)
}

// -------------------------------------------------------------------

// TaskScheduler_Trigger_Event_NamedValue

// string name = 1;
inline void TaskScheduler_Trigger_Event_NamedValue::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger_Event_NamedValue::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.name)
  return name_.GetNoArena();
}
inline void TaskScheduler_Trigger_Event_NamedValue::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.name)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger_Event_NamedValue::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.name)
}
#endif
inline void TaskScheduler_Trigger_Event_NamedValue::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.name)
}
inline void TaskScheduler_Trigger_Event_NamedValue::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.name)
}
inline ::std::string* TaskScheduler_Trigger_Event_NamedValue::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger_Event_NamedValue::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger_Event_NamedValue::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.name)
}

// string value = 2;
inline void TaskScheduler_Trigger_Event_NamedValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger_Event_NamedValue::value() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.value)
  return value_.GetNoArena();
}
inline void TaskScheduler_Trigger_Event_NamedValue::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.value)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger_Event_NamedValue::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.value)
}
#endif
inline void TaskScheduler_Trigger_Event_NamedValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.value)
}
inline void TaskScheduler_Trigger_Event_NamedValue::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.value)
}
inline ::std::string* TaskScheduler_Trigger_Event_NamedValue::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger_Event_NamedValue::release_value() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger_Event_NamedValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.Event.NamedValue.value)
}

// -------------------------------------------------------------------

// TaskScheduler_Trigger_Event

// string delay = 1;
inline void TaskScheduler_Trigger_Event::clear_delay() {
  delay_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger_Event::delay() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Event.delay)
  return delay_.GetNoArena();
}
inline void TaskScheduler_Trigger_Event::set_delay(const ::std::string& value) {
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Event.delay)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger_Event::set_delay(::std::string&& value) {
  
  delay_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.Event.delay)
}
#endif
inline void TaskScheduler_Trigger_Event::set_delay(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.Event.delay)
}
inline void TaskScheduler_Trigger_Event::set_delay(const char* value, size_t size) {
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.Event.delay)
}
inline ::std::string* TaskScheduler_Trigger_Event::mutable_delay() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.Event.delay)
  return delay_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger_Event::release_delay() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.Event.delay)
  
  return delay_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger_Event::set_allocated_delay(::std::string* delay) {
  if (delay != NULL) {
    
  } else {
    
  }
  delay_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), delay);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.Event.delay)
}

// repeated .aspia.proto.TaskScheduler.Trigger.Event.NamedValue named_value = 2;
inline int TaskScheduler_Trigger_Event::named_value_size() const {
  return named_value_.size();
}
inline void TaskScheduler_Trigger_Event::clear_named_value() {
  named_value_.Clear();
}
inline const ::aspia::proto::TaskScheduler_Trigger_Event_NamedValue& TaskScheduler_Trigger_Event::named_value(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Event.named_value)
  return named_value_.Get(index);
}
inline ::aspia::proto::TaskScheduler_Trigger_Event_NamedValue* TaskScheduler_Trigger_Event::mutable_named_value(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.Event.named_value)
  return named_value_.Mutable(index);
}
inline ::aspia::proto::TaskScheduler_Trigger_Event_NamedValue* TaskScheduler_Trigger_Event::add_named_value() {
  // @@protoc_insertion_point(field_add:aspia.proto.TaskScheduler.Trigger.Event.named_value)
  return named_value_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Trigger_Event_NamedValue >*
TaskScheduler_Trigger_Event::mutable_named_value() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.TaskScheduler.Trigger.Event.named_value)
  return &named_value_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Trigger_Event_NamedValue >&
TaskScheduler_Trigger_Event::named_value() const {
  // @@protoc_insertion_point(field_list:aspia.proto.TaskScheduler.Trigger.Event.named_value)
  return named_value_;
}

// -------------------------------------------------------------------

// TaskScheduler_Trigger_Daily

// int32 days_interval = 1;
inline void TaskScheduler_Trigger_Daily::clear_days_interval() {
  days_interval_ = 0;
}
inline ::google::protobuf::int32 TaskScheduler_Trigger_Daily::days_interval() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Daily.days_interval)
  return days_interval_;
}
inline void TaskScheduler_Trigger_Daily::set_days_interval(::google::protobuf::int32 value) {
  
  days_interval_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Daily.days_interval)
}

// -------------------------------------------------------------------

// TaskScheduler_Trigger_Weekly

// int32 weeks_interval = 1;
inline void TaskScheduler_Trigger_Weekly::clear_weeks_interval() {
  weeks_interval_ = 0;
}
inline ::google::protobuf::int32 TaskScheduler_Trigger_Weekly::weeks_interval() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Weekly.weeks_interval)
  return weeks_interval_;
}
inline void TaskScheduler_Trigger_Weekly::set_weeks_interval(::google::protobuf::int32 value) {
  
  weeks_interval_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Weekly.weeks_interval)
}

// uint32 days_of_week = 2;
inline void TaskScheduler_Trigger_Weekly::clear_days_of_week() {
  days_of_week_ = 0u;
}
inline ::google::protobuf::uint32 TaskScheduler_Trigger_Weekly::days_of_week() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Weekly.days_of_week)
  return days_of_week_;
}
inline void TaskScheduler_Trigger_Weekly::set_days_of_week(::google::protobuf::uint32 value) {
  
  days_of_week_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Weekly.days_of_week)
}

// -------------------------------------------------------------------

// TaskScheduler_Trigger_Monthly

// uint32 days_of_month = 1;
inline void TaskScheduler_Trigger_Monthly::clear_days_of_month() {
  days_of_month_ = 0u;
}
inline ::google::protobuf::uint32 TaskScheduler_Trigger_Monthly::days_of_month() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Monthly.days_of_month)
  return days_of_month_;
}
inline void TaskScheduler_Trigger_Monthly::set_days_of_month(::google::protobuf::uint32 value) {
  
  days_of_month_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Monthly.days_of_month)
}

// uint32 months_of_year = 2;
inline void TaskScheduler_Trigger_Monthly::clear_months_of_year() {
  months_of_year_ = 0u;
}
inline ::google::protobuf::uint32 TaskScheduler_Trigger_Monthly::months_of_year() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Monthly.months_of_year)
  return months_of_year_;
}
inline void TaskScheduler_Trigger_Monthly::set_months_of_year(::google::protobuf::uint32 value) {
  
  months_of_year_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Monthly.months_of_year)
}

// bool last_day = 3;
inline void TaskScheduler_Trigger_Monthly::clear_last_day() {
  last_day_ = false;
}
inline bool TaskScheduler_Trigger_Monthly::last_day() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Monthly.last_day)
  return last_day_;
}
inline void TaskScheduler_Trigger_Monthly::set_last_day(bool value) {
  
  last_day_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Monthly.last_day)
}

// -------------------------------------------------------------------

// TaskScheduler_Trigger_MonthlyDow

// uint32 days_of_week = 1;
inline void TaskScheduler_Trigger_MonthlyDow::clear_days_of_week() {
  days_of_week_ = 0u;
}
inline ::google::protobuf::uint32 TaskScheduler_Trigger_MonthlyDow::days_of_week() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.MonthlyDow.days_of_week)
  return days_of_week_;
}
inline void TaskScheduler_Trigger_MonthlyDow::set_days_of_week(::google::protobuf::uint32 value) {
  
  days_of_week_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.MonthlyDow.days_of_week)
}

// uint32 months_of_year = 2;
inline void TaskScheduler_Trigger_MonthlyDow::clear_months_of_year() {
  months_of_year_ = 0u;
}
inline ::google::protobuf::uint32 TaskScheduler_Trigger_MonthlyDow::months_of_year() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.MonthlyDow.months_of_year)
  return months_of_year_;
}
inline void TaskScheduler_Trigger_MonthlyDow::set_months_of_year(::google::protobuf::uint32 value) {
  
  months_of_year_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.MonthlyDow.months_of_year)
}

// bool last_week = 3;
inline void TaskScheduler_Trigger_MonthlyDow::clear_last_week() {
  last_week_ = false;
}
inline bool TaskScheduler_Trigger_MonthlyDow::last_week() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.MonthlyDow.last_week)
  return last_week_;
}
inline void TaskScheduler_Trigger_MonthlyDow::set_last_week(bool value) {
  
  last_week_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.MonthlyDow.last_week)
}

// uint32 weeks_of_month = 4;
inline void TaskScheduler_Trigger_MonthlyDow::clear_weeks_of_month() {
  weeks_of_month_ = 0u;
}
inline ::google::protobuf::uint32 TaskScheduler_Trigger_MonthlyDow::weeks_of_month() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.MonthlyDow.weeks_of_month)
  return weeks_of_month_;
}
inline void TaskScheduler_Trigger_MonthlyDow::set_weeks_of_month(::google::protobuf::uint32 value) {
  
  weeks_of_month_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.MonthlyDow.weeks_of_month)
}

// -------------------------------------------------------------------

// TaskScheduler_Trigger_Registration

// string delay = 1;
inline void TaskScheduler_Trigger_Registration::clear_delay() {
  delay_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger_Registration::delay() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Registration.delay)
  return delay_.GetNoArena();
}
inline void TaskScheduler_Trigger_Registration::set_delay(const ::std::string& value) {
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Registration.delay)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger_Registration::set_delay(::std::string&& value) {
  
  delay_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.Registration.delay)
}
#endif
inline void TaskScheduler_Trigger_Registration::set_delay(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.Registration.delay)
}
inline void TaskScheduler_Trigger_Registration::set_delay(const char* value, size_t size) {
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.Registration.delay)
}
inline ::std::string* TaskScheduler_Trigger_Registration::mutable_delay() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.Registration.delay)
  return delay_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger_Registration::release_delay() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.Registration.delay)
  
  return delay_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger_Registration::set_allocated_delay(::std::string* delay) {
  if (delay != NULL) {
    
  } else {
    
  }
  delay_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), delay);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.Registration.delay)
}

// -------------------------------------------------------------------

// TaskScheduler_Trigger_Boot

// string delay = 1;
inline void TaskScheduler_Trigger_Boot::clear_delay() {
  delay_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger_Boot::delay() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Boot.delay)
  return delay_.GetNoArena();
}
inline void TaskScheduler_Trigger_Boot::set_delay(const ::std::string& value) {
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Boot.delay)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger_Boot::set_delay(::std::string&& value) {
  
  delay_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.Boot.delay)
}
#endif
inline void TaskScheduler_Trigger_Boot::set_delay(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.Boot.delay)
}
inline void TaskScheduler_Trigger_Boot::set_delay(const char* value, size_t size) {
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.Boot.delay)
}
inline ::std::string* TaskScheduler_Trigger_Boot::mutable_delay() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.Boot.delay)
  return delay_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger_Boot::release_delay() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.Boot.delay)
  
  return delay_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger_Boot::set_allocated_delay(::std::string* delay) {
  if (delay != NULL) {
    
  } else {
    
  }
  delay_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), delay);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.Boot.delay)
}

// -------------------------------------------------------------------

// TaskScheduler_Trigger_Logon

// string user_id = 1;
inline void TaskScheduler_Trigger_Logon::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger_Logon::user_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Logon.user_id)
  return user_id_.GetNoArena();
}
inline void TaskScheduler_Trigger_Logon::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Logon.user_id)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger_Logon::set_user_id(::std::string&& value) {
  
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.Logon.user_id)
}
#endif
inline void TaskScheduler_Trigger_Logon::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.Logon.user_id)
}
inline void TaskScheduler_Trigger_Logon::set_user_id(const char* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.Logon.user_id)
}
inline ::std::string* TaskScheduler_Trigger_Logon::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.Logon.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger_Logon::release_user_id() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.Logon.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger_Logon::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.Logon.user_id)
}

// string delay = 2;
inline void TaskScheduler_Trigger_Logon::clear_delay() {
  delay_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger_Logon::delay() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Logon.delay)
  return delay_.GetNoArena();
}
inline void TaskScheduler_Trigger_Logon::set_delay(const ::std::string& value) {
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Logon.delay)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger_Logon::set_delay(::std::string&& value) {
  
  delay_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.Logon.delay)
}
#endif
inline void TaskScheduler_Trigger_Logon::set_delay(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.Logon.delay)
}
inline void TaskScheduler_Trigger_Logon::set_delay(const char* value, size_t size) {
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.Logon.delay)
}
inline ::std::string* TaskScheduler_Trigger_Logon::mutable_delay() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.Logon.delay)
  return delay_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger_Logon::release_delay() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.Logon.delay)
  
  return delay_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger_Logon::set_allocated_delay(::std::string* delay) {
  if (delay != NULL) {
    
  } else {
    
  }
  delay_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), delay);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.Logon.delay)
}

// -------------------------------------------------------------------

// TaskScheduler_Trigger_SessionStateChange

// .aspia.proto.TaskScheduler.Trigger.SessionStateChange.ChangeType change_type = 1;
inline void TaskScheduler_Trigger_SessionStateChange::clear_change_type() {
  change_type_ = 0;
}
inline ::aspia::proto::TaskScheduler_Trigger_SessionStateChange_ChangeType TaskScheduler_Trigger_SessionStateChange::change_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.SessionStateChange.change_type)
  return static_cast< ::aspia::proto::TaskScheduler_Trigger_SessionStateChange_ChangeType >(change_type_);
}
inline void TaskScheduler_Trigger_SessionStateChange::set_change_type(::aspia::proto::TaskScheduler_Trigger_SessionStateChange_ChangeType value) {
  
  change_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.SessionStateChange.change_type)
}

// string user_id = 2;
inline void TaskScheduler_Trigger_SessionStateChange::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger_SessionStateChange::user_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.SessionStateChange.user_id)
  return user_id_.GetNoArena();
}
inline void TaskScheduler_Trigger_SessionStateChange::set_user_id(const ::std::string& value) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.SessionStateChange.user_id)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger_SessionStateChange::set_user_id(::std::string&& value) {
  
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.SessionStateChange.user_id)
}
#endif
inline void TaskScheduler_Trigger_SessionStateChange::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.SessionStateChange.user_id)
}
inline void TaskScheduler_Trigger_SessionStateChange::set_user_id(const char* value, size_t size) {
  
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.SessionStateChange.user_id)
}
inline ::std::string* TaskScheduler_Trigger_SessionStateChange::mutable_user_id() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.SessionStateChange.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger_SessionStateChange::release_user_id() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.SessionStateChange.user_id)
  
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger_SessionStateChange::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    
  } else {
    
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.SessionStateChange.user_id)
}

// string delay = 3;
inline void TaskScheduler_Trigger_SessionStateChange::clear_delay() {
  delay_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger_SessionStateChange::delay() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.SessionStateChange.delay)
  return delay_.GetNoArena();
}
inline void TaskScheduler_Trigger_SessionStateChange::set_delay(const ::std::string& value) {
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.SessionStateChange.delay)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger_SessionStateChange::set_delay(::std::string&& value) {
  
  delay_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.SessionStateChange.delay)
}
#endif
inline void TaskScheduler_Trigger_SessionStateChange::set_delay(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.SessionStateChange.delay)
}
inline void TaskScheduler_Trigger_SessionStateChange::set_delay(const char* value, size_t size) {
  
  delay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.SessionStateChange.delay)
}
inline ::std::string* TaskScheduler_Trigger_SessionStateChange::mutable_delay() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.SessionStateChange.delay)
  return delay_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger_SessionStateChange::release_delay() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.SessionStateChange.delay)
  
  return delay_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger_SessionStateChange::set_allocated_delay(::std::string* delay) {
  if (delay != NULL) {
    
  } else {
    
  }
  delay_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), delay);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.SessionStateChange.delay)
}

// -------------------------------------------------------------------

// TaskScheduler_Trigger_Repetition

// string duration = 1;
inline void TaskScheduler_Trigger_Repetition::clear_duration() {
  duration_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger_Repetition::duration() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Repetition.duration)
  return duration_.GetNoArena();
}
inline void TaskScheduler_Trigger_Repetition::set_duration(const ::std::string& value) {
  
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Repetition.duration)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger_Repetition::set_duration(::std::string&& value) {
  
  duration_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.Repetition.duration)
}
#endif
inline void TaskScheduler_Trigger_Repetition::set_duration(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.Repetition.duration)
}
inline void TaskScheduler_Trigger_Repetition::set_duration(const char* value, size_t size) {
  
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.Repetition.duration)
}
inline ::std::string* TaskScheduler_Trigger_Repetition::mutable_duration() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.Repetition.duration)
  return duration_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger_Repetition::release_duration() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.Repetition.duration)
  
  return duration_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger_Repetition::set_allocated_duration(::std::string* duration) {
  if (duration != NULL) {
    
  } else {
    
  }
  duration_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), duration);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.Repetition.duration)
}

// string interval = 2;
inline void TaskScheduler_Trigger_Repetition::clear_interval() {
  interval_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger_Repetition::interval() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Repetition.interval)
  return interval_.GetNoArena();
}
inline void TaskScheduler_Trigger_Repetition::set_interval(const ::std::string& value) {
  
  interval_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Repetition.interval)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger_Repetition::set_interval(::std::string&& value) {
  
  interval_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.Repetition.interval)
}
#endif
inline void TaskScheduler_Trigger_Repetition::set_interval(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  interval_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.Repetition.interval)
}
inline void TaskScheduler_Trigger_Repetition::set_interval(const char* value, size_t size) {
  
  interval_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.Repetition.interval)
}
inline ::std::string* TaskScheduler_Trigger_Repetition::mutable_interval() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.Repetition.interval)
  return interval_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger_Repetition::release_interval() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.Repetition.interval)
  
  return interval_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger_Repetition::set_allocated_interval(::std::string* interval) {
  if (interval != NULL) {
    
  } else {
    
  }
  interval_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), interval);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.Repetition.interval)
}

// bool stop_at_duration_end = 3;
inline void TaskScheduler_Trigger_Repetition::clear_stop_at_duration_end() {
  stop_at_duration_end_ = false;
}
inline bool TaskScheduler_Trigger_Repetition::stop_at_duration_end() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.Repetition.stop_at_duration_end)
  return stop_at_duration_end_;
}
inline void TaskScheduler_Trigger_Repetition::set_stop_at_duration_end(bool value) {
  
  stop_at_duration_end_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.Repetition.stop_at_duration_end)
}

// -------------------------------------------------------------------

// TaskScheduler_Trigger

// bool enabled = 1;
inline void TaskScheduler_Trigger::clear_enabled() {
  enabled_ = false;
}
inline bool TaskScheduler_Trigger::enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.enabled)
  return enabled_;
}
inline void TaskScheduler_Trigger::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.enabled)
}

// .aspia.proto.TaskScheduler.Trigger.Type type = 2;
inline void TaskScheduler_Trigger::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::TaskScheduler_Trigger_Type TaskScheduler_Trigger::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.type)
  return static_cast< ::aspia::proto::TaskScheduler_Trigger_Type >(type_);
}
inline void TaskScheduler_Trigger::set_type(::aspia::proto::TaskScheduler_Trigger_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.type)
}

// string start_time = 3;
inline void TaskScheduler_Trigger::clear_start_time() {
  start_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger::start_time() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.start_time)
  return start_time_.GetNoArena();
}
inline void TaskScheduler_Trigger::set_start_time(const ::std::string& value) {
  
  start_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.start_time)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger::set_start_time(::std::string&& value) {
  
  start_time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.start_time)
}
#endif
inline void TaskScheduler_Trigger::set_start_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.start_time)
}
inline void TaskScheduler_Trigger::set_start_time(const char* value, size_t size) {
  
  start_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.start_time)
}
inline ::std::string* TaskScheduler_Trigger::mutable_start_time() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.start_time)
  return start_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger::release_start_time() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.start_time)
  
  return start_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger::set_allocated_start_time(::std::string* start_time) {
  if (start_time != NULL) {
    
  } else {
    
  }
  start_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_time);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.start_time)
}

// string end_time = 4;
inline void TaskScheduler_Trigger::clear_end_time() {
  end_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger::end_time() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.end_time)
  return end_time_.GetNoArena();
}
inline void TaskScheduler_Trigger::set_end_time(const ::std::string& value) {
  
  end_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.end_time)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger::set_end_time(::std::string&& value) {
  
  end_time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.end_time)
}
#endif
inline void TaskScheduler_Trigger::set_end_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  end_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.end_time)
}
inline void TaskScheduler_Trigger::set_end_time(const char* value, size_t size) {
  
  end_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.end_time)
}
inline ::std::string* TaskScheduler_Trigger::mutable_end_time() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.end_time)
  return end_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger::release_end_time() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.end_time)
  
  return end_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger::set_allocated_end_time(::std::string* end_time) {
  if (end_time != NULL) {
    
  } else {
    
  }
  end_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end_time);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.end_time)
}

// string execution_time_limit = 5;
inline void TaskScheduler_Trigger::clear_execution_time_limit() {
  execution_time_limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Trigger::execution_time_limit() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.execution_time_limit)
  return execution_time_limit_.GetNoArena();
}
inline void TaskScheduler_Trigger::set_execution_time_limit(const ::std::string& value) {
  
  execution_time_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Trigger.execution_time_limit)
}
#if LANG_CXX11
inline void TaskScheduler_Trigger::set_execution_time_limit(::std::string&& value) {
  
  execution_time_limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Trigger.execution_time_limit)
}
#endif
inline void TaskScheduler_Trigger::set_execution_time_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  execution_time_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Trigger.execution_time_limit)
}
inline void TaskScheduler_Trigger::set_execution_time_limit(const char* value, size_t size) {
  
  execution_time_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Trigger.execution_time_limit)
}
inline ::std::string* TaskScheduler_Trigger::mutable_execution_time_limit() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.execution_time_limit)
  return execution_time_limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Trigger::release_execution_time_limit() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.execution_time_limit)
  
  return execution_time_limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Trigger::set_allocated_execution_time_limit(::std::string* execution_time_limit) {
  if (execution_time_limit != NULL) {
    
  } else {
    
  }
  execution_time_limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), execution_time_limit);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.execution_time_limit)
}

// .aspia.proto.TaskScheduler.Trigger.Repetition repetition = 6;
inline bool TaskScheduler_Trigger::has_repetition() const {
  return this != internal_default_instance() && repetition_ != NULL;
}
inline void TaskScheduler_Trigger::clear_repetition() {
  if (GetArenaNoVirtual() == NULL && repetition_ != NULL) {
    delete repetition_;
  }
  repetition_ = NULL;
}
inline const ::aspia::proto::TaskScheduler_Trigger_Repetition& TaskScheduler_Trigger::repetition() const {
  const ::aspia::proto::TaskScheduler_Trigger_Repetition* p = repetition_;
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.repetition)
  return p != NULL ? *p : *reinterpret_cast<const ::aspia::proto::TaskScheduler_Trigger_Repetition*>(
      &::aspia::proto::_TaskScheduler_Trigger_Repetition_default_instance_);
}
inline ::aspia::proto::TaskScheduler_Trigger_Repetition* TaskScheduler_Trigger::release_repetition() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.repetition)
  
  ::aspia::proto::TaskScheduler_Trigger_Repetition* temp = repetition_;
  repetition_ = NULL;
  return temp;
}
inline ::aspia::proto::TaskScheduler_Trigger_Repetition* TaskScheduler_Trigger::mutable_repetition() {
  
  if (repetition_ == NULL) {
    repetition_ = new ::aspia::proto::TaskScheduler_Trigger_Repetition;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.repetition)
  return repetition_;
}
inline void TaskScheduler_Trigger::set_allocated_repetition(::aspia::proto::TaskScheduler_Trigger_Repetition* repetition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete repetition_;
  }
  if (repetition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      repetition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, repetition, submessage_arena);
    }
    
  } else {
    
  }
  repetition_ = repetition;
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Trigger.repetition)
}

// .aspia.proto.TaskScheduler.Trigger.Event event = 7;
inline bool TaskScheduler_Trigger::has_event() const {
  return TypeUnion_case() == kEvent;
}
inline void TaskScheduler_Trigger::set_has_event() {
  _oneof_case_[0] = kEvent;
}
inline void TaskScheduler_Trigger::clear_event() {
  if (has_event()) {
    delete TypeUnion_.event_;
    clear_has_TypeUnion();
  }
}
inline ::aspia::proto::TaskScheduler_Trigger_Event* TaskScheduler_Trigger::release_event() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.event)
  if (has_event()) {
    clear_has_TypeUnion();
      ::aspia::proto::TaskScheduler_Trigger_Event* temp = TypeUnion_.event_;
    TypeUnion_.event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::aspia::proto::TaskScheduler_Trigger_Event& TaskScheduler_Trigger::event() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.event)
  return has_event()
      ? *TypeUnion_.event_
      : *reinterpret_cast< ::aspia::proto::TaskScheduler_Trigger_Event*>(&::aspia::proto::_TaskScheduler_Trigger_Event_default_instance_);
}
inline ::aspia::proto::TaskScheduler_Trigger_Event* TaskScheduler_Trigger::mutable_event() {
  if (!has_event()) {
    clear_TypeUnion();
    set_has_event();
    TypeUnion_.event_ = new ::aspia::proto::TaskScheduler_Trigger_Event;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.event)
  return TypeUnion_.event_;
}

// .aspia.proto.TaskScheduler.Trigger.Daily daily = 8;
inline bool TaskScheduler_Trigger::has_daily() const {
  return TypeUnion_case() == kDaily;
}
inline void TaskScheduler_Trigger::set_has_daily() {
  _oneof_case_[0] = kDaily;
}
inline void TaskScheduler_Trigger::clear_daily() {
  if (has_daily()) {
    delete TypeUnion_.daily_;
    clear_has_TypeUnion();
  }
}
inline ::aspia::proto::TaskScheduler_Trigger_Daily* TaskScheduler_Trigger::release_daily() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.daily)
  if (has_daily()) {
    clear_has_TypeUnion();
      ::aspia::proto::TaskScheduler_Trigger_Daily* temp = TypeUnion_.daily_;
    TypeUnion_.daily_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::aspia::proto::TaskScheduler_Trigger_Daily& TaskScheduler_Trigger::daily() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.daily)
  return has_daily()
      ? *TypeUnion_.daily_
      : *reinterpret_cast< ::aspia::proto::TaskScheduler_Trigger_Daily*>(&::aspia::proto::_TaskScheduler_Trigger_Daily_default_instance_);
}
inline ::aspia::proto::TaskScheduler_Trigger_Daily* TaskScheduler_Trigger::mutable_daily() {
  if (!has_daily()) {
    clear_TypeUnion();
    set_has_daily();
    TypeUnion_.daily_ = new ::aspia::proto::TaskScheduler_Trigger_Daily;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.daily)
  return TypeUnion_.daily_;
}

// .aspia.proto.TaskScheduler.Trigger.Weekly weekly = 9;
inline bool TaskScheduler_Trigger::has_weekly() const {
  return TypeUnion_case() == kWeekly;
}
inline void TaskScheduler_Trigger::set_has_weekly() {
  _oneof_case_[0] = kWeekly;
}
inline void TaskScheduler_Trigger::clear_weekly() {
  if (has_weekly()) {
    delete TypeUnion_.weekly_;
    clear_has_TypeUnion();
  }
}
inline ::aspia::proto::TaskScheduler_Trigger_Weekly* TaskScheduler_Trigger::release_weekly() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.weekly)
  if (has_weekly()) {
    clear_has_TypeUnion();
      ::aspia::proto::TaskScheduler_Trigger_Weekly* temp = TypeUnion_.weekly_;
    TypeUnion_.weekly_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::aspia::proto::TaskScheduler_Trigger_Weekly& TaskScheduler_Trigger::weekly() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.weekly)
  return has_weekly()
      ? *TypeUnion_.weekly_
      : *reinterpret_cast< ::aspia::proto::TaskScheduler_Trigger_Weekly*>(&::aspia::proto::_TaskScheduler_Trigger_Weekly_default_instance_);
}
inline ::aspia::proto::TaskScheduler_Trigger_Weekly* TaskScheduler_Trigger::mutable_weekly() {
  if (!has_weekly()) {
    clear_TypeUnion();
    set_has_weekly();
    TypeUnion_.weekly_ = new ::aspia::proto::TaskScheduler_Trigger_Weekly;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.weekly)
  return TypeUnion_.weekly_;
}

// .aspia.proto.TaskScheduler.Trigger.Monthly monthly = 10;
inline bool TaskScheduler_Trigger::has_monthly() const {
  return TypeUnion_case() == kMonthly;
}
inline void TaskScheduler_Trigger::set_has_monthly() {
  _oneof_case_[0] = kMonthly;
}
inline void TaskScheduler_Trigger::clear_monthly() {
  if (has_monthly()) {
    delete TypeUnion_.monthly_;
    clear_has_TypeUnion();
  }
}
inline ::aspia::proto::TaskScheduler_Trigger_Monthly* TaskScheduler_Trigger::release_monthly() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.monthly)
  if (has_monthly()) {
    clear_has_TypeUnion();
      ::aspia::proto::TaskScheduler_Trigger_Monthly* temp = TypeUnion_.monthly_;
    TypeUnion_.monthly_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::aspia::proto::TaskScheduler_Trigger_Monthly& TaskScheduler_Trigger::monthly() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.monthly)
  return has_monthly()
      ? *TypeUnion_.monthly_
      : *reinterpret_cast< ::aspia::proto::TaskScheduler_Trigger_Monthly*>(&::aspia::proto::_TaskScheduler_Trigger_Monthly_default_instance_);
}
inline ::aspia::proto::TaskScheduler_Trigger_Monthly* TaskScheduler_Trigger::mutable_monthly() {
  if (!has_monthly()) {
    clear_TypeUnion();
    set_has_monthly();
    TypeUnion_.monthly_ = new ::aspia::proto::TaskScheduler_Trigger_Monthly;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.monthly)
  return TypeUnion_.monthly_;
}

// .aspia.proto.TaskScheduler.Trigger.MonthlyDow monthly_dow = 11;
inline bool TaskScheduler_Trigger::has_monthly_dow() const {
  return TypeUnion_case() == kMonthlyDow;
}
inline void TaskScheduler_Trigger::set_has_monthly_dow() {
  _oneof_case_[0] = kMonthlyDow;
}
inline void TaskScheduler_Trigger::clear_monthly_dow() {
  if (has_monthly_dow()) {
    delete TypeUnion_.monthly_dow_;
    clear_has_TypeUnion();
  }
}
inline ::aspia::proto::TaskScheduler_Trigger_MonthlyDow* TaskScheduler_Trigger::release_monthly_dow() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.monthly_dow)
  if (has_monthly_dow()) {
    clear_has_TypeUnion();
      ::aspia::proto::TaskScheduler_Trigger_MonthlyDow* temp = TypeUnion_.monthly_dow_;
    TypeUnion_.monthly_dow_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::aspia::proto::TaskScheduler_Trigger_MonthlyDow& TaskScheduler_Trigger::monthly_dow() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.monthly_dow)
  return has_monthly_dow()
      ? *TypeUnion_.monthly_dow_
      : *reinterpret_cast< ::aspia::proto::TaskScheduler_Trigger_MonthlyDow*>(&::aspia::proto::_TaskScheduler_Trigger_MonthlyDow_default_instance_);
}
inline ::aspia::proto::TaskScheduler_Trigger_MonthlyDow* TaskScheduler_Trigger::mutable_monthly_dow() {
  if (!has_monthly_dow()) {
    clear_TypeUnion();
    set_has_monthly_dow();
    TypeUnion_.monthly_dow_ = new ::aspia::proto::TaskScheduler_Trigger_MonthlyDow;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.monthly_dow)
  return TypeUnion_.monthly_dow_;
}

// .aspia.proto.TaskScheduler.Trigger.Registration registration = 12;
inline bool TaskScheduler_Trigger::has_registration() const {
  return TypeUnion_case() == kRegistration;
}
inline void TaskScheduler_Trigger::set_has_registration() {
  _oneof_case_[0] = kRegistration;
}
inline void TaskScheduler_Trigger::clear_registration() {
  if (has_registration()) {
    delete TypeUnion_.registration_;
    clear_has_TypeUnion();
  }
}
inline ::aspia::proto::TaskScheduler_Trigger_Registration* TaskScheduler_Trigger::release_registration() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.registration)
  if (has_registration()) {
    clear_has_TypeUnion();
      ::aspia::proto::TaskScheduler_Trigger_Registration* temp = TypeUnion_.registration_;
    TypeUnion_.registration_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::aspia::proto::TaskScheduler_Trigger_Registration& TaskScheduler_Trigger::registration() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.registration)
  return has_registration()
      ? *TypeUnion_.registration_
      : *reinterpret_cast< ::aspia::proto::TaskScheduler_Trigger_Registration*>(&::aspia::proto::_TaskScheduler_Trigger_Registration_default_instance_);
}
inline ::aspia::proto::TaskScheduler_Trigger_Registration* TaskScheduler_Trigger::mutable_registration() {
  if (!has_registration()) {
    clear_TypeUnion();
    set_has_registration();
    TypeUnion_.registration_ = new ::aspia::proto::TaskScheduler_Trigger_Registration;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.registration)
  return TypeUnion_.registration_;
}

// .aspia.proto.TaskScheduler.Trigger.Boot boot = 13;
inline bool TaskScheduler_Trigger::has_boot() const {
  return TypeUnion_case() == kBoot;
}
inline void TaskScheduler_Trigger::set_has_boot() {
  _oneof_case_[0] = kBoot;
}
inline void TaskScheduler_Trigger::clear_boot() {
  if (has_boot()) {
    delete TypeUnion_.boot_;
    clear_has_TypeUnion();
  }
}
inline ::aspia::proto::TaskScheduler_Trigger_Boot* TaskScheduler_Trigger::release_boot() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.boot)
  if (has_boot()) {
    clear_has_TypeUnion();
      ::aspia::proto::TaskScheduler_Trigger_Boot* temp = TypeUnion_.boot_;
    TypeUnion_.boot_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::aspia::proto::TaskScheduler_Trigger_Boot& TaskScheduler_Trigger::boot() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.boot)
  return has_boot()
      ? *TypeUnion_.boot_
      : *reinterpret_cast< ::aspia::proto::TaskScheduler_Trigger_Boot*>(&::aspia::proto::_TaskScheduler_Trigger_Boot_default_instance_);
}
inline ::aspia::proto::TaskScheduler_Trigger_Boot* TaskScheduler_Trigger::mutable_boot() {
  if (!has_boot()) {
    clear_TypeUnion();
    set_has_boot();
    TypeUnion_.boot_ = new ::aspia::proto::TaskScheduler_Trigger_Boot;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.boot)
  return TypeUnion_.boot_;
}

// .aspia.proto.TaskScheduler.Trigger.Logon logon = 14;
inline bool TaskScheduler_Trigger::has_logon() const {
  return TypeUnion_case() == kLogon;
}
inline void TaskScheduler_Trigger::set_has_logon() {
  _oneof_case_[0] = kLogon;
}
inline void TaskScheduler_Trigger::clear_logon() {
  if (has_logon()) {
    delete TypeUnion_.logon_;
    clear_has_TypeUnion();
  }
}
inline ::aspia::proto::TaskScheduler_Trigger_Logon* TaskScheduler_Trigger::release_logon() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.logon)
  if (has_logon()) {
    clear_has_TypeUnion();
      ::aspia::proto::TaskScheduler_Trigger_Logon* temp = TypeUnion_.logon_;
    TypeUnion_.logon_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::aspia::proto::TaskScheduler_Trigger_Logon& TaskScheduler_Trigger::logon() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.logon)
  return has_logon()
      ? *TypeUnion_.logon_
      : *reinterpret_cast< ::aspia::proto::TaskScheduler_Trigger_Logon*>(&::aspia::proto::_TaskScheduler_Trigger_Logon_default_instance_);
}
inline ::aspia::proto::TaskScheduler_Trigger_Logon* TaskScheduler_Trigger::mutable_logon() {
  if (!has_logon()) {
    clear_TypeUnion();
    set_has_logon();
    TypeUnion_.logon_ = new ::aspia::proto::TaskScheduler_Trigger_Logon;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.logon)
  return TypeUnion_.logon_;
}

// .aspia.proto.TaskScheduler.Trigger.SessionStateChange session_state_change = 15;
inline bool TaskScheduler_Trigger::has_session_state_change() const {
  return TypeUnion_case() == kSessionStateChange;
}
inline void TaskScheduler_Trigger::set_has_session_state_change() {
  _oneof_case_[0] = kSessionStateChange;
}
inline void TaskScheduler_Trigger::clear_session_state_change() {
  if (has_session_state_change()) {
    delete TypeUnion_.session_state_change_;
    clear_has_TypeUnion();
  }
}
inline ::aspia::proto::TaskScheduler_Trigger_SessionStateChange* TaskScheduler_Trigger::release_session_state_change() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Trigger.session_state_change)
  if (has_session_state_change()) {
    clear_has_TypeUnion();
      ::aspia::proto::TaskScheduler_Trigger_SessionStateChange* temp = TypeUnion_.session_state_change_;
    TypeUnion_.session_state_change_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::aspia::proto::TaskScheduler_Trigger_SessionStateChange& TaskScheduler_Trigger::session_state_change() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Trigger.session_state_change)
  return has_session_state_change()
      ? *TypeUnion_.session_state_change_
      : *reinterpret_cast< ::aspia::proto::TaskScheduler_Trigger_SessionStateChange*>(&::aspia::proto::_TaskScheduler_Trigger_SessionStateChange_default_instance_);
}
inline ::aspia::proto::TaskScheduler_Trigger_SessionStateChange* TaskScheduler_Trigger::mutable_session_state_change() {
  if (!has_session_state_change()) {
    clear_TypeUnion();
    set_has_session_state_change();
    TypeUnion_.session_state_change_ = new ::aspia::proto::TaskScheduler_Trigger_SessionStateChange;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Trigger.session_state_change)
  return TypeUnion_.session_state_change_;
}

inline bool TaskScheduler_Trigger::has_TypeUnion() const {
  return TypeUnion_case() != TYPEUNION_NOT_SET;
}
inline void TaskScheduler_Trigger::clear_has_TypeUnion() {
  _oneof_case_[0] = TYPEUNION_NOT_SET;
}
inline TaskScheduler_Trigger::TypeUnionCase TaskScheduler_Trigger::TypeUnion_case() const {
  return TaskScheduler_Trigger::TypeUnionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TaskScheduler_Task

// string task_name = 1;
inline void TaskScheduler_Task::clear_task_name() {
  task_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Task::task_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Task.task_name)
  return task_name_.GetNoArena();
}
inline void TaskScheduler_Task::set_task_name(const ::std::string& value) {
  
  task_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Task.task_name)
}
#if LANG_CXX11
inline void TaskScheduler_Task::set_task_name(::std::string&& value) {
  
  task_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Task.task_name)
}
#endif
inline void TaskScheduler_Task::set_task_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  task_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Task.task_name)
}
inline void TaskScheduler_Task::set_task_name(const char* value, size_t size) {
  
  task_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Task.task_name)
}
inline ::std::string* TaskScheduler_Task::mutable_task_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Task.task_name)
  return task_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Task::release_task_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Task.task_name)
  
  return task_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Task::set_allocated_task_name(::std::string* task_name) {
  if (task_name != NULL) {
    
  } else {
    
  }
  task_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Task.task_name)
}

// .aspia.proto.TaskScheduler.Task.Status status = 2;
inline void TaskScheduler_Task::clear_status() {
  status_ = 0;
}
inline ::aspia::proto::TaskScheduler_Task_Status TaskScheduler_Task::status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Task.status)
  return static_cast< ::aspia::proto::TaskScheduler_Task_Status >(status_);
}
inline void TaskScheduler_Task::set_status(::aspia::proto::TaskScheduler_Task_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Task.status)
}

// string comment = 3;
inline void TaskScheduler_Task::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Task::comment() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Task.comment)
  return comment_.GetNoArena();
}
inline void TaskScheduler_Task::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Task.comment)
}
#if LANG_CXX11
inline void TaskScheduler_Task::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Task.comment)
}
#endif
inline void TaskScheduler_Task::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Task.comment)
}
inline void TaskScheduler_Task::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Task.comment)
}
inline ::std::string* TaskScheduler_Task::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Task.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Task::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Task.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Task::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Task.comment)
}

// string account_name = 4;
inline void TaskScheduler_Task::clear_account_name() {
  account_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Task::account_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Task.account_name)
  return account_name_.GetNoArena();
}
inline void TaskScheduler_Task::set_account_name(const ::std::string& value) {
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Task.account_name)
}
#if LANG_CXX11
inline void TaskScheduler_Task::set_account_name(::std::string&& value) {
  
  account_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Task.account_name)
}
#endif
inline void TaskScheduler_Task::set_account_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Task.account_name)
}
inline void TaskScheduler_Task::set_account_name(const char* value, size_t size) {
  
  account_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Task.account_name)
}
inline ::std::string* TaskScheduler_Task::mutable_account_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Task.account_name)
  return account_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Task::release_account_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Task.account_name)
  
  return account_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Task::set_allocated_account_name(::std::string* account_name) {
  if (account_name != NULL) {
    
  } else {
    
  }
  account_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Task.account_name)
}

// string creator = 5;
inline void TaskScheduler_Task::clear_creator() {
  creator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskScheduler_Task::creator() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Task.creator)
  return creator_.GetNoArena();
}
inline void TaskScheduler_Task::set_creator(const ::std::string& value) {
  
  creator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Task.creator)
}
#if LANG_CXX11
inline void TaskScheduler_Task::set_creator(::std::string&& value) {
  
  creator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.TaskScheduler.Task.creator)
}
#endif
inline void TaskScheduler_Task::set_creator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  creator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.TaskScheduler.Task.creator)
}
inline void TaskScheduler_Task::set_creator(const char* value, size_t size) {
  
  creator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.TaskScheduler.Task.creator)
}
inline ::std::string* TaskScheduler_Task::mutable_creator() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Task.creator)
  return creator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskScheduler_Task::release_creator() {
  // @@protoc_insertion_point(field_release:aspia.proto.TaskScheduler.Task.creator)
  
  return creator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskScheduler_Task::set_allocated_creator(::std::string* creator) {
  if (creator != NULL) {
    
  } else {
    
  }
  creator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), creator);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.TaskScheduler.Task.creator)
}

// int64 last_run = 6;
inline void TaskScheduler_Task::clear_last_run() {
  last_run_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskScheduler_Task::last_run() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Task.last_run)
  return last_run_;
}
inline void TaskScheduler_Task::set_last_run(::google::protobuf::int64 value) {
  
  last_run_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Task.last_run)
}

// int64 next_run = 7;
inline void TaskScheduler_Task::clear_next_run() {
  next_run_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskScheduler_Task::next_run() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Task.next_run)
  return next_run_;
}
inline void TaskScheduler_Task::set_next_run(::google::protobuf::int64 value) {
  
  next_run_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Task.next_run)
}

// uint32 number_of_missed_runs = 8;
inline void TaskScheduler_Task::clear_number_of_missed_runs() {
  number_of_missed_runs_ = 0u;
}
inline ::google::protobuf::uint32 TaskScheduler_Task::number_of_missed_runs() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Task.number_of_missed_runs)
  return number_of_missed_runs_;
}
inline void TaskScheduler_Task::set_number_of_missed_runs(::google::protobuf::uint32 value) {
  
  number_of_missed_runs_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Task.number_of_missed_runs)
}

// uint32 last_task_result = 9;
inline void TaskScheduler_Task::clear_last_task_result() {
  last_task_result_ = 0u;
}
inline ::google::protobuf::uint32 TaskScheduler_Task::last_task_result() const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Task.last_task_result)
  return last_task_result_;
}
inline void TaskScheduler_Task::set_last_task_result(::google::protobuf::uint32 value) {
  
  last_task_result_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.TaskScheduler.Task.last_task_result)
}

// repeated .aspia.proto.TaskScheduler.Action action = 10;
inline int TaskScheduler_Task::action_size() const {
  return action_.size();
}
inline void TaskScheduler_Task::clear_action() {
  action_.Clear();
}
inline const ::aspia::proto::TaskScheduler_Action& TaskScheduler_Task::action(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Task.action)
  return action_.Get(index);
}
inline ::aspia::proto::TaskScheduler_Action* TaskScheduler_Task::mutable_action(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Task.action)
  return action_.Mutable(index);
}
inline ::aspia::proto::TaskScheduler_Action* TaskScheduler_Task::add_action() {
  // @@protoc_insertion_point(field_add:aspia.proto.TaskScheduler.Task.action)
  return action_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Action >*
TaskScheduler_Task::mutable_action() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.TaskScheduler.Task.action)
  return &action_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Action >&
TaskScheduler_Task::action() const {
  // @@protoc_insertion_point(field_list:aspia.proto.TaskScheduler.Task.action)
  return action_;
}

// repeated .aspia.proto.TaskScheduler.Trigger trigger = 11;
inline int TaskScheduler_Task::trigger_size() const {
  return trigger_.size();
}
inline void TaskScheduler_Task::clear_trigger() {
  trigger_.Clear();
}
inline const ::aspia::proto::TaskScheduler_Trigger& TaskScheduler_Task::trigger(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.Task.trigger)
  return trigger_.Get(index);
}
inline ::aspia::proto::TaskScheduler_Trigger* TaskScheduler_Task::mutable_trigger(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.Task.trigger)
  return trigger_.Mutable(index);
}
inline ::aspia::proto::TaskScheduler_Trigger* TaskScheduler_Task::add_trigger() {
  // @@protoc_insertion_point(field_add:aspia.proto.TaskScheduler.Task.trigger)
  return trigger_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Trigger >*
TaskScheduler_Task::mutable_trigger() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.TaskScheduler.Task.trigger)
  return &trigger_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Trigger >&
TaskScheduler_Task::trigger() const {
  // @@protoc_insertion_point(field_list:aspia.proto.TaskScheduler.Task.trigger)
  return trigger_;
}

// -------------------------------------------------------------------

// TaskScheduler

// repeated .aspia.proto.TaskScheduler.Task task = 1;
inline int TaskScheduler::task_size() const {
  return task_.size();
}
inline void TaskScheduler::clear_task() {
  task_.Clear();
}
inline const ::aspia::proto::TaskScheduler_Task& TaskScheduler::task(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.TaskScheduler.task)
  return task_.Get(index);
}
inline ::aspia::proto::TaskScheduler_Task* TaskScheduler::mutable_task(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.TaskScheduler.task)
  return task_.Mutable(index);
}
inline ::aspia::proto::TaskScheduler_Task* TaskScheduler::add_task() {
  // @@protoc_insertion_point(field_add:aspia.proto.TaskScheduler.task)
  return task_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Task >*
TaskScheduler::mutable_task() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.TaskScheduler.task)
  return &task_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::TaskScheduler_Task >&
TaskScheduler::task() const {
  // @@protoc_insertion_point(field_list:aspia.proto.TaskScheduler.task)
  return task_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace aspia

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aspia::proto::TaskScheduler_Trigger_SessionStateChange_ChangeType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::TaskScheduler_Trigger_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::TaskScheduler_Trigger_DayOfWeek> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::TaskScheduler_Trigger_DayOfMonth> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::TaskScheduler_Trigger_Month> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::TaskScheduler_Trigger_WeekOfMonth> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::TaskScheduler_Task_Status> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_category_5ftask_5fscheduler_2eproto__INCLUDED

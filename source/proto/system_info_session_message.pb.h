// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system_info_session_message.proto

#ifndef PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED
#define PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace protobuf_system_5finfo_5fsession_5fmessage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[27];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsDmiPortConnectors_ItemImpl();
void InitDefaultsDmiPortConnectors_Item();
void InitDefaultsDmiPortConnectorsImpl();
void InitDefaultsDmiPortConnectors();
void InitDefaultsDmiOnBoardDevices_ItemImpl();
void InitDefaultsDmiOnBoardDevices_Item();
void InitDefaultsDmiOnBoardDevicesImpl();
void InitDefaultsDmiOnBoardDevices();
void InitDefaultsDmiPointingDevices_ItemImpl();
void InitDefaultsDmiPointingDevices_Item();
void InitDefaultsDmiPointingDevicesImpl();
void InitDefaultsDmiPointingDevices();
void InitDefaultsDmiPortableBattery_ItemImpl();
void InitDefaultsDmiPortableBattery_Item();
void InitDefaultsDmiPortableBatteryImpl();
void InitDefaultsDmiPortableBattery();
void InitDefaultsPrograms_ItemImpl();
void InitDefaultsPrograms_Item();
void InitDefaultsProgramsImpl();
void InitDefaultsPrograms();
void InitDefaultsServices_ItemImpl();
void InitDefaultsServices_Item();
void InitDefaultsServicesImpl();
void InitDefaultsServices();
void InitDefaultsNetworkCards_Item_IpAddressImpl();
void InitDefaultsNetworkCards_Item_IpAddress();
void InitDefaultsNetworkCards_ItemImpl();
void InitDefaultsNetworkCards_Item();
void InitDefaultsNetworkCardsImpl();
void InitDefaultsNetworkCards();
void InitDefaultsOpenConnections_ItemImpl();
void InitDefaultsOpenConnections_Item();
void InitDefaultsOpenConnectionsImpl();
void InitDefaultsOpenConnections();
void InitDefaultsSharedResources_ItemImpl();
void InitDefaultsSharedResources_Item();
void InitDefaultsSharedResourcesImpl();
void InitDefaultsSharedResources();
void InitDefaultsRoutes_ItemImpl();
void InitDefaultsRoutes_Item();
void InitDefaultsRoutesImpl();
void InitDefaultsRoutes();
void InitDefaultsUsers_ItemImpl();
void InitDefaultsUsers_Item();
void InitDefaultsUsersImpl();
void InitDefaultsUsers();
void InitDefaultsUserGroups_ItemImpl();
void InitDefaultsUserGroups_Item();
void InitDefaultsUserGroupsImpl();
void InitDefaultsUserGroups();
void InitDefaultsSessions_ItemImpl();
void InitDefaultsSessions_Item();
void InitDefaultsSessionsImpl();
void InitDefaultsSessions();
inline void InitDefaults() {
  InitDefaultsDmiPortConnectors_Item();
  InitDefaultsDmiPortConnectors();
  InitDefaultsDmiOnBoardDevices_Item();
  InitDefaultsDmiOnBoardDevices();
  InitDefaultsDmiPointingDevices_Item();
  InitDefaultsDmiPointingDevices();
  InitDefaultsDmiPortableBattery_Item();
  InitDefaultsDmiPortableBattery();
  InitDefaultsPrograms_Item();
  InitDefaultsPrograms();
  InitDefaultsServices_Item();
  InitDefaultsServices();
  InitDefaultsNetworkCards_Item_IpAddress();
  InitDefaultsNetworkCards_Item();
  InitDefaultsNetworkCards();
  InitDefaultsOpenConnections_Item();
  InitDefaultsOpenConnections();
  InitDefaultsSharedResources_Item();
  InitDefaultsSharedResources();
  InitDefaultsRoutes_Item();
  InitDefaultsRoutes();
  InitDefaultsUsers_Item();
  InitDefaultsUsers();
  InitDefaultsUserGroups_Item();
  InitDefaultsUserGroups();
  InitDefaultsSessions_Item();
  InitDefaultsSessions();
}
}  // namespace protobuf_system_5finfo_5fsession_5fmessage_2eproto
namespace aspia {
namespace proto {
class DmiOnBoardDevices;
class DmiOnBoardDevicesDefaultTypeInternal;
extern DmiOnBoardDevicesDefaultTypeInternal _DmiOnBoardDevices_default_instance_;
class DmiOnBoardDevices_Item;
class DmiOnBoardDevices_ItemDefaultTypeInternal;
extern DmiOnBoardDevices_ItemDefaultTypeInternal _DmiOnBoardDevices_Item_default_instance_;
class DmiPointingDevices;
class DmiPointingDevicesDefaultTypeInternal;
extern DmiPointingDevicesDefaultTypeInternal _DmiPointingDevices_default_instance_;
class DmiPointingDevices_Item;
class DmiPointingDevices_ItemDefaultTypeInternal;
extern DmiPointingDevices_ItemDefaultTypeInternal _DmiPointingDevices_Item_default_instance_;
class DmiPortConnectors;
class DmiPortConnectorsDefaultTypeInternal;
extern DmiPortConnectorsDefaultTypeInternal _DmiPortConnectors_default_instance_;
class DmiPortConnectors_Item;
class DmiPortConnectors_ItemDefaultTypeInternal;
extern DmiPortConnectors_ItemDefaultTypeInternal _DmiPortConnectors_Item_default_instance_;
class DmiPortableBattery;
class DmiPortableBatteryDefaultTypeInternal;
extern DmiPortableBatteryDefaultTypeInternal _DmiPortableBattery_default_instance_;
class DmiPortableBattery_Item;
class DmiPortableBattery_ItemDefaultTypeInternal;
extern DmiPortableBattery_ItemDefaultTypeInternal _DmiPortableBattery_Item_default_instance_;
class NetworkCards;
class NetworkCardsDefaultTypeInternal;
extern NetworkCardsDefaultTypeInternal _NetworkCards_default_instance_;
class NetworkCards_Item;
class NetworkCards_ItemDefaultTypeInternal;
extern NetworkCards_ItemDefaultTypeInternal _NetworkCards_Item_default_instance_;
class NetworkCards_Item_IpAddress;
class NetworkCards_Item_IpAddressDefaultTypeInternal;
extern NetworkCards_Item_IpAddressDefaultTypeInternal _NetworkCards_Item_IpAddress_default_instance_;
class OpenConnections;
class OpenConnectionsDefaultTypeInternal;
extern OpenConnectionsDefaultTypeInternal _OpenConnections_default_instance_;
class OpenConnections_Item;
class OpenConnections_ItemDefaultTypeInternal;
extern OpenConnections_ItemDefaultTypeInternal _OpenConnections_Item_default_instance_;
class Programs;
class ProgramsDefaultTypeInternal;
extern ProgramsDefaultTypeInternal _Programs_default_instance_;
class Programs_Item;
class Programs_ItemDefaultTypeInternal;
extern Programs_ItemDefaultTypeInternal _Programs_Item_default_instance_;
class Routes;
class RoutesDefaultTypeInternal;
extern RoutesDefaultTypeInternal _Routes_default_instance_;
class Routes_Item;
class Routes_ItemDefaultTypeInternal;
extern Routes_ItemDefaultTypeInternal _Routes_Item_default_instance_;
class Services;
class ServicesDefaultTypeInternal;
extern ServicesDefaultTypeInternal _Services_default_instance_;
class Services_Item;
class Services_ItemDefaultTypeInternal;
extern Services_ItemDefaultTypeInternal _Services_Item_default_instance_;
class Sessions;
class SessionsDefaultTypeInternal;
extern SessionsDefaultTypeInternal _Sessions_default_instance_;
class Sessions_Item;
class Sessions_ItemDefaultTypeInternal;
extern Sessions_ItemDefaultTypeInternal _Sessions_Item_default_instance_;
class SharedResources;
class SharedResourcesDefaultTypeInternal;
extern SharedResourcesDefaultTypeInternal _SharedResources_default_instance_;
class SharedResources_Item;
class SharedResources_ItemDefaultTypeInternal;
extern SharedResources_ItemDefaultTypeInternal _SharedResources_Item_default_instance_;
class UserGroups;
class UserGroupsDefaultTypeInternal;
extern UserGroupsDefaultTypeInternal _UserGroups_default_instance_;
class UserGroups_Item;
class UserGroups_ItemDefaultTypeInternal;
extern UserGroups_ItemDefaultTypeInternal _UserGroups_Item_default_instance_;
class Users;
class UsersDefaultTypeInternal;
extern UsersDefaultTypeInternal _Users_default_instance_;
class Users_Item;
class Users_ItemDefaultTypeInternal;
extern Users_ItemDefaultTypeInternal _Users_Item_default_instance_;
}  // namespace proto
}  // namespace aspia
namespace aspia {
namespace proto {

enum DmiPortConnectors_Type {
  DmiPortConnectors_Type_TYPE_UNKNOWN = 0,
  DmiPortConnectors_Type_TYPE_NONE = 1,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_XT_AT_COMPATIBLE = 2,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_PS_2 = 3,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_ECP = 4,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_EPP = 5,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_ECP_EPP = 6,
  DmiPortConnectors_Type_TYPE_SERIAL_PORT_XT_AT_COMPATIBLE = 7,
  DmiPortConnectors_Type_TYPE_SERIAL_PORT_16450_COMPATIBLE = 8,
  DmiPortConnectors_Type_TYPE_SERIAL_PORT_16550_COMPATIBLE = 9,
  DmiPortConnectors_Type_TYPE_SERIAL_PORT_16550A_COMPATIBLE = 10,
  DmiPortConnectors_Type_TYPE_SCSI_PORT = 11,
  DmiPortConnectors_Type_TYPE_MIDI_PORT = 12,
  DmiPortConnectors_Type_TYPE_JOYSTICK_PORT = 13,
  DmiPortConnectors_Type_TYPE_KEYBOARD_PORT = 14,
  DmiPortConnectors_Type_TYPE_MOUSE_PORT = 15,
  DmiPortConnectors_Type_TYPE_SSA_SCSI = 16,
  DmiPortConnectors_Type_TYPE_USB = 17,
  DmiPortConnectors_Type_TYPE_FIREWIRE = 18,
  DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_I = 19,
  DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_II = 20,
  DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_III = 21,
  DmiPortConnectors_Type_TYPE_CARDBUS = 22,
  DmiPortConnectors_Type_TYPE_ACCESS_BUS_PORT = 23,
  DmiPortConnectors_Type_TYPE_SCSI_II = 24,
  DmiPortConnectors_Type_TYPE_SCSI_WIDE = 25,
  DmiPortConnectors_Type_TYPE_PC_98 = 26,
  DmiPortConnectors_Type_TYPE_PC_98_HIRESO = 27,
  DmiPortConnectors_Type_TYPE_PC_H98 = 28,
  DmiPortConnectors_Type_TYPE_VIDEO_PORT = 29,
  DmiPortConnectors_Type_TYPE_AUDIO_PORT = 30,
  DmiPortConnectors_Type_TYPE_MODEM_PORT = 31,
  DmiPortConnectors_Type_TYPE_NETWORK_PORT = 32,
  DmiPortConnectors_Type_TYPE_SATA = 33,
  DmiPortConnectors_Type_TYPE_SAS = 34,
  DmiPortConnectors_Type_TYPE_8251_COMPATIBLE = 35,
  DmiPortConnectors_Type_TYPE_8251_FIFO_COMPATIBLE = 36,
  DmiPortConnectors_Type_DmiPortConnectors_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPortConnectors_Type_DmiPortConnectors_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPortConnectors_Type_IsValid(int value);
const DmiPortConnectors_Type DmiPortConnectors_Type_Type_MIN = DmiPortConnectors_Type_TYPE_UNKNOWN;
const DmiPortConnectors_Type DmiPortConnectors_Type_Type_MAX = DmiPortConnectors_Type_TYPE_8251_FIFO_COMPATIBLE;
const int DmiPortConnectors_Type_Type_ARRAYSIZE = DmiPortConnectors_Type_Type_MAX + 1;

enum DmiPortConnectors_ConnectorType {
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_UNKNOWN = 0,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_NONE = 1,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_OTHER = 2,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CENTRONICS = 3,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS = 4,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PROPRIETARY = 5,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_25_MALE = 6,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_25_FEMALE = 7,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_15_MALE = 8,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_15_FEMALE = 9,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_9_MALE = 10,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_9_FEMALE = 11,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_RJ_11 = 12,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_RJ_45 = 13,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_50_PIN_MINISCSI = 14,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_DIN = 15,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MICRO_DIN = 16,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PS_2 = 17,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_INFRARED = 18,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_HP_HIL = 19,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ACCESS_BUS_USB = 20,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_SSA_SCSI = 21,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_MALE = 22,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_FEMALE = 23,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_IDE = 24,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_FLOPPY = 25,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_9_PIN_DUAL_INLINE = 26,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_25_PIN_DUAL_INLINE = 27,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_50_PIN_DUAL_INLINE = 28,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_68_PIN_DUAL_INLINE = 29,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_SOUND_INPUT_FROM_CDROM = 30,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_14 = 31,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_26 = 32,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_JACK = 33,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_BNC = 34,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_IEEE_1394 = 35,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_SAS_SATE_PLUG_RECEPTACLE = 36,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98 = 37,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_HIRESO = 38,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_H98 = 39,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_NOTE = 40,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_FULL = 41,
  DmiPortConnectors_ConnectorType_DmiPortConnectors_ConnectorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPortConnectors_ConnectorType_DmiPortConnectors_ConnectorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPortConnectors_ConnectorType_IsValid(int value);
const DmiPortConnectors_ConnectorType DmiPortConnectors_ConnectorType_ConnectorType_MIN = DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_UNKNOWN;
const DmiPortConnectors_ConnectorType DmiPortConnectors_ConnectorType_ConnectorType_MAX = DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_FULL;
const int DmiPortConnectors_ConnectorType_ConnectorType_ARRAYSIZE = DmiPortConnectors_ConnectorType_ConnectorType_MAX + 1;

enum DmiOnBoardDevices_Type {
  DmiOnBoardDevices_Type_TYPE_UNKNOWN = 0,
  DmiOnBoardDevices_Type_TYPE_OTHER = 1,
  DmiOnBoardDevices_Type_TYPE_VIDEO = 2,
  DmiOnBoardDevices_Type_TYPE_SCSI_CONTROLLER = 3,
  DmiOnBoardDevices_Type_TYPE_ETHERNET = 4,
  DmiOnBoardDevices_Type_TYPE_TOKEN_RING = 5,
  DmiOnBoardDevices_Type_TYPE_SOUND = 6,
  DmiOnBoardDevices_Type_TYPE_PATA_CONTROLLER = 7,
  DmiOnBoardDevices_Type_TYPE_SATA_CONTROLLER = 8,
  DmiOnBoardDevices_Type_TYPE_SAS_CONTROLLER = 9,
  DmiOnBoardDevices_Type_DmiOnBoardDevices_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiOnBoardDevices_Type_DmiOnBoardDevices_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiOnBoardDevices_Type_IsValid(int value);
const DmiOnBoardDevices_Type DmiOnBoardDevices_Type_Type_MIN = DmiOnBoardDevices_Type_TYPE_UNKNOWN;
const DmiOnBoardDevices_Type DmiOnBoardDevices_Type_Type_MAX = DmiOnBoardDevices_Type_TYPE_SAS_CONTROLLER;
const int DmiOnBoardDevices_Type_Type_ARRAYSIZE = DmiOnBoardDevices_Type_Type_MAX + 1;

enum DmiPointingDevices_Type {
  DmiPointingDevices_Type_TYPE_UNKNOWN = 0,
  DmiPointingDevices_Type_TYPE_OTHER = 1,
  DmiPointingDevices_Type_TYPE_MOUSE = 2,
  DmiPointingDevices_Type_TYPE_TRACK_BALL = 3,
  DmiPointingDevices_Type_TYPE_TRACK_POINT = 4,
  DmiPointingDevices_Type_TYPE_GLIDE_POINT = 5,
  DmiPointingDevices_Type_TYPE_TOUCH_PAD = 6,
  DmiPointingDevices_Type_TYPE_TOUCH_SCREEN = 7,
  DmiPointingDevices_Type_TYPE_OPTICAL_SENSOR = 8,
  DmiPointingDevices_Type_DmiPointingDevices_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPointingDevices_Type_DmiPointingDevices_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPointingDevices_Type_IsValid(int value);
const DmiPointingDevices_Type DmiPointingDevices_Type_Type_MIN = DmiPointingDevices_Type_TYPE_UNKNOWN;
const DmiPointingDevices_Type DmiPointingDevices_Type_Type_MAX = DmiPointingDevices_Type_TYPE_OPTICAL_SENSOR;
const int DmiPointingDevices_Type_Type_ARRAYSIZE = DmiPointingDevices_Type_Type_MAX + 1;

enum DmiPointingDevices_Interface {
  DmiPointingDevices_Interface_INTERFACE_UNKNOWN = 0,
  DmiPointingDevices_Interface_INTERFACE_OTHER = 1,
  DmiPointingDevices_Interface_INTERFACE_SERIAL = 2,
  DmiPointingDevices_Interface_INTERFACE_PS_2 = 3,
  DmiPointingDevices_Interface_INTERFACE_INFRARED = 4,
  DmiPointingDevices_Interface_INTERFACE_HP_HIL = 5,
  DmiPointingDevices_Interface_INTERFACE_BUS_MOUSE = 6,
  DmiPointingDevices_Interface_INTERFACE_ADB = 7,
  DmiPointingDevices_Interface_INTERFACE_BUS_MOUSE_DB_9 = 8,
  DmiPointingDevices_Interface_INTERFACE_BUS_MOUSE_MICRO_DIN = 9,
  DmiPointingDevices_Interface_INTERFACE_USB = 10,
  DmiPointingDevices_Interface_DmiPointingDevices_Interface_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPointingDevices_Interface_DmiPointingDevices_Interface_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPointingDevices_Interface_IsValid(int value);
const DmiPointingDevices_Interface DmiPointingDevices_Interface_Interface_MIN = DmiPointingDevices_Interface_INTERFACE_UNKNOWN;
const DmiPointingDevices_Interface DmiPointingDevices_Interface_Interface_MAX = DmiPointingDevices_Interface_INTERFACE_USB;
const int DmiPointingDevices_Interface_Interface_ARRAYSIZE = DmiPointingDevices_Interface_Interface_MAX + 1;

enum DmiPortableBattery_Chemistry {
  DmiPortableBattery_Chemistry_CHEMISTRY_UNKNOWN = 0,
  DmiPortableBattery_Chemistry_CHEMISTRY_OTHER = 1,
  DmiPortableBattery_Chemistry_CHEMISTRY_LEAD_ACID = 2,
  DmiPortableBattery_Chemistry_CHEMISTRY_NICKEL_CADMIUM = 3,
  DmiPortableBattery_Chemistry_CHEMISTRY_NICKEL_METAL_HYDRIDE = 4,
  DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_ION = 5,
  DmiPortableBattery_Chemistry_CHEMISTRY_ZINC_AIR = 6,
  DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_POLYMER = 7,
  DmiPortableBattery_Chemistry_DmiPortableBattery_Chemistry_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPortableBattery_Chemistry_DmiPortableBattery_Chemistry_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPortableBattery_Chemistry_IsValid(int value);
const DmiPortableBattery_Chemistry DmiPortableBattery_Chemistry_Chemistry_MIN = DmiPortableBattery_Chemistry_CHEMISTRY_UNKNOWN;
const DmiPortableBattery_Chemistry DmiPortableBattery_Chemistry_Chemistry_MAX = DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_POLYMER;
const int DmiPortableBattery_Chemistry_Chemistry_ARRAYSIZE = DmiPortableBattery_Chemistry_Chemistry_MAX + 1;

enum Services_Item_Status {
  Services_Item_Status_STATUS_UNKNOWN = 0,
  Services_Item_Status_STATUS_CONTINUE_PENDING = 1,
  Services_Item_Status_STATUS_PAUSE_PENDING = 2,
  Services_Item_Status_STATUS_PAUSED = 3,
  Services_Item_Status_STATUS_RUNNING = 4,
  Services_Item_Status_STATUS_START_PENDING = 5,
  Services_Item_Status_STATUS_STOP_PENDING = 6,
  Services_Item_Status_STATUS_STOPPED = 7,
  Services_Item_Status_Services_Item_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Services_Item_Status_Services_Item_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Services_Item_Status_IsValid(int value);
const Services_Item_Status Services_Item_Status_Status_MIN = Services_Item_Status_STATUS_UNKNOWN;
const Services_Item_Status Services_Item_Status_Status_MAX = Services_Item_Status_STATUS_STOPPED;
const int Services_Item_Status_Status_ARRAYSIZE = Services_Item_Status_Status_MAX + 1;

enum Services_Item_StartupType {
  Services_Item_StartupType_STARTUP_TYPE_UNKNOWN = 0,
  Services_Item_StartupType_STARTUP_TYPE_AUTO_START = 1,
  Services_Item_StartupType_STARTUP_TYPE_DEMAND_START = 2,
  Services_Item_StartupType_STARTUP_TYPE_DISABLED = 3,
  Services_Item_StartupType_STARTUP_TYPE_BOOT_START = 4,
  Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START = 5,
  Services_Item_StartupType_Services_Item_StartupType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Services_Item_StartupType_Services_Item_StartupType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Services_Item_StartupType_IsValid(int value);
const Services_Item_StartupType Services_Item_StartupType_StartupType_MIN = Services_Item_StartupType_STARTUP_TYPE_UNKNOWN;
const Services_Item_StartupType Services_Item_StartupType_StartupType_MAX = Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START;
const int Services_Item_StartupType_StartupType_ARRAYSIZE = Services_Item_StartupType_StartupType_MAX + 1;

enum OpenConnections_Protocol {
  OpenConnections_Protocol_PROTOCOL_UNKNOWN = 0,
  OpenConnections_Protocol_PROTOCOL_TCP = 1,
  OpenConnections_Protocol_PROTOCOL_UDP = 2,
  OpenConnections_Protocol_OpenConnections_Protocol_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OpenConnections_Protocol_OpenConnections_Protocol_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OpenConnections_Protocol_IsValid(int value);
const OpenConnections_Protocol OpenConnections_Protocol_Protocol_MIN = OpenConnections_Protocol_PROTOCOL_UNKNOWN;
const OpenConnections_Protocol OpenConnections_Protocol_Protocol_MAX = OpenConnections_Protocol_PROTOCOL_UDP;
const int OpenConnections_Protocol_Protocol_ARRAYSIZE = OpenConnections_Protocol_Protocol_MAX + 1;

enum OpenConnections_State {
  OpenConnections_State_STATE_UNKNOWN = 0,
  OpenConnections_State_STATE_CLOSED = 1,
  OpenConnections_State_STATE_LISTENING = 2,
  OpenConnections_State_STATE_SYN_SENT = 3,
  OpenConnections_State_STATE_SYN_RCVD = 4,
  OpenConnections_State_STATE_ESTABLISHED = 5,
  OpenConnections_State_STATE_FIN_WAIT1 = 6,
  OpenConnections_State_STATE_FIN_WAIT2 = 7,
  OpenConnections_State_STATE_CLOSE_WAIT = 8,
  OpenConnections_State_STATE_CLOSING = 9,
  OpenConnections_State_STATE_LAST_ACK = 10,
  OpenConnections_State_STATE_TIME_WAIT = 11,
  OpenConnections_State_STATE_DELETE_TCB = 12,
  OpenConnections_State_OpenConnections_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OpenConnections_State_OpenConnections_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OpenConnections_State_IsValid(int value);
const OpenConnections_State OpenConnections_State_State_MIN = OpenConnections_State_STATE_UNKNOWN;
const OpenConnections_State OpenConnections_State_State_MAX = OpenConnections_State_STATE_DELETE_TCB;
const int OpenConnections_State_State_ARRAYSIZE = OpenConnections_State_State_MAX + 1;

enum SharedResources_Item_Type {
  SharedResources_Item_Type_TYPE_UNKNOWN = 0,
  SharedResources_Item_Type_TYPE_DISK = 1,
  SharedResources_Item_Type_TYPE_PRINTER = 2,
  SharedResources_Item_Type_TYPE_DEVICE = 3,
  SharedResources_Item_Type_TYPE_IPC = 4,
  SharedResources_Item_Type_TYPE_SPECIAL = 5,
  SharedResources_Item_Type_TYPE_TEMPORARY = 6,
  SharedResources_Item_Type_SharedResources_Item_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SharedResources_Item_Type_SharedResources_Item_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SharedResources_Item_Type_IsValid(int value);
const SharedResources_Item_Type SharedResources_Item_Type_Type_MIN = SharedResources_Item_Type_TYPE_UNKNOWN;
const SharedResources_Item_Type SharedResources_Item_Type_Type_MAX = SharedResources_Item_Type_TYPE_TEMPORARY;
const int SharedResources_Item_Type_Type_ARRAYSIZE = SharedResources_Item_Type_Type_MAX + 1;

enum Sessions_ConnectState {
  Sessions_ConnectState_CONNECT_STATE_UNKNOWN = 0,
  Sessions_ConnectState_CONNECT_STATE_ACTIVE = 1,
  Sessions_ConnectState_CONNECT_STATE_CONNECTED = 2,
  Sessions_ConnectState_CONNECT_STATE_CONNECT_QUERY = 3,
  Sessions_ConnectState_CONNECT_STATE_SHADOW = 4,
  Sessions_ConnectState_CONNECT_STATE_DISCONNECTED = 5,
  Sessions_ConnectState_CONNECT_STATE_IDLE = 6,
  Sessions_ConnectState_CONNECT_STATE_LISTEN = 7,
  Sessions_ConnectState_CONNECT_STATE_RESET = 8,
  Sessions_ConnectState_CONNECT_STATE_DOWN = 9,
  Sessions_ConnectState_CONNECT_STATE_INIT = 10,
  Sessions_ConnectState_Sessions_ConnectState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Sessions_ConnectState_Sessions_ConnectState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Sessions_ConnectState_IsValid(int value);
const Sessions_ConnectState Sessions_ConnectState_ConnectState_MIN = Sessions_ConnectState_CONNECT_STATE_UNKNOWN;
const Sessions_ConnectState Sessions_ConnectState_ConnectState_MAX = Sessions_ConnectState_CONNECT_STATE_INIT;
const int Sessions_ConnectState_ConnectState_ARRAYSIZE = Sessions_ConnectState_ConnectState_MAX + 1;

// ===================================================================

class DmiPortConnectors_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortConnectors.Item) */ {
 public:
  DmiPortConnectors_Item();
  virtual ~DmiPortConnectors_Item();

  DmiPortConnectors_Item(const DmiPortConnectors_Item& from);

  inline DmiPortConnectors_Item& operator=(const DmiPortConnectors_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortConnectors_Item(DmiPortConnectors_Item&& from) noexcept
    : DmiPortConnectors_Item() {
    *this = ::std::move(from);
  }

  inline DmiPortConnectors_Item& operator=(DmiPortConnectors_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortConnectors_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortConnectors_Item* internal_default_instance() {
    return reinterpret_cast<const DmiPortConnectors_Item*>(
               &_DmiPortConnectors_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DmiPortConnectors_Item* other);
  friend void swap(DmiPortConnectors_Item& a, DmiPortConnectors_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortConnectors_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortConnectors_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortConnectors_Item& from);
  void MergeFrom(const DmiPortConnectors_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortConnectors_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string internal_designation = 1;
  void clear_internal_designation();
  static const int kInternalDesignationFieldNumber = 1;
  const ::std::string& internal_designation() const;
  void set_internal_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_internal_designation(::std::string&& value);
  #endif
  void set_internal_designation(const char* value);
  void set_internal_designation(const char* value, size_t size);
  ::std::string* mutable_internal_designation();
  ::std::string* release_internal_designation();
  void set_allocated_internal_designation(::std::string* internal_designation);

  // string external_designation = 2;
  void clear_external_designation();
  static const int kExternalDesignationFieldNumber = 2;
  const ::std::string& external_designation() const;
  void set_external_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_external_designation(::std::string&& value);
  #endif
  void set_external_designation(const char* value);
  void set_external_designation(const char* value, size_t size);
  ::std::string* mutable_external_designation();
  ::std::string* release_external_designation();
  void set_allocated_external_designation(::std::string* external_designation);

  // .aspia.proto.DmiPortConnectors.Type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::aspia::proto::DmiPortConnectors_Type type() const;
  void set_type(::aspia::proto::DmiPortConnectors_Type value);

  // .aspia.proto.DmiPortConnectors.ConnectorType internal_connector_type = 4;
  void clear_internal_connector_type();
  static const int kInternalConnectorTypeFieldNumber = 4;
  ::aspia::proto::DmiPortConnectors_ConnectorType internal_connector_type() const;
  void set_internal_connector_type(::aspia::proto::DmiPortConnectors_ConnectorType value);

  // .aspia.proto.DmiPortConnectors.ConnectorType external_connector_type = 5;
  void clear_external_connector_type();
  static const int kExternalConnectorTypeFieldNumber = 5;
  ::aspia::proto::DmiPortConnectors_ConnectorType external_connector_type() const;
  void set_external_connector_type(::aspia::proto::DmiPortConnectors_ConnectorType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortConnectors.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr internal_designation_;
  ::google::protobuf::internal::ArenaStringPtr external_designation_;
  int type_;
  int internal_connector_type_;
  int external_connector_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortConnectors_ItemImpl();
};
// -------------------------------------------------------------------

class DmiPortConnectors : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortConnectors) */ {
 public:
  DmiPortConnectors();
  virtual ~DmiPortConnectors();

  DmiPortConnectors(const DmiPortConnectors& from);

  inline DmiPortConnectors& operator=(const DmiPortConnectors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortConnectors(DmiPortConnectors&& from) noexcept
    : DmiPortConnectors() {
    *this = ::std::move(from);
  }

  inline DmiPortConnectors& operator=(DmiPortConnectors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortConnectors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortConnectors* internal_default_instance() {
    return reinterpret_cast<const DmiPortConnectors*>(
               &_DmiPortConnectors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DmiPortConnectors* other);
  friend void swap(DmiPortConnectors& a, DmiPortConnectors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortConnectors* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortConnectors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortConnectors& from);
  void MergeFrom(const DmiPortConnectors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortConnectors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiPortConnectors_Item Item;

  typedef DmiPortConnectors_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiPortConnectors_Type_TYPE_UNKNOWN;
  static const Type TYPE_NONE =
    DmiPortConnectors_Type_TYPE_NONE;
  static const Type TYPE_PARALLEL_PORT_XT_AT_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_XT_AT_COMPATIBLE;
  static const Type TYPE_PARALLEL_PORT_PS_2 =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_PS_2;
  static const Type TYPE_PARALLEL_PORT_ECP =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_ECP;
  static const Type TYPE_PARALLEL_PORT_EPP =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_EPP;
  static const Type TYPE_PARALLEL_PORT_ECP_EPP =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_ECP_EPP;
  static const Type TYPE_SERIAL_PORT_XT_AT_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_SERIAL_PORT_XT_AT_COMPATIBLE;
  static const Type TYPE_SERIAL_PORT_16450_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_SERIAL_PORT_16450_COMPATIBLE;
  static const Type TYPE_SERIAL_PORT_16550_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_SERIAL_PORT_16550_COMPATIBLE;
  static const Type TYPE_SERIAL_PORT_16550A_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_SERIAL_PORT_16550A_COMPATIBLE;
  static const Type TYPE_SCSI_PORT =
    DmiPortConnectors_Type_TYPE_SCSI_PORT;
  static const Type TYPE_MIDI_PORT =
    DmiPortConnectors_Type_TYPE_MIDI_PORT;
  static const Type TYPE_JOYSTICK_PORT =
    DmiPortConnectors_Type_TYPE_JOYSTICK_PORT;
  static const Type TYPE_KEYBOARD_PORT =
    DmiPortConnectors_Type_TYPE_KEYBOARD_PORT;
  static const Type TYPE_MOUSE_PORT =
    DmiPortConnectors_Type_TYPE_MOUSE_PORT;
  static const Type TYPE_SSA_SCSI =
    DmiPortConnectors_Type_TYPE_SSA_SCSI;
  static const Type TYPE_USB =
    DmiPortConnectors_Type_TYPE_USB;
  static const Type TYPE_FIREWIRE =
    DmiPortConnectors_Type_TYPE_FIREWIRE;
  static const Type TYPE_PCMCIA_TYPE_I =
    DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_I;
  static const Type TYPE_PCMCIA_TYPE_II =
    DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_II;
  static const Type TYPE_PCMCIA_TYPE_III =
    DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_III;
  static const Type TYPE_CARDBUS =
    DmiPortConnectors_Type_TYPE_CARDBUS;
  static const Type TYPE_ACCESS_BUS_PORT =
    DmiPortConnectors_Type_TYPE_ACCESS_BUS_PORT;
  static const Type TYPE_SCSI_II =
    DmiPortConnectors_Type_TYPE_SCSI_II;
  static const Type TYPE_SCSI_WIDE =
    DmiPortConnectors_Type_TYPE_SCSI_WIDE;
  static const Type TYPE_PC_98 =
    DmiPortConnectors_Type_TYPE_PC_98;
  static const Type TYPE_PC_98_HIRESO =
    DmiPortConnectors_Type_TYPE_PC_98_HIRESO;
  static const Type TYPE_PC_H98 =
    DmiPortConnectors_Type_TYPE_PC_H98;
  static const Type TYPE_VIDEO_PORT =
    DmiPortConnectors_Type_TYPE_VIDEO_PORT;
  static const Type TYPE_AUDIO_PORT =
    DmiPortConnectors_Type_TYPE_AUDIO_PORT;
  static const Type TYPE_MODEM_PORT =
    DmiPortConnectors_Type_TYPE_MODEM_PORT;
  static const Type TYPE_NETWORK_PORT =
    DmiPortConnectors_Type_TYPE_NETWORK_PORT;
  static const Type TYPE_SATA =
    DmiPortConnectors_Type_TYPE_SATA;
  static const Type TYPE_SAS =
    DmiPortConnectors_Type_TYPE_SAS;
  static const Type TYPE_8251_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_8251_COMPATIBLE;
  static const Type TYPE_8251_FIFO_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_8251_FIFO_COMPATIBLE;
  static inline bool Type_IsValid(int value) {
    return DmiPortConnectors_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiPortConnectors_Type_Type_MIN;
  static const Type Type_MAX =
    DmiPortConnectors_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiPortConnectors_Type_Type_ARRAYSIZE;

  typedef DmiPortConnectors_ConnectorType ConnectorType;
  static const ConnectorType CONNECTOR_TYPE_UNKNOWN =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_UNKNOWN;
  static const ConnectorType CONNECTOR_TYPE_NONE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_NONE;
  static const ConnectorType CONNECTOR_TYPE_OTHER =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_OTHER;
  static const ConnectorType CONNECTOR_TYPE_CENTRONICS =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CENTRONICS;
  static const ConnectorType CONNECTOR_TYPE_MINI_CENTRONICS =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS;
  static const ConnectorType CONNECTOR_TYPE_PROPRIETARY =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PROPRIETARY;
  static const ConnectorType CONNECTOR_TYPE_DB_25_MALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_25_MALE;
  static const ConnectorType CONNECTOR_TYPE_DB_25_FEMALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_25_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_DB_15_MALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_15_MALE;
  static const ConnectorType CONNECTOR_TYPE_DB_15_FEMALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_15_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_DB_9_MALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_9_MALE;
  static const ConnectorType CONNECTOR_TYPE_DB_9_FEMALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_9_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_RJ_11 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_RJ_11;
  static const ConnectorType CONNECTOR_TYPE_RJ_45 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_RJ_45;
  static const ConnectorType CONNECTOR_TYPE_50_PIN_MINISCSI =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_50_PIN_MINISCSI;
  static const ConnectorType CONNECTOR_TYPE_MINI_DIN =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_DIN;
  static const ConnectorType CONNECTOR_TYPE_MICRO_DIN =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MICRO_DIN;
  static const ConnectorType CONNECTOR_TYPE_PS_2 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PS_2;
  static const ConnectorType CONNECTOR_TYPE_INFRARED =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_INFRARED;
  static const ConnectorType CONNECTOR_TYPE_HP_HIL =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_HP_HIL;
  static const ConnectorType CONNECTOR_TYPE_ACCESS_BUS_USB =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ACCESS_BUS_USB;
  static const ConnectorType CONNECTOR_TYPE_SSA_SCSI =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_SSA_SCSI;
  static const ConnectorType CONNECTOR_TYPE_CIRCULAR_DIN_8_MALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_MALE;
  static const ConnectorType CONNECTOR_TYPE_CIRCULAR_DIN_8_FEMALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_ONBOARD_IDE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_IDE;
  static const ConnectorType CONNECTOR_TYPE_ONBOARD_FLOPPY =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_FLOPPY;
  static const ConnectorType CONNECTOR_TYPE_9_PIN_DUAL_INLINE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_9_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_25_PIN_DUAL_INLINE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_25_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_50_PIN_DUAL_INLINE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_50_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_68_PIN_DUAL_INLINE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_68_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_ONBOARD_SOUND_INPUT_FROM_CDROM =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_SOUND_INPUT_FROM_CDROM;
  static const ConnectorType CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_14 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_14;
  static const ConnectorType CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_26 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_26;
  static const ConnectorType CONNECTOR_TYPE_MINI_JACK =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_JACK;
  static const ConnectorType CONNECTOR_TYPE_BNC =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_BNC;
  static const ConnectorType CONNECTOR_TYPE_IEEE_1394 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_IEEE_1394;
  static const ConnectorType CONNECTOR_TYPE_SAS_SATE_PLUG_RECEPTACLE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_SAS_SATE_PLUG_RECEPTACLE;
  static const ConnectorType CONNECTOR_TYPE_PC_98 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98;
  static const ConnectorType CONNECTOR_TYPE_PC_98_HIRESO =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_HIRESO;
  static const ConnectorType CONNECTOR_TYPE_PC_H98 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_H98;
  static const ConnectorType CONNECTOR_TYPE_PC_98_NOTE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_NOTE;
  static const ConnectorType CONNECTOR_TYPE_PC_98_FULL =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_FULL;
  static inline bool ConnectorType_IsValid(int value) {
    return DmiPortConnectors_ConnectorType_IsValid(value);
  }
  static const ConnectorType ConnectorType_MIN =
    DmiPortConnectors_ConnectorType_ConnectorType_MIN;
  static const ConnectorType ConnectorType_MAX =
    DmiPortConnectors_ConnectorType_ConnectorType_MAX;
  static const int ConnectorType_ARRAYSIZE =
    DmiPortConnectors_ConnectorType_ConnectorType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiPortConnectors.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiPortConnectors_Item& item(int index) const;
  ::aspia::proto::DmiPortConnectors_Item* mutable_item(int index);
  ::aspia::proto::DmiPortConnectors_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortConnectors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortConnectorsImpl();
};
// -------------------------------------------------------------------

class DmiOnBoardDevices_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiOnBoardDevices.Item) */ {
 public:
  DmiOnBoardDevices_Item();
  virtual ~DmiOnBoardDevices_Item();

  DmiOnBoardDevices_Item(const DmiOnBoardDevices_Item& from);

  inline DmiOnBoardDevices_Item& operator=(const DmiOnBoardDevices_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiOnBoardDevices_Item(DmiOnBoardDevices_Item&& from) noexcept
    : DmiOnBoardDevices_Item() {
    *this = ::std::move(from);
  }

  inline DmiOnBoardDevices_Item& operator=(DmiOnBoardDevices_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiOnBoardDevices_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiOnBoardDevices_Item* internal_default_instance() {
    return reinterpret_cast<const DmiOnBoardDevices_Item*>(
               &_DmiOnBoardDevices_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DmiOnBoardDevices_Item* other);
  friend void swap(DmiOnBoardDevices_Item& a, DmiOnBoardDevices_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiOnBoardDevices_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiOnBoardDevices_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiOnBoardDevices_Item& from);
  void MergeFrom(const DmiOnBoardDevices_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiOnBoardDevices_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string description = 1;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .aspia.proto.DmiOnBoardDevices.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::aspia::proto::DmiOnBoardDevices_Type type() const;
  void set_type(::aspia::proto::DmiOnBoardDevices_Type value);

  // bool enabled = 3;
  void clear_enabled();
  static const int kEnabledFieldNumber = 3;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiOnBoardDevices.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  int type_;
  bool enabled_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiOnBoardDevices_ItemImpl();
};
// -------------------------------------------------------------------

class DmiOnBoardDevices : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiOnBoardDevices) */ {
 public:
  DmiOnBoardDevices();
  virtual ~DmiOnBoardDevices();

  DmiOnBoardDevices(const DmiOnBoardDevices& from);

  inline DmiOnBoardDevices& operator=(const DmiOnBoardDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiOnBoardDevices(DmiOnBoardDevices&& from) noexcept
    : DmiOnBoardDevices() {
    *this = ::std::move(from);
  }

  inline DmiOnBoardDevices& operator=(DmiOnBoardDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiOnBoardDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiOnBoardDevices* internal_default_instance() {
    return reinterpret_cast<const DmiOnBoardDevices*>(
               &_DmiOnBoardDevices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DmiOnBoardDevices* other);
  friend void swap(DmiOnBoardDevices& a, DmiOnBoardDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiOnBoardDevices* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiOnBoardDevices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiOnBoardDevices& from);
  void MergeFrom(const DmiOnBoardDevices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiOnBoardDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiOnBoardDevices_Item Item;

  typedef DmiOnBoardDevices_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiOnBoardDevices_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiOnBoardDevices_Type_TYPE_OTHER;
  static const Type TYPE_VIDEO =
    DmiOnBoardDevices_Type_TYPE_VIDEO;
  static const Type TYPE_SCSI_CONTROLLER =
    DmiOnBoardDevices_Type_TYPE_SCSI_CONTROLLER;
  static const Type TYPE_ETHERNET =
    DmiOnBoardDevices_Type_TYPE_ETHERNET;
  static const Type TYPE_TOKEN_RING =
    DmiOnBoardDevices_Type_TYPE_TOKEN_RING;
  static const Type TYPE_SOUND =
    DmiOnBoardDevices_Type_TYPE_SOUND;
  static const Type TYPE_PATA_CONTROLLER =
    DmiOnBoardDevices_Type_TYPE_PATA_CONTROLLER;
  static const Type TYPE_SATA_CONTROLLER =
    DmiOnBoardDevices_Type_TYPE_SATA_CONTROLLER;
  static const Type TYPE_SAS_CONTROLLER =
    DmiOnBoardDevices_Type_TYPE_SAS_CONTROLLER;
  static inline bool Type_IsValid(int value) {
    return DmiOnBoardDevices_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiOnBoardDevices_Type_Type_MIN;
  static const Type Type_MAX =
    DmiOnBoardDevices_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiOnBoardDevices_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiOnBoardDevices.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiOnBoardDevices_Item& item(int index) const;
  ::aspia::proto::DmiOnBoardDevices_Item* mutable_item(int index);
  ::aspia::proto::DmiOnBoardDevices_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiOnBoardDevices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiOnBoardDevicesImpl();
};
// -------------------------------------------------------------------

class DmiPointingDevices_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPointingDevices.Item) */ {
 public:
  DmiPointingDevices_Item();
  virtual ~DmiPointingDevices_Item();

  DmiPointingDevices_Item(const DmiPointingDevices_Item& from);

  inline DmiPointingDevices_Item& operator=(const DmiPointingDevices_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPointingDevices_Item(DmiPointingDevices_Item&& from) noexcept
    : DmiPointingDevices_Item() {
    *this = ::std::move(from);
  }

  inline DmiPointingDevices_Item& operator=(DmiPointingDevices_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPointingDevices_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPointingDevices_Item* internal_default_instance() {
    return reinterpret_cast<const DmiPointingDevices_Item*>(
               &_DmiPointingDevices_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DmiPointingDevices_Item* other);
  friend void swap(DmiPointingDevices_Item& a, DmiPointingDevices_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPointingDevices_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPointingDevices_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPointingDevices_Item& from);
  void MergeFrom(const DmiPointingDevices_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPointingDevices_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .aspia.proto.DmiPointingDevices.Type device_type = 1;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 1;
  ::aspia::proto::DmiPointingDevices_Type device_type() const;
  void set_device_type(::aspia::proto::DmiPointingDevices_Type value);

  // .aspia.proto.DmiPointingDevices.Interface device_interface = 2;
  void clear_device_interface();
  static const int kDeviceInterfaceFieldNumber = 2;
  ::aspia::proto::DmiPointingDevices_Interface device_interface() const;
  void set_device_interface(::aspia::proto::DmiPointingDevices_Interface value);

  // int32 button_count = 3;
  void clear_button_count();
  static const int kButtonCountFieldNumber = 3;
  ::google::protobuf::int32 button_count() const;
  void set_button_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPointingDevices.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int device_type_;
  int device_interface_;
  ::google::protobuf::int32 button_count_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPointingDevices_ItemImpl();
};
// -------------------------------------------------------------------

class DmiPointingDevices : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPointingDevices) */ {
 public:
  DmiPointingDevices();
  virtual ~DmiPointingDevices();

  DmiPointingDevices(const DmiPointingDevices& from);

  inline DmiPointingDevices& operator=(const DmiPointingDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPointingDevices(DmiPointingDevices&& from) noexcept
    : DmiPointingDevices() {
    *this = ::std::move(from);
  }

  inline DmiPointingDevices& operator=(DmiPointingDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPointingDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPointingDevices* internal_default_instance() {
    return reinterpret_cast<const DmiPointingDevices*>(
               &_DmiPointingDevices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(DmiPointingDevices* other);
  friend void swap(DmiPointingDevices& a, DmiPointingDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPointingDevices* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPointingDevices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPointingDevices& from);
  void MergeFrom(const DmiPointingDevices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPointingDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiPointingDevices_Item Item;

  typedef DmiPointingDevices_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiPointingDevices_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiPointingDevices_Type_TYPE_OTHER;
  static const Type TYPE_MOUSE =
    DmiPointingDevices_Type_TYPE_MOUSE;
  static const Type TYPE_TRACK_BALL =
    DmiPointingDevices_Type_TYPE_TRACK_BALL;
  static const Type TYPE_TRACK_POINT =
    DmiPointingDevices_Type_TYPE_TRACK_POINT;
  static const Type TYPE_GLIDE_POINT =
    DmiPointingDevices_Type_TYPE_GLIDE_POINT;
  static const Type TYPE_TOUCH_PAD =
    DmiPointingDevices_Type_TYPE_TOUCH_PAD;
  static const Type TYPE_TOUCH_SCREEN =
    DmiPointingDevices_Type_TYPE_TOUCH_SCREEN;
  static const Type TYPE_OPTICAL_SENSOR =
    DmiPointingDevices_Type_TYPE_OPTICAL_SENSOR;
  static inline bool Type_IsValid(int value) {
    return DmiPointingDevices_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiPointingDevices_Type_Type_MIN;
  static const Type Type_MAX =
    DmiPointingDevices_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiPointingDevices_Type_Type_ARRAYSIZE;

  typedef DmiPointingDevices_Interface Interface;
  static const Interface INTERFACE_UNKNOWN =
    DmiPointingDevices_Interface_INTERFACE_UNKNOWN;
  static const Interface INTERFACE_OTHER =
    DmiPointingDevices_Interface_INTERFACE_OTHER;
  static const Interface INTERFACE_SERIAL =
    DmiPointingDevices_Interface_INTERFACE_SERIAL;
  static const Interface INTERFACE_PS_2 =
    DmiPointingDevices_Interface_INTERFACE_PS_2;
  static const Interface INTERFACE_INFRARED =
    DmiPointingDevices_Interface_INTERFACE_INFRARED;
  static const Interface INTERFACE_HP_HIL =
    DmiPointingDevices_Interface_INTERFACE_HP_HIL;
  static const Interface INTERFACE_BUS_MOUSE =
    DmiPointingDevices_Interface_INTERFACE_BUS_MOUSE;
  static const Interface INTERFACE_ADB =
    DmiPointingDevices_Interface_INTERFACE_ADB;
  static const Interface INTERFACE_BUS_MOUSE_DB_9 =
    DmiPointingDevices_Interface_INTERFACE_BUS_MOUSE_DB_9;
  static const Interface INTERFACE_BUS_MOUSE_MICRO_DIN =
    DmiPointingDevices_Interface_INTERFACE_BUS_MOUSE_MICRO_DIN;
  static const Interface INTERFACE_USB =
    DmiPointingDevices_Interface_INTERFACE_USB;
  static inline bool Interface_IsValid(int value) {
    return DmiPointingDevices_Interface_IsValid(value);
  }
  static const Interface Interface_MIN =
    DmiPointingDevices_Interface_Interface_MIN;
  static const Interface Interface_MAX =
    DmiPointingDevices_Interface_Interface_MAX;
  static const int Interface_ARRAYSIZE =
    DmiPointingDevices_Interface_Interface_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiPointingDevices.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiPointingDevices_Item& item(int index) const;
  ::aspia::proto::DmiPointingDevices_Item* mutable_item(int index);
  ::aspia::proto::DmiPointingDevices_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevices_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevices_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPointingDevices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevices_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPointingDevicesImpl();
};
// -------------------------------------------------------------------

class DmiPortableBattery_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortableBattery.Item) */ {
 public:
  DmiPortableBattery_Item();
  virtual ~DmiPortableBattery_Item();

  DmiPortableBattery_Item(const DmiPortableBattery_Item& from);

  inline DmiPortableBattery_Item& operator=(const DmiPortableBattery_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortableBattery_Item(DmiPortableBattery_Item&& from) noexcept
    : DmiPortableBattery_Item() {
    *this = ::std::move(from);
  }

  inline DmiPortableBattery_Item& operator=(DmiPortableBattery_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortableBattery_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortableBattery_Item* internal_default_instance() {
    return reinterpret_cast<const DmiPortableBattery_Item*>(
               &_DmiPortableBattery_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(DmiPortableBattery_Item* other);
  friend void swap(DmiPortableBattery_Item& a, DmiPortableBattery_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortableBattery_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortableBattery_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortableBattery_Item& from);
  void MergeFrom(const DmiPortableBattery_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortableBattery_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string location = 1;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // string manufacturer = 2;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 2;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string manufacture_date = 3;
  void clear_manufacture_date();
  static const int kManufactureDateFieldNumber = 3;
  const ::std::string& manufacture_date() const;
  void set_manufacture_date(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacture_date(::std::string&& value);
  #endif
  void set_manufacture_date(const char* value);
  void set_manufacture_date(const char* value, size_t size);
  ::std::string* mutable_manufacture_date();
  ::std::string* release_manufacture_date();
  void set_allocated_manufacture_date(::std::string* manufacture_date);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string device_name = 5;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 5;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  #if LANG_CXX11
  void set_device_name(::std::string&& value);
  #endif
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // string sbds_version_number = 9;
  void clear_sbds_version_number();
  static const int kSbdsVersionNumberFieldNumber = 9;
  const ::std::string& sbds_version_number() const;
  void set_sbds_version_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_version_number(::std::string&& value);
  #endif
  void set_sbds_version_number(const char* value);
  void set_sbds_version_number(const char* value, size_t size);
  ::std::string* mutable_sbds_version_number();
  ::std::string* release_sbds_version_number();
  void set_allocated_sbds_version_number(::std::string* sbds_version_number);

  // string sbds_serial_number = 11;
  void clear_sbds_serial_number();
  static const int kSbdsSerialNumberFieldNumber = 11;
  const ::std::string& sbds_serial_number() const;
  void set_sbds_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_serial_number(::std::string&& value);
  #endif
  void set_sbds_serial_number(const char* value);
  void set_sbds_serial_number(const char* value, size_t size);
  ::std::string* mutable_sbds_serial_number();
  ::std::string* release_sbds_serial_number();
  void set_allocated_sbds_serial_number(::std::string* sbds_serial_number);

  // string sbds_manufacture_date = 12;
  void clear_sbds_manufacture_date();
  static const int kSbdsManufactureDateFieldNumber = 12;
  const ::std::string& sbds_manufacture_date() const;
  void set_sbds_manufacture_date(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_manufacture_date(::std::string&& value);
  #endif
  void set_sbds_manufacture_date(const char* value);
  void set_sbds_manufacture_date(const char* value, size_t size);
  ::std::string* mutable_sbds_manufacture_date();
  ::std::string* release_sbds_manufacture_date();
  void set_allocated_sbds_manufacture_date(::std::string* sbds_manufacture_date);

  // string sbds_device_chemistry = 13;
  void clear_sbds_device_chemistry();
  static const int kSbdsDeviceChemistryFieldNumber = 13;
  const ::std::string& sbds_device_chemistry() const;
  void set_sbds_device_chemistry(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_device_chemistry(::std::string&& value);
  #endif
  void set_sbds_device_chemistry(const char* value);
  void set_sbds_device_chemistry(const char* value, size_t size);
  ::std::string* mutable_sbds_device_chemistry();
  ::std::string* release_sbds_device_chemistry();
  void set_allocated_sbds_device_chemistry(::std::string* sbds_device_chemistry);

  // .aspia.proto.DmiPortableBattery.Chemistry chemistry = 6;
  void clear_chemistry();
  static const int kChemistryFieldNumber = 6;
  ::aspia::proto::DmiPortableBattery_Chemistry chemistry() const;
  void set_chemistry(::aspia::proto::DmiPortableBattery_Chemistry value);

  // int32 design_capacity = 7;
  void clear_design_capacity();
  static const int kDesignCapacityFieldNumber = 7;
  ::google::protobuf::int32 design_capacity() const;
  void set_design_capacity(::google::protobuf::int32 value);

  // int32 design_voltage = 8;
  void clear_design_voltage();
  static const int kDesignVoltageFieldNumber = 8;
  ::google::protobuf::int32 design_voltage() const;
  void set_design_voltage(::google::protobuf::int32 value);

  // int32 max_error_in_battery_data = 10;
  void clear_max_error_in_battery_data();
  static const int kMaxErrorInBatteryDataFieldNumber = 10;
  ::google::protobuf::int32 max_error_in_battery_data() const;
  void set_max_error_in_battery_data(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortableBattery.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr manufacture_date_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  ::google::protobuf::internal::ArenaStringPtr sbds_version_number_;
  ::google::protobuf::internal::ArenaStringPtr sbds_serial_number_;
  ::google::protobuf::internal::ArenaStringPtr sbds_manufacture_date_;
  ::google::protobuf::internal::ArenaStringPtr sbds_device_chemistry_;
  int chemistry_;
  ::google::protobuf::int32 design_capacity_;
  ::google::protobuf::int32 design_voltage_;
  ::google::protobuf::int32 max_error_in_battery_data_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortableBattery_ItemImpl();
};
// -------------------------------------------------------------------

class DmiPortableBattery : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortableBattery) */ {
 public:
  DmiPortableBattery();
  virtual ~DmiPortableBattery();

  DmiPortableBattery(const DmiPortableBattery& from);

  inline DmiPortableBattery& operator=(const DmiPortableBattery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortableBattery(DmiPortableBattery&& from) noexcept
    : DmiPortableBattery() {
    *this = ::std::move(from);
  }

  inline DmiPortableBattery& operator=(DmiPortableBattery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortableBattery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortableBattery* internal_default_instance() {
    return reinterpret_cast<const DmiPortableBattery*>(
               &_DmiPortableBattery_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(DmiPortableBattery* other);
  friend void swap(DmiPortableBattery& a, DmiPortableBattery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortableBattery* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortableBattery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortableBattery& from);
  void MergeFrom(const DmiPortableBattery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortableBattery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiPortableBattery_Item Item;

  typedef DmiPortableBattery_Chemistry Chemistry;
  static const Chemistry CHEMISTRY_UNKNOWN =
    DmiPortableBattery_Chemistry_CHEMISTRY_UNKNOWN;
  static const Chemistry CHEMISTRY_OTHER =
    DmiPortableBattery_Chemistry_CHEMISTRY_OTHER;
  static const Chemistry CHEMISTRY_LEAD_ACID =
    DmiPortableBattery_Chemistry_CHEMISTRY_LEAD_ACID;
  static const Chemistry CHEMISTRY_NICKEL_CADMIUM =
    DmiPortableBattery_Chemistry_CHEMISTRY_NICKEL_CADMIUM;
  static const Chemistry CHEMISTRY_NICKEL_METAL_HYDRIDE =
    DmiPortableBattery_Chemistry_CHEMISTRY_NICKEL_METAL_HYDRIDE;
  static const Chemistry CHEMISTRY_LITHIUM_ION =
    DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_ION;
  static const Chemistry CHEMISTRY_ZINC_AIR =
    DmiPortableBattery_Chemistry_CHEMISTRY_ZINC_AIR;
  static const Chemistry CHEMISTRY_LITHIUM_POLYMER =
    DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_POLYMER;
  static inline bool Chemistry_IsValid(int value) {
    return DmiPortableBattery_Chemistry_IsValid(value);
  }
  static const Chemistry Chemistry_MIN =
    DmiPortableBattery_Chemistry_Chemistry_MIN;
  static const Chemistry Chemistry_MAX =
    DmiPortableBattery_Chemistry_Chemistry_MAX;
  static const int Chemistry_ARRAYSIZE =
    DmiPortableBattery_Chemistry_Chemistry_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiPortableBattery.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiPortableBattery_Item& item(int index) const;
  ::aspia::proto::DmiPortableBattery_Item* mutable_item(int index);
  ::aspia::proto::DmiPortableBattery_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortableBattery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortableBatteryImpl();
};
// -------------------------------------------------------------------

class Programs_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Programs.Item) */ {
 public:
  Programs_Item();
  virtual ~Programs_Item();

  Programs_Item(const Programs_Item& from);

  inline Programs_Item& operator=(const Programs_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Programs_Item(Programs_Item&& from) noexcept
    : Programs_Item() {
    *this = ::std::move(from);
  }

  inline Programs_Item& operator=(Programs_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Programs_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Programs_Item* internal_default_instance() {
    return reinterpret_cast<const Programs_Item*>(
               &_Programs_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Programs_Item* other);
  friend void swap(Programs_Item& a, Programs_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Programs_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Programs_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Programs_Item& from);
  void MergeFrom(const Programs_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Programs_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string publisher = 3;
  void clear_publisher();
  static const int kPublisherFieldNumber = 3;
  const ::std::string& publisher() const;
  void set_publisher(const ::std::string& value);
  #if LANG_CXX11
  void set_publisher(::std::string&& value);
  #endif
  void set_publisher(const char* value);
  void set_publisher(const char* value, size_t size);
  ::std::string* mutable_publisher();
  ::std::string* release_publisher();
  void set_allocated_publisher(::std::string* publisher);

  // string install_date = 4;
  void clear_install_date();
  static const int kInstallDateFieldNumber = 4;
  const ::std::string& install_date() const;
  void set_install_date(const ::std::string& value);
  #if LANG_CXX11
  void set_install_date(::std::string&& value);
  #endif
  void set_install_date(const char* value);
  void set_install_date(const char* value, size_t size);
  ::std::string* mutable_install_date();
  ::std::string* release_install_date();
  void set_allocated_install_date(::std::string* install_date);

  // string install_location = 5;
  void clear_install_location();
  static const int kInstallLocationFieldNumber = 5;
  const ::std::string& install_location() const;
  void set_install_location(const ::std::string& value);
  #if LANG_CXX11
  void set_install_location(::std::string&& value);
  #endif
  void set_install_location(const char* value);
  void set_install_location(const char* value, size_t size);
  ::std::string* mutable_install_location();
  ::std::string* release_install_location();
  void set_allocated_install_location(::std::string* install_location);

  // @@protoc_insertion_point(class_scope:aspia.proto.Programs.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr publisher_;
  ::google::protobuf::internal::ArenaStringPtr install_date_;
  ::google::protobuf::internal::ArenaStringPtr install_location_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsPrograms_ItemImpl();
};
// -------------------------------------------------------------------

class Programs : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Programs) */ {
 public:
  Programs();
  virtual ~Programs();

  Programs(const Programs& from);

  inline Programs& operator=(const Programs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Programs(Programs&& from) noexcept
    : Programs() {
    *this = ::std::move(from);
  }

  inline Programs& operator=(Programs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Programs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Programs* internal_default_instance() {
    return reinterpret_cast<const Programs*>(
               &_Programs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Programs* other);
  friend void swap(Programs& a, Programs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Programs* New() const PROTOBUF_FINAL { return New(NULL); }

  Programs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Programs& from);
  void MergeFrom(const Programs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Programs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Programs_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Programs.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Programs_Item& item(int index) const;
  ::aspia::proto::Programs_Item* mutable_item(int index);
  ::aspia::proto::Programs_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Programs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsProgramsImpl();
};
// -------------------------------------------------------------------

class Services_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Services.Item) */ {
 public:
  Services_Item();
  virtual ~Services_Item();

  Services_Item(const Services_Item& from);

  inline Services_Item& operator=(const Services_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Services_Item(Services_Item&& from) noexcept
    : Services_Item() {
    *this = ::std::move(from);
  }

  inline Services_Item& operator=(Services_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Services_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Services_Item* internal_default_instance() {
    return reinterpret_cast<const Services_Item*>(
               &_Services_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Services_Item* other);
  friend void swap(Services_Item& a, Services_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Services_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Services_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Services_Item& from);
  void MergeFrom(const Services_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Services_Item_Status Status;
  static const Status STATUS_UNKNOWN =
    Services_Item_Status_STATUS_UNKNOWN;
  static const Status STATUS_CONTINUE_PENDING =
    Services_Item_Status_STATUS_CONTINUE_PENDING;
  static const Status STATUS_PAUSE_PENDING =
    Services_Item_Status_STATUS_PAUSE_PENDING;
  static const Status STATUS_PAUSED =
    Services_Item_Status_STATUS_PAUSED;
  static const Status STATUS_RUNNING =
    Services_Item_Status_STATUS_RUNNING;
  static const Status STATUS_START_PENDING =
    Services_Item_Status_STATUS_START_PENDING;
  static const Status STATUS_STOP_PENDING =
    Services_Item_Status_STATUS_STOP_PENDING;
  static const Status STATUS_STOPPED =
    Services_Item_Status_STATUS_STOPPED;
  static inline bool Status_IsValid(int value) {
    return Services_Item_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Services_Item_Status_Status_MIN;
  static const Status Status_MAX =
    Services_Item_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Services_Item_Status_Status_ARRAYSIZE;

  typedef Services_Item_StartupType StartupType;
  static const StartupType STARTUP_TYPE_UNKNOWN =
    Services_Item_StartupType_STARTUP_TYPE_UNKNOWN;
  static const StartupType STARTUP_TYPE_AUTO_START =
    Services_Item_StartupType_STARTUP_TYPE_AUTO_START;
  static const StartupType STARTUP_TYPE_DEMAND_START =
    Services_Item_StartupType_STARTUP_TYPE_DEMAND_START;
  static const StartupType STARTUP_TYPE_DISABLED =
    Services_Item_StartupType_STARTUP_TYPE_DISABLED;
  static const StartupType STARTUP_TYPE_BOOT_START =
    Services_Item_StartupType_STARTUP_TYPE_BOOT_START;
  static const StartupType STARTUP_TYPE_SYSTEM_START =
    Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START;
  static inline bool StartupType_IsValid(int value) {
    return Services_Item_StartupType_IsValid(value);
  }
  static const StartupType StartupType_MIN =
    Services_Item_StartupType_StartupType_MIN;
  static const StartupType StartupType_MAX =
    Services_Item_StartupType_StartupType_MAX;
  static const int StartupType_ARRAYSIZE =
    Services_Item_StartupType_StartupType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string display_name = 2;
  void clear_display_name();
  static const int kDisplayNameFieldNumber = 2;
  const ::std::string& display_name() const;
  void set_display_name(const ::std::string& value);
  #if LANG_CXX11
  void set_display_name(::std::string&& value);
  #endif
  void set_display_name(const char* value);
  void set_display_name(const char* value, size_t size);
  ::std::string* mutable_display_name();
  ::std::string* release_display_name();
  void set_allocated_display_name(::std::string* display_name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string binary_path = 6;
  void clear_binary_path();
  static const int kBinaryPathFieldNumber = 6;
  const ::std::string& binary_path() const;
  void set_binary_path(const ::std::string& value);
  #if LANG_CXX11
  void set_binary_path(::std::string&& value);
  #endif
  void set_binary_path(const char* value);
  void set_binary_path(const char* value, size_t size);
  ::std::string* mutable_binary_path();
  ::std::string* release_binary_path();
  void set_allocated_binary_path(::std::string* binary_path);

  // string start_name = 7;
  void clear_start_name();
  static const int kStartNameFieldNumber = 7;
  const ::std::string& start_name() const;
  void set_start_name(const ::std::string& value);
  #if LANG_CXX11
  void set_start_name(::std::string&& value);
  #endif
  void set_start_name(const char* value);
  void set_start_name(const char* value, size_t size);
  ::std::string* mutable_start_name();
  ::std::string* release_start_name();
  void set_allocated_start_name(::std::string* start_name);

  // .aspia.proto.Services.Item.Status status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::aspia::proto::Services_Item_Status status() const;
  void set_status(::aspia::proto::Services_Item_Status value);

  // .aspia.proto.Services.Item.StartupType startup_type = 5;
  void clear_startup_type();
  static const int kStartupTypeFieldNumber = 5;
  ::aspia::proto::Services_Item_StartupType startup_type() const;
  void set_startup_type(::aspia::proto::Services_Item_StartupType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Services.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr display_name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr binary_path_;
  ::google::protobuf::internal::ArenaStringPtr start_name_;
  int status_;
  int startup_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsServices_ItemImpl();
};
// -------------------------------------------------------------------

class Services : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Services) */ {
 public:
  Services();
  virtual ~Services();

  Services(const Services& from);

  inline Services& operator=(const Services& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Services(Services&& from) noexcept
    : Services() {
    *this = ::std::move(from);
  }

  inline Services& operator=(Services&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Services& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Services* internal_default_instance() {
    return reinterpret_cast<const Services*>(
               &_Services_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Services* other);
  friend void swap(Services& a, Services& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Services* New() const PROTOBUF_FINAL { return New(NULL); }

  Services* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Services& from);
  void MergeFrom(const Services& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Services_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Services.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Services_Item& item(int index) const;
  ::aspia::proto::Services_Item* mutable_item(int index);
  ::aspia::proto::Services_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Services)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsServicesImpl();
};
// -------------------------------------------------------------------

class NetworkCards_Item_IpAddress : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.NetworkCards.Item.IpAddress) */ {
 public:
  NetworkCards_Item_IpAddress();
  virtual ~NetworkCards_Item_IpAddress();

  NetworkCards_Item_IpAddress(const NetworkCards_Item_IpAddress& from);

  inline NetworkCards_Item_IpAddress& operator=(const NetworkCards_Item_IpAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards_Item_IpAddress(NetworkCards_Item_IpAddress&& from) noexcept
    : NetworkCards_Item_IpAddress() {
    *this = ::std::move(from);
  }

  inline NetworkCards_Item_IpAddress& operator=(NetworkCards_Item_IpAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards_Item_IpAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkCards_Item_IpAddress* internal_default_instance() {
    return reinterpret_cast<const NetworkCards_Item_IpAddress*>(
               &_NetworkCards_Item_IpAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(NetworkCards_Item_IpAddress* other);
  friend void swap(NetworkCards_Item_IpAddress& a, NetworkCards_Item_IpAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards_Item_IpAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards_Item_IpAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards_Item_IpAddress& from);
  void MergeFrom(const NetworkCards_Item_IpAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards_Item_IpAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // string mask = 2;
  void clear_mask();
  static const int kMaskFieldNumber = 2;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // @@protoc_insertion_point(class_scope:aspia.proto.NetworkCards.Item.IpAddress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsNetworkCards_Item_IpAddressImpl();
};
// -------------------------------------------------------------------

class NetworkCards_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.NetworkCards.Item) */ {
 public:
  NetworkCards_Item();
  virtual ~NetworkCards_Item();

  NetworkCards_Item(const NetworkCards_Item& from);

  inline NetworkCards_Item& operator=(const NetworkCards_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards_Item(NetworkCards_Item&& from) noexcept
    : NetworkCards_Item() {
    *this = ::std::move(from);
  }

  inline NetworkCards_Item& operator=(NetworkCards_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkCards_Item* internal_default_instance() {
    return reinterpret_cast<const NetworkCards_Item*>(
               &_NetworkCards_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(NetworkCards_Item* other);
  friend void swap(NetworkCards_Item& a, NetworkCards_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards_Item& from);
  void MergeFrom(const NetworkCards_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NetworkCards_Item_IpAddress IpAddress;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.NetworkCards.Item.IpAddress ip_address = 11;
  int ip_address_size() const;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 11;
  const ::aspia::proto::NetworkCards_Item_IpAddress& ip_address(int index) const;
  ::aspia::proto::NetworkCards_Item_IpAddress* mutable_ip_address(int index);
  ::aspia::proto::NetworkCards_Item_IpAddress* add_ip_address();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >*
      mutable_ip_address();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >&
      ip_address() const;

  // repeated string gateway_address = 12;
  int gateway_address_size() const;
  void clear_gateway_address();
  static const int kGatewayAddressFieldNumber = 12;
  const ::std::string& gateway_address(int index) const;
  ::std::string* mutable_gateway_address(int index);
  void set_gateway_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_gateway_address(int index, ::std::string&& value);
  #endif
  void set_gateway_address(int index, const char* value);
  void set_gateway_address(int index, const char* value, size_t size);
  ::std::string* add_gateway_address();
  void add_gateway_address(const ::std::string& value);
  #if LANG_CXX11
  void add_gateway_address(::std::string&& value);
  #endif
  void add_gateway_address(const char* value);
  void add_gateway_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& gateway_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_gateway_address();

  // repeated string dhcp_server_address = 13;
  int dhcp_server_address_size() const;
  void clear_dhcp_server_address();
  static const int kDhcpServerAddressFieldNumber = 13;
  const ::std::string& dhcp_server_address(int index) const;
  ::std::string* mutable_dhcp_server_address(int index);
  void set_dhcp_server_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dhcp_server_address(int index, ::std::string&& value);
  #endif
  void set_dhcp_server_address(int index, const char* value);
  void set_dhcp_server_address(int index, const char* value, size_t size);
  ::std::string* add_dhcp_server_address();
  void add_dhcp_server_address(const ::std::string& value);
  #if LANG_CXX11
  void add_dhcp_server_address(::std::string&& value);
  #endif
  void add_dhcp_server_address(const char* value);
  void add_dhcp_server_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dhcp_server_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dhcp_server_address();

  // repeated string dns_server_address = 14;
  int dns_server_address_size() const;
  void clear_dns_server_address();
  static const int kDnsServerAddressFieldNumber = 14;
  const ::std::string& dns_server_address(int index) const;
  ::std::string* mutable_dns_server_address(int index);
  void set_dns_server_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dns_server_address(int index, ::std::string&& value);
  #endif
  void set_dns_server_address(int index, const char* value);
  void set_dns_server_address(int index, const char* value, size_t size);
  ::std::string* add_dns_server_address();
  void add_dns_server_address(const ::std::string& value);
  #if LANG_CXX11
  void add_dns_server_address(::std::string&& value);
  #endif
  void add_dns_server_address(const char* value);
  void add_dns_server_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dns_server_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dns_server_address();

  // string adapter_name = 1;
  void clear_adapter_name();
  static const int kAdapterNameFieldNumber = 1;
  const ::std::string& adapter_name() const;
  void set_adapter_name(const ::std::string& value);
  #if LANG_CXX11
  void set_adapter_name(::std::string&& value);
  #endif
  void set_adapter_name(const char* value);
  void set_adapter_name(const char* value, size_t size);
  ::std::string* mutable_adapter_name();
  ::std::string* release_adapter_name();
  void set_allocated_adapter_name(::std::string* adapter_name);

  // string connection_name = 2;
  void clear_connection_name();
  static const int kConnectionNameFieldNumber = 2;
  const ::std::string& connection_name() const;
  void set_connection_name(const ::std::string& value);
  #if LANG_CXX11
  void set_connection_name(::std::string&& value);
  #endif
  void set_connection_name(const char* value);
  void set_connection_name(const char* value, size_t size);
  ::std::string* mutable_connection_name();
  ::std::string* release_connection_name();
  void set_allocated_connection_name(::std::string* connection_name);

  // string interface_type = 3;
  void clear_interface_type();
  static const int kInterfaceTypeFieldNumber = 3;
  const ::std::string& interface_type() const;
  void set_interface_type(const ::std::string& value);
  #if LANG_CXX11
  void set_interface_type(::std::string&& value);
  #endif
  void set_interface_type(const char* value);
  void set_interface_type(const char* value, size_t size);
  ::std::string* mutable_interface_type();
  ::std::string* release_interface_type();
  void set_allocated_interface_type(::std::string* interface_type);

  // string mac_address = 6;
  void clear_mac_address();
  static const int kMacAddressFieldNumber = 6;
  const ::std::string& mac_address() const;
  void set_mac_address(const ::std::string& value);
  #if LANG_CXX11
  void set_mac_address(::std::string&& value);
  #endif
  void set_mac_address(const char* value);
  void set_mac_address(const char* value, size_t size);
  ::std::string* mutable_mac_address();
  ::std::string* release_mac_address();
  void set_allocated_mac_address(::std::string* mac_address);

  // string primary_wins_server = 8;
  void clear_primary_wins_server();
  static const int kPrimaryWinsServerFieldNumber = 8;
  const ::std::string& primary_wins_server() const;
  void set_primary_wins_server(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_wins_server(::std::string&& value);
  #endif
  void set_primary_wins_server(const char* value);
  void set_primary_wins_server(const char* value, size_t size);
  ::std::string* mutable_primary_wins_server();
  ::std::string* release_primary_wins_server();
  void set_allocated_primary_wins_server(::std::string* primary_wins_server);

  // string secondary_wins_server = 9;
  void clear_secondary_wins_server();
  static const int kSecondaryWinsServerFieldNumber = 9;
  const ::std::string& secondary_wins_server() const;
  void set_secondary_wins_server(const ::std::string& value);
  #if LANG_CXX11
  void set_secondary_wins_server(::std::string&& value);
  #endif
  void set_secondary_wins_server(const char* value);
  void set_secondary_wins_server(const char* value, size_t size);
  ::std::string* mutable_secondary_wins_server();
  ::std::string* release_secondary_wins_server();
  void set_allocated_secondary_wins_server(::std::string* secondary_wins_server);

  // uint32 mtu = 4;
  void clear_mtu();
  static const int kMtuFieldNumber = 4;
  ::google::protobuf::uint32 mtu() const;
  void set_mtu(::google::protobuf::uint32 value);

  // uint32 speed = 5;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  ::google::protobuf::uint32 speed() const;
  void set_speed(::google::protobuf::uint32 value);

  // bool is_wins_enabled = 7;
  void clear_is_wins_enabled();
  static const int kIsWinsEnabledFieldNumber = 7;
  bool is_wins_enabled() const;
  void set_is_wins_enabled(bool value);

  // bool is_dhcp_enabled = 10;
  void clear_is_dhcp_enabled();
  static const int kIsDhcpEnabledFieldNumber = 10;
  bool is_dhcp_enabled() const;
  void set_is_dhcp_enabled(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.NetworkCards.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress > ip_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> gateway_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dhcp_server_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dns_server_address_;
  ::google::protobuf::internal::ArenaStringPtr adapter_name_;
  ::google::protobuf::internal::ArenaStringPtr connection_name_;
  ::google::protobuf::internal::ArenaStringPtr interface_type_;
  ::google::protobuf::internal::ArenaStringPtr mac_address_;
  ::google::protobuf::internal::ArenaStringPtr primary_wins_server_;
  ::google::protobuf::internal::ArenaStringPtr secondary_wins_server_;
  ::google::protobuf::uint32 mtu_;
  ::google::protobuf::uint32 speed_;
  bool is_wins_enabled_;
  bool is_dhcp_enabled_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsNetworkCards_ItemImpl();
};
// -------------------------------------------------------------------

class NetworkCards : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.NetworkCards) */ {
 public:
  NetworkCards();
  virtual ~NetworkCards();

  NetworkCards(const NetworkCards& from);

  inline NetworkCards& operator=(const NetworkCards& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards(NetworkCards&& from) noexcept
    : NetworkCards() {
    *this = ::std::move(from);
  }

  inline NetworkCards& operator=(NetworkCards&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkCards* internal_default_instance() {
    return reinterpret_cast<const NetworkCards*>(
               &_NetworkCards_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(NetworkCards* other);
  friend void swap(NetworkCards& a, NetworkCards& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards& from);
  void MergeFrom(const NetworkCards& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NetworkCards_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.NetworkCards.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::NetworkCards_Item& item(int index) const;
  ::aspia::proto::NetworkCards_Item* mutable_item(int index);
  ::aspia::proto::NetworkCards_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.NetworkCards)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsNetworkCardsImpl();
};
// -------------------------------------------------------------------

class OpenConnections_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.OpenConnections.Item) */ {
 public:
  OpenConnections_Item();
  virtual ~OpenConnections_Item();

  OpenConnections_Item(const OpenConnections_Item& from);

  inline OpenConnections_Item& operator=(const OpenConnections_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenConnections_Item(OpenConnections_Item&& from) noexcept
    : OpenConnections_Item() {
    *this = ::std::move(from);
  }

  inline OpenConnections_Item& operator=(OpenConnections_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OpenConnections_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenConnections_Item* internal_default_instance() {
    return reinterpret_cast<const OpenConnections_Item*>(
               &_OpenConnections_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(OpenConnections_Item* other);
  friend void swap(OpenConnections_Item& a, OpenConnections_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenConnections_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  OpenConnections_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpenConnections_Item& from);
  void MergeFrom(const OpenConnections_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenConnections_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string process_name = 1;
  void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  const ::std::string& process_name() const;
  void set_process_name(const ::std::string& value);
  #if LANG_CXX11
  void set_process_name(::std::string&& value);
  #endif
  void set_process_name(const char* value);
  void set_process_name(const char* value, size_t size);
  ::std::string* mutable_process_name();
  ::std::string* release_process_name();
  void set_allocated_process_name(::std::string* process_name);

  // string local_address = 3;
  void clear_local_address();
  static const int kLocalAddressFieldNumber = 3;
  const ::std::string& local_address() const;
  void set_local_address(const ::std::string& value);
  #if LANG_CXX11
  void set_local_address(::std::string&& value);
  #endif
  void set_local_address(const char* value);
  void set_local_address(const char* value, size_t size);
  ::std::string* mutable_local_address();
  ::std::string* release_local_address();
  void set_allocated_local_address(::std::string* local_address);

  // string remote_address = 4;
  void clear_remote_address();
  static const int kRemoteAddressFieldNumber = 4;
  const ::std::string& remote_address() const;
  void set_remote_address(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_address(::std::string&& value);
  #endif
  void set_remote_address(const char* value);
  void set_remote_address(const char* value, size_t size);
  ::std::string* mutable_remote_address();
  ::std::string* release_remote_address();
  void set_allocated_remote_address(::std::string* remote_address);

  // .aspia.proto.OpenConnections.Protocol protocol = 2;
  void clear_protocol();
  static const int kProtocolFieldNumber = 2;
  ::aspia::proto::OpenConnections_Protocol protocol() const;
  void set_protocol(::aspia::proto::OpenConnections_Protocol value);

  // uint32 local_port = 5;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 5;
  ::google::protobuf::uint32 local_port() const;
  void set_local_port(::google::protobuf::uint32 value);

  // uint32 remote_port = 6;
  void clear_remote_port();
  static const int kRemotePortFieldNumber = 6;
  ::google::protobuf::uint32 remote_port() const;
  void set_remote_port(::google::protobuf::uint32 value);

  // .aspia.proto.OpenConnections.State state = 7;
  void clear_state();
  static const int kStateFieldNumber = 7;
  ::aspia::proto::OpenConnections_State state() const;
  void set_state(::aspia::proto::OpenConnections_State value);

  // @@protoc_insertion_point(class_scope:aspia.proto.OpenConnections.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr process_name_;
  ::google::protobuf::internal::ArenaStringPtr local_address_;
  ::google::protobuf::internal::ArenaStringPtr remote_address_;
  int protocol_;
  ::google::protobuf::uint32 local_port_;
  ::google::protobuf::uint32 remote_port_;
  int state_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsOpenConnections_ItemImpl();
};
// -------------------------------------------------------------------

class OpenConnections : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.OpenConnections) */ {
 public:
  OpenConnections();
  virtual ~OpenConnections();

  OpenConnections(const OpenConnections& from);

  inline OpenConnections& operator=(const OpenConnections& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenConnections(OpenConnections&& from) noexcept
    : OpenConnections() {
    *this = ::std::move(from);
  }

  inline OpenConnections& operator=(OpenConnections&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OpenConnections& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenConnections* internal_default_instance() {
    return reinterpret_cast<const OpenConnections*>(
               &_OpenConnections_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(OpenConnections* other);
  friend void swap(OpenConnections& a, OpenConnections& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenConnections* New() const PROTOBUF_FINAL { return New(NULL); }

  OpenConnections* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpenConnections& from);
  void MergeFrom(const OpenConnections& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenConnections* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef OpenConnections_Item Item;

  typedef OpenConnections_Protocol Protocol;
  static const Protocol PROTOCOL_UNKNOWN =
    OpenConnections_Protocol_PROTOCOL_UNKNOWN;
  static const Protocol PROTOCOL_TCP =
    OpenConnections_Protocol_PROTOCOL_TCP;
  static const Protocol PROTOCOL_UDP =
    OpenConnections_Protocol_PROTOCOL_UDP;
  static inline bool Protocol_IsValid(int value) {
    return OpenConnections_Protocol_IsValid(value);
  }
  static const Protocol Protocol_MIN =
    OpenConnections_Protocol_Protocol_MIN;
  static const Protocol Protocol_MAX =
    OpenConnections_Protocol_Protocol_MAX;
  static const int Protocol_ARRAYSIZE =
    OpenConnections_Protocol_Protocol_ARRAYSIZE;

  typedef OpenConnections_State State;
  static const State STATE_UNKNOWN =
    OpenConnections_State_STATE_UNKNOWN;
  static const State STATE_CLOSED =
    OpenConnections_State_STATE_CLOSED;
  static const State STATE_LISTENING =
    OpenConnections_State_STATE_LISTENING;
  static const State STATE_SYN_SENT =
    OpenConnections_State_STATE_SYN_SENT;
  static const State STATE_SYN_RCVD =
    OpenConnections_State_STATE_SYN_RCVD;
  static const State STATE_ESTABLISHED =
    OpenConnections_State_STATE_ESTABLISHED;
  static const State STATE_FIN_WAIT1 =
    OpenConnections_State_STATE_FIN_WAIT1;
  static const State STATE_FIN_WAIT2 =
    OpenConnections_State_STATE_FIN_WAIT2;
  static const State STATE_CLOSE_WAIT =
    OpenConnections_State_STATE_CLOSE_WAIT;
  static const State STATE_CLOSING =
    OpenConnections_State_STATE_CLOSING;
  static const State STATE_LAST_ACK =
    OpenConnections_State_STATE_LAST_ACK;
  static const State STATE_TIME_WAIT =
    OpenConnections_State_STATE_TIME_WAIT;
  static const State STATE_DELETE_TCB =
    OpenConnections_State_STATE_DELETE_TCB;
  static inline bool State_IsValid(int value) {
    return OpenConnections_State_IsValid(value);
  }
  static const State State_MIN =
    OpenConnections_State_State_MIN;
  static const State State_MAX =
    OpenConnections_State_State_MAX;
  static const int State_ARRAYSIZE =
    OpenConnections_State_State_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.OpenConnections.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::OpenConnections_Item& item(int index) const;
  ::aspia::proto::OpenConnections_Item* mutable_item(int index);
  ::aspia::proto::OpenConnections_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.OpenConnections)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsOpenConnectionsImpl();
};
// -------------------------------------------------------------------

class SharedResources_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.SharedResources.Item) */ {
 public:
  SharedResources_Item();
  virtual ~SharedResources_Item();

  SharedResources_Item(const SharedResources_Item& from);

  inline SharedResources_Item& operator=(const SharedResources_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SharedResources_Item(SharedResources_Item&& from) noexcept
    : SharedResources_Item() {
    *this = ::std::move(from);
  }

  inline SharedResources_Item& operator=(SharedResources_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SharedResources_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SharedResources_Item* internal_default_instance() {
    return reinterpret_cast<const SharedResources_Item*>(
               &_SharedResources_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(SharedResources_Item* other);
  friend void swap(SharedResources_Item& a, SharedResources_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SharedResources_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  SharedResources_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SharedResources_Item& from);
  void MergeFrom(const SharedResources_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedResources_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SharedResources_Item_Type Type;
  static const Type TYPE_UNKNOWN =
    SharedResources_Item_Type_TYPE_UNKNOWN;
  static const Type TYPE_DISK =
    SharedResources_Item_Type_TYPE_DISK;
  static const Type TYPE_PRINTER =
    SharedResources_Item_Type_TYPE_PRINTER;
  static const Type TYPE_DEVICE =
    SharedResources_Item_Type_TYPE_DEVICE;
  static const Type TYPE_IPC =
    SharedResources_Item_Type_TYPE_IPC;
  static const Type TYPE_SPECIAL =
    SharedResources_Item_Type_TYPE_SPECIAL;
  static const Type TYPE_TEMPORARY =
    SharedResources_Item_Type_TYPE_TEMPORARY;
  static inline bool Type_IsValid(int value) {
    return SharedResources_Item_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SharedResources_Item_Type_Type_MIN;
  static const Type Type_MAX =
    SharedResources_Item_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SharedResources_Item_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string local_path = 4;
  void clear_local_path();
  static const int kLocalPathFieldNumber = 4;
  const ::std::string& local_path() const;
  void set_local_path(const ::std::string& value);
  #if LANG_CXX11
  void set_local_path(::std::string&& value);
  #endif
  void set_local_path(const char* value);
  void set_local_path(const char* value, size_t size);
  ::std::string* mutable_local_path();
  ::std::string* release_local_path();
  void set_allocated_local_path(::std::string* local_path);

  // .aspia.proto.SharedResources.Item.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::aspia::proto::SharedResources_Item_Type type() const;
  void set_type(::aspia::proto::SharedResources_Item_Type value);

  // uint32 current_uses = 5;
  void clear_current_uses();
  static const int kCurrentUsesFieldNumber = 5;
  ::google::protobuf::uint32 current_uses() const;
  void set_current_uses(::google::protobuf::uint32 value);

  // uint32 maximum_uses = 6;
  void clear_maximum_uses();
  static const int kMaximumUsesFieldNumber = 6;
  ::google::protobuf::uint32 maximum_uses() const;
  void set_maximum_uses(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.SharedResources.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr local_path_;
  int type_;
  ::google::protobuf::uint32 current_uses_;
  ::google::protobuf::uint32 maximum_uses_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSharedResources_ItemImpl();
};
// -------------------------------------------------------------------

class SharedResources : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.SharedResources) */ {
 public:
  SharedResources();
  virtual ~SharedResources();

  SharedResources(const SharedResources& from);

  inline SharedResources& operator=(const SharedResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SharedResources(SharedResources&& from) noexcept
    : SharedResources() {
    *this = ::std::move(from);
  }

  inline SharedResources& operator=(SharedResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SharedResources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SharedResources* internal_default_instance() {
    return reinterpret_cast<const SharedResources*>(
               &_SharedResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(SharedResources* other);
  friend void swap(SharedResources& a, SharedResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SharedResources* New() const PROTOBUF_FINAL { return New(NULL); }

  SharedResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SharedResources& from);
  void MergeFrom(const SharedResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SharedResources_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.SharedResources.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::SharedResources_Item& item(int index) const;
  ::aspia::proto::SharedResources_Item* mutable_item(int index);
  ::aspia::proto::SharedResources_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.SharedResources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSharedResourcesImpl();
};
// -------------------------------------------------------------------

class Routes_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Routes.Item) */ {
 public:
  Routes_Item();
  virtual ~Routes_Item();

  Routes_Item(const Routes_Item& from);

  inline Routes_Item& operator=(const Routes_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Routes_Item(Routes_Item&& from) noexcept
    : Routes_Item() {
    *this = ::std::move(from);
  }

  inline Routes_Item& operator=(Routes_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Routes_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Routes_Item* internal_default_instance() {
    return reinterpret_cast<const Routes_Item*>(
               &_Routes_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(Routes_Item* other);
  friend void swap(Routes_Item& a, Routes_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Routes_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Routes_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Routes_Item& from);
  void MergeFrom(const Routes_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Routes_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string destonation = 1;
  void clear_destonation();
  static const int kDestonationFieldNumber = 1;
  const ::std::string& destonation() const;
  void set_destonation(const ::std::string& value);
  #if LANG_CXX11
  void set_destonation(::std::string&& value);
  #endif
  void set_destonation(const char* value);
  void set_destonation(const char* value, size_t size);
  ::std::string* mutable_destonation();
  ::std::string* release_destonation();
  void set_allocated_destonation(::std::string* destonation);

  // string mask = 2;
  void clear_mask();
  static const int kMaskFieldNumber = 2;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // string gateway = 3;
  void clear_gateway();
  static const int kGatewayFieldNumber = 3;
  const ::std::string& gateway() const;
  void set_gateway(const ::std::string& value);
  #if LANG_CXX11
  void set_gateway(::std::string&& value);
  #endif
  void set_gateway(const char* value);
  void set_gateway(const char* value, size_t size);
  ::std::string* mutable_gateway();
  ::std::string* release_gateway();
  void set_allocated_gateway(::std::string* gateway);

  // uint32 metric = 4;
  void clear_metric();
  static const int kMetricFieldNumber = 4;
  ::google::protobuf::uint32 metric() const;
  void set_metric(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Routes.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr destonation_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  ::google::protobuf::internal::ArenaStringPtr gateway_;
  ::google::protobuf::uint32 metric_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsRoutes_ItemImpl();
};
// -------------------------------------------------------------------

class Routes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Routes) */ {
 public:
  Routes();
  virtual ~Routes();

  Routes(const Routes& from);

  inline Routes& operator=(const Routes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Routes(Routes&& from) noexcept
    : Routes() {
    *this = ::std::move(from);
  }

  inline Routes& operator=(Routes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Routes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Routes* internal_default_instance() {
    return reinterpret_cast<const Routes*>(
               &_Routes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(Routes* other);
  friend void swap(Routes& a, Routes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Routes* New() const PROTOBUF_FINAL { return New(NULL); }

  Routes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Routes& from);
  void MergeFrom(const Routes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Routes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Routes_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Routes.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Routes_Item& item(int index) const;
  ::aspia::proto::Routes_Item* mutable_item(int index);
  ::aspia::proto::Routes_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Routes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsRoutesImpl();
};
// -------------------------------------------------------------------

class Users_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Users.Item) */ {
 public:
  Users_Item();
  virtual ~Users_Item();

  Users_Item(const Users_Item& from);

  inline Users_Item& operator=(const Users_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Users_Item(Users_Item&& from) noexcept
    : Users_Item() {
    *this = ::std::move(from);
  }

  inline Users_Item& operator=(Users_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Users_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Users_Item* internal_default_instance() {
    return reinterpret_cast<const Users_Item*>(
               &_Users_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(Users_Item* other);
  friend void swap(Users_Item& a, Users_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Users_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Users_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Users_Item& from);
  void MergeFrom(const Users_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Users_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string full_name = 2;
  void clear_full_name();
  static const int kFullNameFieldNumber = 2;
  const ::std::string& full_name() const;
  void set_full_name(const ::std::string& value);
  #if LANG_CXX11
  void set_full_name(::std::string&& value);
  #endif
  void set_full_name(const char* value);
  void set_full_name(const char* value, size_t size);
  ::std::string* mutable_full_name();
  ::std::string* release_full_name();
  void set_allocated_full_name(::std::string* full_name);

  // string comment = 3;
  void clear_comment();
  static const int kCommentFieldNumber = 3;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // bool is_disabled = 4;
  void clear_is_disabled();
  static const int kIsDisabledFieldNumber = 4;
  bool is_disabled() const;
  void set_is_disabled(bool value);

  // bool is_password_cant_change = 5;
  void clear_is_password_cant_change();
  static const int kIsPasswordCantChangeFieldNumber = 5;
  bool is_password_cant_change() const;
  void set_is_password_cant_change(bool value);

  // bool is_password_expired = 6;
  void clear_is_password_expired();
  static const int kIsPasswordExpiredFieldNumber = 6;
  bool is_password_expired() const;
  void set_is_password_expired(bool value);

  // bool is_dont_expire_password = 7;
  void clear_is_dont_expire_password();
  static const int kIsDontExpirePasswordFieldNumber = 7;
  bool is_dont_expire_password() const;
  void set_is_dont_expire_password(bool value);

  // bool is_lockout = 8;
  void clear_is_lockout();
  static const int kIsLockoutFieldNumber = 8;
  bool is_lockout() const;
  void set_is_lockout(bool value);

  // uint32 number_logons = 9;
  void clear_number_logons();
  static const int kNumberLogonsFieldNumber = 9;
  ::google::protobuf::uint32 number_logons() const;
  void set_number_logons(::google::protobuf::uint32 value);

  // uint32 bad_password_count = 10;
  void clear_bad_password_count();
  static const int kBadPasswordCountFieldNumber = 10;
  ::google::protobuf::uint32 bad_password_count() const;
  void set_bad_password_count(::google::protobuf::uint32 value);

  // int64 last_logon_time = 11;
  void clear_last_logon_time();
  static const int kLastLogonTimeFieldNumber = 11;
  ::google::protobuf::int64 last_logon_time() const;
  void set_last_logon_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Users.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr full_name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  bool is_disabled_;
  bool is_password_cant_change_;
  bool is_password_expired_;
  bool is_dont_expire_password_;
  bool is_lockout_;
  ::google::protobuf::uint32 number_logons_;
  ::google::protobuf::uint32 bad_password_count_;
  ::google::protobuf::int64 last_logon_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUsers_ItemImpl();
};
// -------------------------------------------------------------------

class Users : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Users) */ {
 public:
  Users();
  virtual ~Users();

  Users(const Users& from);

  inline Users& operator=(const Users& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Users(Users&& from) noexcept
    : Users() {
    *this = ::std::move(from);
  }

  inline Users& operator=(Users&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Users& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Users* internal_default_instance() {
    return reinterpret_cast<const Users*>(
               &_Users_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Users* other);
  friend void swap(Users& a, Users& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Users* New() const PROTOBUF_FINAL { return New(NULL); }

  Users* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Users& from);
  void MergeFrom(const Users& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Users* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Users_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Users.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Users_Item& item(int index) const;
  ::aspia::proto::Users_Item* mutable_item(int index);
  ::aspia::proto::Users_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Users)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUsersImpl();
};
// -------------------------------------------------------------------

class UserGroups_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.UserGroups.Item) */ {
 public:
  UserGroups_Item();
  virtual ~UserGroups_Item();

  UserGroups_Item(const UserGroups_Item& from);

  inline UserGroups_Item& operator=(const UserGroups_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserGroups_Item(UserGroups_Item&& from) noexcept
    : UserGroups_Item() {
    *this = ::std::move(from);
  }

  inline UserGroups_Item& operator=(UserGroups_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const UserGroups_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserGroups_Item* internal_default_instance() {
    return reinterpret_cast<const UserGroups_Item*>(
               &_UserGroups_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(UserGroups_Item* other);
  friend void swap(UserGroups_Item& a, UserGroups_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserGroups_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  UserGroups_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserGroups_Item& from);
  void MergeFrom(const UserGroups_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserGroups_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string comment = 2;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:aspia.proto.UserGroups.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUserGroups_ItemImpl();
};
// -------------------------------------------------------------------

class UserGroups : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.UserGroups) */ {
 public:
  UserGroups();
  virtual ~UserGroups();

  UserGroups(const UserGroups& from);

  inline UserGroups& operator=(const UserGroups& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserGroups(UserGroups&& from) noexcept
    : UserGroups() {
    *this = ::std::move(from);
  }

  inline UserGroups& operator=(UserGroups&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const UserGroups& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserGroups* internal_default_instance() {
    return reinterpret_cast<const UserGroups*>(
               &_UserGroups_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(UserGroups* other);
  friend void swap(UserGroups& a, UserGroups& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserGroups* New() const PROTOBUF_FINAL { return New(NULL); }

  UserGroups* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserGroups& from);
  void MergeFrom(const UserGroups& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserGroups* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef UserGroups_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.UserGroups.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::UserGroups_Item& item(int index) const;
  ::aspia::proto::UserGroups_Item* mutable_item(int index);
  ::aspia::proto::UserGroups_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.UserGroups)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUserGroupsImpl();
};
// -------------------------------------------------------------------

class Sessions_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Sessions.Item) */ {
 public:
  Sessions_Item();
  virtual ~Sessions_Item();

  Sessions_Item(const Sessions_Item& from);

  inline Sessions_Item& operator=(const Sessions_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sessions_Item(Sessions_Item&& from) noexcept
    : Sessions_Item() {
    *this = ::std::move(from);
  }

  inline Sessions_Item& operator=(Sessions_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Sessions_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sessions_Item* internal_default_instance() {
    return reinterpret_cast<const Sessions_Item*>(
               &_Sessions_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(Sessions_Item* other);
  friend void swap(Sessions_Item& a, Sessions_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sessions_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Sessions_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Sessions_Item& from);
  void MergeFrom(const Sessions_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sessions_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_name = 1;
  void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& user_name() const;
  void set_user_name(const ::std::string& value);
  #if LANG_CXX11
  void set_user_name(::std::string&& value);
  #endif
  void set_user_name(const char* value);
  void set_user_name(const char* value, size_t size);
  ::std::string* mutable_user_name();
  ::std::string* release_user_name();
  void set_allocated_user_name(::std::string* user_name);

  // string domain_name = 2;
  void clear_domain_name();
  static const int kDomainNameFieldNumber = 2;
  const ::std::string& domain_name() const;
  void set_domain_name(const ::std::string& value);
  #if LANG_CXX11
  void set_domain_name(::std::string&& value);
  #endif
  void set_domain_name(const char* value);
  void set_domain_name(const char* value, size_t size);
  ::std::string* mutable_domain_name();
  ::std::string* release_domain_name();
  void set_allocated_domain_name(::std::string* domain_name);

  // string client_name = 5;
  void clear_client_name();
  static const int kClientNameFieldNumber = 5;
  const ::std::string& client_name() const;
  void set_client_name(const ::std::string& value);
  #if LANG_CXX11
  void set_client_name(::std::string&& value);
  #endif
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  ::std::string* mutable_client_name();
  ::std::string* release_client_name();
  void set_allocated_client_name(::std::string* client_name);

  // string winstation_name = 6;
  void clear_winstation_name();
  static const int kWinstationNameFieldNumber = 6;
  const ::std::string& winstation_name() const;
  void set_winstation_name(const ::std::string& value);
  #if LANG_CXX11
  void set_winstation_name(::std::string&& value);
  #endif
  void set_winstation_name(const char* value);
  void set_winstation_name(const char* value, size_t size);
  ::std::string* mutable_winstation_name();
  ::std::string* release_winstation_name();
  void set_allocated_winstation_name(::std::string* winstation_name);

  // uint32 session_id = 3;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  ::google::protobuf::uint32 session_id() const;
  void set_session_id(::google::protobuf::uint32 value);

  // .aspia.proto.Sessions.ConnectState connect_state = 4;
  void clear_connect_state();
  static const int kConnectStateFieldNumber = 4;
  ::aspia::proto::Sessions_ConnectState connect_state() const;
  void set_connect_state(::aspia::proto::Sessions_ConnectState value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Sessions.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  ::google::protobuf::internal::ArenaStringPtr domain_name_;
  ::google::protobuf::internal::ArenaStringPtr client_name_;
  ::google::protobuf::internal::ArenaStringPtr winstation_name_;
  ::google::protobuf::uint32 session_id_;
  int connect_state_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSessions_ItemImpl();
};
// -------------------------------------------------------------------

class Sessions : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Sessions) */ {
 public:
  Sessions();
  virtual ~Sessions();

  Sessions(const Sessions& from);

  inline Sessions& operator=(const Sessions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sessions(Sessions&& from) noexcept
    : Sessions() {
    *this = ::std::move(from);
  }

  inline Sessions& operator=(Sessions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Sessions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sessions* internal_default_instance() {
    return reinterpret_cast<const Sessions*>(
               &_Sessions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(Sessions* other);
  friend void swap(Sessions& a, Sessions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sessions* New() const PROTOBUF_FINAL { return New(NULL); }

  Sessions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Sessions& from);
  void MergeFrom(const Sessions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sessions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Sessions_Item Item;

  typedef Sessions_ConnectState ConnectState;
  static const ConnectState CONNECT_STATE_UNKNOWN =
    Sessions_ConnectState_CONNECT_STATE_UNKNOWN;
  static const ConnectState CONNECT_STATE_ACTIVE =
    Sessions_ConnectState_CONNECT_STATE_ACTIVE;
  static const ConnectState CONNECT_STATE_CONNECTED =
    Sessions_ConnectState_CONNECT_STATE_CONNECTED;
  static const ConnectState CONNECT_STATE_CONNECT_QUERY =
    Sessions_ConnectState_CONNECT_STATE_CONNECT_QUERY;
  static const ConnectState CONNECT_STATE_SHADOW =
    Sessions_ConnectState_CONNECT_STATE_SHADOW;
  static const ConnectState CONNECT_STATE_DISCONNECTED =
    Sessions_ConnectState_CONNECT_STATE_DISCONNECTED;
  static const ConnectState CONNECT_STATE_IDLE =
    Sessions_ConnectState_CONNECT_STATE_IDLE;
  static const ConnectState CONNECT_STATE_LISTEN =
    Sessions_ConnectState_CONNECT_STATE_LISTEN;
  static const ConnectState CONNECT_STATE_RESET =
    Sessions_ConnectState_CONNECT_STATE_RESET;
  static const ConnectState CONNECT_STATE_DOWN =
    Sessions_ConnectState_CONNECT_STATE_DOWN;
  static const ConnectState CONNECT_STATE_INIT =
    Sessions_ConnectState_CONNECT_STATE_INIT;
  static inline bool ConnectState_IsValid(int value) {
    return Sessions_ConnectState_IsValid(value);
  }
  static const ConnectState ConnectState_MIN =
    Sessions_ConnectState_ConnectState_MIN;
  static const ConnectState ConnectState_MAX =
    Sessions_ConnectState_ConnectState_MAX;
  static const int ConnectState_ARRAYSIZE =
    Sessions_ConnectState_ConnectState_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Sessions.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Sessions_Item& item(int index) const;
  ::aspia::proto::Sessions_Item* mutable_item(int index);
  ::aspia::proto::Sessions_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Sessions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSessionsImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DmiPortConnectors_Item

// string internal_designation = 1;
inline void DmiPortConnectors_Item::clear_internal_designation() {
  internal_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnectors_Item::internal_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.internal_designation)
  return internal_designation_.GetNoArena();
}
inline void DmiPortConnectors_Item::set_internal_designation(const ::std::string& value) {
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
#if LANG_CXX11
inline void DmiPortConnectors_Item::set_internal_designation(::std::string&& value) {
  
  internal_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
#endif
inline void DmiPortConnectors_Item::set_internal_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
inline void DmiPortConnectors_Item::set_internal_designation(const char* value, size_t size) {
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
inline ::std::string* DmiPortConnectors_Item::mutable_internal_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.Item.internal_designation)
  return internal_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnectors_Item::release_internal_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnectors.Item.internal_designation)
  
  return internal_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnectors_Item::set_allocated_internal_designation(::std::string* internal_designation) {
  if (internal_designation != NULL) {
    
  } else {
    
  }
  internal_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), internal_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnectors.Item.internal_designation)
}

// string external_designation = 2;
inline void DmiPortConnectors_Item::clear_external_designation() {
  external_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnectors_Item::external_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.external_designation)
  return external_designation_.GetNoArena();
}
inline void DmiPortConnectors_Item::set_external_designation(const ::std::string& value) {
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.external_designation)
}
#if LANG_CXX11
inline void DmiPortConnectors_Item::set_external_designation(::std::string&& value) {
  
  external_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnectors.Item.external_designation)
}
#endif
inline void DmiPortConnectors_Item::set_external_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnectors.Item.external_designation)
}
inline void DmiPortConnectors_Item::set_external_designation(const char* value, size_t size) {
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnectors.Item.external_designation)
}
inline ::std::string* DmiPortConnectors_Item::mutable_external_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.Item.external_designation)
  return external_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnectors_Item::release_external_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnectors.Item.external_designation)
  
  return external_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnectors_Item::set_allocated_external_designation(::std::string* external_designation) {
  if (external_designation != NULL) {
    
  } else {
    
  }
  external_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), external_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnectors.Item.external_designation)
}

// .aspia.proto.DmiPortConnectors.Type type = 3;
inline void DmiPortConnectors_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiPortConnectors_Type DmiPortConnectors_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.type)
  return static_cast< ::aspia::proto::DmiPortConnectors_Type >(type_);
}
inline void DmiPortConnectors_Item::set_type(::aspia::proto::DmiPortConnectors_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.type)
}

// .aspia.proto.DmiPortConnectors.ConnectorType internal_connector_type = 4;
inline void DmiPortConnectors_Item::clear_internal_connector_type() {
  internal_connector_type_ = 0;
}
inline ::aspia::proto::DmiPortConnectors_ConnectorType DmiPortConnectors_Item::internal_connector_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
  return static_cast< ::aspia::proto::DmiPortConnectors_ConnectorType >(internal_connector_type_);
}
inline void DmiPortConnectors_Item::set_internal_connector_type(::aspia::proto::DmiPortConnectors_ConnectorType value) {
  
  internal_connector_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
}

// .aspia.proto.DmiPortConnectors.ConnectorType external_connector_type = 5;
inline void DmiPortConnectors_Item::clear_external_connector_type() {
  external_connector_type_ = 0;
}
inline ::aspia::proto::DmiPortConnectors_ConnectorType DmiPortConnectors_Item::external_connector_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.external_connector_type)
  return static_cast< ::aspia::proto::DmiPortConnectors_ConnectorType >(external_connector_type_);
}
inline void DmiPortConnectors_Item::set_external_connector_type(::aspia::proto::DmiPortConnectors_ConnectorType value) {
  
  external_connector_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.external_connector_type)
}

// -------------------------------------------------------------------

// DmiPortConnectors

// repeated .aspia.proto.DmiPortConnectors.Item item = 1;
inline int DmiPortConnectors::item_size() const {
  return item_.size();
}
inline void DmiPortConnectors::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiPortConnectors_Item& DmiPortConnectors::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiPortConnectors_Item* DmiPortConnectors::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiPortConnectors_Item* DmiPortConnectors::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiPortConnectors.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >*
DmiPortConnectors::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiPortConnectors.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >&
DmiPortConnectors::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiPortConnectors.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiOnBoardDevices_Item

// string description = 1;
inline void DmiOnBoardDevices_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiOnBoardDevices_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.Item.description)
  return description_.GetNoArena();
}
inline void DmiOnBoardDevices_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiOnBoardDevices.Item.description)
}
#if LANG_CXX11
inline void DmiOnBoardDevices_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiOnBoardDevices.Item.description)
}
#endif
inline void DmiOnBoardDevices_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiOnBoardDevices.Item.description)
}
inline void DmiOnBoardDevices_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiOnBoardDevices.Item.description)
}
inline ::std::string* DmiOnBoardDevices_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiOnBoardDevices.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiOnBoardDevices_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiOnBoardDevices.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiOnBoardDevices_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiOnBoardDevices.Item.description)
}

// .aspia.proto.DmiOnBoardDevices.Type type = 2;
inline void DmiOnBoardDevices_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiOnBoardDevices_Type DmiOnBoardDevices_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.Item.type)
  return static_cast< ::aspia::proto::DmiOnBoardDevices_Type >(type_);
}
inline void DmiOnBoardDevices_Item::set_type(::aspia::proto::DmiOnBoardDevices_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiOnBoardDevices.Item.type)
}

// bool enabled = 3;
inline void DmiOnBoardDevices_Item::clear_enabled() {
  enabled_ = false;
}
inline bool DmiOnBoardDevices_Item::enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.Item.enabled)
  return enabled_;
}
inline void DmiOnBoardDevices_Item::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiOnBoardDevices.Item.enabled)
}

// -------------------------------------------------------------------

// DmiOnBoardDevices

// repeated .aspia.proto.DmiOnBoardDevices.Item item = 1;
inline int DmiOnBoardDevices::item_size() const {
  return item_.size();
}
inline void DmiOnBoardDevices::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiOnBoardDevices_Item& DmiOnBoardDevices::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiOnBoardDevices_Item* DmiOnBoardDevices::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiOnBoardDevices.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiOnBoardDevices_Item* DmiOnBoardDevices::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiOnBoardDevices.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >*
DmiOnBoardDevices::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiOnBoardDevices.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >&
DmiOnBoardDevices::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiOnBoardDevices.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiPointingDevices_Item

// .aspia.proto.DmiPointingDevices.Type device_type = 1;
inline void DmiPointingDevices_Item::clear_device_type() {
  device_type_ = 0;
}
inline ::aspia::proto::DmiPointingDevices_Type DmiPointingDevices_Item::device_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPointingDevices.Item.device_type)
  return static_cast< ::aspia::proto::DmiPointingDevices_Type >(device_type_);
}
inline void DmiPointingDevices_Item::set_device_type(::aspia::proto::DmiPointingDevices_Type value) {
  
  device_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPointingDevices.Item.device_type)
}

// .aspia.proto.DmiPointingDevices.Interface device_interface = 2;
inline void DmiPointingDevices_Item::clear_device_interface() {
  device_interface_ = 0;
}
inline ::aspia::proto::DmiPointingDevices_Interface DmiPointingDevices_Item::device_interface() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPointingDevices.Item.device_interface)
  return static_cast< ::aspia::proto::DmiPointingDevices_Interface >(device_interface_);
}
inline void DmiPointingDevices_Item::set_device_interface(::aspia::proto::DmiPointingDevices_Interface value) {
  
  device_interface_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPointingDevices.Item.device_interface)
}

// int32 button_count = 3;
inline void DmiPointingDevices_Item::clear_button_count() {
  button_count_ = 0;
}
inline ::google::protobuf::int32 DmiPointingDevices_Item::button_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPointingDevices.Item.button_count)
  return button_count_;
}
inline void DmiPointingDevices_Item::set_button_count(::google::protobuf::int32 value) {
  
  button_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPointingDevices.Item.button_count)
}

// -------------------------------------------------------------------

// DmiPointingDevices

// repeated .aspia.proto.DmiPointingDevices.Item item = 1;
inline int DmiPointingDevices::item_size() const {
  return item_.size();
}
inline void DmiPointingDevices::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiPointingDevices_Item& DmiPointingDevices::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPointingDevices.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiPointingDevices_Item* DmiPointingDevices::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPointingDevices.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiPointingDevices_Item* DmiPointingDevices::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiPointingDevices.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevices_Item >*
DmiPointingDevices::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiPointingDevices.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevices_Item >&
DmiPointingDevices::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiPointingDevices.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiPortableBattery_Item

// string location = 1;
inline void DmiPortableBattery_Item::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.location)
  return location_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.location)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.location)
}
#endif
inline void DmiPortableBattery_Item::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.location)
}
inline void DmiPortableBattery_Item::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.location)
}
inline ::std::string* DmiPortableBattery_Item::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_location() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.location)
}

// string manufacturer = 2;
inline void DmiPortableBattery_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
#endif
inline void DmiPortableBattery_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
inline void DmiPortableBattery_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
inline ::std::string* DmiPortableBattery_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.manufacturer)
}

// string manufacture_date = 3;
inline void DmiPortableBattery_Item::clear_manufacture_date() {
  manufacture_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::manufacture_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.manufacture_date)
  return manufacture_date_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_manufacture_date(const ::std::string& value) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_manufacture_date(::std::string&& value) {
  
  manufacture_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
#endif
inline void DmiPortableBattery_Item::set_manufacture_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
inline void DmiPortableBattery_Item::set_manufacture_date(const char* value, size_t size) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
inline ::std::string* DmiPortableBattery_Item::mutable_manufacture_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.manufacture_date)
  return manufacture_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_manufacture_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.manufacture_date)
  
  return manufacture_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_manufacture_date(::std::string* manufacture_date) {
  if (manufacture_date != NULL) {
    
  } else {
    
  }
  manufacture_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacture_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}

// string serial_number = 4;
inline void DmiPortableBattery_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.serial_number)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.serial_number)
}
#endif
inline void DmiPortableBattery_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.serial_number)
}
inline void DmiPortableBattery_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.serial_number)
}
inline ::std::string* DmiPortableBattery_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.serial_number)
}

// string device_name = 5;
inline void DmiPortableBattery_Item::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::device_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.device_name)
  return device_name_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_device_name(const ::std::string& value) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.device_name)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_device_name(::std::string&& value) {
  
  device_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.device_name)
}
#endif
inline void DmiPortableBattery_Item::set_device_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.device_name)
}
inline void DmiPortableBattery_Item::set_device_name(const char* value, size_t size) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.device_name)
}
inline ::std::string* DmiPortableBattery_Item::mutable_device_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_device_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.device_name)
  
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    
  } else {
    
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.device_name)
}

// .aspia.proto.DmiPortableBattery.Chemistry chemistry = 6;
inline void DmiPortableBattery_Item::clear_chemistry() {
  chemistry_ = 0;
}
inline ::aspia::proto::DmiPortableBattery_Chemistry DmiPortableBattery_Item::chemistry() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.chemistry)
  return static_cast< ::aspia::proto::DmiPortableBattery_Chemistry >(chemistry_);
}
inline void DmiPortableBattery_Item::set_chemistry(::aspia::proto::DmiPortableBattery_Chemistry value) {
  
  chemistry_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.chemistry)
}

// int32 design_capacity = 7;
inline void DmiPortableBattery_Item::clear_design_capacity() {
  design_capacity_ = 0;
}
inline ::google::protobuf::int32 DmiPortableBattery_Item::design_capacity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.design_capacity)
  return design_capacity_;
}
inline void DmiPortableBattery_Item::set_design_capacity(::google::protobuf::int32 value) {
  
  design_capacity_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.design_capacity)
}

// int32 design_voltage = 8;
inline void DmiPortableBattery_Item::clear_design_voltage() {
  design_voltage_ = 0;
}
inline ::google::protobuf::int32 DmiPortableBattery_Item::design_voltage() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.design_voltage)
  return design_voltage_;
}
inline void DmiPortableBattery_Item::set_design_voltage(::google::protobuf::int32 value) {
  
  design_voltage_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.design_voltage)
}

// string sbds_version_number = 9;
inline void DmiPortableBattery_Item::clear_sbds_version_number() {
  sbds_version_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_version_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
  return sbds_version_number_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_version_number(const ::std::string& value) {
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_version_number(::std::string&& value) {
  
  sbds_version_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_version_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
inline void DmiPortableBattery_Item::set_sbds_version_number(const char* value, size_t size) {
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_version_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
  return sbds_version_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_version_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
  
  return sbds_version_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_version_number(::std::string* sbds_version_number) {
  if (sbds_version_number != NULL) {
    
  } else {
    
  }
  sbds_version_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_version_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}

// int32 max_error_in_battery_data = 10;
inline void DmiPortableBattery_Item::clear_max_error_in_battery_data() {
  max_error_in_battery_data_ = 0;
}
inline ::google::protobuf::int32 DmiPortableBattery_Item::max_error_in_battery_data() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.max_error_in_battery_data)
  return max_error_in_battery_data_;
}
inline void DmiPortableBattery_Item::set_max_error_in_battery_data(::google::protobuf::int32 value) {
  
  max_error_in_battery_data_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.max_error_in_battery_data)
}

// string sbds_serial_number = 11;
inline void DmiPortableBattery_Item::clear_sbds_serial_number() {
  sbds_serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
  return sbds_serial_number_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_serial_number(const ::std::string& value) {
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_serial_number(::std::string&& value) {
  
  sbds_serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
inline void DmiPortableBattery_Item::set_sbds_serial_number(const char* value, size_t size) {
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
  return sbds_serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
  
  return sbds_serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_serial_number(::std::string* sbds_serial_number) {
  if (sbds_serial_number != NULL) {
    
  } else {
    
  }
  sbds_serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}

// string sbds_manufacture_date = 12;
inline void DmiPortableBattery_Item::clear_sbds_manufacture_date() {
  sbds_manufacture_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_manufacture_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
  return sbds_manufacture_date_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(const ::std::string& value) {
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(::std::string&& value) {
  
  sbds_manufacture_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(const char* value, size_t size) {
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_manufacture_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
  return sbds_manufacture_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_manufacture_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
  
  return sbds_manufacture_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_manufacture_date(::std::string* sbds_manufacture_date) {
  if (sbds_manufacture_date != NULL) {
    
  } else {
    
  }
  sbds_manufacture_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_manufacture_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}

// string sbds_device_chemistry = 13;
inline void DmiPortableBattery_Item::clear_sbds_device_chemistry() {
  sbds_device_chemistry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_device_chemistry() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
  return sbds_device_chemistry_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(const ::std::string& value) {
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(::std::string&& value) {
  
  sbds_device_chemistry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(const char* value, size_t size) {
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_device_chemistry() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
  return sbds_device_chemistry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_device_chemistry() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
  
  return sbds_device_chemistry_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_device_chemistry(::std::string* sbds_device_chemistry) {
  if (sbds_device_chemistry != NULL) {
    
  } else {
    
  }
  sbds_device_chemistry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_device_chemistry);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}

// -------------------------------------------------------------------

// DmiPortableBattery

// repeated .aspia.proto.DmiPortableBattery.Item item = 1;
inline int DmiPortableBattery::item_size() const {
  return item_.size();
}
inline void DmiPortableBattery::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiPortableBattery_Item& DmiPortableBattery::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiPortableBattery_Item* DmiPortableBattery::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiPortableBattery_Item* DmiPortableBattery::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiPortableBattery.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >*
DmiPortableBattery::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiPortableBattery.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >&
DmiPortableBattery::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiPortableBattery.item)
  return item_;
}

// -------------------------------------------------------------------

// Programs_Item

// string name = 1;
inline void Programs_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.name)
  return name_.GetNoArena();
}
inline void Programs_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.name)
}
#if LANG_CXX11
inline void Programs_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.name)
}
#endif
inline void Programs_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.name)
}
inline void Programs_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.name)
}
inline ::std::string* Programs_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.name)
}

// string version = 2;
inline void Programs_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.version)
  return version_.GetNoArena();
}
inline void Programs_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.version)
}
#if LANG_CXX11
inline void Programs_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.version)
}
#endif
inline void Programs_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.version)
}
inline void Programs_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.version)
}
inline ::std::string* Programs_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.version)
}

// string publisher = 3;
inline void Programs_Item::clear_publisher() {
  publisher_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::publisher() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.publisher)
  return publisher_.GetNoArena();
}
inline void Programs_Item::set_publisher(const ::std::string& value) {
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.publisher)
}
#if LANG_CXX11
inline void Programs_Item::set_publisher(::std::string&& value) {
  
  publisher_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.publisher)
}
#endif
inline void Programs_Item::set_publisher(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.publisher)
}
inline void Programs_Item::set_publisher(const char* value, size_t size) {
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.publisher)
}
inline ::std::string* Programs_Item::mutable_publisher() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.publisher)
  return publisher_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_publisher() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.publisher)
  
  return publisher_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_publisher(::std::string* publisher) {
  if (publisher != NULL) {
    
  } else {
    
  }
  publisher_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publisher);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.publisher)
}

// string install_date = 4;
inline void Programs_Item::clear_install_date() {
  install_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::install_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.install_date)
  return install_date_.GetNoArena();
}
inline void Programs_Item::set_install_date(const ::std::string& value) {
  
  install_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.install_date)
}
#if LANG_CXX11
inline void Programs_Item::set_install_date(::std::string&& value) {
  
  install_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.install_date)
}
#endif
inline void Programs_Item::set_install_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  install_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.install_date)
}
inline void Programs_Item::set_install_date(const char* value, size_t size) {
  
  install_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.install_date)
}
inline ::std::string* Programs_Item::mutable_install_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.install_date)
  return install_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_install_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.install_date)
  
  return install_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_install_date(::std::string* install_date) {
  if (install_date != NULL) {
    
  } else {
    
  }
  install_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), install_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.install_date)
}

// string install_location = 5;
inline void Programs_Item::clear_install_location() {
  install_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::install_location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.install_location)
  return install_location_.GetNoArena();
}
inline void Programs_Item::set_install_location(const ::std::string& value) {
  
  install_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.install_location)
}
#if LANG_CXX11
inline void Programs_Item::set_install_location(::std::string&& value) {
  
  install_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.install_location)
}
#endif
inline void Programs_Item::set_install_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  install_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.install_location)
}
inline void Programs_Item::set_install_location(const char* value, size_t size) {
  
  install_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.install_location)
}
inline ::std::string* Programs_Item::mutable_install_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.install_location)
  return install_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_install_location() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.install_location)
  
  return install_location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_install_location(::std::string* install_location) {
  if (install_location != NULL) {
    
  } else {
    
  }
  install_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), install_location);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.install_location)
}

// -------------------------------------------------------------------

// Programs

// repeated .aspia.proto.Programs.Item item = 1;
inline int Programs::item_size() const {
  return item_.size();
}
inline void Programs::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Programs_Item& Programs::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.item)
  return item_.Get(index);
}
inline ::aspia::proto::Programs_Item* Programs::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Programs_Item* Programs::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Programs.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >*
Programs::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Programs.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >&
Programs::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Programs.item)
  return item_;
}

// -------------------------------------------------------------------

// Services_Item

// string name = 1;
inline void Services_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.name)
  return name_.GetNoArena();
}
inline void Services_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.name)
}
#if LANG_CXX11
inline void Services_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.name)
}
#endif
inline void Services_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.name)
}
inline void Services_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.name)
}
inline ::std::string* Services_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.name)
}

// string display_name = 2;
inline void Services_Item::clear_display_name() {
  display_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::display_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.display_name)
  return display_name_.GetNoArena();
}
inline void Services_Item::set_display_name(const ::std::string& value) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.display_name)
}
#if LANG_CXX11
inline void Services_Item::set_display_name(::std::string&& value) {
  
  display_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.display_name)
}
#endif
inline void Services_Item::set_display_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.display_name)
}
inline void Services_Item::set_display_name(const char* value, size_t size) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.display_name)
}
inline ::std::string* Services_Item::mutable_display_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.display_name)
  return display_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_display_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.display_name)
  
  return display_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_display_name(::std::string* display_name) {
  if (display_name != NULL) {
    
  } else {
    
  }
  display_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.display_name)
}

// string description = 3;
inline void Services_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.description)
  return description_.GetNoArena();
}
inline void Services_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.description)
}
#if LANG_CXX11
inline void Services_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.description)
}
#endif
inline void Services_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.description)
}
inline void Services_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.description)
}
inline ::std::string* Services_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.description)
}

// .aspia.proto.Services.Item.Status status = 4;
inline void Services_Item::clear_status() {
  status_ = 0;
}
inline ::aspia::proto::Services_Item_Status Services_Item::status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.status)
  return static_cast< ::aspia::proto::Services_Item_Status >(status_);
}
inline void Services_Item::set_status(::aspia::proto::Services_Item_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.status)
}

// .aspia.proto.Services.Item.StartupType startup_type = 5;
inline void Services_Item::clear_startup_type() {
  startup_type_ = 0;
}
inline ::aspia::proto::Services_Item_StartupType Services_Item::startup_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.startup_type)
  return static_cast< ::aspia::proto::Services_Item_StartupType >(startup_type_);
}
inline void Services_Item::set_startup_type(::aspia::proto::Services_Item_StartupType value) {
  
  startup_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.startup_type)
}

// string binary_path = 6;
inline void Services_Item::clear_binary_path() {
  binary_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::binary_path() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.binary_path)
  return binary_path_.GetNoArena();
}
inline void Services_Item::set_binary_path(const ::std::string& value) {
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.binary_path)
}
#if LANG_CXX11
inline void Services_Item::set_binary_path(::std::string&& value) {
  
  binary_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.binary_path)
}
#endif
inline void Services_Item::set_binary_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.binary_path)
}
inline void Services_Item::set_binary_path(const char* value, size_t size) {
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.binary_path)
}
inline ::std::string* Services_Item::mutable_binary_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.binary_path)
  return binary_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_binary_path() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.binary_path)
  
  return binary_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_binary_path(::std::string* binary_path) {
  if (binary_path != NULL) {
    
  } else {
    
  }
  binary_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), binary_path);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.binary_path)
}

// string start_name = 7;
inline void Services_Item::clear_start_name() {
  start_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::start_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.start_name)
  return start_name_.GetNoArena();
}
inline void Services_Item::set_start_name(const ::std::string& value) {
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.start_name)
}
#if LANG_CXX11
inline void Services_Item::set_start_name(::std::string&& value) {
  
  start_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.start_name)
}
#endif
inline void Services_Item::set_start_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.start_name)
}
inline void Services_Item::set_start_name(const char* value, size_t size) {
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.start_name)
}
inline ::std::string* Services_Item::mutable_start_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.start_name)
  return start_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_start_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.start_name)
  
  return start_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_start_name(::std::string* start_name) {
  if (start_name != NULL) {
    
  } else {
    
  }
  start_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.start_name)
}

// -------------------------------------------------------------------

// Services

// repeated .aspia.proto.Services.Item item = 1;
inline int Services::item_size() const {
  return item_.size();
}
inline void Services::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Services_Item& Services::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.item)
  return item_.Get(index);
}
inline ::aspia::proto::Services_Item* Services::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Services_Item* Services::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Services.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >*
Services::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Services.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >&
Services::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Services.item)
  return item_;
}

// -------------------------------------------------------------------

// NetworkCards_Item_IpAddress

// string address = 1;
inline void NetworkCards_Item_IpAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item_IpAddress::address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.IpAddress.address)
  return address_.GetNoArena();
}
inline void NetworkCards_Item_IpAddress::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.IpAddress.address)
}
#if LANG_CXX11
inline void NetworkCards_Item_IpAddress::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.IpAddress.address)
}
#endif
inline void NetworkCards_Item_IpAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.IpAddress.address)
}
inline void NetworkCards_Item_IpAddress::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.IpAddress.address)
}
inline ::std::string* NetworkCards_Item_IpAddress::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.IpAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item_IpAddress::release_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.IpAddress.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item_IpAddress::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.IpAddress.address)
}

// string mask = 2;
inline void NetworkCards_Item_IpAddress::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item_IpAddress::mask() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.IpAddress.mask)
  return mask_.GetNoArena();
}
inline void NetworkCards_Item_IpAddress::set_mask(const ::std::string& value) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
#if LANG_CXX11
inline void NetworkCards_Item_IpAddress::set_mask(::std::string&& value) {
  
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
#endif
inline void NetworkCards_Item_IpAddress::set_mask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
inline void NetworkCards_Item_IpAddress::set_mask(const char* value, size_t size) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
inline ::std::string* NetworkCards_Item_IpAddress::mutable_mask() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.IpAddress.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item_IpAddress::release_mask() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.IpAddress.mask)
  
  return mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item_IpAddress::set_allocated_mask(::std::string* mask) {
  if (mask != NULL) {
    
  } else {
    
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.IpAddress.mask)
}

// -------------------------------------------------------------------

// NetworkCards_Item

// string adapter_name = 1;
inline void NetworkCards_Item::clear_adapter_name() {
  adapter_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::adapter_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.adapter_name)
  return adapter_name_.GetNoArena();
}
inline void NetworkCards_Item::set_adapter_name(const ::std::string& value) {
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.adapter_name)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_adapter_name(::std::string&& value) {
  
  adapter_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.adapter_name)
}
#endif
inline void NetworkCards_Item::set_adapter_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.adapter_name)
}
inline void NetworkCards_Item::set_adapter_name(const char* value, size_t size) {
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.adapter_name)
}
inline ::std::string* NetworkCards_Item::mutable_adapter_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.adapter_name)
  return adapter_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_adapter_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.adapter_name)
  
  return adapter_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_adapter_name(::std::string* adapter_name) {
  if (adapter_name != NULL) {
    
  } else {
    
  }
  adapter_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adapter_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.adapter_name)
}

// string connection_name = 2;
inline void NetworkCards_Item::clear_connection_name() {
  connection_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::connection_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.connection_name)
  return connection_name_.GetNoArena();
}
inline void NetworkCards_Item::set_connection_name(const ::std::string& value) {
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.connection_name)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_connection_name(::std::string&& value) {
  
  connection_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.connection_name)
}
#endif
inline void NetworkCards_Item::set_connection_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.connection_name)
}
inline void NetworkCards_Item::set_connection_name(const char* value, size_t size) {
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.connection_name)
}
inline ::std::string* NetworkCards_Item::mutable_connection_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.connection_name)
  return connection_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_connection_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.connection_name)
  
  return connection_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_connection_name(::std::string* connection_name) {
  if (connection_name != NULL) {
    
  } else {
    
  }
  connection_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connection_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.connection_name)
}

// string interface_type = 3;
inline void NetworkCards_Item::clear_interface_type() {
  interface_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::interface_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.interface_type)
  return interface_type_.GetNoArena();
}
inline void NetworkCards_Item::set_interface_type(const ::std::string& value) {
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.interface_type)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_interface_type(::std::string&& value) {
  
  interface_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.interface_type)
}
#endif
inline void NetworkCards_Item::set_interface_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.interface_type)
}
inline void NetworkCards_Item::set_interface_type(const char* value, size_t size) {
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.interface_type)
}
inline ::std::string* NetworkCards_Item::mutable_interface_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.interface_type)
  return interface_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_interface_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.interface_type)
  
  return interface_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_interface_type(::std::string* interface_type) {
  if (interface_type != NULL) {
    
  } else {
    
  }
  interface_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), interface_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.interface_type)
}

// uint32 mtu = 4;
inline void NetworkCards_Item::clear_mtu() {
  mtu_ = 0u;
}
inline ::google::protobuf::uint32 NetworkCards_Item::mtu() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.mtu)
  return mtu_;
}
inline void NetworkCards_Item::set_mtu(::google::protobuf::uint32 value) {
  
  mtu_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.mtu)
}

// uint32 speed = 5;
inline void NetworkCards_Item::clear_speed() {
  speed_ = 0u;
}
inline ::google::protobuf::uint32 NetworkCards_Item::speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.speed)
  return speed_;
}
inline void NetworkCards_Item::set_speed(::google::protobuf::uint32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.speed)
}

// string mac_address = 6;
inline void NetworkCards_Item::clear_mac_address() {
  mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::mac_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.mac_address)
  return mac_address_.GetNoArena();
}
inline void NetworkCards_Item::set_mac_address(const ::std::string& value) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.mac_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_mac_address(::std::string&& value) {
  
  mac_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.mac_address)
}
#endif
inline void NetworkCards_Item::set_mac_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.mac_address)
}
inline void NetworkCards_Item::set_mac_address(const char* value, size_t size) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.mac_address)
}
inline ::std::string* NetworkCards_Item::mutable_mac_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.mac_address)
  return mac_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_mac_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.mac_address)
  
  return mac_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_mac_address(::std::string* mac_address) {
  if (mac_address != NULL) {
    
  } else {
    
  }
  mac_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.mac_address)
}

// bool is_wins_enabled = 7;
inline void NetworkCards_Item::clear_is_wins_enabled() {
  is_wins_enabled_ = false;
}
inline bool NetworkCards_Item::is_wins_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.is_wins_enabled)
  return is_wins_enabled_;
}
inline void NetworkCards_Item::set_is_wins_enabled(bool value) {
  
  is_wins_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.is_wins_enabled)
}

// string primary_wins_server = 8;
inline void NetworkCards_Item::clear_primary_wins_server() {
  primary_wins_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::primary_wins_server() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.primary_wins_server)
  return primary_wins_server_.GetNoArena();
}
inline void NetworkCards_Item::set_primary_wins_server(const ::std::string& value) {
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.primary_wins_server)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_primary_wins_server(::std::string&& value) {
  
  primary_wins_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.primary_wins_server)
}
#endif
inline void NetworkCards_Item::set_primary_wins_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.primary_wins_server)
}
inline void NetworkCards_Item::set_primary_wins_server(const char* value, size_t size) {
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.primary_wins_server)
}
inline ::std::string* NetworkCards_Item::mutable_primary_wins_server() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.primary_wins_server)
  return primary_wins_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_primary_wins_server() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.primary_wins_server)
  
  return primary_wins_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_primary_wins_server(::std::string* primary_wins_server) {
  if (primary_wins_server != NULL) {
    
  } else {
    
  }
  primary_wins_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_wins_server);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.primary_wins_server)
}

// string secondary_wins_server = 9;
inline void NetworkCards_Item::clear_secondary_wins_server() {
  secondary_wins_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::secondary_wins_server() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.secondary_wins_server)
  return secondary_wins_server_.GetNoArena();
}
inline void NetworkCards_Item::set_secondary_wins_server(const ::std::string& value) {
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_secondary_wins_server(::std::string&& value) {
  
  secondary_wins_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
#endif
inline void NetworkCards_Item::set_secondary_wins_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
inline void NetworkCards_Item::set_secondary_wins_server(const char* value, size_t size) {
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
inline ::std::string* NetworkCards_Item::mutable_secondary_wins_server() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.secondary_wins_server)
  return secondary_wins_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_secondary_wins_server() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.secondary_wins_server)
  
  return secondary_wins_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_secondary_wins_server(::std::string* secondary_wins_server) {
  if (secondary_wins_server != NULL) {
    
  } else {
    
  }
  secondary_wins_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secondary_wins_server);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.secondary_wins_server)
}

// bool is_dhcp_enabled = 10;
inline void NetworkCards_Item::clear_is_dhcp_enabled() {
  is_dhcp_enabled_ = false;
}
inline bool NetworkCards_Item::is_dhcp_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.is_dhcp_enabled)
  return is_dhcp_enabled_;
}
inline void NetworkCards_Item::set_is_dhcp_enabled(bool value) {
  
  is_dhcp_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.is_dhcp_enabled)
}

// repeated .aspia.proto.NetworkCards.Item.IpAddress ip_address = 11;
inline int NetworkCards_Item::ip_address_size() const {
  return ip_address_.size();
}
inline void NetworkCards_Item::clear_ip_address() {
  ip_address_.Clear();
}
inline const ::aspia::proto::NetworkCards_Item_IpAddress& NetworkCards_Item::ip_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_.Get(index);
}
inline ::aspia::proto::NetworkCards_Item_IpAddress* NetworkCards_Item::mutable_ip_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_.Mutable(index);
}
inline ::aspia::proto::NetworkCards_Item_IpAddress* NetworkCards_Item::add_ip_address() {
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >*
NetworkCards_Item::mutable_ip_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.ip_address)
  return &ip_address_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >&
NetworkCards_Item::ip_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_;
}

// repeated string gateway_address = 12;
inline int NetworkCards_Item::gateway_address_size() const {
  return gateway_address_.size();
}
inline void NetworkCards_Item::clear_gateway_address() {
  gateway_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::gateway_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_gateway_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_.Mutable(index);
}
inline void NetworkCards_Item::set_gateway_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.gateway_address)
  gateway_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_gateway_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.gateway_address)
  gateway_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_gateway_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  gateway_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.gateway_address)
}
inline void NetworkCards_Item::set_gateway_address(int index, const char* value, size_t size) {
  gateway_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.gateway_address)
}
inline ::std::string* NetworkCards_Item::add_gateway_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_.Add();
}
inline void NetworkCards_Item::add_gateway_address(const ::std::string& value) {
  gateway_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.gateway_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_gateway_address(::std::string&& value) {
  gateway_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.gateway_address)
}
#endif
inline void NetworkCards_Item::add_gateway_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  gateway_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.proto.NetworkCards.Item.gateway_address)
}
inline void NetworkCards_Item::add_gateway_address(const char* value, size_t size) {
  gateway_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.proto.NetworkCards.Item.gateway_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::gateway_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_gateway_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.gateway_address)
  return &gateway_address_;
}

// repeated string dhcp_server_address = 13;
inline int NetworkCards_Item::dhcp_server_address_size() const {
  return dhcp_server_address_.size();
}
inline void NetworkCards_Item::clear_dhcp_server_address() {
  dhcp_server_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::dhcp_server_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_dhcp_server_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Mutable(index);
}
inline void NetworkCards_Item::set_dhcp_server_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dhcp_server_address)
  dhcp_server_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_dhcp_server_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dhcp_server_address)
  dhcp_server_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_dhcp_server_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dhcp_server_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline void NetworkCards_Item::set_dhcp_server_address(int index, const char* value, size_t size) {
  dhcp_server_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline ::std::string* NetworkCards_Item::add_dhcp_server_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Add();
}
inline void NetworkCards_Item::add_dhcp_server_address(const ::std::string& value) {
  dhcp_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_dhcp_server_address(::std::string&& value) {
  dhcp_server_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
#endif
inline void NetworkCards_Item::add_dhcp_server_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dhcp_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline void NetworkCards_Item::add_dhcp_server_address(const char* value, size_t size) {
  dhcp_server_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::dhcp_server_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_dhcp_server_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return &dhcp_server_address_;
}

// repeated string dns_server_address = 14;
inline int NetworkCards_Item::dns_server_address_size() const {
  return dns_server_address_.size();
}
inline void NetworkCards_Item::clear_dns_server_address() {
  dns_server_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::dns_server_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_dns_server_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Mutable(index);
}
inline void NetworkCards_Item::set_dns_server_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dns_server_address)
  dns_server_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_dns_server_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dns_server_address)
  dns_server_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_dns_server_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_server_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline void NetworkCards_Item::set_dns_server_address(int index, const char* value, size_t size) {
  dns_server_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline ::std::string* NetworkCards_Item::add_dns_server_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Add();
}
inline void NetworkCards_Item::add_dns_server_address(const ::std::string& value) {
  dns_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dns_server_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_dns_server_address(::std::string&& value) {
  dns_server_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dns_server_address)
}
#endif
inline void NetworkCards_Item::add_dns_server_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline void NetworkCards_Item::add_dns_server_address(const char* value, size_t size) {
  dns_server_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::dns_server_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_dns_server_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.dns_server_address)
  return &dns_server_address_;
}

// -------------------------------------------------------------------

// NetworkCards

// repeated .aspia.proto.NetworkCards.Item item = 1;
inline int NetworkCards::item_size() const {
  return item_.size();
}
inline void NetworkCards::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::NetworkCards_Item& NetworkCards::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.item)
  return item_.Get(index);
}
inline ::aspia::proto::NetworkCards_Item* NetworkCards::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::NetworkCards_Item* NetworkCards::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >*
NetworkCards::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >&
NetworkCards::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.item)
  return item_;
}

// -------------------------------------------------------------------

// OpenConnections_Item

// string process_name = 1;
inline void OpenConnections_Item::clear_process_name() {
  process_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::process_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.process_name)
  return process_name_.GetNoArena();
}
inline void OpenConnections_Item::set_process_name(const ::std::string& value) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.process_name)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_process_name(::std::string&& value) {
  
  process_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.process_name)
}
#endif
inline void OpenConnections_Item::set_process_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.process_name)
}
inline void OpenConnections_Item::set_process_name(const char* value, size_t size) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.process_name)
}
inline ::std::string* OpenConnections_Item::mutable_process_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.process_name)
  return process_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_process_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.process_name)
  
  return process_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_process_name(::std::string* process_name) {
  if (process_name != NULL) {
    
  } else {
    
  }
  process_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.process_name)
}

// .aspia.proto.OpenConnections.Protocol protocol = 2;
inline void OpenConnections_Item::clear_protocol() {
  protocol_ = 0;
}
inline ::aspia::proto::OpenConnections_Protocol OpenConnections_Item::protocol() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.protocol)
  return static_cast< ::aspia::proto::OpenConnections_Protocol >(protocol_);
}
inline void OpenConnections_Item::set_protocol(::aspia::proto::OpenConnections_Protocol value) {
  
  protocol_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.protocol)
}

// string local_address = 3;
inline void OpenConnections_Item::clear_local_address() {
  local_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::local_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.local_address)
  return local_address_.GetNoArena();
}
inline void OpenConnections_Item::set_local_address(const ::std::string& value) {
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.local_address)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_local_address(::std::string&& value) {
  
  local_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.local_address)
}
#endif
inline void OpenConnections_Item::set_local_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.local_address)
}
inline void OpenConnections_Item::set_local_address(const char* value, size_t size) {
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.local_address)
}
inline ::std::string* OpenConnections_Item::mutable_local_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.local_address)
  return local_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_local_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.local_address)
  
  return local_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_local_address(::std::string* local_address) {
  if (local_address != NULL) {
    
  } else {
    
  }
  local_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.local_address)
}

// string remote_address = 4;
inline void OpenConnections_Item::clear_remote_address() {
  remote_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::remote_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.remote_address)
  return remote_address_.GetNoArena();
}
inline void OpenConnections_Item::set_remote_address(const ::std::string& value) {
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.remote_address)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_remote_address(::std::string&& value) {
  
  remote_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.remote_address)
}
#endif
inline void OpenConnections_Item::set_remote_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.remote_address)
}
inline void OpenConnections_Item::set_remote_address(const char* value, size_t size) {
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.remote_address)
}
inline ::std::string* OpenConnections_Item::mutable_remote_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.remote_address)
  return remote_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_remote_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.remote_address)
  
  return remote_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_remote_address(::std::string* remote_address) {
  if (remote_address != NULL) {
    
  } else {
    
  }
  remote_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.remote_address)
}

// uint32 local_port = 5;
inline void OpenConnections_Item::clear_local_port() {
  local_port_ = 0u;
}
inline ::google::protobuf::uint32 OpenConnections_Item::local_port() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.local_port)
  return local_port_;
}
inline void OpenConnections_Item::set_local_port(::google::protobuf::uint32 value) {
  
  local_port_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.local_port)
}

// uint32 remote_port = 6;
inline void OpenConnections_Item::clear_remote_port() {
  remote_port_ = 0u;
}
inline ::google::protobuf::uint32 OpenConnections_Item::remote_port() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.remote_port)
  return remote_port_;
}
inline void OpenConnections_Item::set_remote_port(::google::protobuf::uint32 value) {
  
  remote_port_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.remote_port)
}

// .aspia.proto.OpenConnections.State state = 7;
inline void OpenConnections_Item::clear_state() {
  state_ = 0;
}
inline ::aspia::proto::OpenConnections_State OpenConnections_Item::state() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.state)
  return static_cast< ::aspia::proto::OpenConnections_State >(state_);
}
inline void OpenConnections_Item::set_state(::aspia::proto::OpenConnections_State value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.state)
}

// -------------------------------------------------------------------

// OpenConnections

// repeated .aspia.proto.OpenConnections.Item item = 1;
inline int OpenConnections::item_size() const {
  return item_.size();
}
inline void OpenConnections::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::OpenConnections_Item& OpenConnections::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.item)
  return item_.Get(index);
}
inline ::aspia::proto::OpenConnections_Item* OpenConnections::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::OpenConnections_Item* OpenConnections::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.OpenConnections.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >*
OpenConnections::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.OpenConnections.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >&
OpenConnections::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.OpenConnections.item)
  return item_;
}

// -------------------------------------------------------------------

// SharedResources_Item

// string name = 1;
inline void SharedResources_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.name)
  return name_.GetNoArena();
}
inline void SharedResources_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.name)
}
#if LANG_CXX11
inline void SharedResources_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SharedResources.Item.name)
}
#endif
inline void SharedResources_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SharedResources.Item.name)
}
inline void SharedResources_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SharedResources.Item.name)
}
inline ::std::string* SharedResources_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.SharedResources.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SharedResources.Item.name)
}

// .aspia.proto.SharedResources.Item.Type type = 2;
inline void SharedResources_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::SharedResources_Item_Type SharedResources_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.type)
  return static_cast< ::aspia::proto::SharedResources_Item_Type >(type_);
}
inline void SharedResources_Item::set_type(::aspia::proto::SharedResources_Item_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.type)
}

// string description = 3;
inline void SharedResources_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.description)
  return description_.GetNoArena();
}
inline void SharedResources_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.description)
}
#if LANG_CXX11
inline void SharedResources_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SharedResources.Item.description)
}
#endif
inline void SharedResources_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SharedResources.Item.description)
}
inline void SharedResources_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SharedResources.Item.description)
}
inline ::std::string* SharedResources_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.SharedResources.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SharedResources.Item.description)
}

// string local_path = 4;
inline void SharedResources_Item::clear_local_path() {
  local_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::local_path() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.local_path)
  return local_path_.GetNoArena();
}
inline void SharedResources_Item::set_local_path(const ::std::string& value) {
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.local_path)
}
#if LANG_CXX11
inline void SharedResources_Item::set_local_path(::std::string&& value) {
  
  local_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SharedResources.Item.local_path)
}
#endif
inline void SharedResources_Item::set_local_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SharedResources.Item.local_path)
}
inline void SharedResources_Item::set_local_path(const char* value, size_t size) {
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SharedResources.Item.local_path)
}
inline ::std::string* SharedResources_Item::mutable_local_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.Item.local_path)
  return local_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_local_path() {
  // @@protoc_insertion_point(field_release:aspia.proto.SharedResources.Item.local_path)
  
  return local_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_local_path(::std::string* local_path) {
  if (local_path != NULL) {
    
  } else {
    
  }
  local_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_path);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SharedResources.Item.local_path)
}

// uint32 current_uses = 5;
inline void SharedResources_Item::clear_current_uses() {
  current_uses_ = 0u;
}
inline ::google::protobuf::uint32 SharedResources_Item::current_uses() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.current_uses)
  return current_uses_;
}
inline void SharedResources_Item::set_current_uses(::google::protobuf::uint32 value) {
  
  current_uses_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.current_uses)
}

// uint32 maximum_uses = 6;
inline void SharedResources_Item::clear_maximum_uses() {
  maximum_uses_ = 0u;
}
inline ::google::protobuf::uint32 SharedResources_Item::maximum_uses() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.maximum_uses)
  return maximum_uses_;
}
inline void SharedResources_Item::set_maximum_uses(::google::protobuf::uint32 value) {
  
  maximum_uses_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.maximum_uses)
}

// -------------------------------------------------------------------

// SharedResources

// repeated .aspia.proto.SharedResources.Item item = 1;
inline int SharedResources::item_size() const {
  return item_.size();
}
inline void SharedResources::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::SharedResources_Item& SharedResources::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.item)
  return item_.Get(index);
}
inline ::aspia::proto::SharedResources_Item* SharedResources::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::SharedResources_Item* SharedResources::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.SharedResources.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >*
SharedResources::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.SharedResources.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >&
SharedResources::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.SharedResources.item)
  return item_;
}

// -------------------------------------------------------------------

// Routes_Item

// string destonation = 1;
inline void Routes_Item::clear_destonation() {
  destonation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::destonation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.destonation)
  return destonation_.GetNoArena();
}
inline void Routes_Item::set_destonation(const ::std::string& value) {
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.destonation)
}
#if LANG_CXX11
inline void Routes_Item::set_destonation(::std::string&& value) {
  
  destonation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Routes.Item.destonation)
}
#endif
inline void Routes_Item::set_destonation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Routes.Item.destonation)
}
inline void Routes_Item::set_destonation(const char* value, size_t size) {
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Routes.Item.destonation)
}
inline ::std::string* Routes_Item::mutable_destonation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.Item.destonation)
  return destonation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_destonation() {
  // @@protoc_insertion_point(field_release:aspia.proto.Routes.Item.destonation)
  
  return destonation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_destonation(::std::string* destonation) {
  if (destonation != NULL) {
    
  } else {
    
  }
  destonation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destonation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Routes.Item.destonation)
}

// string mask = 2;
inline void Routes_Item::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::mask() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.mask)
  return mask_.GetNoArena();
}
inline void Routes_Item::set_mask(const ::std::string& value) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.mask)
}
#if LANG_CXX11
inline void Routes_Item::set_mask(::std::string&& value) {
  
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Routes.Item.mask)
}
#endif
inline void Routes_Item::set_mask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Routes.Item.mask)
}
inline void Routes_Item::set_mask(const char* value, size_t size) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Routes.Item.mask)
}
inline ::std::string* Routes_Item::mutable_mask() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.Item.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_mask() {
  // @@protoc_insertion_point(field_release:aspia.proto.Routes.Item.mask)
  
  return mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_mask(::std::string* mask) {
  if (mask != NULL) {
    
  } else {
    
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Routes.Item.mask)
}

// string gateway = 3;
inline void Routes_Item::clear_gateway() {
  gateway_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::gateway() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.gateway)
  return gateway_.GetNoArena();
}
inline void Routes_Item::set_gateway(const ::std::string& value) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.gateway)
}
#if LANG_CXX11
inline void Routes_Item::set_gateway(::std::string&& value) {
  
  gateway_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Routes.Item.gateway)
}
#endif
inline void Routes_Item::set_gateway(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Routes.Item.gateway)
}
inline void Routes_Item::set_gateway(const char* value, size_t size) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Routes.Item.gateway)
}
inline ::std::string* Routes_Item::mutable_gateway() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.Item.gateway)
  return gateway_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_gateway() {
  // @@protoc_insertion_point(field_release:aspia.proto.Routes.Item.gateway)
  
  return gateway_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_gateway(::std::string* gateway) {
  if (gateway != NULL) {
    
  } else {
    
  }
  gateway_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gateway);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Routes.Item.gateway)
}

// uint32 metric = 4;
inline void Routes_Item::clear_metric() {
  metric_ = 0u;
}
inline ::google::protobuf::uint32 Routes_Item::metric() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.metric)
  return metric_;
}
inline void Routes_Item::set_metric(::google::protobuf::uint32 value) {
  
  metric_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.metric)
}

// -------------------------------------------------------------------

// Routes

// repeated .aspia.proto.Routes.Item item = 1;
inline int Routes::item_size() const {
  return item_.size();
}
inline void Routes::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Routes_Item& Routes::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.item)
  return item_.Get(index);
}
inline ::aspia::proto::Routes_Item* Routes::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Routes_Item* Routes::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Routes.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >*
Routes::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Routes.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >&
Routes::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Routes.item)
  return item_;
}

// -------------------------------------------------------------------

// Users_Item

// string name = 1;
inline void Users_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.name)
  return name_.GetNoArena();
}
inline void Users_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.name)
}
#if LANG_CXX11
inline void Users_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Users.Item.name)
}
#endif
inline void Users_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Users.Item.name)
}
inline void Users_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Users.Item.name)
}
inline ::std::string* Users_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Users.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Users.Item.name)
}

// string full_name = 2;
inline void Users_Item::clear_full_name() {
  full_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::full_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.full_name)
  return full_name_.GetNoArena();
}
inline void Users_Item::set_full_name(const ::std::string& value) {
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.full_name)
}
#if LANG_CXX11
inline void Users_Item::set_full_name(::std::string&& value) {
  
  full_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Users.Item.full_name)
}
#endif
inline void Users_Item::set_full_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Users.Item.full_name)
}
inline void Users_Item::set_full_name(const char* value, size_t size) {
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Users.Item.full_name)
}
inline ::std::string* Users_Item::mutable_full_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.Item.full_name)
  return full_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_full_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Users.Item.full_name)
  
  return full_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_full_name(::std::string* full_name) {
  if (full_name != NULL) {
    
  } else {
    
  }
  full_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), full_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Users.Item.full_name)
}

// string comment = 3;
inline void Users_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.comment)
  return comment_.GetNoArena();
}
inline void Users_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.comment)
}
#if LANG_CXX11
inline void Users_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Users.Item.comment)
}
#endif
inline void Users_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Users.Item.comment)
}
inline void Users_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Users.Item.comment)
}
inline ::std::string* Users_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.proto.Users.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Users.Item.comment)
}

// bool is_disabled = 4;
inline void Users_Item::clear_is_disabled() {
  is_disabled_ = false;
}
inline bool Users_Item::is_disabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_disabled)
  return is_disabled_;
}
inline void Users_Item::set_is_disabled(bool value) {
  
  is_disabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_disabled)
}

// bool is_password_cant_change = 5;
inline void Users_Item::clear_is_password_cant_change() {
  is_password_cant_change_ = false;
}
inline bool Users_Item::is_password_cant_change() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_password_cant_change)
  return is_password_cant_change_;
}
inline void Users_Item::set_is_password_cant_change(bool value) {
  
  is_password_cant_change_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_password_cant_change)
}

// bool is_password_expired = 6;
inline void Users_Item::clear_is_password_expired() {
  is_password_expired_ = false;
}
inline bool Users_Item::is_password_expired() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_password_expired)
  return is_password_expired_;
}
inline void Users_Item::set_is_password_expired(bool value) {
  
  is_password_expired_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_password_expired)
}

// bool is_dont_expire_password = 7;
inline void Users_Item::clear_is_dont_expire_password() {
  is_dont_expire_password_ = false;
}
inline bool Users_Item::is_dont_expire_password() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_dont_expire_password)
  return is_dont_expire_password_;
}
inline void Users_Item::set_is_dont_expire_password(bool value) {
  
  is_dont_expire_password_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_dont_expire_password)
}

// bool is_lockout = 8;
inline void Users_Item::clear_is_lockout() {
  is_lockout_ = false;
}
inline bool Users_Item::is_lockout() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_lockout)
  return is_lockout_;
}
inline void Users_Item::set_is_lockout(bool value) {
  
  is_lockout_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_lockout)
}

// uint32 number_logons = 9;
inline void Users_Item::clear_number_logons() {
  number_logons_ = 0u;
}
inline ::google::protobuf::uint32 Users_Item::number_logons() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.number_logons)
  return number_logons_;
}
inline void Users_Item::set_number_logons(::google::protobuf::uint32 value) {
  
  number_logons_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.number_logons)
}

// uint32 bad_password_count = 10;
inline void Users_Item::clear_bad_password_count() {
  bad_password_count_ = 0u;
}
inline ::google::protobuf::uint32 Users_Item::bad_password_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.bad_password_count)
  return bad_password_count_;
}
inline void Users_Item::set_bad_password_count(::google::protobuf::uint32 value) {
  
  bad_password_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.bad_password_count)
}

// int64 last_logon_time = 11;
inline void Users_Item::clear_last_logon_time() {
  last_logon_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Users_Item::last_logon_time() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.last_logon_time)
  return last_logon_time_;
}
inline void Users_Item::set_last_logon_time(::google::protobuf::int64 value) {
  
  last_logon_time_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.last_logon_time)
}

// -------------------------------------------------------------------

// Users

// repeated .aspia.proto.Users.Item item = 1;
inline int Users::item_size() const {
  return item_.size();
}
inline void Users::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Users_Item& Users::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.item)
  return item_.Get(index);
}
inline ::aspia::proto::Users_Item* Users::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Users_Item* Users::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Users.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >*
Users::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Users.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >&
Users::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Users.item)
  return item_;
}

// -------------------------------------------------------------------

// UserGroups_Item

// string name = 1;
inline void UserGroups_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserGroups_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.UserGroups.Item.name)
  return name_.GetNoArena();
}
inline void UserGroups_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.UserGroups.Item.name)
}
#if LANG_CXX11
inline void UserGroups_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.UserGroups.Item.name)
}
#endif
inline void UserGroups_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.UserGroups.Item.name)
}
inline void UserGroups_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.UserGroups.Item.name)
}
inline ::std::string* UserGroups_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.UserGroups.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserGroups_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.UserGroups.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserGroups_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.UserGroups.Item.name)
}

// string comment = 2;
inline void UserGroups_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserGroups_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.proto.UserGroups.Item.comment)
  return comment_.GetNoArena();
}
inline void UserGroups_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.UserGroups.Item.comment)
}
#if LANG_CXX11
inline void UserGroups_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.UserGroups.Item.comment)
}
#endif
inline void UserGroups_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.UserGroups.Item.comment)
}
inline void UserGroups_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.UserGroups.Item.comment)
}
inline ::std::string* UserGroups_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.UserGroups.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserGroups_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.proto.UserGroups.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserGroups_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.UserGroups.Item.comment)
}

// -------------------------------------------------------------------

// UserGroups

// repeated .aspia.proto.UserGroups.Item item = 1;
inline int UserGroups::item_size() const {
  return item_.size();
}
inline void UserGroups::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::UserGroups_Item& UserGroups::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.UserGroups.item)
  return item_.Get(index);
}
inline ::aspia::proto::UserGroups_Item* UserGroups::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.UserGroups.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::UserGroups_Item* UserGroups::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.UserGroups.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >*
UserGroups::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.UserGroups.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >&
UserGroups::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.UserGroups.item)
  return item_;
}

// -------------------------------------------------------------------

// Sessions_Item

// string user_name = 1;
inline void Sessions_Item::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::user_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.user_name)
  return user_name_.GetNoArena();
}
inline void Sessions_Item::set_user_name(const ::std::string& value) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.user_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_user_name(::std::string&& value) {
  
  user_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.user_name)
}
#endif
inline void Sessions_Item::set_user_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.user_name)
}
inline void Sessions_Item::set_user_name(const char* value, size_t size) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.user_name)
}
inline ::std::string* Sessions_Item::mutable_user_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_user_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.user_name)
  
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    
  } else {
    
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.user_name)
}

// string domain_name = 2;
inline void Sessions_Item::clear_domain_name() {
  domain_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::domain_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.domain_name)
  return domain_name_.GetNoArena();
}
inline void Sessions_Item::set_domain_name(const ::std::string& value) {
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.domain_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_domain_name(::std::string&& value) {
  
  domain_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.domain_name)
}
#endif
inline void Sessions_Item::set_domain_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.domain_name)
}
inline void Sessions_Item::set_domain_name(const char* value, size_t size) {
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.domain_name)
}
inline ::std::string* Sessions_Item::mutable_domain_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.domain_name)
  return domain_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_domain_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.domain_name)
  
  return domain_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_domain_name(::std::string* domain_name) {
  if (domain_name != NULL) {
    
  } else {
    
  }
  domain_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.domain_name)
}

// uint32 session_id = 3;
inline void Sessions_Item::clear_session_id() {
  session_id_ = 0u;
}
inline ::google::protobuf::uint32 Sessions_Item::session_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.session_id)
  return session_id_;
}
inline void Sessions_Item::set_session_id(::google::protobuf::uint32 value) {
  
  session_id_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.session_id)
}

// .aspia.proto.Sessions.ConnectState connect_state = 4;
inline void Sessions_Item::clear_connect_state() {
  connect_state_ = 0;
}
inline ::aspia::proto::Sessions_ConnectState Sessions_Item::connect_state() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.connect_state)
  return static_cast< ::aspia::proto::Sessions_ConnectState >(connect_state_);
}
inline void Sessions_Item::set_connect_state(::aspia::proto::Sessions_ConnectState value) {
  
  connect_state_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.connect_state)
}

// string client_name = 5;
inline void Sessions_Item::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::client_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.client_name)
  return client_name_.GetNoArena();
}
inline void Sessions_Item::set_client_name(const ::std::string& value) {
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.client_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_client_name(::std::string&& value) {
  
  client_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.client_name)
}
#endif
inline void Sessions_Item::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.client_name)
}
inline void Sessions_Item::set_client_name(const char* value, size_t size) {
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.client_name)
}
inline ::std::string* Sessions_Item::mutable_client_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.client_name)
  return client_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_client_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.client_name)
  
  return client_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_client_name(::std::string* client_name) {
  if (client_name != NULL) {
    
  } else {
    
  }
  client_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.client_name)
}

// string winstation_name = 6;
inline void Sessions_Item::clear_winstation_name() {
  winstation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::winstation_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.winstation_name)
  return winstation_name_.GetNoArena();
}
inline void Sessions_Item::set_winstation_name(const ::std::string& value) {
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.winstation_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_winstation_name(::std::string&& value) {
  
  winstation_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.winstation_name)
}
#endif
inline void Sessions_Item::set_winstation_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.winstation_name)
}
inline void Sessions_Item::set_winstation_name(const char* value, size_t size) {
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.winstation_name)
}
inline ::std::string* Sessions_Item::mutable_winstation_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.winstation_name)
  return winstation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_winstation_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.winstation_name)
  
  return winstation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_winstation_name(::std::string* winstation_name) {
  if (winstation_name != NULL) {
    
  } else {
    
  }
  winstation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), winstation_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.winstation_name)
}

// -------------------------------------------------------------------

// Sessions

// repeated .aspia.proto.Sessions.Item item = 1;
inline int Sessions::item_size() const {
  return item_.size();
}
inline void Sessions::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Sessions_Item& Sessions::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.item)
  return item_.Get(index);
}
inline ::aspia::proto::Sessions_Item* Sessions::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Sessions_Item* Sessions::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Sessions.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >*
Sessions::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Sessions.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >&
Sessions::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Sessions.item)
  return item_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace aspia

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aspia::proto::DmiPortConnectors_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPortConnectors_ConnectorType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiOnBoardDevices_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPointingDevices_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPointingDevices_Interface> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPortableBattery_Chemistry> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Services_Item_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Services_Item_StartupType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::OpenConnections_Protocol> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::OpenConnections_State> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::SharedResources_Item_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Sessions_ConnectState> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system_info_session_message.proto

#ifndef PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED
#define PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace protobuf_system_5finfo_5fsession_5fmessage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[43];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsDmiBios_CharacteristicsImpl();
void InitDefaultsDmiBios_Characteristics();
void InitDefaultsDmiBiosImpl();
void InitDefaultsDmiBios();
void InitDefaultsDmiSystemImpl();
void InitDefaultsDmiSystem();
void InitDefaultsDmiBaseboard_FeaturesImpl();
void InitDefaultsDmiBaseboard_Features();
void InitDefaultsDmiBaseboard_ItemImpl();
void InitDefaultsDmiBaseboard_Item();
void InitDefaultsDmiBaseboardImpl();
void InitDefaultsDmiBaseboard();
void InitDefaultsDmiChassis_ItemImpl();
void InitDefaultsDmiChassis_Item();
void InitDefaultsDmiChassisImpl();
void InitDefaultsDmiChassis();
void InitDefaultsDmiCaches_ItemImpl();
void InitDefaultsDmiCaches_Item();
void InitDefaultsDmiCachesImpl();
void InitDefaultsDmiCaches();
void InitDefaultsDmiProcessors_ItemImpl();
void InitDefaultsDmiProcessors_Item();
void InitDefaultsDmiProcessorsImpl();
void InitDefaultsDmiProcessors();
void InitDefaultsDmiMemoryDevices_ItemImpl();
void InitDefaultsDmiMemoryDevices_Item();
void InitDefaultsDmiMemoryDevicesImpl();
void InitDefaultsDmiMemoryDevices();
void InitDefaultsDmiSystemSlots_ItemImpl();
void InitDefaultsDmiSystemSlots_Item();
void InitDefaultsDmiSystemSlotsImpl();
void InitDefaultsDmiSystemSlots();
void InitDefaultsDmiPortConnectors_ItemImpl();
void InitDefaultsDmiPortConnectors_Item();
void InitDefaultsDmiPortConnectorsImpl();
void InitDefaultsDmiPortConnectors();
void InitDefaultsDmiOnBoardDevices_ItemImpl();
void InitDefaultsDmiOnBoardDevices_Item();
void InitDefaultsDmiOnBoardDevicesImpl();
void InitDefaultsDmiOnBoardDevices();
void InitDefaultsDmiPointingDevices_ItemImpl();
void InitDefaultsDmiPointingDevices_Item();
void InitDefaultsDmiPointingDevicesImpl();
void InitDefaultsDmiPointingDevices();
void InitDefaultsDmiPortableBattery_ItemImpl();
void InitDefaultsDmiPortableBattery_Item();
void InitDefaultsDmiPortableBatteryImpl();
void InitDefaultsDmiPortableBattery();
void InitDefaultsPrograms_ItemImpl();
void InitDefaultsPrograms_Item();
void InitDefaultsProgramsImpl();
void InitDefaultsPrograms();
void InitDefaultsServices_ItemImpl();
void InitDefaultsServices_Item();
void InitDefaultsServicesImpl();
void InitDefaultsServices();
void InitDefaultsNetworkCards_Item_IpAddressImpl();
void InitDefaultsNetworkCards_Item_IpAddress();
void InitDefaultsNetworkCards_ItemImpl();
void InitDefaultsNetworkCards_Item();
void InitDefaultsNetworkCardsImpl();
void InitDefaultsNetworkCards();
void InitDefaultsOpenConnections_ItemImpl();
void InitDefaultsOpenConnections_Item();
void InitDefaultsOpenConnectionsImpl();
void InitDefaultsOpenConnections();
void InitDefaultsSharedResources_ItemImpl();
void InitDefaultsSharedResources_Item();
void InitDefaultsSharedResourcesImpl();
void InitDefaultsSharedResources();
void InitDefaultsRoutes_ItemImpl();
void InitDefaultsRoutes_Item();
void InitDefaultsRoutesImpl();
void InitDefaultsRoutes();
void InitDefaultsUsers_ItemImpl();
void InitDefaultsUsers_Item();
void InitDefaultsUsersImpl();
void InitDefaultsUsers();
void InitDefaultsUserGroups_ItemImpl();
void InitDefaultsUserGroups_Item();
void InitDefaultsUserGroupsImpl();
void InitDefaultsUserGroups();
void InitDefaultsSessions_ItemImpl();
void InitDefaultsSessions_Item();
void InitDefaultsSessionsImpl();
void InitDefaultsSessions();
inline void InitDefaults() {
  InitDefaultsDmiBios_Characteristics();
  InitDefaultsDmiBios();
  InitDefaultsDmiSystem();
  InitDefaultsDmiBaseboard_Features();
  InitDefaultsDmiBaseboard_Item();
  InitDefaultsDmiBaseboard();
  InitDefaultsDmiChassis_Item();
  InitDefaultsDmiChassis();
  InitDefaultsDmiCaches_Item();
  InitDefaultsDmiCaches();
  InitDefaultsDmiProcessors_Item();
  InitDefaultsDmiProcessors();
  InitDefaultsDmiMemoryDevices_Item();
  InitDefaultsDmiMemoryDevices();
  InitDefaultsDmiSystemSlots_Item();
  InitDefaultsDmiSystemSlots();
  InitDefaultsDmiPortConnectors_Item();
  InitDefaultsDmiPortConnectors();
  InitDefaultsDmiOnBoardDevices_Item();
  InitDefaultsDmiOnBoardDevices();
  InitDefaultsDmiPointingDevices_Item();
  InitDefaultsDmiPointingDevices();
  InitDefaultsDmiPortableBattery_Item();
  InitDefaultsDmiPortableBattery();
  InitDefaultsPrograms_Item();
  InitDefaultsPrograms();
  InitDefaultsServices_Item();
  InitDefaultsServices();
  InitDefaultsNetworkCards_Item_IpAddress();
  InitDefaultsNetworkCards_Item();
  InitDefaultsNetworkCards();
  InitDefaultsOpenConnections_Item();
  InitDefaultsOpenConnections();
  InitDefaultsSharedResources_Item();
  InitDefaultsSharedResources();
  InitDefaultsRoutes_Item();
  InitDefaultsRoutes();
  InitDefaultsUsers_Item();
  InitDefaultsUsers();
  InitDefaultsUserGroups_Item();
  InitDefaultsUserGroups();
  InitDefaultsSessions_Item();
  InitDefaultsSessions();
}
}  // namespace protobuf_system_5finfo_5fsession_5fmessage_2eproto
namespace aspia {
namespace proto {
class DmiBaseboard;
class DmiBaseboardDefaultTypeInternal;
extern DmiBaseboardDefaultTypeInternal _DmiBaseboard_default_instance_;
class DmiBaseboard_Features;
class DmiBaseboard_FeaturesDefaultTypeInternal;
extern DmiBaseboard_FeaturesDefaultTypeInternal _DmiBaseboard_Features_default_instance_;
class DmiBaseboard_Item;
class DmiBaseboard_ItemDefaultTypeInternal;
extern DmiBaseboard_ItemDefaultTypeInternal _DmiBaseboard_Item_default_instance_;
class DmiBios;
class DmiBiosDefaultTypeInternal;
extern DmiBiosDefaultTypeInternal _DmiBios_default_instance_;
class DmiBios_Characteristics;
class DmiBios_CharacteristicsDefaultTypeInternal;
extern DmiBios_CharacteristicsDefaultTypeInternal _DmiBios_Characteristics_default_instance_;
class DmiCaches;
class DmiCachesDefaultTypeInternal;
extern DmiCachesDefaultTypeInternal _DmiCaches_default_instance_;
class DmiCaches_Item;
class DmiCaches_ItemDefaultTypeInternal;
extern DmiCaches_ItemDefaultTypeInternal _DmiCaches_Item_default_instance_;
class DmiChassis;
class DmiChassisDefaultTypeInternal;
extern DmiChassisDefaultTypeInternal _DmiChassis_default_instance_;
class DmiChassis_Item;
class DmiChassis_ItemDefaultTypeInternal;
extern DmiChassis_ItemDefaultTypeInternal _DmiChassis_Item_default_instance_;
class DmiMemoryDevices;
class DmiMemoryDevicesDefaultTypeInternal;
extern DmiMemoryDevicesDefaultTypeInternal _DmiMemoryDevices_default_instance_;
class DmiMemoryDevices_Item;
class DmiMemoryDevices_ItemDefaultTypeInternal;
extern DmiMemoryDevices_ItemDefaultTypeInternal _DmiMemoryDevices_Item_default_instance_;
class DmiOnBoardDevices;
class DmiOnBoardDevicesDefaultTypeInternal;
extern DmiOnBoardDevicesDefaultTypeInternal _DmiOnBoardDevices_default_instance_;
class DmiOnBoardDevices_Item;
class DmiOnBoardDevices_ItemDefaultTypeInternal;
extern DmiOnBoardDevices_ItemDefaultTypeInternal _DmiOnBoardDevices_Item_default_instance_;
class DmiPointingDevices;
class DmiPointingDevicesDefaultTypeInternal;
extern DmiPointingDevicesDefaultTypeInternal _DmiPointingDevices_default_instance_;
class DmiPointingDevices_Item;
class DmiPointingDevices_ItemDefaultTypeInternal;
extern DmiPointingDevices_ItemDefaultTypeInternal _DmiPointingDevices_Item_default_instance_;
class DmiPortConnectors;
class DmiPortConnectorsDefaultTypeInternal;
extern DmiPortConnectorsDefaultTypeInternal _DmiPortConnectors_default_instance_;
class DmiPortConnectors_Item;
class DmiPortConnectors_ItemDefaultTypeInternal;
extern DmiPortConnectors_ItemDefaultTypeInternal _DmiPortConnectors_Item_default_instance_;
class DmiPortableBattery;
class DmiPortableBatteryDefaultTypeInternal;
extern DmiPortableBatteryDefaultTypeInternal _DmiPortableBattery_default_instance_;
class DmiPortableBattery_Item;
class DmiPortableBattery_ItemDefaultTypeInternal;
extern DmiPortableBattery_ItemDefaultTypeInternal _DmiPortableBattery_Item_default_instance_;
class DmiProcessors;
class DmiProcessorsDefaultTypeInternal;
extern DmiProcessorsDefaultTypeInternal _DmiProcessors_default_instance_;
class DmiProcessors_Item;
class DmiProcessors_ItemDefaultTypeInternal;
extern DmiProcessors_ItemDefaultTypeInternal _DmiProcessors_Item_default_instance_;
class DmiSystem;
class DmiSystemDefaultTypeInternal;
extern DmiSystemDefaultTypeInternal _DmiSystem_default_instance_;
class DmiSystemSlots;
class DmiSystemSlotsDefaultTypeInternal;
extern DmiSystemSlotsDefaultTypeInternal _DmiSystemSlots_default_instance_;
class DmiSystemSlots_Item;
class DmiSystemSlots_ItemDefaultTypeInternal;
extern DmiSystemSlots_ItemDefaultTypeInternal _DmiSystemSlots_Item_default_instance_;
class NetworkCards;
class NetworkCardsDefaultTypeInternal;
extern NetworkCardsDefaultTypeInternal _NetworkCards_default_instance_;
class NetworkCards_Item;
class NetworkCards_ItemDefaultTypeInternal;
extern NetworkCards_ItemDefaultTypeInternal _NetworkCards_Item_default_instance_;
class NetworkCards_Item_IpAddress;
class NetworkCards_Item_IpAddressDefaultTypeInternal;
extern NetworkCards_Item_IpAddressDefaultTypeInternal _NetworkCards_Item_IpAddress_default_instance_;
class OpenConnections;
class OpenConnectionsDefaultTypeInternal;
extern OpenConnectionsDefaultTypeInternal _OpenConnections_default_instance_;
class OpenConnections_Item;
class OpenConnections_ItemDefaultTypeInternal;
extern OpenConnections_ItemDefaultTypeInternal _OpenConnections_Item_default_instance_;
class Programs;
class ProgramsDefaultTypeInternal;
extern ProgramsDefaultTypeInternal _Programs_default_instance_;
class Programs_Item;
class Programs_ItemDefaultTypeInternal;
extern Programs_ItemDefaultTypeInternal _Programs_Item_default_instance_;
class Routes;
class RoutesDefaultTypeInternal;
extern RoutesDefaultTypeInternal _Routes_default_instance_;
class Routes_Item;
class Routes_ItemDefaultTypeInternal;
extern Routes_ItemDefaultTypeInternal _Routes_Item_default_instance_;
class Services;
class ServicesDefaultTypeInternal;
extern ServicesDefaultTypeInternal _Services_default_instance_;
class Services_Item;
class Services_ItemDefaultTypeInternal;
extern Services_ItemDefaultTypeInternal _Services_Item_default_instance_;
class Sessions;
class SessionsDefaultTypeInternal;
extern SessionsDefaultTypeInternal _Sessions_default_instance_;
class Sessions_Item;
class Sessions_ItemDefaultTypeInternal;
extern Sessions_ItemDefaultTypeInternal _Sessions_Item_default_instance_;
class SharedResources;
class SharedResourcesDefaultTypeInternal;
extern SharedResourcesDefaultTypeInternal _SharedResources_default_instance_;
class SharedResources_Item;
class SharedResources_ItemDefaultTypeInternal;
extern SharedResources_ItemDefaultTypeInternal _SharedResources_Item_default_instance_;
class UserGroups;
class UserGroupsDefaultTypeInternal;
extern UserGroupsDefaultTypeInternal _UserGroups_default_instance_;
class UserGroups_Item;
class UserGroups_ItemDefaultTypeInternal;
extern UserGroups_ItemDefaultTypeInternal _UserGroups_Item_default_instance_;
class Users;
class UsersDefaultTypeInternal;
extern UsersDefaultTypeInternal _Users_default_instance_;
class Users_Item;
class Users_ItemDefaultTypeInternal;
extern Users_ItemDefaultTypeInternal _Users_Item_default_instance_;
}  // namespace proto
}  // namespace aspia
namespace aspia {
namespace proto {

enum DmiSystem_WakeupType {
  DmiSystem_WakeupType_WAKEUP_TYPE_UNKNOWN = 0,
  DmiSystem_WakeupType_WAKEUP_TYPE_OTHER = 1,
  DmiSystem_WakeupType_WAKEUP_TYPE_APM_TIMER = 2,
  DmiSystem_WakeupType_WAKEUP_TYPE_MODEM_RING = 3,
  DmiSystem_WakeupType_WAKEUP_TYPE_LAN_REMOTE = 4,
  DmiSystem_WakeupType_WAKEUP_TYPE_POWER_SWITCH = 5,
  DmiSystem_WakeupType_WAKEUP_TYPE_PCI_PME = 6,
  DmiSystem_WakeupType_WAKEUP_TYPE_AC_POWER_RESTORED = 7,
  DmiSystem_WakeupType_DmiSystem_WakeupType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiSystem_WakeupType_DmiSystem_WakeupType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiSystem_WakeupType_IsValid(int value);
const DmiSystem_WakeupType DmiSystem_WakeupType_WakeupType_MIN = DmiSystem_WakeupType_WAKEUP_TYPE_UNKNOWN;
const DmiSystem_WakeupType DmiSystem_WakeupType_WakeupType_MAX = DmiSystem_WakeupType_WAKEUP_TYPE_AC_POWER_RESTORED;
const int DmiSystem_WakeupType_WakeupType_ARRAYSIZE = DmiSystem_WakeupType_WakeupType_MAX + 1;

enum DmiBaseboard_BoardType {
  DmiBaseboard_BoardType_BOARD_TYPE_UNKNOWN = 0,
  DmiBaseboard_BoardType_BOARD_TYPE_OTHER = 1,
  DmiBaseboard_BoardType_BOARD_TYPE_SERVER_BLADE = 2,
  DmiBaseboard_BoardType_BOARD_TYPE_CONNECTIVITY_SWITCH = 3,
  DmiBaseboard_BoardType_BOARD_TYPE_SYSTEM_MANAGEMENT_MODULE = 4,
  DmiBaseboard_BoardType_BOARD_TYPE_PROCESSOR_MODULE = 5,
  DmiBaseboard_BoardType_BOARD_TYPE_IO_MODULE = 6,
  DmiBaseboard_BoardType_BOARD_TYPE_MEMORY_MODULE = 7,
  DmiBaseboard_BoardType_BOARD_TYPE_DAUGHTER_BOARD = 8,
  DmiBaseboard_BoardType_BOARD_TYPE_MOTHERBOARD = 9,
  DmiBaseboard_BoardType_BOARD_TYPE_PROCESSOR_PLUS_MEMORY_MODULE = 10,
  DmiBaseboard_BoardType_BOARD_TYPE_PROCESSOR_PLUS_IO_MODULE = 11,
  DmiBaseboard_BoardType_BOARD_TYPE_INTERCONNECT_BOARD = 12,
  DmiBaseboard_BoardType_DmiBaseboard_BoardType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiBaseboard_BoardType_DmiBaseboard_BoardType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiBaseboard_BoardType_IsValid(int value);
const DmiBaseboard_BoardType DmiBaseboard_BoardType_BoardType_MIN = DmiBaseboard_BoardType_BOARD_TYPE_UNKNOWN;
const DmiBaseboard_BoardType DmiBaseboard_BoardType_BoardType_MAX = DmiBaseboard_BoardType_BOARD_TYPE_INTERCONNECT_BOARD;
const int DmiBaseboard_BoardType_BoardType_ARRAYSIZE = DmiBaseboard_BoardType_BoardType_MAX + 1;

enum DmiChassis_Type {
  DmiChassis_Type_TYPE_UNKNOWN = 0,
  DmiChassis_Type_TYPE_OTHER = 1,
  DmiChassis_Type_TYPE_DESKTOP = 2,
  DmiChassis_Type_TYPE_LOW_PROFILE_DESKTOP = 3,
  DmiChassis_Type_TYPE_PIZZA_BOX = 4,
  DmiChassis_Type_TYPE_MINI_TOWER = 5,
  DmiChassis_Type_TYPE_TOWER = 6,
  DmiChassis_Type_TYPE_PORTABLE = 7,
  DmiChassis_Type_TYPE_LAPTOP = 8,
  DmiChassis_Type_TYPE_NOTEBOOK = 9,
  DmiChassis_Type_TYPE_HAND_HELD = 10,
  DmiChassis_Type_TYPE_DOCKING_STATION = 11,
  DmiChassis_Type_TYPE_ALL_IN_ONE = 12,
  DmiChassis_Type_TYPE_SUB_NOTEBOOK = 13,
  DmiChassis_Type_TYPE_SPACE_SAVING = 14,
  DmiChassis_Type_TYPE_LUNCH_BOX = 15,
  DmiChassis_Type_TYPE_MAIN_SERVER_CHASSIS = 16,
  DmiChassis_Type_TYPE_EXPANSION_CHASSIS = 17,
  DmiChassis_Type_TYPE_SUB_CHASSIS = 18,
  DmiChassis_Type_TYPE_BUS_EXPANSION_CHASSIS = 19,
  DmiChassis_Type_TYPE_PERIPHERIAL_CHASSIS = 20,
  DmiChassis_Type_TYPE_RAID_CHASSIS = 21,
  DmiChassis_Type_TYPE_RACK_MOUNT_CHASSIS = 22,
  DmiChassis_Type_TYPE_SEALED_CASE_PC = 23,
  DmiChassis_Type_TYPE_MULTI_SYSTEM_CHASSIS = 24,
  DmiChassis_Type_TYPE_COMPACT_PCI = 25,
  DmiChassis_Type_TYPE_ADVANCED_TCA = 26,
  DmiChassis_Type_TYPE_BLADE = 27,
  DmiChassis_Type_TYPE_BLADE_ENCLOSURE = 28,
  DmiChassis_Type_DmiChassis_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiChassis_Type_DmiChassis_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiChassis_Type_IsValid(int value);
const DmiChassis_Type DmiChassis_Type_Type_MIN = DmiChassis_Type_TYPE_UNKNOWN;
const DmiChassis_Type DmiChassis_Type_Type_MAX = DmiChassis_Type_TYPE_BLADE_ENCLOSURE;
const int DmiChassis_Type_Type_ARRAYSIZE = DmiChassis_Type_Type_MAX + 1;

enum DmiChassis_Status {
  DmiChassis_Status_STATUS_UNKNOWN = 0,
  DmiChassis_Status_STATUS_OTHER = 1,
  DmiChassis_Status_STATUS_SAFE = 2,
  DmiChassis_Status_STATUS_WARNING = 3,
  DmiChassis_Status_STATUS_CRITICAL = 4,
  DmiChassis_Status_STATUS_NON_RECOVERABLE = 5,
  DmiChassis_Status_DmiChassis_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiChassis_Status_DmiChassis_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiChassis_Status_IsValid(int value);
const DmiChassis_Status DmiChassis_Status_Status_MIN = DmiChassis_Status_STATUS_UNKNOWN;
const DmiChassis_Status DmiChassis_Status_Status_MAX = DmiChassis_Status_STATUS_NON_RECOVERABLE;
const int DmiChassis_Status_Status_ARRAYSIZE = DmiChassis_Status_Status_MAX + 1;

enum DmiChassis_SecurityStatus {
  DmiChassis_SecurityStatus_SECURITY_STATUS_UNKNOWN = 0,
  DmiChassis_SecurityStatus_SECURITY_STATUS_OTHER = 1,
  DmiChassis_SecurityStatus_SECURITY_STATUS_NONE = 2,
  DmiChassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_LOCKED_OUT = 3,
  DmiChassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED = 4,
  DmiChassis_SecurityStatus_DmiChassis_SecurityStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiChassis_SecurityStatus_DmiChassis_SecurityStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiChassis_SecurityStatus_IsValid(int value);
const DmiChassis_SecurityStatus DmiChassis_SecurityStatus_SecurityStatus_MIN = DmiChassis_SecurityStatus_SECURITY_STATUS_UNKNOWN;
const DmiChassis_SecurityStatus DmiChassis_SecurityStatus_SecurityStatus_MAX = DmiChassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED;
const int DmiChassis_SecurityStatus_SecurityStatus_ARRAYSIZE = DmiChassis_SecurityStatus_SecurityStatus_MAX + 1;

enum DmiCaches_Location {
  DmiCaches_Location_LOCATION_UNKNOWN = 0,
  DmiCaches_Location_LOCATION_INTERNAL = 1,
  DmiCaches_Location_LOCATION_EXTERNAL = 2,
  DmiCaches_Location_LOCATION_RESERVED = 3,
  DmiCaches_Location_DmiCaches_Location_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_Location_DmiCaches_Location_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_Location_IsValid(int value);
const DmiCaches_Location DmiCaches_Location_Location_MIN = DmiCaches_Location_LOCATION_UNKNOWN;
const DmiCaches_Location DmiCaches_Location_Location_MAX = DmiCaches_Location_LOCATION_RESERVED;
const int DmiCaches_Location_Location_ARRAYSIZE = DmiCaches_Location_Location_MAX + 1;

enum DmiCaches_Status {
  DmiCaches_Status_STATUS_UNKNOWN = 0,
  DmiCaches_Status_STATUS_ENABLED = 1,
  DmiCaches_Status_STATUS_DISABLED = 2,
  DmiCaches_Status_DmiCaches_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_Status_DmiCaches_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_Status_IsValid(int value);
const DmiCaches_Status DmiCaches_Status_Status_MIN = DmiCaches_Status_STATUS_UNKNOWN;
const DmiCaches_Status DmiCaches_Status_Status_MAX = DmiCaches_Status_STATUS_DISABLED;
const int DmiCaches_Status_Status_ARRAYSIZE = DmiCaches_Status_Status_MAX + 1;

enum DmiCaches_Mode {
  DmiCaches_Mode_MODE_UNKNOWN = 0,
  DmiCaches_Mode_MODE_WRITE_THRU = 1,
  DmiCaches_Mode_MODE_WRITE_BACK = 2,
  DmiCaches_Mode_MODE_WRITE_WITH_MEMORY_ADDRESS = 3,
  DmiCaches_Mode_DmiCaches_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_Mode_DmiCaches_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_Mode_IsValid(int value);
const DmiCaches_Mode DmiCaches_Mode_Mode_MIN = DmiCaches_Mode_MODE_UNKNOWN;
const DmiCaches_Mode DmiCaches_Mode_Mode_MAX = DmiCaches_Mode_MODE_WRITE_WITH_MEMORY_ADDRESS;
const int DmiCaches_Mode_Mode_ARRAYSIZE = DmiCaches_Mode_Mode_MAX + 1;

enum DmiCaches_SRAMType {
  DmiCaches_SRAMType_SRAM_TYPE_BAD = 0,
  DmiCaches_SRAMType_SRAM_TYPE_OTHER = 1,
  DmiCaches_SRAMType_SRAM_TYPE_UNKNOWN = 2,
  DmiCaches_SRAMType_SRAM_TYPE_NON_BURST = 4,
  DmiCaches_SRAMType_SRAM_TYPE_BURST = 8,
  DmiCaches_SRAMType_SRAM_TYPE_PIPELINE_BURST = 16,
  DmiCaches_SRAMType_SRAM_TYPE_SYNCHRONOUS = 32,
  DmiCaches_SRAMType_SRAM_TYPE_ASYNCHRONOUS = 64,
  DmiCaches_SRAMType_DmiCaches_SRAMType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_SRAMType_DmiCaches_SRAMType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_SRAMType_IsValid(int value);
const DmiCaches_SRAMType DmiCaches_SRAMType_SRAMType_MIN = DmiCaches_SRAMType_SRAM_TYPE_BAD;
const DmiCaches_SRAMType DmiCaches_SRAMType_SRAMType_MAX = DmiCaches_SRAMType_SRAM_TYPE_ASYNCHRONOUS;
const int DmiCaches_SRAMType_SRAMType_ARRAYSIZE = DmiCaches_SRAMType_SRAMType_MAX + 1;

enum DmiCaches_ErrorCorrectionType {
  DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_UNKNOWN = 0,
  DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_OTHER = 1,
  DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_NONE = 2,
  DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_PARITY = 3,
  DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_SINGLE_BIT_ECC = 4,
  DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_MULTI_BIT_ECC = 5,
  DmiCaches_ErrorCorrectionType_DmiCaches_ErrorCorrectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_ErrorCorrectionType_DmiCaches_ErrorCorrectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_ErrorCorrectionType_IsValid(int value);
const DmiCaches_ErrorCorrectionType DmiCaches_ErrorCorrectionType_ErrorCorrectionType_MIN = DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_UNKNOWN;
const DmiCaches_ErrorCorrectionType DmiCaches_ErrorCorrectionType_ErrorCorrectionType_MAX = DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_MULTI_BIT_ECC;
const int DmiCaches_ErrorCorrectionType_ErrorCorrectionType_ARRAYSIZE = DmiCaches_ErrorCorrectionType_ErrorCorrectionType_MAX + 1;

enum DmiCaches_Type {
  DmiCaches_Type_TYPE_UNKNOWN = 0,
  DmiCaches_Type_TYPE_OTHER = 1,
  DmiCaches_Type_TYPE_INSTRUCTION = 2,
  DmiCaches_Type_TYPE_DATA = 3,
  DmiCaches_Type_TYPE_UNIFIED = 4,
  DmiCaches_Type_DmiCaches_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_Type_DmiCaches_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_Type_IsValid(int value);
const DmiCaches_Type DmiCaches_Type_Type_MIN = DmiCaches_Type_TYPE_UNKNOWN;
const DmiCaches_Type DmiCaches_Type_Type_MAX = DmiCaches_Type_TYPE_UNIFIED;
const int DmiCaches_Type_Type_ARRAYSIZE = DmiCaches_Type_Type_MAX + 1;

enum DmiCaches_Associativity {
  DmiCaches_Associativity_ASSOCIATIVITY_UNKNOWN = 0,
  DmiCaches_Associativity_ASSOCIATIVITY_OTHER = 1,
  DmiCaches_Associativity_ASSOCIATIVITY_DIRECT_MAPPED = 2,
  DmiCaches_Associativity_ASSOCIATIVITY_2_WAY = 3,
  DmiCaches_Associativity_ASSOCIATIVITY_4_WAY = 4,
  DmiCaches_Associativity_ASSOCIATIVITY_FULLY = 5,
  DmiCaches_Associativity_ASSOCIATIVITY_8_WAY = 6,
  DmiCaches_Associativity_ASSOCIATIVITY_16_WAY = 7,
  DmiCaches_Associativity_ASSOCIATIVITY_12_WAY = 8,
  DmiCaches_Associativity_ASSOCIATIVITY_24_WAY = 9,
  DmiCaches_Associativity_ASSOCIATIVITY_32_WAY = 10,
  DmiCaches_Associativity_ASSOCIATIVITY_48_WAY = 11,
  DmiCaches_Associativity_ASSOCIATIVITY_64_WAY = 12,
  DmiCaches_Associativity_ASSOCIATIVITY_20_WAY = 13,
  DmiCaches_Associativity_DmiCaches_Associativity_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_Associativity_DmiCaches_Associativity_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_Associativity_IsValid(int value);
const DmiCaches_Associativity DmiCaches_Associativity_Associativity_MIN = DmiCaches_Associativity_ASSOCIATIVITY_UNKNOWN;
const DmiCaches_Associativity DmiCaches_Associativity_Associativity_MAX = DmiCaches_Associativity_ASSOCIATIVITY_20_WAY;
const int DmiCaches_Associativity_Associativity_ARRAYSIZE = DmiCaches_Associativity_Associativity_MAX + 1;

enum DmiProcessors_Family {
  DmiProcessors_Family_FAMILY_UNKNOWN = 0,
  DmiProcessors_Family_FAMILY_OTHER = 1,
  DmiProcessors_Family_FAMILY_8086 = 2,
  DmiProcessors_Family_FAMILY_80286 = 3,
  DmiProcessors_Family_FAMILY_INTEL_386_PROCESSOR = 4,
  DmiProcessors_Family_FAMILY_INTEL_486_PROCESSOR = 5,
  DmiProcessors_Family_FAMILY_8087 = 6,
  DmiProcessors_Family_FAMILY_80287 = 7,
  DmiProcessors_Family_FAMILY_80387 = 8,
  DmiProcessors_Family_FAMILY_80487 = 9,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_PROCESSOR = 10,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_PRO_PROCESSOR = 11,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_2_PROCESSOR = 12,
  DmiProcessors_Family_FAMILY_PENTIUM_PROCESSOR_WITH_MMX = 13,
  DmiProcessors_Family_FAMILY_INTEL_CELERON_PROCESSOR = 14,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_2_XEON_PROCESSOR = 15,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_3_PROCESSOR = 16,
  DmiProcessors_Family_FAMILY_M1_FAMILY = 17,
  DmiProcessors_Family_FAMILY_M2_FAMILY = 18,
  DmiProcessors_Family_FAMILY_INTEL_CELEROM_M_PROCESSOR = 19,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_4_HT_PROCESSOR = 20,
  DmiProcessors_Family_FAMILY_AMD_DURON_PROCESSOR_FAMILY = 21,
  DmiProcessors_Family_FAMILY_AMD_K5_FAMILY = 22,
  DmiProcessors_Family_FAMILY_AMD_K6_FAMILY = 23,
  DmiProcessors_Family_FAMILY_AMD_K6_2 = 24,
  DmiProcessors_Family_FAMILY_AMD_K6_3 = 25,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_PROCESSOR_FAMILY = 26,
  DmiProcessors_Family_FAMILY_AMD_29000_FAMILY = 27,
  DmiProcessors_Family_FAMILY_AMD_K6_2_PLUS = 28,
  DmiProcessors_Family_FAMILY_POWER_PC_FAMILY = 29,
  DmiProcessors_Family_FAMILY_POWER_PC_601 = 30,
  DmiProcessors_Family_FAMILY_POWER_PC_603 = 31,
  DmiProcessors_Family_FAMILY_POWER_PC_603_PLUS = 32,
  DmiProcessors_Family_FAMILY_POWER_PC_604 = 33,
  DmiProcessors_Family_FAMILY_POWER_PC_620 = 34,
  DmiProcessors_Family_FAMILY_POWER_PC_X704 = 35,
  DmiProcessors_Family_FAMILY_POWER_PC_750 = 36,
  DmiProcessors_Family_FAMILY_INTEL_CORE_DUO_PROCESSOR = 37,
  DmiProcessors_Family_FAMILY_INTEL_CORE_DUO_MOBILE_PROCESSOR = 38,
  DmiProcessors_Family_FAMILY_INTEL_CORE_SOLO_MOBILE_PROCESSOR = 39,
  DmiProcessors_Family_FAMILY_INTEL_ATOM_PROCESSOR = 40,
  DmiProcessors_Family_FAMILY_INTEL_CORE_M_PROCESSOR = 41,
  DmiProcessors_Family_FAMILY_INTEL_CORE_M3_PROCESSOR = 42,
  DmiProcessors_Family_FAMILY_INTEL_CORE_M5_PROCESSOR = 43,
  DmiProcessors_Family_FAMILY_INTEL_CORE_M7_PROCESSOR = 44,
  DmiProcessors_Family_FAMILY_ALPHA_FAMILY = 45,
  DmiProcessors_Family_FAMILY_ALPHA_21064 = 46,
  DmiProcessors_Family_FAMILY_ALPHA_21066 = 47,
  DmiProcessors_Family_FAMILY_ALPHA_21164 = 48,
  DmiProcessors_Family_FAMILY_ALPHA_21164PC = 49,
  DmiProcessors_Family_FAMILY_ALPHA_21164A = 50,
  DmiProcessors_Family_FAMILY_ALPHA_21264 = 51,
  DmiProcessors_Family_FAMILY_ALPHA_21364 = 52,
  DmiProcessors_Family_FAMILY_AMD_TURION_2_ULTRA_DUAL_CORE_MOBILE_M_FAMILY = 53,
  DmiProcessors_Family_FAMILY_AMD_TURION_2_DUAL_CORE_MOBILE_M_FAMILY = 54,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_2_DUAL_CORE_M_FAMILY = 55,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_6100_SERIES_PROCESSOR = 56,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_4100_SERIES_PROCESSOR = 57,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_6200_SERIES_PROCESSOR = 58,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_4200_SERIES_PROCESSOR = 59,
  DmiProcessors_Family_FAMILY_AMD_FX_SERIES_PROCESSOR = 60,
  DmiProcessors_Family_FAMILY_MIPS_FAMILY = 61,
  DmiProcessors_Family_FAMILY_MIPS_R4000 = 62,
  DmiProcessors_Family_FAMILY_MIPS_R4200 = 63,
  DmiProcessors_Family_FAMILY_MIPS_R4400 = 64,
  DmiProcessors_Family_FAMILY_MIPS_R4600 = 65,
  DmiProcessors_Family_FAMILY_MIPS_R10000 = 66,
  DmiProcessors_Family_FAMILY_AMD_C_SERIES_PROCESSOR = 67,
  DmiProcessors_Family_FAMILY_AMD_E_SERIES_PROCESSOR = 68,
  DmiProcessors_Family_FAMILY_AMD_A_SERIES_PROCESSOR = 69,
  DmiProcessors_Family_FAMILY_AMD_G_SERIES_PROCESSOR = 70,
  DmiProcessors_Family_FAMILY_AMD_Z_SERIES_PROCESSOR = 71,
  DmiProcessors_Family_FAMILY_AMD_R_SERIES_PROCESSOR = 72,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_4300_SERIES_PROCESSOR = 73,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_6300_SERIES_PROCESSOR = 74,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_3300_SERIES_PROCESSOR = 75,
  DmiProcessors_Family_FAMILY_AMD_FIREPRO_SERIES_PROCESSOR = 76,
  DmiProcessors_Family_FAMILY_SPARC_FAMILY = 77,
  DmiProcessors_Family_FAMILY_SUPER_SPARC = 78,
  DmiProcessors_Family_FAMILY_MICRO_SPARC_2 = 79,
  DmiProcessors_Family_FAMILY_MICRO_SPARC_2EP = 80,
  DmiProcessors_Family_FAMILY_ULTRA_SPARC = 81,
  DmiProcessors_Family_FAMILY_ULTRA_SPARC_2 = 82,
  DmiProcessors_Family_FAMILY_ULTRA_SPARC_2I = 83,
  DmiProcessors_Family_FAMILY_ULTRA_SPARC_3 = 84,
  DmiProcessors_Family_FAMILY_ULTRA_SPARC_3I = 85,
  DmiProcessors_Family_FAMILY_68040_FAMILY = 86,
  DmiProcessors_Family_FAMILY_68XXX = 87,
  DmiProcessors_Family_FAMILY_68000 = 88,
  DmiProcessors_Family_FAMILY_68010 = 89,
  DmiProcessors_Family_FAMILY_68020 = 90,
  DmiProcessors_Family_FAMILY_68030 = 91,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_X4_QUAD_CORE_PROCESSOR_FAMILY = 92,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_X1000_SERIES_PROCESSOR = 93,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_X2000_SERIES_APU = 94,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_A_SERIES_PROCESSOR = 95,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_X3000_SERIES_APU = 96,
  DmiProcessors_Family_FAMILY_AMD_ZEN_PROCESSOR_FAMILY = 97,
  DmiProcessors_Family_FAMILY_HOBBIT_FAMILY = 98,
  DmiProcessors_Family_FAMILY_CRUSOE_TM5000_FAMILY = 99,
  DmiProcessors_Family_FAMILY_CRUSOE_TM3000_FAMILY = 100,
  DmiProcessors_Family_FAMILY_EFFICEON_TM8000_FAMILY = 101,
  DmiProcessors_Family_FAMILY_WEITEK = 102,
  DmiProcessors_Family_FAMILY_INTEL_ITANIUM_PROCESSOR = 103,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_64_PROCESSOR_FAMILY = 104,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_PROCESSOR_FAMILY = 105,
  DmiProcessors_Family_FAMILY_AMD_SEMPRON_PROCESSOR_FAMILY = 106,
  DmiProcessors_Family_FAMILY_AMD_TURION_64_MOBILE_TECHNOLOGY = 107,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_DUAL_CORE_PROCESSOR_FAMILY = 108,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_64_X2_DUAL_CORE_PROCESSOR_FAMILY = 109,
  DmiProcessors_Family_FAMILY_AMD_TURION_64_X2_MOBILE_TECHNOLOGY = 110,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_QUAD_CORE_PROCESSOR_FAMILY = 111,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_THIRD_GEN_PROCESSOR_FAMILY = 112,
  DmiProcessors_Family_FAMILY_AMD_PHENOM_FX_QUAD_CORE_PROCESSOR_FAMILY = 113,
  DmiProcessors_Family_FAMILY_AMD_PHENOM_X4_QUAD_CORE_PROCESSOR_FAMILY = 114,
  DmiProcessors_Family_FAMILY_AMD_PHENOM_X2_DUAL_CORE_PROCESSOR_FAMILY = 115,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_X2_DUAL_CORE_PROCESSOR_FAMILY = 116,
  DmiProcessors_Family_FAMILY_PA_RISC_FAMILY = 117,
  DmiProcessors_Family_FAMILY_PA_RISC_8500 = 118,
  DmiProcessors_Family_FAMILY_PA_RISC_8000 = 119,
  DmiProcessors_Family_FAMILY_PA_RISC_7300LC = 120,
  DmiProcessors_Family_FAMILY_PA_RISC_7200 = 121,
  DmiProcessors_Family_FAMILY_PA_RISC_7100LC = 122,
  DmiProcessors_Family_FAMILY_PA_RISC_7100 = 123,
  DmiProcessors_Family_FAMILY_V30_FAMILY = 124,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_3200_PROCESSOR_SERIES = 125,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_3000_PROCESSOR_SERIES = 126,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_5300_PROCESSOR_SERIES = 127,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5100_PROCESSOR_SERIES = 128,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5000_PROCESSOR_SERIES = 129,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_LV_PROCESSOR = 130,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_ULV_PROCESSOR = 131,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_7100_PROCESSOR_SERIES = 132,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_5400_PROCESSOR_SERIES = 133,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_PROCESSOR = 134,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5200_PROCESSOR_SERIES = 135,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_7200_PROCESSOR_SERIES = 136,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_7300_PROCESSOR_SERIES = 137,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_7400_PROCESSOR_SERIES = 138,
  DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_7400_PROCESSOR_SERIES = 139,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_3_XEON_PROCESSOR = 140,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_3_PROCESSOR_WITH_SPEED_STEP = 141,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_4_PROCESSOR = 142,
  DmiProcessors_Family_FAMILY_INTEL_XEON_PROCESSOR = 143,
  DmiProcessors_Family_FAMILY_AS400_FAMILY = 144,
  DmiProcessors_Family_FAMILY_INTEL_XEON_MP_PROCESSOR = 145,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_XP_PROCESSOR_FAMILY = 146,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_MP_PROCESSOR_FAMILY = 147,
  DmiProcessors_Family_FAMILY_INTEL_ITANIUM_2_PROCESSOR = 148,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_M_PROCESSOR = 149,
  DmiProcessors_Family_FAMILY_INTEL_CELERON_D_PROCESSOR = 150,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_D_PROCESSOR = 151,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_PROCESSOR_EXTREME_EDITION = 152,
  DmiProcessors_Family_FAMILY_INTEL_CORE_SOLO_PROCESSOR = 153,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_DUO_PROCESSOR = 154,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_SOLO_PROCESSOR = 155,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_EXTREME_PROCESSOR = 156,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_QUAD_PROCESSOR = 157,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_EXTREME_MOBILE_PROCESSOR = 158,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_DUO_MOBILE_PROCESSOR = 159,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_SOLO_MOBILE_PROCESSOR = 160,
  DmiProcessors_Family_FAMILY_INTEL_CORE_I7_PROCESSOR = 161,
  DmiProcessors_Family_FAMILY_INTEL_CELERON_DUAL_CORE_PROCESSOR = 162,
  DmiProcessors_Family_FAMILY_IBM390_FAMILY = 163,
  DmiProcessors_Family_FAMILY_G4 = 164,
  DmiProcessors_Family_FAMILY_G5 = 165,
  DmiProcessors_Family_FAMILY_ESA_390_G6 = 166,
  DmiProcessors_Family_FAMILY_Z_ARCHITECTURE_BASE = 167,
  DmiProcessors_Family_FAMILY_INTEL_CORE_I5_PROCESSOR = 168,
  DmiProcessors_Family_FAMILY_INTEL_CORE_I3_PROCESSOR = 169,
  DmiProcessors_Family_FAMILY_VIA_C7_M_PROCESSOR_FAMILY = 170,
  DmiProcessors_Family_FAMILY_VIA_C7_D_PROCESSOR_FAMILY = 171,
  DmiProcessors_Family_FAMILY_VIA_C7_PROCESSOR_FAMILY = 172,
  DmiProcessors_Family_FAMILY_VIA_EDEN_PROCESSOR_FAMILY = 173,
  DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_PROCESSOR = 174,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_3XXX_PROCESSOR_SERIES = 175,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_3XXX_PROCESSOR_SERIES = 176,
  DmiProcessors_Family_FAMILY_VIA_NANO_PROCESSOR_FAMILY = 177,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5XXX_PROCESSOR_SERIES = 178,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_5XXX_PROCESSOR_SERIES = 179,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_7XXX_PROCESSOR_SERIES = 180,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_7XXX_PROCESSOR_SERIES = 181,
  DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_7XXX_PROCESSOR_SERIES = 182,
  DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_3400_PROCESSOR_SERIES = 183,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_3000_PROCESSOR_SERIES = 184,
  DmiProcessors_Family_FAMILY_AMD_SEMPRON_II_PROCESSOR = 185,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_QUAD_CORE_EMBEDDED_PROCESSOR_FAMILY = 186,
  DmiProcessors_Family_FAMILY_AMD_PHENOM_TRIPLE_CORE_PROCESSOR_FAMILY = 187,
  DmiProcessors_Family_FAMILY_AMD_TURION_ULTRA_DUAL_CORE_MOBILE_PROCESSOR_FAMILY = 188,
  DmiProcessors_Family_FAMILY_AMD_TURION_DUAL_CORE_MOBILE_PROCESSOR_FAMILY = 189,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_DUAL_CORE_PROCESSOR_FAMILY = 190,
  DmiProcessors_Family_FAMILY_AMD_SEMPRON_SI_PROCESSOR_FAMILY = 191,
  DmiProcessors_Family_FAMILY_AMD_PHENOM_2_PROCESSOR_FAMILY = 192,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_2_PROCESSOR_FAMILY = 193,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_SIX_CORE_PROCESSOR_FAMILY = 194,
  DmiProcessors_Family_FAMILY_AMD_SEMPRON_M_PROCESSOR_FAMILY = 195,
  DmiProcessors_Family_FAMILY_I860 = 196,
  DmiProcessors_Family_FAMILY_I960 = 197,
  DmiProcessors_Family_FAMILY_ARM_V7 = 198,
  DmiProcessors_Family_FAMILY_ARM_V8 = 199,
  DmiProcessors_Family_FAMILY_SH_3 = 200,
  DmiProcessors_Family_FAMILY_SH_4 = 201,
  DmiProcessors_Family_FAMILY_ARM = 202,
  DmiProcessors_Family_FAMILY_STRONG_ARM = 203,
  DmiProcessors_Family_FAMILY_6X86 = 204,
  DmiProcessors_Family_FAMILY_MEDIA_GX = 205,
  DmiProcessors_Family_FAMILY_MII = 206,
  DmiProcessors_Family_FAMILY_WIN_CHIP = 207,
  DmiProcessors_Family_FAMILY_DSP = 208,
  DmiProcessors_Family_FAMILY_VIDEO_PROCESSOR = 209,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_FAMILY = 210,
  DmiProcessors_Family_FAMILY_AMD_K7_FAMILY = 211,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_OR_AMD_K7_FAMILY = 212,
  DmiProcessors_Family_DmiProcessors_Family_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiProcessors_Family_DmiProcessors_Family_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiProcessors_Family_IsValid(int value);
const DmiProcessors_Family DmiProcessors_Family_Family_MIN = DmiProcessors_Family_FAMILY_UNKNOWN;
const DmiProcessors_Family DmiProcessors_Family_Family_MAX = DmiProcessors_Family_FAMILY_INTEL_CORE_2_OR_AMD_K7_FAMILY;
const int DmiProcessors_Family_Family_ARRAYSIZE = DmiProcessors_Family_Family_MAX + 1;

enum DmiProcessors_Type {
  DmiProcessors_Type_TYPE_UNKNOWN = 0,
  DmiProcessors_Type_TYPE_OTHER = 1,
  DmiProcessors_Type_TYPE_CENTRAL_PROCESSOR = 2,
  DmiProcessors_Type_TYPE_MATH_PROCESSOR = 3,
  DmiProcessors_Type_TYPE_DSP_PROCESSOR = 4,
  DmiProcessors_Type_TYPE_VIDEO_PROCESSOR = 5,
  DmiProcessors_Type_DmiProcessors_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiProcessors_Type_DmiProcessors_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiProcessors_Type_IsValid(int value);
const DmiProcessors_Type DmiProcessors_Type_Type_MIN = DmiProcessors_Type_TYPE_UNKNOWN;
const DmiProcessors_Type DmiProcessors_Type_Type_MAX = DmiProcessors_Type_TYPE_VIDEO_PROCESSOR;
const int DmiProcessors_Type_Type_ARRAYSIZE = DmiProcessors_Type_Type_MAX + 1;

enum DmiProcessors_Status {
  DmiProcessors_Status_STATUS_UNKNOWN = 0,
  DmiProcessors_Status_STATUS_ENABLED = 1,
  DmiProcessors_Status_STATUS_DISABLED_BY_USER = 2,
  DmiProcessors_Status_STATUS_DISABLED_BY_BIOS = 3,
  DmiProcessors_Status_STATUS_IDLE = 4,
  DmiProcessors_Status_STATUS_OTHER = 5,
  DmiProcessors_Status_DmiProcessors_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiProcessors_Status_DmiProcessors_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiProcessors_Status_IsValid(int value);
const DmiProcessors_Status DmiProcessors_Status_Status_MIN = DmiProcessors_Status_STATUS_UNKNOWN;
const DmiProcessors_Status DmiProcessors_Status_Status_MAX = DmiProcessors_Status_STATUS_OTHER;
const int DmiProcessors_Status_Status_ARRAYSIZE = DmiProcessors_Status_Status_MAX + 1;

enum DmiProcessors_Upgrade {
  DmiProcessors_Upgrade_UPGRADE_UNKNOWN = 0,
  DmiProcessors_Upgrade_UPGRADE_OTHER = 1,
  DmiProcessors_Upgrade_UPGRADE_DAUGHTER_BOARD = 2,
  DmiProcessors_Upgrade_UPGRADE_ZIF_SOCKET = 3,
  DmiProcessors_Upgrade_UPGRADE_REPLACEABLE_PIGGY_BACK = 4,
  DmiProcessors_Upgrade_UPGRADE_NONE = 5,
  DmiProcessors_Upgrade_UPGRADE_LIF_SOCKET = 6,
  DmiProcessors_Upgrade_UPGRADE_SLOT_1 = 7,
  DmiProcessors_Upgrade_UPGRADE_SLOT_2 = 8,
  DmiProcessors_Upgrade_UPGRADE_370_PIN_SOCKET = 9,
  DmiProcessors_Upgrade_UPGRADE_SLOT_A = 10,
  DmiProcessors_Upgrade_UPGRADE_SLOT_M = 11,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_423 = 12,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_462 = 13,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_478 = 14,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_754 = 15,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_940 = 16,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_939 = 17,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_MPGA604 = 18,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA771 = 19,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA775 = 20,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_S1 = 21,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_AM2 = 22,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_F = 23,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1366 = 24,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_G34 = 25,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_AM3 = 26,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_C32 = 27,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1156 = 28,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1567 = 29,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_PGA988A = 30,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1288 = 31,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_RPGA988B = 32,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1023 = 33,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1224 = 34,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1155 = 35,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1356 = 36,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA2011 = 37,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_FS1 = 38,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_FS2 = 39,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_FM1 = 40,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_FM2 = 41,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA2011_3 = 42,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1356_3 = 43,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1150 = 44,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1168 = 45,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1234 = 46,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1364 = 47,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_AM4 = 48,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1151 = 49,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1356 = 50,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1440 = 51,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1515 = 52,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA3647_1 = 53,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_SP3 = 54,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_SP3_R2 = 55,
  DmiProcessors_Upgrade_DmiProcessors_Upgrade_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiProcessors_Upgrade_DmiProcessors_Upgrade_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiProcessors_Upgrade_IsValid(int value);
const DmiProcessors_Upgrade DmiProcessors_Upgrade_Upgrade_MIN = DmiProcessors_Upgrade_UPGRADE_UNKNOWN;
const DmiProcessors_Upgrade DmiProcessors_Upgrade_Upgrade_MAX = DmiProcessors_Upgrade_UPGRADE_SOCKET_SP3_R2;
const int DmiProcessors_Upgrade_Upgrade_ARRAYSIZE = DmiProcessors_Upgrade_Upgrade_MAX + 1;

enum DmiProcessors_Characteristics {
  DmiProcessors_Characteristics_CHARACTERISTIC_NONE = 0,
  DmiProcessors_Characteristics_CHARACTERISTIC_64BIT_CAPABLE = 1,
  DmiProcessors_Characteristics_CHARACTERISTIC_MULTI_CORE = 2,
  DmiProcessors_Characteristics_CHARACTERISTIC_HARDWARE_THREAD = 4,
  DmiProcessors_Characteristics_CHARACTERISTIC_EXECUTE_PROTECTION = 8,
  DmiProcessors_Characteristics_CHARACTERISTIC_ENHANCED_VIRTUALIZATION = 16,
  DmiProcessors_Characteristics_CHARACTERISTIC_POWER_CONTROL = 32,
  DmiProcessors_Characteristics_DmiProcessors_Characteristics_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiProcessors_Characteristics_DmiProcessors_Characteristics_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiProcessors_Characteristics_IsValid(int value);
const DmiProcessors_Characteristics DmiProcessors_Characteristics_Characteristics_MIN = DmiProcessors_Characteristics_CHARACTERISTIC_NONE;
const DmiProcessors_Characteristics DmiProcessors_Characteristics_Characteristics_MAX = DmiProcessors_Characteristics_CHARACTERISTIC_POWER_CONTROL;
const int DmiProcessors_Characteristics_Characteristics_ARRAYSIZE = DmiProcessors_Characteristics_Characteristics_MAX + 1;

enum DmiMemoryDevices_Type {
  DmiMemoryDevices_Type_TYPE_UNKNOWN = 0,
  DmiMemoryDevices_Type_TYPE_OTHER = 1,
  DmiMemoryDevices_Type_TYPE_DRAM = 2,
  DmiMemoryDevices_Type_TYPE_EDRAM = 3,
  DmiMemoryDevices_Type_TYPE_VRAM = 4,
  DmiMemoryDevices_Type_TYPE_SRAM = 5,
  DmiMemoryDevices_Type_TYPE_RAM = 6,
  DmiMemoryDevices_Type_TYPE_ROM = 7,
  DmiMemoryDevices_Type_TYPE_FLASH = 8,
  DmiMemoryDevices_Type_TYPE_EEPROM = 9,
  DmiMemoryDevices_Type_TYPE_FEPROM = 10,
  DmiMemoryDevices_Type_TYPE_EPROM = 11,
  DmiMemoryDevices_Type_TYPE_CDRAM = 12,
  DmiMemoryDevices_Type_TYPE_3DRAM = 13,
  DmiMemoryDevices_Type_TYPE_SDRAM = 14,
  DmiMemoryDevices_Type_TYPE_SGRAM = 15,
  DmiMemoryDevices_Type_TYPE_RDRAM = 16,
  DmiMemoryDevices_Type_TYPE_DDR = 17,
  DmiMemoryDevices_Type_TYPE_DDR2 = 18,
  DmiMemoryDevices_Type_TYPE_DDR2_FB_DIMM = 19,
  DmiMemoryDevices_Type_TYPE_DDR3 = 20,
  DmiMemoryDevices_Type_TYPE_FBD2 = 21,
  DmiMemoryDevices_Type_TYPE_DDR4 = 22,
  DmiMemoryDevices_Type_TYPE_LPDDR = 23,
  DmiMemoryDevices_Type_TYPE_LPDDR2 = 24,
  DmiMemoryDevices_Type_TYPE_LPDDR3 = 25,
  DmiMemoryDevices_Type_TYPE_LPDDR4 = 26,
  DmiMemoryDevices_Type_DmiMemoryDevices_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiMemoryDevices_Type_DmiMemoryDevices_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiMemoryDevices_Type_IsValid(int value);
const DmiMemoryDevices_Type DmiMemoryDevices_Type_Type_MIN = DmiMemoryDevices_Type_TYPE_UNKNOWN;
const DmiMemoryDevices_Type DmiMemoryDevices_Type_Type_MAX = DmiMemoryDevices_Type_TYPE_LPDDR4;
const int DmiMemoryDevices_Type_Type_ARRAYSIZE = DmiMemoryDevices_Type_Type_MAX + 1;

enum DmiMemoryDevices_FormFactor {
  DmiMemoryDevices_FormFactor_FORM_FACTOR_UNKNOWN = 0,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_OTHER = 1,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_SIMM = 2,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_SIP = 3,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_CHIP = 4,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_DIP = 5,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_ZIP = 6,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_PROPRIETARY_CARD = 7,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_DIMM = 8,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_TSOP = 9,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_ROW_OF_CHIPS = 10,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_RIMM = 11,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_SODIMM = 12,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_SRIMM = 13,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_FB_DIMM = 14,
  DmiMemoryDevices_FormFactor_DmiMemoryDevices_FormFactor_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiMemoryDevices_FormFactor_DmiMemoryDevices_FormFactor_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiMemoryDevices_FormFactor_IsValid(int value);
const DmiMemoryDevices_FormFactor DmiMemoryDevices_FormFactor_FormFactor_MIN = DmiMemoryDevices_FormFactor_FORM_FACTOR_UNKNOWN;
const DmiMemoryDevices_FormFactor DmiMemoryDevices_FormFactor_FormFactor_MAX = DmiMemoryDevices_FormFactor_FORM_FACTOR_FB_DIMM;
const int DmiMemoryDevices_FormFactor_FormFactor_ARRAYSIZE = DmiMemoryDevices_FormFactor_FormFactor_MAX + 1;

enum DmiSystemSlots_Type {
  DmiSystemSlots_Type_TYPE_UNKNOWN = 0,
  DmiSystemSlots_Type_TYPE_OTHER = 1,
  DmiSystemSlots_Type_TYPE_ISA = 2,
  DmiSystemSlots_Type_TYPE_MCA = 3,
  DmiSystemSlots_Type_TYPE_EISA = 4,
  DmiSystemSlots_Type_TYPE_PCI = 5,
  DmiSystemSlots_Type_TYPE_PC_CARD = 6,
  DmiSystemSlots_Type_TYPE_VLB = 7,
  DmiSystemSlots_Type_TYPE_PROPRIETARY = 8,
  DmiSystemSlots_Type_TYPE_PROCESSOR_CARD = 9,
  DmiSystemSlots_Type_TYPE_PROPRIETARY_MEMORY_CARD = 10,
  DmiSystemSlots_Type_TYPE_IO_RISER_CARD = 11,
  DmiSystemSlots_Type_TYPE_NUBUS = 12,
  DmiSystemSlots_Type_TYPE_PCI_66 = 13,
  DmiSystemSlots_Type_TYPE_AGP = 14,
  DmiSystemSlots_Type_TYPE_AGP_2X = 15,
  DmiSystemSlots_Type_TYPE_AGP_4X = 16,
  DmiSystemSlots_Type_TYPE_PCI_X = 17,
  DmiSystemSlots_Type_TYPE_AGP_8X = 18,
  DmiSystemSlots_Type_TYPE_M2_SOCKET_1DP = 19,
  DmiSystemSlots_Type_TYPE_M2_SOCKET_1SD = 20,
  DmiSystemSlots_Type_TYPE_M2_SOCKET_2 = 21,
  DmiSystemSlots_Type_TYPE_M2_SOCKET_3 = 22,
  DmiSystemSlots_Type_TYPE_MXM_TYPE_I = 23,
  DmiSystemSlots_Type_TYPE_MXM_TYPE_II = 24,
  DmiSystemSlots_Type_TYPE_MXM_TYPE_III = 25,
  DmiSystemSlots_Type_TYPE_MXM_TYPE_III_HE = 26,
  DmiSystemSlots_Type_TYPE_MXM_TYPE_IV = 27,
  DmiSystemSlots_Type_TYPE_MXM_30_TYPE_A = 28,
  DmiSystemSlots_Type_TYPE_MXM_30_TYPE_B = 29,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_SFF_8639 = 30,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_SFF_8639 = 31,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_MINI_52PIN_WITH_BOTTOM_SIDE = 32,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_MINI_52PIN = 33,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_MINI_76PIN = 34,
  DmiSystemSlots_Type_TYPE_PC98_C20 = 35,
  DmiSystemSlots_Type_TYPE_PC98_C24 = 36,
  DmiSystemSlots_Type_TYPE_PC98_E = 37,
  DmiSystemSlots_Type_TYPE_PC98_LOCAL_BUS = 38,
  DmiSystemSlots_Type_TYPE_PC98_CARD = 39,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS = 40,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X1 = 41,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X2 = 42,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X4 = 43,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X8 = 44,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X16 = 45,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2 = 46,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X1 = 47,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X2 = 48,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X4 = 49,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X8 = 50,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X16 = 51,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3 = 52,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X1 = 53,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X2 = 54,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X4 = 55,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X8 = 56,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X16 = 57,
  DmiSystemSlots_Type_DmiSystemSlots_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiSystemSlots_Type_DmiSystemSlots_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiSystemSlots_Type_IsValid(int value);
const DmiSystemSlots_Type DmiSystemSlots_Type_Type_MIN = DmiSystemSlots_Type_TYPE_UNKNOWN;
const DmiSystemSlots_Type DmiSystemSlots_Type_Type_MAX = DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X16;
const int DmiSystemSlots_Type_Type_ARRAYSIZE = DmiSystemSlots_Type_Type_MAX + 1;

enum DmiSystemSlots_Usage {
  DmiSystemSlots_Usage_USAGE_UNKNOWN = 0,
  DmiSystemSlots_Usage_USAGE_OTHER = 1,
  DmiSystemSlots_Usage_USAGE_AVAILABLE = 2,
  DmiSystemSlots_Usage_USAGE_IN_USE = 3,
  DmiSystemSlots_Usage_DmiSystemSlots_Usage_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiSystemSlots_Usage_DmiSystemSlots_Usage_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiSystemSlots_Usage_IsValid(int value);
const DmiSystemSlots_Usage DmiSystemSlots_Usage_Usage_MIN = DmiSystemSlots_Usage_USAGE_UNKNOWN;
const DmiSystemSlots_Usage DmiSystemSlots_Usage_Usage_MAX = DmiSystemSlots_Usage_USAGE_IN_USE;
const int DmiSystemSlots_Usage_Usage_ARRAYSIZE = DmiSystemSlots_Usage_Usage_MAX + 1;

enum DmiSystemSlots_BusWidth {
  DmiSystemSlots_BusWidth_BUS_WIDTH_UNKNOWN = 0,
  DmiSystemSlots_BusWidth_BUS_WIDTH_OTHER = 1,
  DmiSystemSlots_BusWidth_BUS_WIDTH_8_BIT = 2,
  DmiSystemSlots_BusWidth_BUS_WIDTH_16_BIT = 3,
  DmiSystemSlots_BusWidth_BUS_WIDTH_32_BIT = 4,
  DmiSystemSlots_BusWidth_BUS_WIDTH_64_BIT = 5,
  DmiSystemSlots_BusWidth_BUS_WIDTH_128_BIT = 6,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X1 = 7,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X2 = 8,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X4 = 9,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X8 = 10,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X12 = 11,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X16 = 12,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X32 = 13,
  DmiSystemSlots_BusWidth_DmiSystemSlots_BusWidth_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiSystemSlots_BusWidth_DmiSystemSlots_BusWidth_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiSystemSlots_BusWidth_IsValid(int value);
const DmiSystemSlots_BusWidth DmiSystemSlots_BusWidth_BusWidth_MIN = DmiSystemSlots_BusWidth_BUS_WIDTH_UNKNOWN;
const DmiSystemSlots_BusWidth DmiSystemSlots_BusWidth_BusWidth_MAX = DmiSystemSlots_BusWidth_BUS_WIDTH_X32;
const int DmiSystemSlots_BusWidth_BusWidth_ARRAYSIZE = DmiSystemSlots_BusWidth_BusWidth_MAX + 1;

enum DmiSystemSlots_Length {
  DmiSystemSlots_Length_LENGTH_UNKNOWN = 0,
  DmiSystemSlots_Length_LENGTH_OTHER = 1,
  DmiSystemSlots_Length_LENGTH_SHORT = 2,
  DmiSystemSlots_Length_LENGTH_LONG = 3,
  DmiSystemSlots_Length_DmiSystemSlots_Length_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiSystemSlots_Length_DmiSystemSlots_Length_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiSystemSlots_Length_IsValid(int value);
const DmiSystemSlots_Length DmiSystemSlots_Length_Length_MIN = DmiSystemSlots_Length_LENGTH_UNKNOWN;
const DmiSystemSlots_Length DmiSystemSlots_Length_Length_MAX = DmiSystemSlots_Length_LENGTH_LONG;
const int DmiSystemSlots_Length_Length_ARRAYSIZE = DmiSystemSlots_Length_Length_MAX + 1;

enum DmiPortConnectors_Type {
  DmiPortConnectors_Type_TYPE_UNKNOWN = 0,
  DmiPortConnectors_Type_TYPE_NONE = 1,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_XT_AT_COMPATIBLE = 2,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_PS_2 = 3,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_ECP = 4,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_EPP = 5,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_ECP_EPP = 6,
  DmiPortConnectors_Type_TYPE_SERIAL_PORT_XT_AT_COMPATIBLE = 7,
  DmiPortConnectors_Type_TYPE_SERIAL_PORT_16450_COMPATIBLE = 8,
  DmiPortConnectors_Type_TYPE_SERIAL_PORT_16550_COMPATIBLE = 9,
  DmiPortConnectors_Type_TYPE_SERIAL_PORT_16550A_COMPATIBLE = 10,
  DmiPortConnectors_Type_TYPE_SCSI_PORT = 11,
  DmiPortConnectors_Type_TYPE_MIDI_PORT = 12,
  DmiPortConnectors_Type_TYPE_JOYSTICK_PORT = 13,
  DmiPortConnectors_Type_TYPE_KEYBOARD_PORT = 14,
  DmiPortConnectors_Type_TYPE_MOUSE_PORT = 15,
  DmiPortConnectors_Type_TYPE_SSA_SCSI = 16,
  DmiPortConnectors_Type_TYPE_USB = 17,
  DmiPortConnectors_Type_TYPE_FIREWIRE = 18,
  DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_I = 19,
  DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_II = 20,
  DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_III = 21,
  DmiPortConnectors_Type_TYPE_CARDBUS = 22,
  DmiPortConnectors_Type_TYPE_ACCESS_BUS_PORT = 23,
  DmiPortConnectors_Type_TYPE_SCSI_II = 24,
  DmiPortConnectors_Type_TYPE_SCSI_WIDE = 25,
  DmiPortConnectors_Type_TYPE_PC_98 = 26,
  DmiPortConnectors_Type_TYPE_PC_98_HIRESO = 27,
  DmiPortConnectors_Type_TYPE_PC_H98 = 28,
  DmiPortConnectors_Type_TYPE_VIDEO_PORT = 29,
  DmiPortConnectors_Type_TYPE_AUDIO_PORT = 30,
  DmiPortConnectors_Type_TYPE_MODEM_PORT = 31,
  DmiPortConnectors_Type_TYPE_NETWORK_PORT = 32,
  DmiPortConnectors_Type_TYPE_SATA = 33,
  DmiPortConnectors_Type_TYPE_SAS = 34,
  DmiPortConnectors_Type_TYPE_8251_COMPATIBLE = 35,
  DmiPortConnectors_Type_TYPE_8251_FIFO_COMPATIBLE = 36,
  DmiPortConnectors_Type_DmiPortConnectors_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPortConnectors_Type_DmiPortConnectors_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPortConnectors_Type_IsValid(int value);
const DmiPortConnectors_Type DmiPortConnectors_Type_Type_MIN = DmiPortConnectors_Type_TYPE_UNKNOWN;
const DmiPortConnectors_Type DmiPortConnectors_Type_Type_MAX = DmiPortConnectors_Type_TYPE_8251_FIFO_COMPATIBLE;
const int DmiPortConnectors_Type_Type_ARRAYSIZE = DmiPortConnectors_Type_Type_MAX + 1;

enum DmiPortConnectors_ConnectorType {
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_UNKNOWN = 0,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_NONE = 1,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_OTHER = 2,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CENTRONICS = 3,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS = 4,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PROPRIETARY = 5,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_25_MALE = 6,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_25_FEMALE = 7,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_15_MALE = 8,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_15_FEMALE = 9,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_9_MALE = 10,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_9_FEMALE = 11,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_RJ_11 = 12,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_RJ_45 = 13,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_50_PIN_MINISCSI = 14,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_DIN = 15,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MICRO_DIN = 16,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PS_2 = 17,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_INFRARED = 18,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_HP_HIL = 19,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ACCESS_BUS_USB = 20,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_SSA_SCSI = 21,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_MALE = 22,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_FEMALE = 23,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_IDE = 24,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_FLOPPY = 25,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_9_PIN_DUAL_INLINE = 26,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_25_PIN_DUAL_INLINE = 27,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_50_PIN_DUAL_INLINE = 28,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_68_PIN_DUAL_INLINE = 29,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_SOUND_INPUT_FROM_CDROM = 30,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_14 = 31,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_26 = 32,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_JACK = 33,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_BNC = 34,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_IEEE_1394 = 35,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_SAS_SATE_PLUG_RECEPTACLE = 36,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98 = 37,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_HIRESO = 38,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_H98 = 39,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_NOTE = 40,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_FULL = 41,
  DmiPortConnectors_ConnectorType_DmiPortConnectors_ConnectorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPortConnectors_ConnectorType_DmiPortConnectors_ConnectorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPortConnectors_ConnectorType_IsValid(int value);
const DmiPortConnectors_ConnectorType DmiPortConnectors_ConnectorType_ConnectorType_MIN = DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_UNKNOWN;
const DmiPortConnectors_ConnectorType DmiPortConnectors_ConnectorType_ConnectorType_MAX = DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_FULL;
const int DmiPortConnectors_ConnectorType_ConnectorType_ARRAYSIZE = DmiPortConnectors_ConnectorType_ConnectorType_MAX + 1;

enum DmiOnBoardDevices_Type {
  DmiOnBoardDevices_Type_TYPE_UNKNOWN = 0,
  DmiOnBoardDevices_Type_TYPE_OTHER = 1,
  DmiOnBoardDevices_Type_TYPE_VIDEO = 2,
  DmiOnBoardDevices_Type_TYPE_SCSI_CONTROLLER = 3,
  DmiOnBoardDevices_Type_TYPE_ETHERNET = 4,
  DmiOnBoardDevices_Type_TYPE_TOKEN_RING = 5,
  DmiOnBoardDevices_Type_TYPE_SOUND = 6,
  DmiOnBoardDevices_Type_TYPE_PATA_CONTROLLER = 7,
  DmiOnBoardDevices_Type_TYPE_SATA_CONTROLLER = 8,
  DmiOnBoardDevices_Type_TYPE_SAS_CONTROLLER = 9,
  DmiOnBoardDevices_Type_DmiOnBoardDevices_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiOnBoardDevices_Type_DmiOnBoardDevices_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiOnBoardDevices_Type_IsValid(int value);
const DmiOnBoardDevices_Type DmiOnBoardDevices_Type_Type_MIN = DmiOnBoardDevices_Type_TYPE_UNKNOWN;
const DmiOnBoardDevices_Type DmiOnBoardDevices_Type_Type_MAX = DmiOnBoardDevices_Type_TYPE_SAS_CONTROLLER;
const int DmiOnBoardDevices_Type_Type_ARRAYSIZE = DmiOnBoardDevices_Type_Type_MAX + 1;

enum DmiPointingDevices_Type {
  DmiPointingDevices_Type_TYPE_UNKNOWN = 0,
  DmiPointingDevices_Type_TYPE_OTHER = 1,
  DmiPointingDevices_Type_TYPE_MOUSE = 2,
  DmiPointingDevices_Type_TYPE_TRACK_BALL = 3,
  DmiPointingDevices_Type_TYPE_TRACK_POINT = 4,
  DmiPointingDevices_Type_TYPE_GLIDE_POINT = 5,
  DmiPointingDevices_Type_TYPE_TOUCH_PAD = 6,
  DmiPointingDevices_Type_TYPE_TOUCH_SCREEN = 7,
  DmiPointingDevices_Type_TYPE_OPTICAL_SENSOR = 8,
  DmiPointingDevices_Type_DmiPointingDevices_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPointingDevices_Type_DmiPointingDevices_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPointingDevices_Type_IsValid(int value);
const DmiPointingDevices_Type DmiPointingDevices_Type_Type_MIN = DmiPointingDevices_Type_TYPE_UNKNOWN;
const DmiPointingDevices_Type DmiPointingDevices_Type_Type_MAX = DmiPointingDevices_Type_TYPE_OPTICAL_SENSOR;
const int DmiPointingDevices_Type_Type_ARRAYSIZE = DmiPointingDevices_Type_Type_MAX + 1;

enum DmiPointingDevices_Interface {
  DmiPointingDevices_Interface_INTERFACE_UNKNOWN = 0,
  DmiPointingDevices_Interface_INTERFACE_OTHER = 1,
  DmiPointingDevices_Interface_INTERFACE_SERIAL = 2,
  DmiPointingDevices_Interface_INTERFACE_PS_2 = 3,
  DmiPointingDevices_Interface_INTERFACE_INFRARED = 4,
  DmiPointingDevices_Interface_INTERFACE_HP_HIL = 5,
  DmiPointingDevices_Interface_INTERFACE_BUS_MOUSE = 6,
  DmiPointingDevices_Interface_INTERFACE_ADB = 7,
  DmiPointingDevices_Interface_INTERFACE_BUS_MOUSE_DB_9 = 8,
  DmiPointingDevices_Interface_INTERFACE_BUS_MOUSE_MICRO_DIN = 9,
  DmiPointingDevices_Interface_INTERFACE_USB = 10,
  DmiPointingDevices_Interface_DmiPointingDevices_Interface_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPointingDevices_Interface_DmiPointingDevices_Interface_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPointingDevices_Interface_IsValid(int value);
const DmiPointingDevices_Interface DmiPointingDevices_Interface_Interface_MIN = DmiPointingDevices_Interface_INTERFACE_UNKNOWN;
const DmiPointingDevices_Interface DmiPointingDevices_Interface_Interface_MAX = DmiPointingDevices_Interface_INTERFACE_USB;
const int DmiPointingDevices_Interface_Interface_ARRAYSIZE = DmiPointingDevices_Interface_Interface_MAX + 1;

enum DmiPortableBattery_Chemistry {
  DmiPortableBattery_Chemistry_CHEMISTRY_UNKNOWN = 0,
  DmiPortableBattery_Chemistry_CHEMISTRY_OTHER = 1,
  DmiPortableBattery_Chemistry_CHEMISTRY_LEAD_ACID = 2,
  DmiPortableBattery_Chemistry_CHEMISTRY_NICKEL_CADMIUM = 3,
  DmiPortableBattery_Chemistry_CHEMISTRY_NICKEL_METAL_HYDRIDE = 4,
  DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_ION = 5,
  DmiPortableBattery_Chemistry_CHEMISTRY_ZINC_AIR = 6,
  DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_POLYMER = 7,
  DmiPortableBattery_Chemistry_DmiPortableBattery_Chemistry_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPortableBattery_Chemistry_DmiPortableBattery_Chemistry_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPortableBattery_Chemistry_IsValid(int value);
const DmiPortableBattery_Chemistry DmiPortableBattery_Chemistry_Chemistry_MIN = DmiPortableBattery_Chemistry_CHEMISTRY_UNKNOWN;
const DmiPortableBattery_Chemistry DmiPortableBattery_Chemistry_Chemistry_MAX = DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_POLYMER;
const int DmiPortableBattery_Chemistry_Chemistry_ARRAYSIZE = DmiPortableBattery_Chemistry_Chemistry_MAX + 1;

enum Services_Item_Status {
  Services_Item_Status_STATUS_UNKNOWN = 0,
  Services_Item_Status_STATUS_CONTINUE_PENDING = 1,
  Services_Item_Status_STATUS_PAUSE_PENDING = 2,
  Services_Item_Status_STATUS_PAUSED = 3,
  Services_Item_Status_STATUS_RUNNING = 4,
  Services_Item_Status_STATUS_START_PENDING = 5,
  Services_Item_Status_STATUS_STOP_PENDING = 6,
  Services_Item_Status_STATUS_STOPPED = 7,
  Services_Item_Status_Services_Item_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Services_Item_Status_Services_Item_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Services_Item_Status_IsValid(int value);
const Services_Item_Status Services_Item_Status_Status_MIN = Services_Item_Status_STATUS_UNKNOWN;
const Services_Item_Status Services_Item_Status_Status_MAX = Services_Item_Status_STATUS_STOPPED;
const int Services_Item_Status_Status_ARRAYSIZE = Services_Item_Status_Status_MAX + 1;

enum Services_Item_StartupType {
  Services_Item_StartupType_STARTUP_TYPE_UNKNOWN = 0,
  Services_Item_StartupType_STARTUP_TYPE_AUTO_START = 1,
  Services_Item_StartupType_STARTUP_TYPE_DEMAND_START = 2,
  Services_Item_StartupType_STARTUP_TYPE_DISABLED = 3,
  Services_Item_StartupType_STARTUP_TYPE_BOOT_START = 4,
  Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START = 5,
  Services_Item_StartupType_Services_Item_StartupType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Services_Item_StartupType_Services_Item_StartupType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Services_Item_StartupType_IsValid(int value);
const Services_Item_StartupType Services_Item_StartupType_StartupType_MIN = Services_Item_StartupType_STARTUP_TYPE_UNKNOWN;
const Services_Item_StartupType Services_Item_StartupType_StartupType_MAX = Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START;
const int Services_Item_StartupType_StartupType_ARRAYSIZE = Services_Item_StartupType_StartupType_MAX + 1;

enum OpenConnections_Protocol {
  OpenConnections_Protocol_PROTOCOL_UNKNOWN = 0,
  OpenConnections_Protocol_PROTOCOL_TCP = 1,
  OpenConnections_Protocol_PROTOCOL_UDP = 2,
  OpenConnections_Protocol_OpenConnections_Protocol_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OpenConnections_Protocol_OpenConnections_Protocol_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OpenConnections_Protocol_IsValid(int value);
const OpenConnections_Protocol OpenConnections_Protocol_Protocol_MIN = OpenConnections_Protocol_PROTOCOL_UNKNOWN;
const OpenConnections_Protocol OpenConnections_Protocol_Protocol_MAX = OpenConnections_Protocol_PROTOCOL_UDP;
const int OpenConnections_Protocol_Protocol_ARRAYSIZE = OpenConnections_Protocol_Protocol_MAX + 1;

enum OpenConnections_State {
  OpenConnections_State_STATE_UNKNOWN = 0,
  OpenConnections_State_STATE_CLOSED = 1,
  OpenConnections_State_STATE_LISTENING = 2,
  OpenConnections_State_STATE_SYN_SENT = 3,
  OpenConnections_State_STATE_SYN_RCVD = 4,
  OpenConnections_State_STATE_ESTABLISHED = 5,
  OpenConnections_State_STATE_FIN_WAIT1 = 6,
  OpenConnections_State_STATE_FIN_WAIT2 = 7,
  OpenConnections_State_STATE_CLOSE_WAIT = 8,
  OpenConnections_State_STATE_CLOSING = 9,
  OpenConnections_State_STATE_LAST_ACK = 10,
  OpenConnections_State_STATE_TIME_WAIT = 11,
  OpenConnections_State_STATE_DELETE_TCB = 12,
  OpenConnections_State_OpenConnections_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OpenConnections_State_OpenConnections_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OpenConnections_State_IsValid(int value);
const OpenConnections_State OpenConnections_State_State_MIN = OpenConnections_State_STATE_UNKNOWN;
const OpenConnections_State OpenConnections_State_State_MAX = OpenConnections_State_STATE_DELETE_TCB;
const int OpenConnections_State_State_ARRAYSIZE = OpenConnections_State_State_MAX + 1;

enum SharedResources_Item_Type {
  SharedResources_Item_Type_TYPE_UNKNOWN = 0,
  SharedResources_Item_Type_TYPE_DISK = 1,
  SharedResources_Item_Type_TYPE_PRINTER = 2,
  SharedResources_Item_Type_TYPE_DEVICE = 3,
  SharedResources_Item_Type_TYPE_IPC = 4,
  SharedResources_Item_Type_TYPE_SPECIAL = 5,
  SharedResources_Item_Type_TYPE_TEMPORARY = 6,
  SharedResources_Item_Type_SharedResources_Item_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SharedResources_Item_Type_SharedResources_Item_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SharedResources_Item_Type_IsValid(int value);
const SharedResources_Item_Type SharedResources_Item_Type_Type_MIN = SharedResources_Item_Type_TYPE_UNKNOWN;
const SharedResources_Item_Type SharedResources_Item_Type_Type_MAX = SharedResources_Item_Type_TYPE_TEMPORARY;
const int SharedResources_Item_Type_Type_ARRAYSIZE = SharedResources_Item_Type_Type_MAX + 1;

enum Sessions_ConnectState {
  Sessions_ConnectState_CONNECT_STATE_UNKNOWN = 0,
  Sessions_ConnectState_CONNECT_STATE_ACTIVE = 1,
  Sessions_ConnectState_CONNECT_STATE_CONNECTED = 2,
  Sessions_ConnectState_CONNECT_STATE_CONNECT_QUERY = 3,
  Sessions_ConnectState_CONNECT_STATE_SHADOW = 4,
  Sessions_ConnectState_CONNECT_STATE_DISCONNECTED = 5,
  Sessions_ConnectState_CONNECT_STATE_IDLE = 6,
  Sessions_ConnectState_CONNECT_STATE_LISTEN = 7,
  Sessions_ConnectState_CONNECT_STATE_RESET = 8,
  Sessions_ConnectState_CONNECT_STATE_DOWN = 9,
  Sessions_ConnectState_CONNECT_STATE_INIT = 10,
  Sessions_ConnectState_Sessions_ConnectState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Sessions_ConnectState_Sessions_ConnectState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Sessions_ConnectState_IsValid(int value);
const Sessions_ConnectState Sessions_ConnectState_ConnectState_MIN = Sessions_ConnectState_CONNECT_STATE_UNKNOWN;
const Sessions_ConnectState Sessions_ConnectState_ConnectState_MAX = Sessions_ConnectState_CONNECT_STATE_INIT;
const int Sessions_ConnectState_ConnectState_ARRAYSIZE = Sessions_ConnectState_ConnectState_MAX + 1;

// ===================================================================

class DmiBios_Characteristics : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBios.Characteristics) */ {
 public:
  DmiBios_Characteristics();
  virtual ~DmiBios_Characteristics();

  DmiBios_Characteristics(const DmiBios_Characteristics& from);

  inline DmiBios_Characteristics& operator=(const DmiBios_Characteristics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBios_Characteristics(DmiBios_Characteristics&& from) noexcept
    : DmiBios_Characteristics() {
    *this = ::std::move(from);
  }

  inline DmiBios_Characteristics& operator=(DmiBios_Characteristics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBios_Characteristics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBios_Characteristics* internal_default_instance() {
    return reinterpret_cast<const DmiBios_Characteristics*>(
               &_DmiBios_Characteristics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DmiBios_Characteristics* other);
  friend void swap(DmiBios_Characteristics& a, DmiBios_Characteristics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBios_Characteristics* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBios_Characteristics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBios_Characteristics& from);
  void MergeFrom(const DmiBios_Characteristics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBios_Characteristics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool has_isa = 1;
  void clear_has_isa();
  static const int kHasIsaFieldNumber = 1;
  bool has_isa() const;
  void set_has_isa(bool value);

  // bool has_mca = 2;
  void clear_has_mca();
  static const int kHasMcaFieldNumber = 2;
  bool has_mca() const;
  void set_has_mca(bool value);

  // bool has_eisa = 3;
  void clear_has_eisa();
  static const int kHasEisaFieldNumber = 3;
  bool has_eisa() const;
  void set_has_eisa(bool value);

  // bool has_pci = 4;
  void clear_has_pci();
  static const int kHasPciFieldNumber = 4;
  bool has_pci() const;
  void set_has_pci(bool value);

  // bool has_pc_card = 5;
  void clear_has_pc_card();
  static const int kHasPcCardFieldNumber = 5;
  bool has_pc_card() const;
  void set_has_pc_card(bool value);

  // bool has_pnp = 6;
  void clear_has_pnp();
  static const int kHasPnpFieldNumber = 6;
  bool has_pnp() const;
  void set_has_pnp(bool value);

  // bool has_apm = 7;
  void clear_has_apm();
  static const int kHasApmFieldNumber = 7;
  bool has_apm() const;
  void set_has_apm(bool value);

  // bool has_bios_upgradeable = 8;
  void clear_has_bios_upgradeable();
  static const int kHasBiosUpgradeableFieldNumber = 8;
  bool has_bios_upgradeable() const;
  void set_has_bios_upgradeable(bool value);

  // bool has_bios_shadowing = 9;
  void clear_has_bios_shadowing();
  static const int kHasBiosShadowingFieldNumber = 9;
  bool has_bios_shadowing() const;
  void set_has_bios_shadowing(bool value);

  // bool has_vlb = 10;
  void clear_has_vlb();
  static const int kHasVlbFieldNumber = 10;
  bool has_vlb() const;
  void set_has_vlb(bool value);

  // bool has_escd = 11;
  void clear_has_escd();
  static const int kHasEscdFieldNumber = 11;
  bool has_escd() const;
  void set_has_escd(bool value);

  // bool has_boot_from_cd = 12;
  void clear_has_boot_from_cd();
  static const int kHasBootFromCdFieldNumber = 12;
  bool has_boot_from_cd() const;
  void set_has_boot_from_cd(bool value);

  // bool has_selectable_boot = 13;
  void clear_has_selectable_boot();
  static const int kHasSelectableBootFieldNumber = 13;
  bool has_selectable_boot() const;
  void set_has_selectable_boot(bool value);

  // bool has_socketed_boot_rom = 14;
  void clear_has_socketed_boot_rom();
  static const int kHasSocketedBootRomFieldNumber = 14;
  bool has_socketed_boot_rom() const;
  void set_has_socketed_boot_rom(bool value);

  // bool has_boot_from_pc_card = 15;
  void clear_has_boot_from_pc_card();
  static const int kHasBootFromPcCardFieldNumber = 15;
  bool has_boot_from_pc_card() const;
  void set_has_boot_from_pc_card(bool value);

  // bool has_edd = 16;
  void clear_has_edd();
  static const int kHasEddFieldNumber = 16;
  bool has_edd() const;
  void set_has_edd(bool value);

  // bool has_japanese_floppy_for_nec9800 = 17;
  void clear_has_japanese_floppy_for_nec9800();
  static const int kHasJapaneseFloppyForNec9800FieldNumber = 17;
  bool has_japanese_floppy_for_nec9800() const;
  void set_has_japanese_floppy_for_nec9800(bool value);

  // bool has_japanece_floppy_for_toshiba = 18;
  void clear_has_japanece_floppy_for_toshiba();
  static const int kHasJapaneceFloppyForToshibaFieldNumber = 18;
  bool has_japanece_floppy_for_toshiba() const;
  void set_has_japanece_floppy_for_toshiba(bool value);

  // bool has_525_360kb_floppy = 19;
  void clear_has_525_360kb_floppy();
  static const int kHas525360KbFloppyFieldNumber = 19;
  bool has_525_360kb_floppy() const;
  void set_has_525_360kb_floppy(bool value);

  // bool has_525_12mb_floppy = 20;
  void clear_has_525_12mb_floppy();
  static const int kHas52512MbFloppyFieldNumber = 20;
  bool has_525_12mb_floppy() const;
  void set_has_525_12mb_floppy(bool value);

  // bool has_35_720kb_floppy = 21;
  void clear_has_35_720kb_floppy();
  static const int kHas35720KbFloppyFieldNumber = 21;
  bool has_35_720kb_floppy() const;
  void set_has_35_720kb_floppy(bool value);

  // bool has_35_288mb_floppy = 22;
  void clear_has_35_288mb_floppy();
  static const int kHas35288MbFloppyFieldNumber = 22;
  bool has_35_288mb_floppy() const;
  void set_has_35_288mb_floppy(bool value);

  // bool has_print_screen = 23;
  void clear_has_print_screen();
  static const int kHasPrintScreenFieldNumber = 23;
  bool has_print_screen() const;
  void set_has_print_screen(bool value);

  // bool has_8042_keyboard = 24;
  void clear_has_8042_keyboard();
  static const int kHas8042KeyboardFieldNumber = 24;
  bool has_8042_keyboard() const;
  void set_has_8042_keyboard(bool value);

  // bool has_serial = 25;
  void clear_has_serial();
  static const int kHasSerialFieldNumber = 25;
  bool has_serial() const;
  void set_has_serial(bool value);

  // bool has_printer = 26;
  void clear_has_printer();
  static const int kHasPrinterFieldNumber = 26;
  bool has_printer() const;
  void set_has_printer(bool value);

  // bool has_cga_video = 27;
  void clear_has_cga_video();
  static const int kHasCgaVideoFieldNumber = 27;
  bool has_cga_video() const;
  void set_has_cga_video(bool value);

  // bool has_nec_pc98 = 28;
  void clear_has_nec_pc98();
  static const int kHasNecPc98FieldNumber = 28;
  bool has_nec_pc98() const;
  void set_has_nec_pc98(bool value);

  // bool has_acpi = 29;
  void clear_has_acpi();
  static const int kHasAcpiFieldNumber = 29;
  bool has_acpi() const;
  void set_has_acpi(bool value);

  // bool has_usb_legacy = 30;
  void clear_has_usb_legacy();
  static const int kHasUsbLegacyFieldNumber = 30;
  bool has_usb_legacy() const;
  void set_has_usb_legacy(bool value);

  // bool has_agp = 31;
  void clear_has_agp();
  static const int kHasAgpFieldNumber = 31;
  bool has_agp() const;
  void set_has_agp(bool value);

  // bool has_i2o_boot = 32;
  void clear_has_i2o_boot();
  static const int kHasI2OBootFieldNumber = 32;
  bool has_i2o_boot() const;
  void set_has_i2o_boot(bool value);

  // bool has_ls120_boot = 33;
  void clear_has_ls120_boot();
  static const int kHasLs120BootFieldNumber = 33;
  bool has_ls120_boot() const;
  void set_has_ls120_boot(bool value);

  // bool has_atapi_zip_drive_boot = 34;
  void clear_has_atapi_zip_drive_boot();
  static const int kHasAtapiZipDriveBootFieldNumber = 34;
  bool has_atapi_zip_drive_boot() const;
  void set_has_atapi_zip_drive_boot(bool value);

  // bool has_ieee1394_boot = 35;
  void clear_has_ieee1394_boot();
  static const int kHasIeee1394BootFieldNumber = 35;
  bool has_ieee1394_boot() const;
  void set_has_ieee1394_boot(bool value);

  // bool has_smart_battery = 36;
  void clear_has_smart_battery();
  static const int kHasSmartBatteryFieldNumber = 36;
  bool has_smart_battery() const;
  void set_has_smart_battery(bool value);

  // bool has_bios_boot_specification = 37;
  void clear_has_bios_boot_specification();
  static const int kHasBiosBootSpecificationFieldNumber = 37;
  bool has_bios_boot_specification() const;
  void set_has_bios_boot_specification(bool value);

  // bool has_key_init_network_boot = 38;
  void clear_has_key_init_network_boot();
  static const int kHasKeyInitNetworkBootFieldNumber = 38;
  bool has_key_init_network_boot() const;
  void set_has_key_init_network_boot(bool value);

  // bool has_targeted_content_distrib = 39;
  void clear_has_targeted_content_distrib();
  static const int kHasTargetedContentDistribFieldNumber = 39;
  bool has_targeted_content_distrib() const;
  void set_has_targeted_content_distrib(bool value);

  // bool has_uefi = 40;
  void clear_has_uefi();
  static const int kHasUefiFieldNumber = 40;
  bool has_uefi() const;
  void set_has_uefi(bool value);

  // bool has_virtual_machine = 41;
  void clear_has_virtual_machine();
  static const int kHasVirtualMachineFieldNumber = 41;
  bool has_virtual_machine() const;
  void set_has_virtual_machine(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBios.Characteristics)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool has_isa_;
  bool has_mca_;
  bool has_eisa_;
  bool has_pci_;
  bool has_pc_card_;
  bool has_pnp_;
  bool has_apm_;
  bool has_bios_upgradeable_;
  bool has_bios_shadowing_;
  bool has_vlb_;
  bool has_escd_;
  bool has_boot_from_cd_;
  bool has_selectable_boot_;
  bool has_socketed_boot_rom_;
  bool has_boot_from_pc_card_;
  bool has_edd_;
  bool has_japanese_floppy_for_nec9800_;
  bool has_japanece_floppy_for_toshiba_;
  bool has_525_360kb_floppy_;
  bool has_525_12mb_floppy_;
  bool has_35_720kb_floppy_;
  bool has_35_288mb_floppy_;
  bool has_print_screen_;
  bool has_8042_keyboard_;
  bool has_serial_;
  bool has_printer_;
  bool has_cga_video_;
  bool has_nec_pc98_;
  bool has_acpi_;
  bool has_usb_legacy_;
  bool has_agp_;
  bool has_i2o_boot_;
  bool has_ls120_boot_;
  bool has_atapi_zip_drive_boot_;
  bool has_ieee1394_boot_;
  bool has_smart_battery_;
  bool has_bios_boot_specification_;
  bool has_key_init_network_boot_;
  bool has_targeted_content_distrib_;
  bool has_uefi_;
  bool has_virtual_machine_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBios_CharacteristicsImpl();
};
// -------------------------------------------------------------------

class DmiBios : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBios) */ {
 public:
  DmiBios();
  virtual ~DmiBios();

  DmiBios(const DmiBios& from);

  inline DmiBios& operator=(const DmiBios& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBios(DmiBios&& from) noexcept
    : DmiBios() {
    *this = ::std::move(from);
  }

  inline DmiBios& operator=(DmiBios&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBios& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBios* internal_default_instance() {
    return reinterpret_cast<const DmiBios*>(
               &_DmiBios_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DmiBios* other);
  friend void swap(DmiBios& a, DmiBios& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBios* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBios* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBios& from);
  void MergeFrom(const DmiBios& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBios* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiBios_Characteristics Characteristics;

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string date = 3;
  void clear_date();
  static const int kDateFieldNumber = 3;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // string bios_revision = 5;
  void clear_bios_revision();
  static const int kBiosRevisionFieldNumber = 5;
  const ::std::string& bios_revision() const;
  void set_bios_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_bios_revision(::std::string&& value);
  #endif
  void set_bios_revision(const char* value);
  void set_bios_revision(const char* value, size_t size);
  ::std::string* mutable_bios_revision();
  ::std::string* release_bios_revision();
  void set_allocated_bios_revision(::std::string* bios_revision);

  // string firmware_revision = 6;
  void clear_firmware_revision();
  static const int kFirmwareRevisionFieldNumber = 6;
  const ::std::string& firmware_revision() const;
  void set_firmware_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_firmware_revision(::std::string&& value);
  #endif
  void set_firmware_revision(const char* value);
  void set_firmware_revision(const char* value, size_t size);
  ::std::string* mutable_firmware_revision();
  ::std::string* release_firmware_revision();
  void set_allocated_firmware_revision(::std::string* firmware_revision);

  // string address = 7;
  void clear_address();
  static const int kAddressFieldNumber = 7;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // .aspia.proto.DmiBios.Characteristics characteristics = 9;
  bool has_characteristics() const;
  void clear_characteristics();
  static const int kCharacteristicsFieldNumber = 9;
  const ::aspia::proto::DmiBios_Characteristics& characteristics() const;
  ::aspia::proto::DmiBios_Characteristics* release_characteristics();
  ::aspia::proto::DmiBios_Characteristics* mutable_characteristics();
  void set_allocated_characteristics(::aspia::proto::DmiBios_Characteristics* characteristics);

  // uint64 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // int32 runtime_size = 8;
  void clear_runtime_size();
  static const int kRuntimeSizeFieldNumber = 8;
  ::google::protobuf::int32 runtime_size() const;
  void set_runtime_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBios)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr bios_revision_;
  ::google::protobuf::internal::ArenaStringPtr firmware_revision_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::aspia::proto::DmiBios_Characteristics* characteristics_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 runtime_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBiosImpl();
};
// -------------------------------------------------------------------

class DmiSystem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiSystem) */ {
 public:
  DmiSystem();
  virtual ~DmiSystem();

  DmiSystem(const DmiSystem& from);

  inline DmiSystem& operator=(const DmiSystem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiSystem(DmiSystem&& from) noexcept
    : DmiSystem() {
    *this = ::std::move(from);
  }

  inline DmiSystem& operator=(DmiSystem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiSystem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiSystem* internal_default_instance() {
    return reinterpret_cast<const DmiSystem*>(
               &_DmiSystem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DmiSystem* other);
  friend void swap(DmiSystem& a, DmiSystem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiSystem* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiSystem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiSystem& from);
  void MergeFrom(const DmiSystem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiSystem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiSystem_WakeupType WakeupType;
  static const WakeupType WAKEUP_TYPE_UNKNOWN =
    DmiSystem_WakeupType_WAKEUP_TYPE_UNKNOWN;
  static const WakeupType WAKEUP_TYPE_OTHER =
    DmiSystem_WakeupType_WAKEUP_TYPE_OTHER;
  static const WakeupType WAKEUP_TYPE_APM_TIMER =
    DmiSystem_WakeupType_WAKEUP_TYPE_APM_TIMER;
  static const WakeupType WAKEUP_TYPE_MODEM_RING =
    DmiSystem_WakeupType_WAKEUP_TYPE_MODEM_RING;
  static const WakeupType WAKEUP_TYPE_LAN_REMOTE =
    DmiSystem_WakeupType_WAKEUP_TYPE_LAN_REMOTE;
  static const WakeupType WAKEUP_TYPE_POWER_SWITCH =
    DmiSystem_WakeupType_WAKEUP_TYPE_POWER_SWITCH;
  static const WakeupType WAKEUP_TYPE_PCI_PME =
    DmiSystem_WakeupType_WAKEUP_TYPE_PCI_PME;
  static const WakeupType WAKEUP_TYPE_AC_POWER_RESTORED =
    DmiSystem_WakeupType_WAKEUP_TYPE_AC_POWER_RESTORED;
  static inline bool WakeupType_IsValid(int value) {
    return DmiSystem_WakeupType_IsValid(value);
  }
  static const WakeupType WakeupType_MIN =
    DmiSystem_WakeupType_WakeupType_MIN;
  static const WakeupType WakeupType_MAX =
    DmiSystem_WakeupType_WakeupType_MAX;
  static const int WakeupType_ARRAYSIZE =
    DmiSystem_WakeupType_WakeupType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string product_name = 2;
  void clear_product_name();
  static const int kProductNameFieldNumber = 2;
  const ::std::string& product_name() const;
  void set_product_name(const ::std::string& value);
  #if LANG_CXX11
  void set_product_name(::std::string&& value);
  #endif
  void set_product_name(const char* value);
  void set_product_name(const char* value, size_t size);
  ::std::string* mutable_product_name();
  ::std::string* release_product_name();
  void set_allocated_product_name(::std::string* product_name);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string uuid = 5;
  void clear_uuid();
  static const int kUuidFieldNumber = 5;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // string sku_number = 7;
  void clear_sku_number();
  static const int kSkuNumberFieldNumber = 7;
  const ::std::string& sku_number() const;
  void set_sku_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sku_number(::std::string&& value);
  #endif
  void set_sku_number(const char* value);
  void set_sku_number(const char* value, size_t size);
  ::std::string* mutable_sku_number();
  ::std::string* release_sku_number();
  void set_allocated_sku_number(::std::string* sku_number);

  // string family = 8;
  void clear_family();
  static const int kFamilyFieldNumber = 8;
  const ::std::string& family() const;
  void set_family(const ::std::string& value);
  #if LANG_CXX11
  void set_family(::std::string&& value);
  #endif
  void set_family(const char* value);
  void set_family(const char* value, size_t size);
  ::std::string* mutable_family();
  ::std::string* release_family();
  void set_allocated_family(::std::string* family);

  // .aspia.proto.DmiSystem.WakeupType wakeup_type = 6;
  void clear_wakeup_type();
  static const int kWakeupTypeFieldNumber = 6;
  ::aspia::proto::DmiSystem_WakeupType wakeup_type() const;
  void set_wakeup_type(::aspia::proto::DmiSystem_WakeupType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiSystem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr product_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr sku_number_;
  ::google::protobuf::internal::ArenaStringPtr family_;
  int wakeup_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiSystemImpl();
};
// -------------------------------------------------------------------

class DmiBaseboard_Features : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBaseboard.Features) */ {
 public:
  DmiBaseboard_Features();
  virtual ~DmiBaseboard_Features();

  DmiBaseboard_Features(const DmiBaseboard_Features& from);

  inline DmiBaseboard_Features& operator=(const DmiBaseboard_Features& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBaseboard_Features(DmiBaseboard_Features&& from) noexcept
    : DmiBaseboard_Features() {
    *this = ::std::move(from);
  }

  inline DmiBaseboard_Features& operator=(DmiBaseboard_Features&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBaseboard_Features& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBaseboard_Features* internal_default_instance() {
    return reinterpret_cast<const DmiBaseboard_Features*>(
               &_DmiBaseboard_Features_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DmiBaseboard_Features* other);
  friend void swap(DmiBaseboard_Features& a, DmiBaseboard_Features& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBaseboard_Features* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBaseboard_Features* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBaseboard_Features& from);
  void MergeFrom(const DmiBaseboard_Features& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBaseboard_Features* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_hosting_board = 1;
  void clear_is_hosting_board();
  static const int kIsHostingBoardFieldNumber = 1;
  bool is_hosting_board() const;
  void set_is_hosting_board(bool value);

  // bool is_requires_at_least_one_daughter_board = 2;
  void clear_is_requires_at_least_one_daughter_board();
  static const int kIsRequiresAtLeastOneDaughterBoardFieldNumber = 2;
  bool is_requires_at_least_one_daughter_board() const;
  void set_is_requires_at_least_one_daughter_board(bool value);

  // bool is_removable = 3;
  void clear_is_removable();
  static const int kIsRemovableFieldNumber = 3;
  bool is_removable() const;
  void set_is_removable(bool value);

  // bool is_replaceable = 4;
  void clear_is_replaceable();
  static const int kIsReplaceableFieldNumber = 4;
  bool is_replaceable() const;
  void set_is_replaceable(bool value);

  // bool is_hot_swappable = 5;
  void clear_is_hot_swappable();
  static const int kIsHotSwappableFieldNumber = 5;
  bool is_hot_swappable() const;
  void set_is_hot_swappable(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBaseboard.Features)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool is_hosting_board_;
  bool is_requires_at_least_one_daughter_board_;
  bool is_removable_;
  bool is_replaceable_;
  bool is_hot_swappable_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBaseboard_FeaturesImpl();
};
// -------------------------------------------------------------------

class DmiBaseboard_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBaseboard.Item) */ {
 public:
  DmiBaseboard_Item();
  virtual ~DmiBaseboard_Item();

  DmiBaseboard_Item(const DmiBaseboard_Item& from);

  inline DmiBaseboard_Item& operator=(const DmiBaseboard_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBaseboard_Item(DmiBaseboard_Item&& from) noexcept
    : DmiBaseboard_Item() {
    *this = ::std::move(from);
  }

  inline DmiBaseboard_Item& operator=(DmiBaseboard_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBaseboard_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBaseboard_Item* internal_default_instance() {
    return reinterpret_cast<const DmiBaseboard_Item*>(
               &_DmiBaseboard_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DmiBaseboard_Item* other);
  friend void swap(DmiBaseboard_Item& a, DmiBaseboard_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBaseboard_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBaseboard_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBaseboard_Item& from);
  void MergeFrom(const DmiBaseboard_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBaseboard_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string product_name = 2;
  void clear_product_name();
  static const int kProductNameFieldNumber = 2;
  const ::std::string& product_name() const;
  void set_product_name(const ::std::string& value);
  #if LANG_CXX11
  void set_product_name(::std::string&& value);
  #endif
  void set_product_name(const char* value);
  void set_product_name(const char* value, size_t size);
  ::std::string* mutable_product_name();
  ::std::string* release_product_name();
  void set_allocated_product_name(::std::string* product_name);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 5;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 5;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // string location_in_chassis = 7;
  void clear_location_in_chassis();
  static const int kLocationInChassisFieldNumber = 7;
  const ::std::string& location_in_chassis() const;
  void set_location_in_chassis(const ::std::string& value);
  #if LANG_CXX11
  void set_location_in_chassis(::std::string&& value);
  #endif
  void set_location_in_chassis(const char* value);
  void set_location_in_chassis(const char* value, size_t size);
  ::std::string* mutable_location_in_chassis();
  ::std::string* release_location_in_chassis();
  void set_allocated_location_in_chassis(::std::string* location_in_chassis);

  // .aspia.proto.DmiBaseboard.Features features = 6;
  bool has_features() const;
  void clear_features();
  static const int kFeaturesFieldNumber = 6;
  const ::aspia::proto::DmiBaseboard_Features& features() const;
  ::aspia::proto::DmiBaseboard_Features* release_features();
  ::aspia::proto::DmiBaseboard_Features* mutable_features();
  void set_allocated_features(::aspia::proto::DmiBaseboard_Features* features);

  // .aspia.proto.DmiBaseboard.BoardType type = 8;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  ::aspia::proto::DmiBaseboard_BoardType type() const;
  void set_type(::aspia::proto::DmiBaseboard_BoardType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBaseboard.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr product_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  ::google::protobuf::internal::ArenaStringPtr location_in_chassis_;
  ::aspia::proto::DmiBaseboard_Features* features_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBaseboard_ItemImpl();
};
// -------------------------------------------------------------------

class DmiBaseboard : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBaseboard) */ {
 public:
  DmiBaseboard();
  virtual ~DmiBaseboard();

  DmiBaseboard(const DmiBaseboard& from);

  inline DmiBaseboard& operator=(const DmiBaseboard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBaseboard(DmiBaseboard&& from) noexcept
    : DmiBaseboard() {
    *this = ::std::move(from);
  }

  inline DmiBaseboard& operator=(DmiBaseboard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBaseboard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBaseboard* internal_default_instance() {
    return reinterpret_cast<const DmiBaseboard*>(
               &_DmiBaseboard_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(DmiBaseboard* other);
  friend void swap(DmiBaseboard& a, DmiBaseboard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBaseboard* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBaseboard* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBaseboard& from);
  void MergeFrom(const DmiBaseboard& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBaseboard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiBaseboard_Features Features;
  typedef DmiBaseboard_Item Item;

  typedef DmiBaseboard_BoardType BoardType;
  static const BoardType BOARD_TYPE_UNKNOWN =
    DmiBaseboard_BoardType_BOARD_TYPE_UNKNOWN;
  static const BoardType BOARD_TYPE_OTHER =
    DmiBaseboard_BoardType_BOARD_TYPE_OTHER;
  static const BoardType BOARD_TYPE_SERVER_BLADE =
    DmiBaseboard_BoardType_BOARD_TYPE_SERVER_BLADE;
  static const BoardType BOARD_TYPE_CONNECTIVITY_SWITCH =
    DmiBaseboard_BoardType_BOARD_TYPE_CONNECTIVITY_SWITCH;
  static const BoardType BOARD_TYPE_SYSTEM_MANAGEMENT_MODULE =
    DmiBaseboard_BoardType_BOARD_TYPE_SYSTEM_MANAGEMENT_MODULE;
  static const BoardType BOARD_TYPE_PROCESSOR_MODULE =
    DmiBaseboard_BoardType_BOARD_TYPE_PROCESSOR_MODULE;
  static const BoardType BOARD_TYPE_IO_MODULE =
    DmiBaseboard_BoardType_BOARD_TYPE_IO_MODULE;
  static const BoardType BOARD_TYPE_MEMORY_MODULE =
    DmiBaseboard_BoardType_BOARD_TYPE_MEMORY_MODULE;
  static const BoardType BOARD_TYPE_DAUGHTER_BOARD =
    DmiBaseboard_BoardType_BOARD_TYPE_DAUGHTER_BOARD;
  static const BoardType BOARD_TYPE_MOTHERBOARD =
    DmiBaseboard_BoardType_BOARD_TYPE_MOTHERBOARD;
  static const BoardType BOARD_TYPE_PROCESSOR_PLUS_MEMORY_MODULE =
    DmiBaseboard_BoardType_BOARD_TYPE_PROCESSOR_PLUS_MEMORY_MODULE;
  static const BoardType BOARD_TYPE_PROCESSOR_PLUS_IO_MODULE =
    DmiBaseboard_BoardType_BOARD_TYPE_PROCESSOR_PLUS_IO_MODULE;
  static const BoardType BOARD_TYPE_INTERCONNECT_BOARD =
    DmiBaseboard_BoardType_BOARD_TYPE_INTERCONNECT_BOARD;
  static inline bool BoardType_IsValid(int value) {
    return DmiBaseboard_BoardType_IsValid(value);
  }
  static const BoardType BoardType_MIN =
    DmiBaseboard_BoardType_BoardType_MIN;
  static const BoardType BoardType_MAX =
    DmiBaseboard_BoardType_BoardType_MAX;
  static const int BoardType_ARRAYSIZE =
    DmiBaseboard_BoardType_BoardType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiBaseboard.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiBaseboard_Item& item(int index) const;
  ::aspia::proto::DmiBaseboard_Item* mutable_item(int index);
  ::aspia::proto::DmiBaseboard_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBaseboard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBaseboardImpl();
};
// -------------------------------------------------------------------

class DmiChassis_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiChassis.Item) */ {
 public:
  DmiChassis_Item();
  virtual ~DmiChassis_Item();

  DmiChassis_Item(const DmiChassis_Item& from);

  inline DmiChassis_Item& operator=(const DmiChassis_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiChassis_Item(DmiChassis_Item&& from) noexcept
    : DmiChassis_Item() {
    *this = ::std::move(from);
  }

  inline DmiChassis_Item& operator=(DmiChassis_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiChassis_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiChassis_Item* internal_default_instance() {
    return reinterpret_cast<const DmiChassis_Item*>(
               &_DmiChassis_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(DmiChassis_Item* other);
  friend void swap(DmiChassis_Item& a, DmiChassis_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiChassis_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiChassis_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiChassis_Item& from);
  void MergeFrom(const DmiChassis_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiChassis_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 3;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 3;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 4;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 4;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // .aspia.proto.DmiChassis.Type type = 5;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::aspia::proto::DmiChassis_Type type() const;
  void set_type(::aspia::proto::DmiChassis_Type value);

  // .aspia.proto.DmiChassis.Status os_load_status = 6;
  void clear_os_load_status();
  static const int kOsLoadStatusFieldNumber = 6;
  ::aspia::proto::DmiChassis_Status os_load_status() const;
  void set_os_load_status(::aspia::proto::DmiChassis_Status value);

  // .aspia.proto.DmiChassis.Status power_source_status = 7;
  void clear_power_source_status();
  static const int kPowerSourceStatusFieldNumber = 7;
  ::aspia::proto::DmiChassis_Status power_source_status() const;
  void set_power_source_status(::aspia::proto::DmiChassis_Status value);

  // .aspia.proto.DmiChassis.Status temparature_status = 8;
  void clear_temparature_status();
  static const int kTemparatureStatusFieldNumber = 8;
  ::aspia::proto::DmiChassis_Status temparature_status() const;
  void set_temparature_status(::aspia::proto::DmiChassis_Status value);

  // .aspia.proto.DmiChassis.SecurityStatus security_status = 9;
  void clear_security_status();
  static const int kSecurityStatusFieldNumber = 9;
  ::aspia::proto::DmiChassis_SecurityStatus security_status() const;
  void set_security_status(::aspia::proto::DmiChassis_SecurityStatus value);

  // int32 height = 10;
  void clear_height();
  static const int kHeightFieldNumber = 10;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // int32 number_of_power_cords = 11;
  void clear_number_of_power_cords();
  static const int kNumberOfPowerCordsFieldNumber = 11;
  ::google::protobuf::int32 number_of_power_cords() const;
  void set_number_of_power_cords(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiChassis.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  int type_;
  int os_load_status_;
  int power_source_status_;
  int temparature_status_;
  int security_status_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 number_of_power_cords_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiChassis_ItemImpl();
};
// -------------------------------------------------------------------

class DmiChassis : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiChassis) */ {
 public:
  DmiChassis();
  virtual ~DmiChassis();

  DmiChassis(const DmiChassis& from);

  inline DmiChassis& operator=(const DmiChassis& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiChassis(DmiChassis&& from) noexcept
    : DmiChassis() {
    *this = ::std::move(from);
  }

  inline DmiChassis& operator=(DmiChassis&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiChassis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiChassis* internal_default_instance() {
    return reinterpret_cast<const DmiChassis*>(
               &_DmiChassis_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(DmiChassis* other);
  friend void swap(DmiChassis& a, DmiChassis& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiChassis* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiChassis* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiChassis& from);
  void MergeFrom(const DmiChassis& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiChassis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiChassis_Item Item;

  typedef DmiChassis_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiChassis_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiChassis_Type_TYPE_OTHER;
  static const Type TYPE_DESKTOP =
    DmiChassis_Type_TYPE_DESKTOP;
  static const Type TYPE_LOW_PROFILE_DESKTOP =
    DmiChassis_Type_TYPE_LOW_PROFILE_DESKTOP;
  static const Type TYPE_PIZZA_BOX =
    DmiChassis_Type_TYPE_PIZZA_BOX;
  static const Type TYPE_MINI_TOWER =
    DmiChassis_Type_TYPE_MINI_TOWER;
  static const Type TYPE_TOWER =
    DmiChassis_Type_TYPE_TOWER;
  static const Type TYPE_PORTABLE =
    DmiChassis_Type_TYPE_PORTABLE;
  static const Type TYPE_LAPTOP =
    DmiChassis_Type_TYPE_LAPTOP;
  static const Type TYPE_NOTEBOOK =
    DmiChassis_Type_TYPE_NOTEBOOK;
  static const Type TYPE_HAND_HELD =
    DmiChassis_Type_TYPE_HAND_HELD;
  static const Type TYPE_DOCKING_STATION =
    DmiChassis_Type_TYPE_DOCKING_STATION;
  static const Type TYPE_ALL_IN_ONE =
    DmiChassis_Type_TYPE_ALL_IN_ONE;
  static const Type TYPE_SUB_NOTEBOOK =
    DmiChassis_Type_TYPE_SUB_NOTEBOOK;
  static const Type TYPE_SPACE_SAVING =
    DmiChassis_Type_TYPE_SPACE_SAVING;
  static const Type TYPE_LUNCH_BOX =
    DmiChassis_Type_TYPE_LUNCH_BOX;
  static const Type TYPE_MAIN_SERVER_CHASSIS =
    DmiChassis_Type_TYPE_MAIN_SERVER_CHASSIS;
  static const Type TYPE_EXPANSION_CHASSIS =
    DmiChassis_Type_TYPE_EXPANSION_CHASSIS;
  static const Type TYPE_SUB_CHASSIS =
    DmiChassis_Type_TYPE_SUB_CHASSIS;
  static const Type TYPE_BUS_EXPANSION_CHASSIS =
    DmiChassis_Type_TYPE_BUS_EXPANSION_CHASSIS;
  static const Type TYPE_PERIPHERIAL_CHASSIS =
    DmiChassis_Type_TYPE_PERIPHERIAL_CHASSIS;
  static const Type TYPE_RAID_CHASSIS =
    DmiChassis_Type_TYPE_RAID_CHASSIS;
  static const Type TYPE_RACK_MOUNT_CHASSIS =
    DmiChassis_Type_TYPE_RACK_MOUNT_CHASSIS;
  static const Type TYPE_SEALED_CASE_PC =
    DmiChassis_Type_TYPE_SEALED_CASE_PC;
  static const Type TYPE_MULTI_SYSTEM_CHASSIS =
    DmiChassis_Type_TYPE_MULTI_SYSTEM_CHASSIS;
  static const Type TYPE_COMPACT_PCI =
    DmiChassis_Type_TYPE_COMPACT_PCI;
  static const Type TYPE_ADVANCED_TCA =
    DmiChassis_Type_TYPE_ADVANCED_TCA;
  static const Type TYPE_BLADE =
    DmiChassis_Type_TYPE_BLADE;
  static const Type TYPE_BLADE_ENCLOSURE =
    DmiChassis_Type_TYPE_BLADE_ENCLOSURE;
  static inline bool Type_IsValid(int value) {
    return DmiChassis_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiChassis_Type_Type_MIN;
  static const Type Type_MAX =
    DmiChassis_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiChassis_Type_Type_ARRAYSIZE;

  typedef DmiChassis_Status Status;
  static const Status STATUS_UNKNOWN =
    DmiChassis_Status_STATUS_UNKNOWN;
  static const Status STATUS_OTHER =
    DmiChassis_Status_STATUS_OTHER;
  static const Status STATUS_SAFE =
    DmiChassis_Status_STATUS_SAFE;
  static const Status STATUS_WARNING =
    DmiChassis_Status_STATUS_WARNING;
  static const Status STATUS_CRITICAL =
    DmiChassis_Status_STATUS_CRITICAL;
  static const Status STATUS_NON_RECOVERABLE =
    DmiChassis_Status_STATUS_NON_RECOVERABLE;
  static inline bool Status_IsValid(int value) {
    return DmiChassis_Status_IsValid(value);
  }
  static const Status Status_MIN =
    DmiChassis_Status_Status_MIN;
  static const Status Status_MAX =
    DmiChassis_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    DmiChassis_Status_Status_ARRAYSIZE;

  typedef DmiChassis_SecurityStatus SecurityStatus;
  static const SecurityStatus SECURITY_STATUS_UNKNOWN =
    DmiChassis_SecurityStatus_SECURITY_STATUS_UNKNOWN;
  static const SecurityStatus SECURITY_STATUS_OTHER =
    DmiChassis_SecurityStatus_SECURITY_STATUS_OTHER;
  static const SecurityStatus SECURITY_STATUS_NONE =
    DmiChassis_SecurityStatus_SECURITY_STATUS_NONE;
  static const SecurityStatus SECURITY_STATUS_EXTERNAL_INTERFACE_LOCKED_OUT =
    DmiChassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_LOCKED_OUT;
  static const SecurityStatus SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED =
    DmiChassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED;
  static inline bool SecurityStatus_IsValid(int value) {
    return DmiChassis_SecurityStatus_IsValid(value);
  }
  static const SecurityStatus SecurityStatus_MIN =
    DmiChassis_SecurityStatus_SecurityStatus_MIN;
  static const SecurityStatus SecurityStatus_MAX =
    DmiChassis_SecurityStatus_SecurityStatus_MAX;
  static const int SecurityStatus_ARRAYSIZE =
    DmiChassis_SecurityStatus_SecurityStatus_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiChassis.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiChassis_Item& item(int index) const;
  ::aspia::proto::DmiChassis_Item* mutable_item(int index);
  ::aspia::proto::DmiChassis_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiChassis)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiChassisImpl();
};
// -------------------------------------------------------------------

class DmiCaches_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiCaches.Item) */ {
 public:
  DmiCaches_Item();
  virtual ~DmiCaches_Item();

  DmiCaches_Item(const DmiCaches_Item& from);

  inline DmiCaches_Item& operator=(const DmiCaches_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiCaches_Item(DmiCaches_Item&& from) noexcept
    : DmiCaches_Item() {
    *this = ::std::move(from);
  }

  inline DmiCaches_Item& operator=(DmiCaches_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiCaches_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiCaches_Item* internal_default_instance() {
    return reinterpret_cast<const DmiCaches_Item*>(
               &_DmiCaches_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(DmiCaches_Item* other);
  friend void swap(DmiCaches_Item& a, DmiCaches_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiCaches_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiCaches_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiCaches_Item& from);
  void MergeFrom(const DmiCaches_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiCaches_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .aspia.proto.DmiCaches.Location location = 2;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  ::aspia::proto::DmiCaches_Location location() const;
  void set_location(::aspia::proto::DmiCaches_Location value);

  // .aspia.proto.DmiCaches.Status status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::aspia::proto::DmiCaches_Status status() const;
  void set_status(::aspia::proto::DmiCaches_Status value);

  // .aspia.proto.DmiCaches.Mode mode = 4;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::aspia::proto::DmiCaches_Mode mode() const;
  void set_mode(::aspia::proto::DmiCaches_Mode value);

  // int32 level = 5;
  void clear_level();
  static const int kLevelFieldNumber = 5;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // int32 maximum_size = 6;
  void clear_maximum_size();
  static const int kMaximumSizeFieldNumber = 6;
  ::google::protobuf::int32 maximum_size() const;
  void set_maximum_size(::google::protobuf::int32 value);

  // int32 current_size = 7;
  void clear_current_size();
  static const int kCurrentSizeFieldNumber = 7;
  ::google::protobuf::int32 current_size() const;
  void set_current_size(::google::protobuf::int32 value);

  // uint32 supported_sram_types = 8;
  void clear_supported_sram_types();
  static const int kSupportedSramTypesFieldNumber = 8;
  ::google::protobuf::uint32 supported_sram_types() const;
  void set_supported_sram_types(::google::protobuf::uint32 value);

  // .aspia.proto.DmiCaches.SRAMType current_sram_type = 9;
  void clear_current_sram_type();
  static const int kCurrentSramTypeFieldNumber = 9;
  ::aspia::proto::DmiCaches_SRAMType current_sram_type() const;
  void set_current_sram_type(::aspia::proto::DmiCaches_SRAMType value);

  // int32 speed = 10;
  void clear_speed();
  static const int kSpeedFieldNumber = 10;
  ::google::protobuf::int32 speed() const;
  void set_speed(::google::protobuf::int32 value);

  // .aspia.proto.DmiCaches.ErrorCorrectionType error_correction_type = 11;
  void clear_error_correction_type();
  static const int kErrorCorrectionTypeFieldNumber = 11;
  ::aspia::proto::DmiCaches_ErrorCorrectionType error_correction_type() const;
  void set_error_correction_type(::aspia::proto::DmiCaches_ErrorCorrectionType value);

  // .aspia.proto.DmiCaches.Type type = 12;
  void clear_type();
  static const int kTypeFieldNumber = 12;
  ::aspia::proto::DmiCaches_Type type() const;
  void set_type(::aspia::proto::DmiCaches_Type value);

  // .aspia.proto.DmiCaches.Associativity associativity = 13;
  void clear_associativity();
  static const int kAssociativityFieldNumber = 13;
  ::aspia::proto::DmiCaches_Associativity associativity() const;
  void set_associativity(::aspia::proto::DmiCaches_Associativity value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiCaches.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int location_;
  int status_;
  int mode_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 maximum_size_;
  ::google::protobuf::int32 current_size_;
  ::google::protobuf::uint32 supported_sram_types_;
  int current_sram_type_;
  ::google::protobuf::int32 speed_;
  int error_correction_type_;
  int type_;
  int associativity_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiCaches_ItemImpl();
};
// -------------------------------------------------------------------

class DmiCaches : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiCaches) */ {
 public:
  DmiCaches();
  virtual ~DmiCaches();

  DmiCaches(const DmiCaches& from);

  inline DmiCaches& operator=(const DmiCaches& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiCaches(DmiCaches&& from) noexcept
    : DmiCaches() {
    *this = ::std::move(from);
  }

  inline DmiCaches& operator=(DmiCaches&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiCaches& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiCaches* internal_default_instance() {
    return reinterpret_cast<const DmiCaches*>(
               &_DmiCaches_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(DmiCaches* other);
  friend void swap(DmiCaches& a, DmiCaches& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiCaches* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiCaches* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiCaches& from);
  void MergeFrom(const DmiCaches& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiCaches* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiCaches_Item Item;

  typedef DmiCaches_Location Location;
  static const Location LOCATION_UNKNOWN =
    DmiCaches_Location_LOCATION_UNKNOWN;
  static const Location LOCATION_INTERNAL =
    DmiCaches_Location_LOCATION_INTERNAL;
  static const Location LOCATION_EXTERNAL =
    DmiCaches_Location_LOCATION_EXTERNAL;
  static const Location LOCATION_RESERVED =
    DmiCaches_Location_LOCATION_RESERVED;
  static inline bool Location_IsValid(int value) {
    return DmiCaches_Location_IsValid(value);
  }
  static const Location Location_MIN =
    DmiCaches_Location_Location_MIN;
  static const Location Location_MAX =
    DmiCaches_Location_Location_MAX;
  static const int Location_ARRAYSIZE =
    DmiCaches_Location_Location_ARRAYSIZE;

  typedef DmiCaches_Status Status;
  static const Status STATUS_UNKNOWN =
    DmiCaches_Status_STATUS_UNKNOWN;
  static const Status STATUS_ENABLED =
    DmiCaches_Status_STATUS_ENABLED;
  static const Status STATUS_DISABLED =
    DmiCaches_Status_STATUS_DISABLED;
  static inline bool Status_IsValid(int value) {
    return DmiCaches_Status_IsValid(value);
  }
  static const Status Status_MIN =
    DmiCaches_Status_Status_MIN;
  static const Status Status_MAX =
    DmiCaches_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    DmiCaches_Status_Status_ARRAYSIZE;

  typedef DmiCaches_Mode Mode;
  static const Mode MODE_UNKNOWN =
    DmiCaches_Mode_MODE_UNKNOWN;
  static const Mode MODE_WRITE_THRU =
    DmiCaches_Mode_MODE_WRITE_THRU;
  static const Mode MODE_WRITE_BACK =
    DmiCaches_Mode_MODE_WRITE_BACK;
  static const Mode MODE_WRITE_WITH_MEMORY_ADDRESS =
    DmiCaches_Mode_MODE_WRITE_WITH_MEMORY_ADDRESS;
  static inline bool Mode_IsValid(int value) {
    return DmiCaches_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    DmiCaches_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    DmiCaches_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    DmiCaches_Mode_Mode_ARRAYSIZE;

  typedef DmiCaches_SRAMType SRAMType;
  static const SRAMType SRAM_TYPE_BAD =
    DmiCaches_SRAMType_SRAM_TYPE_BAD;
  static const SRAMType SRAM_TYPE_OTHER =
    DmiCaches_SRAMType_SRAM_TYPE_OTHER;
  static const SRAMType SRAM_TYPE_UNKNOWN =
    DmiCaches_SRAMType_SRAM_TYPE_UNKNOWN;
  static const SRAMType SRAM_TYPE_NON_BURST =
    DmiCaches_SRAMType_SRAM_TYPE_NON_BURST;
  static const SRAMType SRAM_TYPE_BURST =
    DmiCaches_SRAMType_SRAM_TYPE_BURST;
  static const SRAMType SRAM_TYPE_PIPELINE_BURST =
    DmiCaches_SRAMType_SRAM_TYPE_PIPELINE_BURST;
  static const SRAMType SRAM_TYPE_SYNCHRONOUS =
    DmiCaches_SRAMType_SRAM_TYPE_SYNCHRONOUS;
  static const SRAMType SRAM_TYPE_ASYNCHRONOUS =
    DmiCaches_SRAMType_SRAM_TYPE_ASYNCHRONOUS;
  static inline bool SRAMType_IsValid(int value) {
    return DmiCaches_SRAMType_IsValid(value);
  }
  static const SRAMType SRAMType_MIN =
    DmiCaches_SRAMType_SRAMType_MIN;
  static const SRAMType SRAMType_MAX =
    DmiCaches_SRAMType_SRAMType_MAX;
  static const int SRAMType_ARRAYSIZE =
    DmiCaches_SRAMType_SRAMType_ARRAYSIZE;

  typedef DmiCaches_ErrorCorrectionType ErrorCorrectionType;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_UNKNOWN =
    DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_UNKNOWN;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_OTHER =
    DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_OTHER;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_NONE =
    DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_NONE;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_PARITY =
    DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_PARITY;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_SINGLE_BIT_ECC =
    DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_SINGLE_BIT_ECC;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_MULTI_BIT_ECC =
    DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_MULTI_BIT_ECC;
  static inline bool ErrorCorrectionType_IsValid(int value) {
    return DmiCaches_ErrorCorrectionType_IsValid(value);
  }
  static const ErrorCorrectionType ErrorCorrectionType_MIN =
    DmiCaches_ErrorCorrectionType_ErrorCorrectionType_MIN;
  static const ErrorCorrectionType ErrorCorrectionType_MAX =
    DmiCaches_ErrorCorrectionType_ErrorCorrectionType_MAX;
  static const int ErrorCorrectionType_ARRAYSIZE =
    DmiCaches_ErrorCorrectionType_ErrorCorrectionType_ARRAYSIZE;

  typedef DmiCaches_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiCaches_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiCaches_Type_TYPE_OTHER;
  static const Type TYPE_INSTRUCTION =
    DmiCaches_Type_TYPE_INSTRUCTION;
  static const Type TYPE_DATA =
    DmiCaches_Type_TYPE_DATA;
  static const Type TYPE_UNIFIED =
    DmiCaches_Type_TYPE_UNIFIED;
  static inline bool Type_IsValid(int value) {
    return DmiCaches_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiCaches_Type_Type_MIN;
  static const Type Type_MAX =
    DmiCaches_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiCaches_Type_Type_ARRAYSIZE;

  typedef DmiCaches_Associativity Associativity;
  static const Associativity ASSOCIATIVITY_UNKNOWN =
    DmiCaches_Associativity_ASSOCIATIVITY_UNKNOWN;
  static const Associativity ASSOCIATIVITY_OTHER =
    DmiCaches_Associativity_ASSOCIATIVITY_OTHER;
  static const Associativity ASSOCIATIVITY_DIRECT_MAPPED =
    DmiCaches_Associativity_ASSOCIATIVITY_DIRECT_MAPPED;
  static const Associativity ASSOCIATIVITY_2_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_2_WAY;
  static const Associativity ASSOCIATIVITY_4_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_4_WAY;
  static const Associativity ASSOCIATIVITY_FULLY =
    DmiCaches_Associativity_ASSOCIATIVITY_FULLY;
  static const Associativity ASSOCIATIVITY_8_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_8_WAY;
  static const Associativity ASSOCIATIVITY_16_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_16_WAY;
  static const Associativity ASSOCIATIVITY_12_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_12_WAY;
  static const Associativity ASSOCIATIVITY_24_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_24_WAY;
  static const Associativity ASSOCIATIVITY_32_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_32_WAY;
  static const Associativity ASSOCIATIVITY_48_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_48_WAY;
  static const Associativity ASSOCIATIVITY_64_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_64_WAY;
  static const Associativity ASSOCIATIVITY_20_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_20_WAY;
  static inline bool Associativity_IsValid(int value) {
    return DmiCaches_Associativity_IsValid(value);
  }
  static const Associativity Associativity_MIN =
    DmiCaches_Associativity_Associativity_MIN;
  static const Associativity Associativity_MAX =
    DmiCaches_Associativity_Associativity_MAX;
  static const int Associativity_ARRAYSIZE =
    DmiCaches_Associativity_Associativity_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiCaches.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiCaches_Item& item(int index) const;
  ::aspia::proto::DmiCaches_Item* mutable_item(int index);
  ::aspia::proto::DmiCaches_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiCaches)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiCachesImpl();
};
// -------------------------------------------------------------------

class DmiProcessors_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiProcessors.Item) */ {
 public:
  DmiProcessors_Item();
  virtual ~DmiProcessors_Item();

  DmiProcessors_Item(const DmiProcessors_Item& from);

  inline DmiProcessors_Item& operator=(const DmiProcessors_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiProcessors_Item(DmiProcessors_Item&& from) noexcept
    : DmiProcessors_Item() {
    *this = ::std::move(from);
  }

  inline DmiProcessors_Item& operator=(DmiProcessors_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiProcessors_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiProcessors_Item* internal_default_instance() {
    return reinterpret_cast<const DmiProcessors_Item*>(
               &_DmiProcessors_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(DmiProcessors_Item* other);
  friend void swap(DmiProcessors_Item& a, DmiProcessors_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiProcessors_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiProcessors_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiProcessors_Item& from);
  void MergeFrom(const DmiProcessors_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiProcessors_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string socket = 6;
  void clear_socket();
  static const int kSocketFieldNumber = 6;
  const ::std::string& socket() const;
  void set_socket(const ::std::string& value);
  #if LANG_CXX11
  void set_socket(::std::string&& value);
  #endif
  void set_socket(const char* value);
  void set_socket(const char* value, size_t size);
  ::std::string* mutable_socket();
  ::std::string* release_socket();
  void set_allocated_socket(::std::string* socket);

  // string serial_number = 12;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 12;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 13;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 13;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // string part_number = 14;
  void clear_part_number();
  static const int kPartNumberFieldNumber = 14;
  const ::std::string& part_number() const;
  void set_part_number(const ::std::string& value);
  #if LANG_CXX11
  void set_part_number(::std::string&& value);
  #endif
  void set_part_number(const char* value);
  void set_part_number(const char* value, size_t size);
  ::std::string* mutable_part_number();
  ::std::string* release_part_number();
  void set_allocated_part_number(::std::string* part_number);

  // .aspia.proto.DmiProcessors.Family family = 3;
  void clear_family();
  static const int kFamilyFieldNumber = 3;
  ::aspia::proto::DmiProcessors_Family family() const;
  void set_family(::aspia::proto::DmiProcessors_Family value);

  // .aspia.proto.DmiProcessors.Type type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::aspia::proto::DmiProcessors_Type type() const;
  void set_type(::aspia::proto::DmiProcessors_Type value);

  // .aspia.proto.DmiProcessors.Status status = 5;
  void clear_status();
  static const int kStatusFieldNumber = 5;
  ::aspia::proto::DmiProcessors_Status status() const;
  void set_status(::aspia::proto::DmiProcessors_Status value);

  // .aspia.proto.DmiProcessors.Upgrade upgrade = 7;
  void clear_upgrade();
  static const int kUpgradeFieldNumber = 7;
  ::aspia::proto::DmiProcessors_Upgrade upgrade() const;
  void set_upgrade(::aspia::proto::DmiProcessors_Upgrade value);

  // int32 external_clock = 8;
  void clear_external_clock();
  static const int kExternalClockFieldNumber = 8;
  ::google::protobuf::int32 external_clock() const;
  void set_external_clock(::google::protobuf::int32 value);

  // int32 current_speed = 9;
  void clear_current_speed();
  static const int kCurrentSpeedFieldNumber = 9;
  ::google::protobuf::int32 current_speed() const;
  void set_current_speed(::google::protobuf::int32 value);

  // double voltage = 11;
  void clear_voltage();
  static const int kVoltageFieldNumber = 11;
  double voltage() const;
  void set_voltage(double value);

  // int32 maximum_speed = 10;
  void clear_maximum_speed();
  static const int kMaximumSpeedFieldNumber = 10;
  ::google::protobuf::int32 maximum_speed() const;
  void set_maximum_speed(::google::protobuf::int32 value);

  // int32 core_count = 15;
  void clear_core_count();
  static const int kCoreCountFieldNumber = 15;
  ::google::protobuf::int32 core_count() const;
  void set_core_count(::google::protobuf::int32 value);

  // int32 core_enabled = 16;
  void clear_core_enabled();
  static const int kCoreEnabledFieldNumber = 16;
  ::google::protobuf::int32 core_enabled() const;
  void set_core_enabled(::google::protobuf::int32 value);

  // int32 thread_count = 17;
  void clear_thread_count();
  static const int kThreadCountFieldNumber = 17;
  ::google::protobuf::int32 thread_count() const;
  void set_thread_count(::google::protobuf::int32 value);

  // uint32 characteristics = 18;
  void clear_characteristics();
  static const int kCharacteristicsFieldNumber = 18;
  ::google::protobuf::uint32 characteristics() const;
  void set_characteristics(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiProcessors.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr socket_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  ::google::protobuf::internal::ArenaStringPtr part_number_;
  int family_;
  int type_;
  int status_;
  int upgrade_;
  ::google::protobuf::int32 external_clock_;
  ::google::protobuf::int32 current_speed_;
  double voltage_;
  ::google::protobuf::int32 maximum_speed_;
  ::google::protobuf::int32 core_count_;
  ::google::protobuf::int32 core_enabled_;
  ::google::protobuf::int32 thread_count_;
  ::google::protobuf::uint32 characteristics_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiProcessors_ItemImpl();
};
// -------------------------------------------------------------------

class DmiProcessors : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiProcessors) */ {
 public:
  DmiProcessors();
  virtual ~DmiProcessors();

  DmiProcessors(const DmiProcessors& from);

  inline DmiProcessors& operator=(const DmiProcessors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiProcessors(DmiProcessors&& from) noexcept
    : DmiProcessors() {
    *this = ::std::move(from);
  }

  inline DmiProcessors& operator=(DmiProcessors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiProcessors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiProcessors* internal_default_instance() {
    return reinterpret_cast<const DmiProcessors*>(
               &_DmiProcessors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(DmiProcessors* other);
  friend void swap(DmiProcessors& a, DmiProcessors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiProcessors* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiProcessors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiProcessors& from);
  void MergeFrom(const DmiProcessors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiProcessors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiProcessors_Item Item;

  typedef DmiProcessors_Family Family;
  static const Family FAMILY_UNKNOWN =
    DmiProcessors_Family_FAMILY_UNKNOWN;
  static const Family FAMILY_OTHER =
    DmiProcessors_Family_FAMILY_OTHER;
  static const Family FAMILY_8086 =
    DmiProcessors_Family_FAMILY_8086;
  static const Family FAMILY_80286 =
    DmiProcessors_Family_FAMILY_80286;
  static const Family FAMILY_INTEL_386_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_386_PROCESSOR;
  static const Family FAMILY_INTEL_486_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_486_PROCESSOR;
  static const Family FAMILY_8087 =
    DmiProcessors_Family_FAMILY_8087;
  static const Family FAMILY_80287 =
    DmiProcessors_Family_FAMILY_80287;
  static const Family FAMILY_80387 =
    DmiProcessors_Family_FAMILY_80387;
  static const Family FAMILY_80487 =
    DmiProcessors_Family_FAMILY_80487;
  static const Family FAMILY_INTEL_PENTIUM_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_PRO_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_PRO_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_2_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_2_PROCESSOR;
  static const Family FAMILY_PENTIUM_PROCESSOR_WITH_MMX =
    DmiProcessors_Family_FAMILY_PENTIUM_PROCESSOR_WITH_MMX;
  static const Family FAMILY_INTEL_CELERON_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CELERON_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_2_XEON_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_2_XEON_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_3_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_3_PROCESSOR;
  static const Family FAMILY_M1_FAMILY =
    DmiProcessors_Family_FAMILY_M1_FAMILY;
  static const Family FAMILY_M2_FAMILY =
    DmiProcessors_Family_FAMILY_M2_FAMILY;
  static const Family FAMILY_INTEL_CELEROM_M_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CELEROM_M_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_4_HT_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_4_HT_PROCESSOR;
  static const Family FAMILY_AMD_DURON_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_DURON_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_K5_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_K5_FAMILY;
  static const Family FAMILY_AMD_K6_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_K6_FAMILY;
  static const Family FAMILY_AMD_K6_2 =
    DmiProcessors_Family_FAMILY_AMD_K6_2;
  static const Family FAMILY_AMD_K6_3 =
    DmiProcessors_Family_FAMILY_AMD_K6_3;
  static const Family FAMILY_AMD_ATHLON_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_29000_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_29000_FAMILY;
  static const Family FAMILY_AMD_K6_2_PLUS =
    DmiProcessors_Family_FAMILY_AMD_K6_2_PLUS;
  static const Family FAMILY_POWER_PC_FAMILY =
    DmiProcessors_Family_FAMILY_POWER_PC_FAMILY;
  static const Family FAMILY_POWER_PC_601 =
    DmiProcessors_Family_FAMILY_POWER_PC_601;
  static const Family FAMILY_POWER_PC_603 =
    DmiProcessors_Family_FAMILY_POWER_PC_603;
  static const Family FAMILY_POWER_PC_603_PLUS =
    DmiProcessors_Family_FAMILY_POWER_PC_603_PLUS;
  static const Family FAMILY_POWER_PC_604 =
    DmiProcessors_Family_FAMILY_POWER_PC_604;
  static const Family FAMILY_POWER_PC_620 =
    DmiProcessors_Family_FAMILY_POWER_PC_620;
  static const Family FAMILY_POWER_PC_X704 =
    DmiProcessors_Family_FAMILY_POWER_PC_X704;
  static const Family FAMILY_POWER_PC_750 =
    DmiProcessors_Family_FAMILY_POWER_PC_750;
  static const Family FAMILY_INTEL_CORE_DUO_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_DUO_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_DUO_MOBILE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_DUO_MOBILE_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_SOLO_MOBILE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_SOLO_MOBILE_PROCESSOR;
  static const Family FAMILY_INTEL_ATOM_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_ATOM_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_M_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_M_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_M3_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_M3_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_M5_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_M5_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_M7_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_M7_PROCESSOR;
  static const Family FAMILY_ALPHA_FAMILY =
    DmiProcessors_Family_FAMILY_ALPHA_FAMILY;
  static const Family FAMILY_ALPHA_21064 =
    DmiProcessors_Family_FAMILY_ALPHA_21064;
  static const Family FAMILY_ALPHA_21066 =
    DmiProcessors_Family_FAMILY_ALPHA_21066;
  static const Family FAMILY_ALPHA_21164 =
    DmiProcessors_Family_FAMILY_ALPHA_21164;
  static const Family FAMILY_ALPHA_21164PC =
    DmiProcessors_Family_FAMILY_ALPHA_21164PC;
  static const Family FAMILY_ALPHA_21164A =
    DmiProcessors_Family_FAMILY_ALPHA_21164A;
  static const Family FAMILY_ALPHA_21264 =
    DmiProcessors_Family_FAMILY_ALPHA_21264;
  static const Family FAMILY_ALPHA_21364 =
    DmiProcessors_Family_FAMILY_ALPHA_21364;
  static const Family FAMILY_AMD_TURION_2_ULTRA_DUAL_CORE_MOBILE_M_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_TURION_2_ULTRA_DUAL_CORE_MOBILE_M_FAMILY;
  static const Family FAMILY_AMD_TURION_2_DUAL_CORE_MOBILE_M_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_TURION_2_DUAL_CORE_MOBILE_M_FAMILY;
  static const Family FAMILY_AMD_ATHLON_2_DUAL_CORE_M_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_2_DUAL_CORE_M_FAMILY;
  static const Family FAMILY_AMD_OPTERON_6100_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_6100_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_4100_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_4100_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_6200_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_6200_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_4200_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_4200_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_FX_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_FX_SERIES_PROCESSOR;
  static const Family FAMILY_MIPS_FAMILY =
    DmiProcessors_Family_FAMILY_MIPS_FAMILY;
  static const Family FAMILY_MIPS_R4000 =
    DmiProcessors_Family_FAMILY_MIPS_R4000;
  static const Family FAMILY_MIPS_R4200 =
    DmiProcessors_Family_FAMILY_MIPS_R4200;
  static const Family FAMILY_MIPS_R4400 =
    DmiProcessors_Family_FAMILY_MIPS_R4400;
  static const Family FAMILY_MIPS_R4600 =
    DmiProcessors_Family_FAMILY_MIPS_R4600;
  static const Family FAMILY_MIPS_R10000 =
    DmiProcessors_Family_FAMILY_MIPS_R10000;
  static const Family FAMILY_AMD_C_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_C_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_E_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_E_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_A_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_A_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_G_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_G_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_Z_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_Z_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_R_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_R_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_4300_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_4300_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_6300_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_6300_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_3300_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_3300_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_FIREPRO_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_FIREPRO_SERIES_PROCESSOR;
  static const Family FAMILY_SPARC_FAMILY =
    DmiProcessors_Family_FAMILY_SPARC_FAMILY;
  static const Family FAMILY_SUPER_SPARC =
    DmiProcessors_Family_FAMILY_SUPER_SPARC;
  static const Family FAMILY_MICRO_SPARC_2 =
    DmiProcessors_Family_FAMILY_MICRO_SPARC_2;
  static const Family FAMILY_MICRO_SPARC_2EP =
    DmiProcessors_Family_FAMILY_MICRO_SPARC_2EP;
  static const Family FAMILY_ULTRA_SPARC =
    DmiProcessors_Family_FAMILY_ULTRA_SPARC;
  static const Family FAMILY_ULTRA_SPARC_2 =
    DmiProcessors_Family_FAMILY_ULTRA_SPARC_2;
  static const Family FAMILY_ULTRA_SPARC_2I =
    DmiProcessors_Family_FAMILY_ULTRA_SPARC_2I;
  static const Family FAMILY_ULTRA_SPARC_3 =
    DmiProcessors_Family_FAMILY_ULTRA_SPARC_3;
  static const Family FAMILY_ULTRA_SPARC_3I =
    DmiProcessors_Family_FAMILY_ULTRA_SPARC_3I;
  static const Family FAMILY_68040_FAMILY =
    DmiProcessors_Family_FAMILY_68040_FAMILY;
  static const Family FAMILY_68XXX =
    DmiProcessors_Family_FAMILY_68XXX;
  static const Family FAMILY_68000 =
    DmiProcessors_Family_FAMILY_68000;
  static const Family FAMILY_68010 =
    DmiProcessors_Family_FAMILY_68010;
  static const Family FAMILY_68020 =
    DmiProcessors_Family_FAMILY_68020;
  static const Family FAMILY_68030 =
    DmiProcessors_Family_FAMILY_68030;
  static const Family FAMILY_AMD_ATHLON_X4_QUAD_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_X4_QUAD_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_OPTERON_X1000_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_X1000_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_X2000_SERIES_APU =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_X2000_SERIES_APU;
  static const Family FAMILY_AMD_OPTERON_A_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_A_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_X3000_SERIES_APU =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_X3000_SERIES_APU;
  static const Family FAMILY_AMD_ZEN_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ZEN_PROCESSOR_FAMILY;
  static const Family FAMILY_HOBBIT_FAMILY =
    DmiProcessors_Family_FAMILY_HOBBIT_FAMILY;
  static const Family FAMILY_CRUSOE_TM5000_FAMILY =
    DmiProcessors_Family_FAMILY_CRUSOE_TM5000_FAMILY;
  static const Family FAMILY_CRUSOE_TM3000_FAMILY =
    DmiProcessors_Family_FAMILY_CRUSOE_TM3000_FAMILY;
  static const Family FAMILY_EFFICEON_TM8000_FAMILY =
    DmiProcessors_Family_FAMILY_EFFICEON_TM8000_FAMILY;
  static const Family FAMILY_WEITEK =
    DmiProcessors_Family_FAMILY_WEITEK;
  static const Family FAMILY_INTEL_ITANIUM_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_ITANIUM_PROCESSOR;
  static const Family FAMILY_AMD_ATHLON_64_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_64_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_OPTERON_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_SEMPRON_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_SEMPRON_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_TURION_64_MOBILE_TECHNOLOGY =
    DmiProcessors_Family_FAMILY_AMD_TURION_64_MOBILE_TECHNOLOGY;
  static const Family FAMILY_AMD_OPTERON_DUAL_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_DUAL_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_ATHLON_64_X2_DUAL_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_64_X2_DUAL_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_TURION_64_X2_MOBILE_TECHNOLOGY =
    DmiProcessors_Family_FAMILY_AMD_TURION_64_X2_MOBILE_TECHNOLOGY;
  static const Family FAMILY_AMD_OPTERON_QUAD_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_QUAD_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_OPTERON_THIRD_GEN_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_THIRD_GEN_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_PHENOM_FX_QUAD_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_PHENOM_FX_QUAD_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_PHENOM_X4_QUAD_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_PHENOM_X4_QUAD_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_PHENOM_X2_DUAL_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_PHENOM_X2_DUAL_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_ATHLON_X2_DUAL_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_X2_DUAL_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_PA_RISC_FAMILY =
    DmiProcessors_Family_FAMILY_PA_RISC_FAMILY;
  static const Family FAMILY_PA_RISC_8500 =
    DmiProcessors_Family_FAMILY_PA_RISC_8500;
  static const Family FAMILY_PA_RISC_8000 =
    DmiProcessors_Family_FAMILY_PA_RISC_8000;
  static const Family FAMILY_PA_RISC_7300LC =
    DmiProcessors_Family_FAMILY_PA_RISC_7300LC;
  static const Family FAMILY_PA_RISC_7200 =
    DmiProcessors_Family_FAMILY_PA_RISC_7200;
  static const Family FAMILY_PA_RISC_7100LC =
    DmiProcessors_Family_FAMILY_PA_RISC_7100LC;
  static const Family FAMILY_PA_RISC_7100 =
    DmiProcessors_Family_FAMILY_PA_RISC_7100;
  static const Family FAMILY_V30_FAMILY =
    DmiProcessors_Family_FAMILY_V30_FAMILY;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_3200_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_3200_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_3000_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_3000_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_5300_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_5300_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_5100_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5100_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_5000_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5000_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_LV_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_LV_PROCESSOR;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_ULV_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_ULV_PROCESSOR;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_7100_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_7100_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_5400_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_5400_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_PROCESSOR;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_5200_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5200_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_7200_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_7200_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_7300_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_7300_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_7400_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_7400_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_MULTI_CORE_7400_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_7400_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_PENTIUM_3_XEON_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_3_XEON_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_3_PROCESSOR_WITH_SPEED_STEP =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_3_PROCESSOR_WITH_SPEED_STEP;
  static const Family FAMILY_INTEL_PENTIUM_4_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_4_PROCESSOR;
  static const Family FAMILY_INTEL_XEON_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_XEON_PROCESSOR;
  static const Family FAMILY_AS400_FAMILY =
    DmiProcessors_Family_FAMILY_AS400_FAMILY;
  static const Family FAMILY_INTEL_XEON_MP_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_XEON_MP_PROCESSOR;
  static const Family FAMILY_AMD_ATHLON_XP_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_XP_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_ATHLON_MP_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_MP_PROCESSOR_FAMILY;
  static const Family FAMILY_INTEL_ITANIUM_2_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_ITANIUM_2_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_M_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_M_PROCESSOR;
  static const Family FAMILY_INTEL_CELERON_D_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CELERON_D_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_D_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_D_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_PROCESSOR_EXTREME_EDITION =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_PROCESSOR_EXTREME_EDITION;
  static const Family FAMILY_INTEL_CORE_SOLO_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_SOLO_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_DUO_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_DUO_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_SOLO_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_SOLO_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_EXTREME_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_EXTREME_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_QUAD_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_QUAD_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_EXTREME_MOBILE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_EXTREME_MOBILE_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_DUO_MOBILE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_DUO_MOBILE_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_SOLO_MOBILE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_SOLO_MOBILE_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_I7_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_I7_PROCESSOR;
  static const Family FAMILY_INTEL_CELERON_DUAL_CORE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CELERON_DUAL_CORE_PROCESSOR;
  static const Family FAMILY_IBM390_FAMILY =
    DmiProcessors_Family_FAMILY_IBM390_FAMILY;
  static const Family FAMILY_G4 =
    DmiProcessors_Family_FAMILY_G4;
  static const Family FAMILY_G5 =
    DmiProcessors_Family_FAMILY_G5;
  static const Family FAMILY_ESA_390_G6 =
    DmiProcessors_Family_FAMILY_ESA_390_G6;
  static const Family FAMILY_Z_ARCHITECTURE_BASE =
    DmiProcessors_Family_FAMILY_Z_ARCHITECTURE_BASE;
  static const Family FAMILY_INTEL_CORE_I5_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_I5_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_I3_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_I3_PROCESSOR;
  static const Family FAMILY_VIA_C7_M_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_VIA_C7_M_PROCESSOR_FAMILY;
  static const Family FAMILY_VIA_C7_D_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_VIA_C7_D_PROCESSOR_FAMILY;
  static const Family FAMILY_VIA_C7_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_VIA_C7_PROCESSOR_FAMILY;
  static const Family FAMILY_VIA_EDEN_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_VIA_EDEN_PROCESSOR_FAMILY;
  static const Family FAMILY_INTEL_XEON_MULTI_CORE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_PROCESSOR;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_3XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_3XXX_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_3XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_3XXX_PROCESSOR_SERIES;
  static const Family FAMILY_VIA_NANO_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_VIA_NANO_PROCESSOR_FAMILY;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_5XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5XXX_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_5XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_5XXX_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_7XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_7XXX_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_7XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_7XXX_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_MULTI_CORE_7XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_7XXX_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_MULTI_CORE_3400_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_3400_PROCESSOR_SERIES;
  static const Family FAMILY_AMD_OPTERON_3000_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_3000_PROCESSOR_SERIES;
  static const Family FAMILY_AMD_SEMPRON_II_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_SEMPRON_II_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_QUAD_CORE_EMBEDDED_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_QUAD_CORE_EMBEDDED_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_PHENOM_TRIPLE_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_PHENOM_TRIPLE_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_TURION_ULTRA_DUAL_CORE_MOBILE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_TURION_ULTRA_DUAL_CORE_MOBILE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_TURION_DUAL_CORE_MOBILE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_TURION_DUAL_CORE_MOBILE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_ATHLON_DUAL_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_DUAL_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_SEMPRON_SI_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_SEMPRON_SI_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_PHENOM_2_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_PHENOM_2_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_ATHLON_2_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_2_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_OPTERON_SIX_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_SIX_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_SEMPRON_M_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_SEMPRON_M_PROCESSOR_FAMILY;
  static const Family FAMILY_I860 =
    DmiProcessors_Family_FAMILY_I860;
  static const Family FAMILY_I960 =
    DmiProcessors_Family_FAMILY_I960;
  static const Family FAMILY_ARM_V7 =
    DmiProcessors_Family_FAMILY_ARM_V7;
  static const Family FAMILY_ARM_V8 =
    DmiProcessors_Family_FAMILY_ARM_V8;
  static const Family FAMILY_SH_3 =
    DmiProcessors_Family_FAMILY_SH_3;
  static const Family FAMILY_SH_4 =
    DmiProcessors_Family_FAMILY_SH_4;
  static const Family FAMILY_ARM =
    DmiProcessors_Family_FAMILY_ARM;
  static const Family FAMILY_STRONG_ARM =
    DmiProcessors_Family_FAMILY_STRONG_ARM;
  static const Family FAMILY_6X86 =
    DmiProcessors_Family_FAMILY_6X86;
  static const Family FAMILY_MEDIA_GX =
    DmiProcessors_Family_FAMILY_MEDIA_GX;
  static const Family FAMILY_MII =
    DmiProcessors_Family_FAMILY_MII;
  static const Family FAMILY_WIN_CHIP =
    DmiProcessors_Family_FAMILY_WIN_CHIP;
  static const Family FAMILY_DSP =
    DmiProcessors_Family_FAMILY_DSP;
  static const Family FAMILY_VIDEO_PROCESSOR =
    DmiProcessors_Family_FAMILY_VIDEO_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_FAMILY =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_FAMILY;
  static const Family FAMILY_AMD_K7_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_K7_FAMILY;
  static const Family FAMILY_INTEL_CORE_2_OR_AMD_K7_FAMILY =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_OR_AMD_K7_FAMILY;
  static inline bool Family_IsValid(int value) {
    return DmiProcessors_Family_IsValid(value);
  }
  static const Family Family_MIN =
    DmiProcessors_Family_Family_MIN;
  static const Family Family_MAX =
    DmiProcessors_Family_Family_MAX;
  static const int Family_ARRAYSIZE =
    DmiProcessors_Family_Family_ARRAYSIZE;

  typedef DmiProcessors_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiProcessors_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiProcessors_Type_TYPE_OTHER;
  static const Type TYPE_CENTRAL_PROCESSOR =
    DmiProcessors_Type_TYPE_CENTRAL_PROCESSOR;
  static const Type TYPE_MATH_PROCESSOR =
    DmiProcessors_Type_TYPE_MATH_PROCESSOR;
  static const Type TYPE_DSP_PROCESSOR =
    DmiProcessors_Type_TYPE_DSP_PROCESSOR;
  static const Type TYPE_VIDEO_PROCESSOR =
    DmiProcessors_Type_TYPE_VIDEO_PROCESSOR;
  static inline bool Type_IsValid(int value) {
    return DmiProcessors_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiProcessors_Type_Type_MIN;
  static const Type Type_MAX =
    DmiProcessors_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiProcessors_Type_Type_ARRAYSIZE;

  typedef DmiProcessors_Status Status;
  static const Status STATUS_UNKNOWN =
    DmiProcessors_Status_STATUS_UNKNOWN;
  static const Status STATUS_ENABLED =
    DmiProcessors_Status_STATUS_ENABLED;
  static const Status STATUS_DISABLED_BY_USER =
    DmiProcessors_Status_STATUS_DISABLED_BY_USER;
  static const Status STATUS_DISABLED_BY_BIOS =
    DmiProcessors_Status_STATUS_DISABLED_BY_BIOS;
  static const Status STATUS_IDLE =
    DmiProcessors_Status_STATUS_IDLE;
  static const Status STATUS_OTHER =
    DmiProcessors_Status_STATUS_OTHER;
  static inline bool Status_IsValid(int value) {
    return DmiProcessors_Status_IsValid(value);
  }
  static const Status Status_MIN =
    DmiProcessors_Status_Status_MIN;
  static const Status Status_MAX =
    DmiProcessors_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    DmiProcessors_Status_Status_ARRAYSIZE;

  typedef DmiProcessors_Upgrade Upgrade;
  static const Upgrade UPGRADE_UNKNOWN =
    DmiProcessors_Upgrade_UPGRADE_UNKNOWN;
  static const Upgrade UPGRADE_OTHER =
    DmiProcessors_Upgrade_UPGRADE_OTHER;
  static const Upgrade UPGRADE_DAUGHTER_BOARD =
    DmiProcessors_Upgrade_UPGRADE_DAUGHTER_BOARD;
  static const Upgrade UPGRADE_ZIF_SOCKET =
    DmiProcessors_Upgrade_UPGRADE_ZIF_SOCKET;
  static const Upgrade UPGRADE_REPLACEABLE_PIGGY_BACK =
    DmiProcessors_Upgrade_UPGRADE_REPLACEABLE_PIGGY_BACK;
  static const Upgrade UPGRADE_NONE =
    DmiProcessors_Upgrade_UPGRADE_NONE;
  static const Upgrade UPGRADE_LIF_SOCKET =
    DmiProcessors_Upgrade_UPGRADE_LIF_SOCKET;
  static const Upgrade UPGRADE_SLOT_1 =
    DmiProcessors_Upgrade_UPGRADE_SLOT_1;
  static const Upgrade UPGRADE_SLOT_2 =
    DmiProcessors_Upgrade_UPGRADE_SLOT_2;
  static const Upgrade UPGRADE_370_PIN_SOCKET =
    DmiProcessors_Upgrade_UPGRADE_370_PIN_SOCKET;
  static const Upgrade UPGRADE_SLOT_A =
    DmiProcessors_Upgrade_UPGRADE_SLOT_A;
  static const Upgrade UPGRADE_SLOT_M =
    DmiProcessors_Upgrade_UPGRADE_SLOT_M;
  static const Upgrade UPGRADE_SOCKET_423 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_423;
  static const Upgrade UPGRADE_SOCKET_462 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_462;
  static const Upgrade UPGRADE_SOCKET_478 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_478;
  static const Upgrade UPGRADE_SOCKET_754 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_754;
  static const Upgrade UPGRADE_SOCKET_940 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_940;
  static const Upgrade UPGRADE_SOCKET_939 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_939;
  static const Upgrade UPGRADE_SOCKET_MPGA604 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_MPGA604;
  static const Upgrade UPGRADE_SOCKET_LGA771 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA771;
  static const Upgrade UPGRADE_SOCKET_LGA775 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA775;
  static const Upgrade UPGRADE_SOCKET_S1 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_S1;
  static const Upgrade UPGRADE_SOCKET_AM2 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_AM2;
  static const Upgrade UPGRADE_SOCKET_F =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_F;
  static const Upgrade UPGRADE_SOCKET_LGA1366 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1366;
  static const Upgrade UPGRADE_SOCKET_G34 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_G34;
  static const Upgrade UPGRADE_SOCKET_AM3 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_AM3;
  static const Upgrade UPGRADE_SOCKET_C32 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_C32;
  static const Upgrade UPGRADE_SOCKET_LGA1156 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1156;
  static const Upgrade UPGRADE_SOCKET_LGA1567 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1567;
  static const Upgrade UPGRADE_SOCKET_PGA988A =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_PGA988A;
  static const Upgrade UPGRADE_SOCKET_BGA1288 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1288;
  static const Upgrade UPGRADE_SOCKET_RPGA988B =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_RPGA988B;
  static const Upgrade UPGRADE_SOCKET_BGA1023 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1023;
  static const Upgrade UPGRADE_SOCKET_BGA1224 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1224;
  static const Upgrade UPGRADE_SOCKET_BGA1155 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1155;
  static const Upgrade UPGRADE_SOCKET_LGA1356 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1356;
  static const Upgrade UPGRADE_SOCKET_LGA2011 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA2011;
  static const Upgrade UPGRADE_SOCKET_FS1 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_FS1;
  static const Upgrade UPGRADE_SOCKET_FS2 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_FS2;
  static const Upgrade UPGRADE_SOCKET_FM1 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_FM1;
  static const Upgrade UPGRADE_SOCKET_FM2 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_FM2;
  static const Upgrade UPGRADE_SOCKET_LGA2011_3 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA2011_3;
  static const Upgrade UPGRADE_SOCKET_LGA1356_3 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1356_3;
  static const Upgrade UPGRADE_SOCKET_LGA1150 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1150;
  static const Upgrade UPGRADE_SOCKET_BGA1168 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1168;
  static const Upgrade UPGRADE_SOCKET_BGA1234 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1234;
  static const Upgrade UPGRADE_SOCKET_BGA1364 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1364;
  static const Upgrade UPGRADE_SOCKET_AM4 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_AM4;
  static const Upgrade UPGRADE_SOCKET_LGA1151 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1151;
  static const Upgrade UPGRADE_SOCKET_BGA1356 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1356;
  static const Upgrade UPGRADE_SOCKET_BGA1440 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1440;
  static const Upgrade UPGRADE_SOCKET_BGA1515 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1515;
  static const Upgrade UPGRADE_SOCKET_LGA3647_1 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA3647_1;
  static const Upgrade UPGRADE_SOCKET_SP3 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_SP3;
  static const Upgrade UPGRADE_SOCKET_SP3_R2 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_SP3_R2;
  static inline bool Upgrade_IsValid(int value) {
    return DmiProcessors_Upgrade_IsValid(value);
  }
  static const Upgrade Upgrade_MIN =
    DmiProcessors_Upgrade_Upgrade_MIN;
  static const Upgrade Upgrade_MAX =
    DmiProcessors_Upgrade_Upgrade_MAX;
  static const int Upgrade_ARRAYSIZE =
    DmiProcessors_Upgrade_Upgrade_ARRAYSIZE;

  typedef DmiProcessors_Characteristics Characteristics;
  static const Characteristics CHARACTERISTIC_NONE =
    DmiProcessors_Characteristics_CHARACTERISTIC_NONE;
  static const Characteristics CHARACTERISTIC_64BIT_CAPABLE =
    DmiProcessors_Characteristics_CHARACTERISTIC_64BIT_CAPABLE;
  static const Characteristics CHARACTERISTIC_MULTI_CORE =
    DmiProcessors_Characteristics_CHARACTERISTIC_MULTI_CORE;
  static const Characteristics CHARACTERISTIC_HARDWARE_THREAD =
    DmiProcessors_Characteristics_CHARACTERISTIC_HARDWARE_THREAD;
  static const Characteristics CHARACTERISTIC_EXECUTE_PROTECTION =
    DmiProcessors_Characteristics_CHARACTERISTIC_EXECUTE_PROTECTION;
  static const Characteristics CHARACTERISTIC_ENHANCED_VIRTUALIZATION =
    DmiProcessors_Characteristics_CHARACTERISTIC_ENHANCED_VIRTUALIZATION;
  static const Characteristics CHARACTERISTIC_POWER_CONTROL =
    DmiProcessors_Characteristics_CHARACTERISTIC_POWER_CONTROL;
  static inline bool Characteristics_IsValid(int value) {
    return DmiProcessors_Characteristics_IsValid(value);
  }
  static const Characteristics Characteristics_MIN =
    DmiProcessors_Characteristics_Characteristics_MIN;
  static const Characteristics Characteristics_MAX =
    DmiProcessors_Characteristics_Characteristics_MAX;
  static const int Characteristics_ARRAYSIZE =
    DmiProcessors_Characteristics_Characteristics_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiProcessors.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiProcessors_Item& item(int index) const;
  ::aspia::proto::DmiProcessors_Item* mutable_item(int index);
  ::aspia::proto::DmiProcessors_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiProcessors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiProcessorsImpl();
};
// -------------------------------------------------------------------

class DmiMemoryDevices_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiMemoryDevices.Item) */ {
 public:
  DmiMemoryDevices_Item();
  virtual ~DmiMemoryDevices_Item();

  DmiMemoryDevices_Item(const DmiMemoryDevices_Item& from);

  inline DmiMemoryDevices_Item& operator=(const DmiMemoryDevices_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiMemoryDevices_Item(DmiMemoryDevices_Item&& from) noexcept
    : DmiMemoryDevices_Item() {
    *this = ::std::move(from);
  }

  inline DmiMemoryDevices_Item& operator=(DmiMemoryDevices_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiMemoryDevices_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiMemoryDevices_Item* internal_default_instance() {
    return reinterpret_cast<const DmiMemoryDevices_Item*>(
               &_DmiMemoryDevices_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DmiMemoryDevices_Item* other);
  friend void swap(DmiMemoryDevices_Item& a, DmiMemoryDevices_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiMemoryDevices_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiMemoryDevices_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiMemoryDevices_Item& from);
  void MergeFrom(const DmiMemoryDevices_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiMemoryDevices_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device_locator = 1;
  void clear_device_locator();
  static const int kDeviceLocatorFieldNumber = 1;
  const ::std::string& device_locator() const;
  void set_device_locator(const ::std::string& value);
  #if LANG_CXX11
  void set_device_locator(::std::string&& value);
  #endif
  void set_device_locator(const char* value);
  void set_device_locator(const char* value, size_t size);
  ::std::string* mutable_device_locator();
  ::std::string* release_device_locator();
  void set_allocated_device_locator(::std::string* device_locator);

  // string serial_number = 6;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 6;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string part_number = 7;
  void clear_part_number();
  static const int kPartNumberFieldNumber = 7;
  const ::std::string& part_number() const;
  void set_part_number(const ::std::string& value);
  #if LANG_CXX11
  void set_part_number(::std::string&& value);
  #endif
  void set_part_number(const char* value);
  void set_part_number(const char* value, size_t size);
  ::std::string* mutable_part_number();
  ::std::string* release_part_number();
  void set_allocated_part_number(::std::string* part_number);

  // string manufactorer = 8;
  void clear_manufactorer();
  static const int kManufactorerFieldNumber = 8;
  const ::std::string& manufactorer() const;
  void set_manufactorer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufactorer(::std::string&& value);
  #endif
  void set_manufactorer(const char* value);
  void set_manufactorer(const char* value, size_t size);
  ::std::string* mutable_manufactorer();
  ::std::string* release_manufactorer();
  void set_allocated_manufactorer(::std::string* manufactorer);

  // string bank = 9;
  void clear_bank();
  static const int kBankFieldNumber = 9;
  const ::std::string& bank() const;
  void set_bank(const ::std::string& value);
  #if LANG_CXX11
  void set_bank(::std::string&& value);
  #endif
  void set_bank(const char* value);
  void set_bank(const char* value, size_t size);
  ::std::string* mutable_bank();
  ::std::string* release_bank();
  void set_allocated_bank(::std::string* bank);

  // int32 size = 2;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // .aspia.proto.DmiMemoryDevices.Type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::aspia::proto::DmiMemoryDevices_Type type() const;
  void set_type(::aspia::proto::DmiMemoryDevices_Type value);

  // int32 speed = 4;
  void clear_speed();
  static const int kSpeedFieldNumber = 4;
  ::google::protobuf::int32 speed() const;
  void set_speed(::google::protobuf::int32 value);

  // .aspia.proto.DmiMemoryDevices.FormFactor form_factor = 5;
  void clear_form_factor();
  static const int kFormFactorFieldNumber = 5;
  ::aspia::proto::DmiMemoryDevices_FormFactor form_factor() const;
  void set_form_factor(::aspia::proto::DmiMemoryDevices_FormFactor value);

  // int32 total_width = 10;
  void clear_total_width();
  static const int kTotalWidthFieldNumber = 10;
  ::google::protobuf::int32 total_width() const;
  void set_total_width(::google::protobuf::int32 value);

  // int32 data_width = 11;
  void clear_data_width();
  static const int kDataWidthFieldNumber = 11;
  ::google::protobuf::int32 data_width() const;
  void set_data_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiMemoryDevices.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_locator_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr part_number_;
  ::google::protobuf::internal::ArenaStringPtr manufactorer_;
  ::google::protobuf::internal::ArenaStringPtr bank_;
  ::google::protobuf::int32 size_;
  int type_;
  ::google::protobuf::int32 speed_;
  int form_factor_;
  ::google::protobuf::int32 total_width_;
  ::google::protobuf::int32 data_width_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiMemoryDevices_ItemImpl();
};
// -------------------------------------------------------------------

class DmiMemoryDevices : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiMemoryDevices) */ {
 public:
  DmiMemoryDevices();
  virtual ~DmiMemoryDevices();

  DmiMemoryDevices(const DmiMemoryDevices& from);

  inline DmiMemoryDevices& operator=(const DmiMemoryDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiMemoryDevices(DmiMemoryDevices&& from) noexcept
    : DmiMemoryDevices() {
    *this = ::std::move(from);
  }

  inline DmiMemoryDevices& operator=(DmiMemoryDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiMemoryDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiMemoryDevices* internal_default_instance() {
    return reinterpret_cast<const DmiMemoryDevices*>(
               &_DmiMemoryDevices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(DmiMemoryDevices* other);
  friend void swap(DmiMemoryDevices& a, DmiMemoryDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiMemoryDevices* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiMemoryDevices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiMemoryDevices& from);
  void MergeFrom(const DmiMemoryDevices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiMemoryDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiMemoryDevices_Item Item;

  typedef DmiMemoryDevices_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiMemoryDevices_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiMemoryDevices_Type_TYPE_OTHER;
  static const Type TYPE_DRAM =
    DmiMemoryDevices_Type_TYPE_DRAM;
  static const Type TYPE_EDRAM =
    DmiMemoryDevices_Type_TYPE_EDRAM;
  static const Type TYPE_VRAM =
    DmiMemoryDevices_Type_TYPE_VRAM;
  static const Type TYPE_SRAM =
    DmiMemoryDevices_Type_TYPE_SRAM;
  static const Type TYPE_RAM =
    DmiMemoryDevices_Type_TYPE_RAM;
  static const Type TYPE_ROM =
    DmiMemoryDevices_Type_TYPE_ROM;
  static const Type TYPE_FLASH =
    DmiMemoryDevices_Type_TYPE_FLASH;
  static const Type TYPE_EEPROM =
    DmiMemoryDevices_Type_TYPE_EEPROM;
  static const Type TYPE_FEPROM =
    DmiMemoryDevices_Type_TYPE_FEPROM;
  static const Type TYPE_EPROM =
    DmiMemoryDevices_Type_TYPE_EPROM;
  static const Type TYPE_CDRAM =
    DmiMemoryDevices_Type_TYPE_CDRAM;
  static const Type TYPE_3DRAM =
    DmiMemoryDevices_Type_TYPE_3DRAM;
  static const Type TYPE_SDRAM =
    DmiMemoryDevices_Type_TYPE_SDRAM;
  static const Type TYPE_SGRAM =
    DmiMemoryDevices_Type_TYPE_SGRAM;
  static const Type TYPE_RDRAM =
    DmiMemoryDevices_Type_TYPE_RDRAM;
  static const Type TYPE_DDR =
    DmiMemoryDevices_Type_TYPE_DDR;
  static const Type TYPE_DDR2 =
    DmiMemoryDevices_Type_TYPE_DDR2;
  static const Type TYPE_DDR2_FB_DIMM =
    DmiMemoryDevices_Type_TYPE_DDR2_FB_DIMM;
  static const Type TYPE_DDR3 =
    DmiMemoryDevices_Type_TYPE_DDR3;
  static const Type TYPE_FBD2 =
    DmiMemoryDevices_Type_TYPE_FBD2;
  static const Type TYPE_DDR4 =
    DmiMemoryDevices_Type_TYPE_DDR4;
  static const Type TYPE_LPDDR =
    DmiMemoryDevices_Type_TYPE_LPDDR;
  static const Type TYPE_LPDDR2 =
    DmiMemoryDevices_Type_TYPE_LPDDR2;
  static const Type TYPE_LPDDR3 =
    DmiMemoryDevices_Type_TYPE_LPDDR3;
  static const Type TYPE_LPDDR4 =
    DmiMemoryDevices_Type_TYPE_LPDDR4;
  static inline bool Type_IsValid(int value) {
    return DmiMemoryDevices_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiMemoryDevices_Type_Type_MIN;
  static const Type Type_MAX =
    DmiMemoryDevices_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiMemoryDevices_Type_Type_ARRAYSIZE;

  typedef DmiMemoryDevices_FormFactor FormFactor;
  static const FormFactor FORM_FACTOR_UNKNOWN =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_UNKNOWN;
  static const FormFactor FORM_FACTOR_OTHER =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_OTHER;
  static const FormFactor FORM_FACTOR_SIMM =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_SIMM;
  static const FormFactor FORM_FACTOR_SIP =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_SIP;
  static const FormFactor FORM_FACTOR_CHIP =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_CHIP;
  static const FormFactor FORM_FACTOR_DIP =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_DIP;
  static const FormFactor FORM_FACTOR_ZIP =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_ZIP;
  static const FormFactor FORM_FACTOR_PROPRIETARY_CARD =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_PROPRIETARY_CARD;
  static const FormFactor FORM_FACTOR_DIMM =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_DIMM;
  static const FormFactor FORM_FACTOR_TSOP =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_TSOP;
  static const FormFactor FORM_FACTOR_ROW_OF_CHIPS =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_ROW_OF_CHIPS;
  static const FormFactor FORM_FACTOR_RIMM =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_RIMM;
  static const FormFactor FORM_FACTOR_SODIMM =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_SODIMM;
  static const FormFactor FORM_FACTOR_SRIMM =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_SRIMM;
  static const FormFactor FORM_FACTOR_FB_DIMM =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_FB_DIMM;
  static inline bool FormFactor_IsValid(int value) {
    return DmiMemoryDevices_FormFactor_IsValid(value);
  }
  static const FormFactor FormFactor_MIN =
    DmiMemoryDevices_FormFactor_FormFactor_MIN;
  static const FormFactor FormFactor_MAX =
    DmiMemoryDevices_FormFactor_FormFactor_MAX;
  static const int FormFactor_ARRAYSIZE =
    DmiMemoryDevices_FormFactor_FormFactor_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiMemoryDevices.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiMemoryDevices_Item& item(int index) const;
  ::aspia::proto::DmiMemoryDevices_Item* mutable_item(int index);
  ::aspia::proto::DmiMemoryDevices_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiMemoryDevices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiMemoryDevicesImpl();
};
// -------------------------------------------------------------------

class DmiSystemSlots_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiSystemSlots.Item) */ {
 public:
  DmiSystemSlots_Item();
  virtual ~DmiSystemSlots_Item();

  DmiSystemSlots_Item(const DmiSystemSlots_Item& from);

  inline DmiSystemSlots_Item& operator=(const DmiSystemSlots_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiSystemSlots_Item(DmiSystemSlots_Item&& from) noexcept
    : DmiSystemSlots_Item() {
    *this = ::std::move(from);
  }

  inline DmiSystemSlots_Item& operator=(DmiSystemSlots_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiSystemSlots_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiSystemSlots_Item* internal_default_instance() {
    return reinterpret_cast<const DmiSystemSlots_Item*>(
               &_DmiSystemSlots_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(DmiSystemSlots_Item* other);
  friend void swap(DmiSystemSlots_Item& a, DmiSystemSlots_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiSystemSlots_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiSystemSlots_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiSystemSlots_Item& from);
  void MergeFrom(const DmiSystemSlots_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiSystemSlots_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string slot_designation = 1;
  void clear_slot_designation();
  static const int kSlotDesignationFieldNumber = 1;
  const ::std::string& slot_designation() const;
  void set_slot_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_slot_designation(::std::string&& value);
  #endif
  void set_slot_designation(const char* value);
  void set_slot_designation(const char* value, size_t size);
  ::std::string* mutable_slot_designation();
  ::std::string* release_slot_designation();
  void set_allocated_slot_designation(::std::string* slot_designation);

  // .aspia.proto.DmiSystemSlots.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::aspia::proto::DmiSystemSlots_Type type() const;
  void set_type(::aspia::proto::DmiSystemSlots_Type value);

  // .aspia.proto.DmiSystemSlots.Usage usage = 3;
  void clear_usage();
  static const int kUsageFieldNumber = 3;
  ::aspia::proto::DmiSystemSlots_Usage usage() const;
  void set_usage(::aspia::proto::DmiSystemSlots_Usage value);

  // .aspia.proto.DmiSystemSlots.BusWidth bus_width = 4;
  void clear_bus_width();
  static const int kBusWidthFieldNumber = 4;
  ::aspia::proto::DmiSystemSlots_BusWidth bus_width() const;
  void set_bus_width(::aspia::proto::DmiSystemSlots_BusWidth value);

  // .aspia.proto.DmiSystemSlots.Length length = 5;
  void clear_length();
  static const int kLengthFieldNumber = 5;
  ::aspia::proto::DmiSystemSlots_Length length() const;
  void set_length(::aspia::proto::DmiSystemSlots_Length value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiSystemSlots.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr slot_designation_;
  int type_;
  int usage_;
  int bus_width_;
  int length_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiSystemSlots_ItemImpl();
};
// -------------------------------------------------------------------

class DmiSystemSlots : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiSystemSlots) */ {
 public:
  DmiSystemSlots();
  virtual ~DmiSystemSlots();

  DmiSystemSlots(const DmiSystemSlots& from);

  inline DmiSystemSlots& operator=(const DmiSystemSlots& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiSystemSlots(DmiSystemSlots&& from) noexcept
    : DmiSystemSlots() {
    *this = ::std::move(from);
  }

  inline DmiSystemSlots& operator=(DmiSystemSlots&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiSystemSlots& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiSystemSlots* internal_default_instance() {
    return reinterpret_cast<const DmiSystemSlots*>(
               &_DmiSystemSlots_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(DmiSystemSlots* other);
  friend void swap(DmiSystemSlots& a, DmiSystemSlots& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiSystemSlots* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiSystemSlots* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiSystemSlots& from);
  void MergeFrom(const DmiSystemSlots& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiSystemSlots* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiSystemSlots_Item Item;

  typedef DmiSystemSlots_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiSystemSlots_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiSystemSlots_Type_TYPE_OTHER;
  static const Type TYPE_ISA =
    DmiSystemSlots_Type_TYPE_ISA;
  static const Type TYPE_MCA =
    DmiSystemSlots_Type_TYPE_MCA;
  static const Type TYPE_EISA =
    DmiSystemSlots_Type_TYPE_EISA;
  static const Type TYPE_PCI =
    DmiSystemSlots_Type_TYPE_PCI;
  static const Type TYPE_PC_CARD =
    DmiSystemSlots_Type_TYPE_PC_CARD;
  static const Type TYPE_VLB =
    DmiSystemSlots_Type_TYPE_VLB;
  static const Type TYPE_PROPRIETARY =
    DmiSystemSlots_Type_TYPE_PROPRIETARY;
  static const Type TYPE_PROCESSOR_CARD =
    DmiSystemSlots_Type_TYPE_PROCESSOR_CARD;
  static const Type TYPE_PROPRIETARY_MEMORY_CARD =
    DmiSystemSlots_Type_TYPE_PROPRIETARY_MEMORY_CARD;
  static const Type TYPE_IO_RISER_CARD =
    DmiSystemSlots_Type_TYPE_IO_RISER_CARD;
  static const Type TYPE_NUBUS =
    DmiSystemSlots_Type_TYPE_NUBUS;
  static const Type TYPE_PCI_66 =
    DmiSystemSlots_Type_TYPE_PCI_66;
  static const Type TYPE_AGP =
    DmiSystemSlots_Type_TYPE_AGP;
  static const Type TYPE_AGP_2X =
    DmiSystemSlots_Type_TYPE_AGP_2X;
  static const Type TYPE_AGP_4X =
    DmiSystemSlots_Type_TYPE_AGP_4X;
  static const Type TYPE_PCI_X =
    DmiSystemSlots_Type_TYPE_PCI_X;
  static const Type TYPE_AGP_8X =
    DmiSystemSlots_Type_TYPE_AGP_8X;
  static const Type TYPE_M2_SOCKET_1DP =
    DmiSystemSlots_Type_TYPE_M2_SOCKET_1DP;
  static const Type TYPE_M2_SOCKET_1SD =
    DmiSystemSlots_Type_TYPE_M2_SOCKET_1SD;
  static const Type TYPE_M2_SOCKET_2 =
    DmiSystemSlots_Type_TYPE_M2_SOCKET_2;
  static const Type TYPE_M2_SOCKET_3 =
    DmiSystemSlots_Type_TYPE_M2_SOCKET_3;
  static const Type TYPE_MXM_TYPE_I =
    DmiSystemSlots_Type_TYPE_MXM_TYPE_I;
  static const Type TYPE_MXM_TYPE_II =
    DmiSystemSlots_Type_TYPE_MXM_TYPE_II;
  static const Type TYPE_MXM_TYPE_III =
    DmiSystemSlots_Type_TYPE_MXM_TYPE_III;
  static const Type TYPE_MXM_TYPE_III_HE =
    DmiSystemSlots_Type_TYPE_MXM_TYPE_III_HE;
  static const Type TYPE_MXM_TYPE_IV =
    DmiSystemSlots_Type_TYPE_MXM_TYPE_IV;
  static const Type TYPE_MXM_30_TYPE_A =
    DmiSystemSlots_Type_TYPE_MXM_30_TYPE_A;
  static const Type TYPE_MXM_30_TYPE_B =
    DmiSystemSlots_Type_TYPE_MXM_30_TYPE_B;
  static const Type TYPE_PCI_EXPRESS_2_SFF_8639 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_SFF_8639;
  static const Type TYPE_PCI_EXPRESS_3_SFF_8639 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_SFF_8639;
  static const Type TYPE_PCI_EXPRESS_MINI_52PIN_WITH_BOTTOM_SIDE =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_MINI_52PIN_WITH_BOTTOM_SIDE;
  static const Type TYPE_PCI_EXPRESS_MINI_52PIN =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_MINI_52PIN;
  static const Type TYPE_PCI_EXPRESS_MINI_76PIN =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_MINI_76PIN;
  static const Type TYPE_PC98_C20 =
    DmiSystemSlots_Type_TYPE_PC98_C20;
  static const Type TYPE_PC98_C24 =
    DmiSystemSlots_Type_TYPE_PC98_C24;
  static const Type TYPE_PC98_E =
    DmiSystemSlots_Type_TYPE_PC98_E;
  static const Type TYPE_PC98_LOCAL_BUS =
    DmiSystemSlots_Type_TYPE_PC98_LOCAL_BUS;
  static const Type TYPE_PC98_CARD =
    DmiSystemSlots_Type_TYPE_PC98_CARD;
  static const Type TYPE_PCI_EXPRESS =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS;
  static const Type TYPE_PCI_EXPRESS_X1 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X1;
  static const Type TYPE_PCI_EXPRESS_X2 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X2;
  static const Type TYPE_PCI_EXPRESS_X4 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X4;
  static const Type TYPE_PCI_EXPRESS_X8 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X8;
  static const Type TYPE_PCI_EXPRESS_X16 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X16;
  static const Type TYPE_PCI_EXPRESS_2 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2;
  static const Type TYPE_PCI_EXPRESS_2_X1 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X1;
  static const Type TYPE_PCI_EXPRESS_2_X2 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X2;
  static const Type TYPE_PCI_EXPRESS_2_X4 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X4;
  static const Type TYPE_PCI_EXPRESS_2_X8 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X8;
  static const Type TYPE_PCI_EXPRESS_2_X16 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X16;
  static const Type TYPE_PCI_EXPRESS_3 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3;
  static const Type TYPE_PCI_EXPRESS_3_X1 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X1;
  static const Type TYPE_PCI_EXPRESS_3_X2 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X2;
  static const Type TYPE_PCI_EXPRESS_3_X4 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X4;
  static const Type TYPE_PCI_EXPRESS_3_X8 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X8;
  static const Type TYPE_PCI_EXPRESS_3_X16 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X16;
  static inline bool Type_IsValid(int value) {
    return DmiSystemSlots_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiSystemSlots_Type_Type_MIN;
  static const Type Type_MAX =
    DmiSystemSlots_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiSystemSlots_Type_Type_ARRAYSIZE;

  typedef DmiSystemSlots_Usage Usage;
  static const Usage USAGE_UNKNOWN =
    DmiSystemSlots_Usage_USAGE_UNKNOWN;
  static const Usage USAGE_OTHER =
    DmiSystemSlots_Usage_USAGE_OTHER;
  static const Usage USAGE_AVAILABLE =
    DmiSystemSlots_Usage_USAGE_AVAILABLE;
  static const Usage USAGE_IN_USE =
    DmiSystemSlots_Usage_USAGE_IN_USE;
  static inline bool Usage_IsValid(int value) {
    return DmiSystemSlots_Usage_IsValid(value);
  }
  static const Usage Usage_MIN =
    DmiSystemSlots_Usage_Usage_MIN;
  static const Usage Usage_MAX =
    DmiSystemSlots_Usage_Usage_MAX;
  static const int Usage_ARRAYSIZE =
    DmiSystemSlots_Usage_Usage_ARRAYSIZE;

  typedef DmiSystemSlots_BusWidth BusWidth;
  static const BusWidth BUS_WIDTH_UNKNOWN =
    DmiSystemSlots_BusWidth_BUS_WIDTH_UNKNOWN;
  static const BusWidth BUS_WIDTH_OTHER =
    DmiSystemSlots_BusWidth_BUS_WIDTH_OTHER;
  static const BusWidth BUS_WIDTH_8_BIT =
    DmiSystemSlots_BusWidth_BUS_WIDTH_8_BIT;
  static const BusWidth BUS_WIDTH_16_BIT =
    DmiSystemSlots_BusWidth_BUS_WIDTH_16_BIT;
  static const BusWidth BUS_WIDTH_32_BIT =
    DmiSystemSlots_BusWidth_BUS_WIDTH_32_BIT;
  static const BusWidth BUS_WIDTH_64_BIT =
    DmiSystemSlots_BusWidth_BUS_WIDTH_64_BIT;
  static const BusWidth BUS_WIDTH_128_BIT =
    DmiSystemSlots_BusWidth_BUS_WIDTH_128_BIT;
  static const BusWidth BUS_WIDTH_X1 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X1;
  static const BusWidth BUS_WIDTH_X2 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X2;
  static const BusWidth BUS_WIDTH_X4 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X4;
  static const BusWidth BUS_WIDTH_X8 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X8;
  static const BusWidth BUS_WIDTH_X12 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X12;
  static const BusWidth BUS_WIDTH_X16 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X16;
  static const BusWidth BUS_WIDTH_X32 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X32;
  static inline bool BusWidth_IsValid(int value) {
    return DmiSystemSlots_BusWidth_IsValid(value);
  }
  static const BusWidth BusWidth_MIN =
    DmiSystemSlots_BusWidth_BusWidth_MIN;
  static const BusWidth BusWidth_MAX =
    DmiSystemSlots_BusWidth_BusWidth_MAX;
  static const int BusWidth_ARRAYSIZE =
    DmiSystemSlots_BusWidth_BusWidth_ARRAYSIZE;

  typedef DmiSystemSlots_Length Length;
  static const Length LENGTH_UNKNOWN =
    DmiSystemSlots_Length_LENGTH_UNKNOWN;
  static const Length LENGTH_OTHER =
    DmiSystemSlots_Length_LENGTH_OTHER;
  static const Length LENGTH_SHORT =
    DmiSystemSlots_Length_LENGTH_SHORT;
  static const Length LENGTH_LONG =
    DmiSystemSlots_Length_LENGTH_LONG;
  static inline bool Length_IsValid(int value) {
    return DmiSystemSlots_Length_IsValid(value);
  }
  static const Length Length_MIN =
    DmiSystemSlots_Length_Length_MIN;
  static const Length Length_MAX =
    DmiSystemSlots_Length_Length_MAX;
  static const int Length_ARRAYSIZE =
    DmiSystemSlots_Length_Length_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiSystemSlots.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiSystemSlots_Item& item(int index) const;
  ::aspia::proto::DmiSystemSlots_Item* mutable_item(int index);
  ::aspia::proto::DmiSystemSlots_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiSystemSlots)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiSystemSlotsImpl();
};
// -------------------------------------------------------------------

class DmiPortConnectors_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortConnectors.Item) */ {
 public:
  DmiPortConnectors_Item();
  virtual ~DmiPortConnectors_Item();

  DmiPortConnectors_Item(const DmiPortConnectors_Item& from);

  inline DmiPortConnectors_Item& operator=(const DmiPortConnectors_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortConnectors_Item(DmiPortConnectors_Item&& from) noexcept
    : DmiPortConnectors_Item() {
    *this = ::std::move(from);
  }

  inline DmiPortConnectors_Item& operator=(DmiPortConnectors_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortConnectors_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortConnectors_Item* internal_default_instance() {
    return reinterpret_cast<const DmiPortConnectors_Item*>(
               &_DmiPortConnectors_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(DmiPortConnectors_Item* other);
  friend void swap(DmiPortConnectors_Item& a, DmiPortConnectors_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortConnectors_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortConnectors_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortConnectors_Item& from);
  void MergeFrom(const DmiPortConnectors_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortConnectors_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string internal_designation = 1;
  void clear_internal_designation();
  static const int kInternalDesignationFieldNumber = 1;
  const ::std::string& internal_designation() const;
  void set_internal_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_internal_designation(::std::string&& value);
  #endif
  void set_internal_designation(const char* value);
  void set_internal_designation(const char* value, size_t size);
  ::std::string* mutable_internal_designation();
  ::std::string* release_internal_designation();
  void set_allocated_internal_designation(::std::string* internal_designation);

  // string external_designation = 2;
  void clear_external_designation();
  static const int kExternalDesignationFieldNumber = 2;
  const ::std::string& external_designation() const;
  void set_external_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_external_designation(::std::string&& value);
  #endif
  void set_external_designation(const char* value);
  void set_external_designation(const char* value, size_t size);
  ::std::string* mutable_external_designation();
  ::std::string* release_external_designation();
  void set_allocated_external_designation(::std::string* external_designation);

  // .aspia.proto.DmiPortConnectors.Type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::aspia::proto::DmiPortConnectors_Type type() const;
  void set_type(::aspia::proto::DmiPortConnectors_Type value);

  // .aspia.proto.DmiPortConnectors.ConnectorType internal_connector_type = 4;
  void clear_internal_connector_type();
  static const int kInternalConnectorTypeFieldNumber = 4;
  ::aspia::proto::DmiPortConnectors_ConnectorType internal_connector_type() const;
  void set_internal_connector_type(::aspia::proto::DmiPortConnectors_ConnectorType value);

  // .aspia.proto.DmiPortConnectors.ConnectorType external_connector_type = 5;
  void clear_external_connector_type();
  static const int kExternalConnectorTypeFieldNumber = 5;
  ::aspia::proto::DmiPortConnectors_ConnectorType external_connector_type() const;
  void set_external_connector_type(::aspia::proto::DmiPortConnectors_ConnectorType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortConnectors.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr internal_designation_;
  ::google::protobuf::internal::ArenaStringPtr external_designation_;
  int type_;
  int internal_connector_type_;
  int external_connector_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortConnectors_ItemImpl();
};
// -------------------------------------------------------------------

class DmiPortConnectors : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortConnectors) */ {
 public:
  DmiPortConnectors();
  virtual ~DmiPortConnectors();

  DmiPortConnectors(const DmiPortConnectors& from);

  inline DmiPortConnectors& operator=(const DmiPortConnectors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortConnectors(DmiPortConnectors&& from) noexcept
    : DmiPortConnectors() {
    *this = ::std::move(from);
  }

  inline DmiPortConnectors& operator=(DmiPortConnectors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortConnectors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortConnectors* internal_default_instance() {
    return reinterpret_cast<const DmiPortConnectors*>(
               &_DmiPortConnectors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(DmiPortConnectors* other);
  friend void swap(DmiPortConnectors& a, DmiPortConnectors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortConnectors* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortConnectors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortConnectors& from);
  void MergeFrom(const DmiPortConnectors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortConnectors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiPortConnectors_Item Item;

  typedef DmiPortConnectors_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiPortConnectors_Type_TYPE_UNKNOWN;
  static const Type TYPE_NONE =
    DmiPortConnectors_Type_TYPE_NONE;
  static const Type TYPE_PARALLEL_PORT_XT_AT_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_XT_AT_COMPATIBLE;
  static const Type TYPE_PARALLEL_PORT_PS_2 =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_PS_2;
  static const Type TYPE_PARALLEL_PORT_ECP =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_ECP;
  static const Type TYPE_PARALLEL_PORT_EPP =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_EPP;
  static const Type TYPE_PARALLEL_PORT_ECP_EPP =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_ECP_EPP;
  static const Type TYPE_SERIAL_PORT_XT_AT_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_SERIAL_PORT_XT_AT_COMPATIBLE;
  static const Type TYPE_SERIAL_PORT_16450_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_SERIAL_PORT_16450_COMPATIBLE;
  static const Type TYPE_SERIAL_PORT_16550_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_SERIAL_PORT_16550_COMPATIBLE;
  static const Type TYPE_SERIAL_PORT_16550A_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_SERIAL_PORT_16550A_COMPATIBLE;
  static const Type TYPE_SCSI_PORT =
    DmiPortConnectors_Type_TYPE_SCSI_PORT;
  static const Type TYPE_MIDI_PORT =
    DmiPortConnectors_Type_TYPE_MIDI_PORT;
  static const Type TYPE_JOYSTICK_PORT =
    DmiPortConnectors_Type_TYPE_JOYSTICK_PORT;
  static const Type TYPE_KEYBOARD_PORT =
    DmiPortConnectors_Type_TYPE_KEYBOARD_PORT;
  static const Type TYPE_MOUSE_PORT =
    DmiPortConnectors_Type_TYPE_MOUSE_PORT;
  static const Type TYPE_SSA_SCSI =
    DmiPortConnectors_Type_TYPE_SSA_SCSI;
  static const Type TYPE_USB =
    DmiPortConnectors_Type_TYPE_USB;
  static const Type TYPE_FIREWIRE =
    DmiPortConnectors_Type_TYPE_FIREWIRE;
  static const Type TYPE_PCMCIA_TYPE_I =
    DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_I;
  static const Type TYPE_PCMCIA_TYPE_II =
    DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_II;
  static const Type TYPE_PCMCIA_TYPE_III =
    DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_III;
  static const Type TYPE_CARDBUS =
    DmiPortConnectors_Type_TYPE_CARDBUS;
  static const Type TYPE_ACCESS_BUS_PORT =
    DmiPortConnectors_Type_TYPE_ACCESS_BUS_PORT;
  static const Type TYPE_SCSI_II =
    DmiPortConnectors_Type_TYPE_SCSI_II;
  static const Type TYPE_SCSI_WIDE =
    DmiPortConnectors_Type_TYPE_SCSI_WIDE;
  static const Type TYPE_PC_98 =
    DmiPortConnectors_Type_TYPE_PC_98;
  static const Type TYPE_PC_98_HIRESO =
    DmiPortConnectors_Type_TYPE_PC_98_HIRESO;
  static const Type TYPE_PC_H98 =
    DmiPortConnectors_Type_TYPE_PC_H98;
  static const Type TYPE_VIDEO_PORT =
    DmiPortConnectors_Type_TYPE_VIDEO_PORT;
  static const Type TYPE_AUDIO_PORT =
    DmiPortConnectors_Type_TYPE_AUDIO_PORT;
  static const Type TYPE_MODEM_PORT =
    DmiPortConnectors_Type_TYPE_MODEM_PORT;
  static const Type TYPE_NETWORK_PORT =
    DmiPortConnectors_Type_TYPE_NETWORK_PORT;
  static const Type TYPE_SATA =
    DmiPortConnectors_Type_TYPE_SATA;
  static const Type TYPE_SAS =
    DmiPortConnectors_Type_TYPE_SAS;
  static const Type TYPE_8251_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_8251_COMPATIBLE;
  static const Type TYPE_8251_FIFO_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_8251_FIFO_COMPATIBLE;
  static inline bool Type_IsValid(int value) {
    return DmiPortConnectors_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiPortConnectors_Type_Type_MIN;
  static const Type Type_MAX =
    DmiPortConnectors_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiPortConnectors_Type_Type_ARRAYSIZE;

  typedef DmiPortConnectors_ConnectorType ConnectorType;
  static const ConnectorType CONNECTOR_TYPE_UNKNOWN =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_UNKNOWN;
  static const ConnectorType CONNECTOR_TYPE_NONE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_NONE;
  static const ConnectorType CONNECTOR_TYPE_OTHER =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_OTHER;
  static const ConnectorType CONNECTOR_TYPE_CENTRONICS =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CENTRONICS;
  static const ConnectorType CONNECTOR_TYPE_MINI_CENTRONICS =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS;
  static const ConnectorType CONNECTOR_TYPE_PROPRIETARY =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PROPRIETARY;
  static const ConnectorType CONNECTOR_TYPE_DB_25_MALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_25_MALE;
  static const ConnectorType CONNECTOR_TYPE_DB_25_FEMALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_25_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_DB_15_MALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_15_MALE;
  static const ConnectorType CONNECTOR_TYPE_DB_15_FEMALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_15_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_DB_9_MALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_9_MALE;
  static const ConnectorType CONNECTOR_TYPE_DB_9_FEMALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_9_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_RJ_11 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_RJ_11;
  static const ConnectorType CONNECTOR_TYPE_RJ_45 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_RJ_45;
  static const ConnectorType CONNECTOR_TYPE_50_PIN_MINISCSI =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_50_PIN_MINISCSI;
  static const ConnectorType CONNECTOR_TYPE_MINI_DIN =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_DIN;
  static const ConnectorType CONNECTOR_TYPE_MICRO_DIN =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MICRO_DIN;
  static const ConnectorType CONNECTOR_TYPE_PS_2 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PS_2;
  static const ConnectorType CONNECTOR_TYPE_INFRARED =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_INFRARED;
  static const ConnectorType CONNECTOR_TYPE_HP_HIL =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_HP_HIL;
  static const ConnectorType CONNECTOR_TYPE_ACCESS_BUS_USB =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ACCESS_BUS_USB;
  static const ConnectorType CONNECTOR_TYPE_SSA_SCSI =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_SSA_SCSI;
  static const ConnectorType CONNECTOR_TYPE_CIRCULAR_DIN_8_MALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_MALE;
  static const ConnectorType CONNECTOR_TYPE_CIRCULAR_DIN_8_FEMALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_ONBOARD_IDE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_IDE;
  static const ConnectorType CONNECTOR_TYPE_ONBOARD_FLOPPY =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_FLOPPY;
  static const ConnectorType CONNECTOR_TYPE_9_PIN_DUAL_INLINE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_9_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_25_PIN_DUAL_INLINE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_25_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_50_PIN_DUAL_INLINE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_50_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_68_PIN_DUAL_INLINE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_68_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_ONBOARD_SOUND_INPUT_FROM_CDROM =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_SOUND_INPUT_FROM_CDROM;
  static const ConnectorType CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_14 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_14;
  static const ConnectorType CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_26 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_26;
  static const ConnectorType CONNECTOR_TYPE_MINI_JACK =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_JACK;
  static const ConnectorType CONNECTOR_TYPE_BNC =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_BNC;
  static const ConnectorType CONNECTOR_TYPE_IEEE_1394 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_IEEE_1394;
  static const ConnectorType CONNECTOR_TYPE_SAS_SATE_PLUG_RECEPTACLE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_SAS_SATE_PLUG_RECEPTACLE;
  static const ConnectorType CONNECTOR_TYPE_PC_98 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98;
  static const ConnectorType CONNECTOR_TYPE_PC_98_HIRESO =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_HIRESO;
  static const ConnectorType CONNECTOR_TYPE_PC_H98 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_H98;
  static const ConnectorType CONNECTOR_TYPE_PC_98_NOTE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_NOTE;
  static const ConnectorType CONNECTOR_TYPE_PC_98_FULL =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_FULL;
  static inline bool ConnectorType_IsValid(int value) {
    return DmiPortConnectors_ConnectorType_IsValid(value);
  }
  static const ConnectorType ConnectorType_MIN =
    DmiPortConnectors_ConnectorType_ConnectorType_MIN;
  static const ConnectorType ConnectorType_MAX =
    DmiPortConnectors_ConnectorType_ConnectorType_MAX;
  static const int ConnectorType_ARRAYSIZE =
    DmiPortConnectors_ConnectorType_ConnectorType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiPortConnectors.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiPortConnectors_Item& item(int index) const;
  ::aspia::proto::DmiPortConnectors_Item* mutable_item(int index);
  ::aspia::proto::DmiPortConnectors_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortConnectors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortConnectorsImpl();
};
// -------------------------------------------------------------------

class DmiOnBoardDevices_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiOnBoardDevices.Item) */ {
 public:
  DmiOnBoardDevices_Item();
  virtual ~DmiOnBoardDevices_Item();

  DmiOnBoardDevices_Item(const DmiOnBoardDevices_Item& from);

  inline DmiOnBoardDevices_Item& operator=(const DmiOnBoardDevices_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiOnBoardDevices_Item(DmiOnBoardDevices_Item&& from) noexcept
    : DmiOnBoardDevices_Item() {
    *this = ::std::move(from);
  }

  inline DmiOnBoardDevices_Item& operator=(DmiOnBoardDevices_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiOnBoardDevices_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiOnBoardDevices_Item* internal_default_instance() {
    return reinterpret_cast<const DmiOnBoardDevices_Item*>(
               &_DmiOnBoardDevices_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(DmiOnBoardDevices_Item* other);
  friend void swap(DmiOnBoardDevices_Item& a, DmiOnBoardDevices_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiOnBoardDevices_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiOnBoardDevices_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiOnBoardDevices_Item& from);
  void MergeFrom(const DmiOnBoardDevices_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiOnBoardDevices_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string description = 1;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .aspia.proto.DmiOnBoardDevices.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::aspia::proto::DmiOnBoardDevices_Type type() const;
  void set_type(::aspia::proto::DmiOnBoardDevices_Type value);

  // bool enabled = 3;
  void clear_enabled();
  static const int kEnabledFieldNumber = 3;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiOnBoardDevices.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  int type_;
  bool enabled_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiOnBoardDevices_ItemImpl();
};
// -------------------------------------------------------------------

class DmiOnBoardDevices : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiOnBoardDevices) */ {
 public:
  DmiOnBoardDevices();
  virtual ~DmiOnBoardDevices();

  DmiOnBoardDevices(const DmiOnBoardDevices& from);

  inline DmiOnBoardDevices& operator=(const DmiOnBoardDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiOnBoardDevices(DmiOnBoardDevices&& from) noexcept
    : DmiOnBoardDevices() {
    *this = ::std::move(from);
  }

  inline DmiOnBoardDevices& operator=(DmiOnBoardDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiOnBoardDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiOnBoardDevices* internal_default_instance() {
    return reinterpret_cast<const DmiOnBoardDevices*>(
               &_DmiOnBoardDevices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(DmiOnBoardDevices* other);
  friend void swap(DmiOnBoardDevices& a, DmiOnBoardDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiOnBoardDevices* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiOnBoardDevices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiOnBoardDevices& from);
  void MergeFrom(const DmiOnBoardDevices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiOnBoardDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiOnBoardDevices_Item Item;

  typedef DmiOnBoardDevices_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiOnBoardDevices_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiOnBoardDevices_Type_TYPE_OTHER;
  static const Type TYPE_VIDEO =
    DmiOnBoardDevices_Type_TYPE_VIDEO;
  static const Type TYPE_SCSI_CONTROLLER =
    DmiOnBoardDevices_Type_TYPE_SCSI_CONTROLLER;
  static const Type TYPE_ETHERNET =
    DmiOnBoardDevices_Type_TYPE_ETHERNET;
  static const Type TYPE_TOKEN_RING =
    DmiOnBoardDevices_Type_TYPE_TOKEN_RING;
  static const Type TYPE_SOUND =
    DmiOnBoardDevices_Type_TYPE_SOUND;
  static const Type TYPE_PATA_CONTROLLER =
    DmiOnBoardDevices_Type_TYPE_PATA_CONTROLLER;
  static const Type TYPE_SATA_CONTROLLER =
    DmiOnBoardDevices_Type_TYPE_SATA_CONTROLLER;
  static const Type TYPE_SAS_CONTROLLER =
    DmiOnBoardDevices_Type_TYPE_SAS_CONTROLLER;
  static inline bool Type_IsValid(int value) {
    return DmiOnBoardDevices_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiOnBoardDevices_Type_Type_MIN;
  static const Type Type_MAX =
    DmiOnBoardDevices_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiOnBoardDevices_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiOnBoardDevices.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiOnBoardDevices_Item& item(int index) const;
  ::aspia::proto::DmiOnBoardDevices_Item* mutable_item(int index);
  ::aspia::proto::DmiOnBoardDevices_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiOnBoardDevices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiOnBoardDevicesImpl();
};
// -------------------------------------------------------------------

class DmiPointingDevices_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPointingDevices.Item) */ {
 public:
  DmiPointingDevices_Item();
  virtual ~DmiPointingDevices_Item();

  DmiPointingDevices_Item(const DmiPointingDevices_Item& from);

  inline DmiPointingDevices_Item& operator=(const DmiPointingDevices_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPointingDevices_Item(DmiPointingDevices_Item&& from) noexcept
    : DmiPointingDevices_Item() {
    *this = ::std::move(from);
  }

  inline DmiPointingDevices_Item& operator=(DmiPointingDevices_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPointingDevices_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPointingDevices_Item* internal_default_instance() {
    return reinterpret_cast<const DmiPointingDevices_Item*>(
               &_DmiPointingDevices_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(DmiPointingDevices_Item* other);
  friend void swap(DmiPointingDevices_Item& a, DmiPointingDevices_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPointingDevices_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPointingDevices_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPointingDevices_Item& from);
  void MergeFrom(const DmiPointingDevices_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPointingDevices_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .aspia.proto.DmiPointingDevices.Type device_type = 1;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 1;
  ::aspia::proto::DmiPointingDevices_Type device_type() const;
  void set_device_type(::aspia::proto::DmiPointingDevices_Type value);

  // .aspia.proto.DmiPointingDevices.Interface device_interface = 2;
  void clear_device_interface();
  static const int kDeviceInterfaceFieldNumber = 2;
  ::aspia::proto::DmiPointingDevices_Interface device_interface() const;
  void set_device_interface(::aspia::proto::DmiPointingDevices_Interface value);

  // int32 button_count = 3;
  void clear_button_count();
  static const int kButtonCountFieldNumber = 3;
  ::google::protobuf::int32 button_count() const;
  void set_button_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPointingDevices.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int device_type_;
  int device_interface_;
  ::google::protobuf::int32 button_count_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPointingDevices_ItemImpl();
};
// -------------------------------------------------------------------

class DmiPointingDevices : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPointingDevices) */ {
 public:
  DmiPointingDevices();
  virtual ~DmiPointingDevices();

  DmiPointingDevices(const DmiPointingDevices& from);

  inline DmiPointingDevices& operator=(const DmiPointingDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPointingDevices(DmiPointingDevices&& from) noexcept
    : DmiPointingDevices() {
    *this = ::std::move(from);
  }

  inline DmiPointingDevices& operator=(DmiPointingDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPointingDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPointingDevices* internal_default_instance() {
    return reinterpret_cast<const DmiPointingDevices*>(
               &_DmiPointingDevices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(DmiPointingDevices* other);
  friend void swap(DmiPointingDevices& a, DmiPointingDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPointingDevices* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPointingDevices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPointingDevices& from);
  void MergeFrom(const DmiPointingDevices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPointingDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiPointingDevices_Item Item;

  typedef DmiPointingDevices_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiPointingDevices_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiPointingDevices_Type_TYPE_OTHER;
  static const Type TYPE_MOUSE =
    DmiPointingDevices_Type_TYPE_MOUSE;
  static const Type TYPE_TRACK_BALL =
    DmiPointingDevices_Type_TYPE_TRACK_BALL;
  static const Type TYPE_TRACK_POINT =
    DmiPointingDevices_Type_TYPE_TRACK_POINT;
  static const Type TYPE_GLIDE_POINT =
    DmiPointingDevices_Type_TYPE_GLIDE_POINT;
  static const Type TYPE_TOUCH_PAD =
    DmiPointingDevices_Type_TYPE_TOUCH_PAD;
  static const Type TYPE_TOUCH_SCREEN =
    DmiPointingDevices_Type_TYPE_TOUCH_SCREEN;
  static const Type TYPE_OPTICAL_SENSOR =
    DmiPointingDevices_Type_TYPE_OPTICAL_SENSOR;
  static inline bool Type_IsValid(int value) {
    return DmiPointingDevices_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiPointingDevices_Type_Type_MIN;
  static const Type Type_MAX =
    DmiPointingDevices_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiPointingDevices_Type_Type_ARRAYSIZE;

  typedef DmiPointingDevices_Interface Interface;
  static const Interface INTERFACE_UNKNOWN =
    DmiPointingDevices_Interface_INTERFACE_UNKNOWN;
  static const Interface INTERFACE_OTHER =
    DmiPointingDevices_Interface_INTERFACE_OTHER;
  static const Interface INTERFACE_SERIAL =
    DmiPointingDevices_Interface_INTERFACE_SERIAL;
  static const Interface INTERFACE_PS_2 =
    DmiPointingDevices_Interface_INTERFACE_PS_2;
  static const Interface INTERFACE_INFRARED =
    DmiPointingDevices_Interface_INTERFACE_INFRARED;
  static const Interface INTERFACE_HP_HIL =
    DmiPointingDevices_Interface_INTERFACE_HP_HIL;
  static const Interface INTERFACE_BUS_MOUSE =
    DmiPointingDevices_Interface_INTERFACE_BUS_MOUSE;
  static const Interface INTERFACE_ADB =
    DmiPointingDevices_Interface_INTERFACE_ADB;
  static const Interface INTERFACE_BUS_MOUSE_DB_9 =
    DmiPointingDevices_Interface_INTERFACE_BUS_MOUSE_DB_9;
  static const Interface INTERFACE_BUS_MOUSE_MICRO_DIN =
    DmiPointingDevices_Interface_INTERFACE_BUS_MOUSE_MICRO_DIN;
  static const Interface INTERFACE_USB =
    DmiPointingDevices_Interface_INTERFACE_USB;
  static inline bool Interface_IsValid(int value) {
    return DmiPointingDevices_Interface_IsValid(value);
  }
  static const Interface Interface_MIN =
    DmiPointingDevices_Interface_Interface_MIN;
  static const Interface Interface_MAX =
    DmiPointingDevices_Interface_Interface_MAX;
  static const int Interface_ARRAYSIZE =
    DmiPointingDevices_Interface_Interface_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiPointingDevices.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiPointingDevices_Item& item(int index) const;
  ::aspia::proto::DmiPointingDevices_Item* mutable_item(int index);
  ::aspia::proto::DmiPointingDevices_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevices_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevices_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPointingDevices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevices_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPointingDevicesImpl();
};
// -------------------------------------------------------------------

class DmiPortableBattery_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortableBattery.Item) */ {
 public:
  DmiPortableBattery_Item();
  virtual ~DmiPortableBattery_Item();

  DmiPortableBattery_Item(const DmiPortableBattery_Item& from);

  inline DmiPortableBattery_Item& operator=(const DmiPortableBattery_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortableBattery_Item(DmiPortableBattery_Item&& from) noexcept
    : DmiPortableBattery_Item() {
    *this = ::std::move(from);
  }

  inline DmiPortableBattery_Item& operator=(DmiPortableBattery_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortableBattery_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortableBattery_Item* internal_default_instance() {
    return reinterpret_cast<const DmiPortableBattery_Item*>(
               &_DmiPortableBattery_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(DmiPortableBattery_Item* other);
  friend void swap(DmiPortableBattery_Item& a, DmiPortableBattery_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortableBattery_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortableBattery_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortableBattery_Item& from);
  void MergeFrom(const DmiPortableBattery_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortableBattery_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string location = 1;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // string manufacturer = 2;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 2;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string manufacture_date = 3;
  void clear_manufacture_date();
  static const int kManufactureDateFieldNumber = 3;
  const ::std::string& manufacture_date() const;
  void set_manufacture_date(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacture_date(::std::string&& value);
  #endif
  void set_manufacture_date(const char* value);
  void set_manufacture_date(const char* value, size_t size);
  ::std::string* mutable_manufacture_date();
  ::std::string* release_manufacture_date();
  void set_allocated_manufacture_date(::std::string* manufacture_date);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string device_name = 5;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 5;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  #if LANG_CXX11
  void set_device_name(::std::string&& value);
  #endif
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // string sbds_version_number = 9;
  void clear_sbds_version_number();
  static const int kSbdsVersionNumberFieldNumber = 9;
  const ::std::string& sbds_version_number() const;
  void set_sbds_version_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_version_number(::std::string&& value);
  #endif
  void set_sbds_version_number(const char* value);
  void set_sbds_version_number(const char* value, size_t size);
  ::std::string* mutable_sbds_version_number();
  ::std::string* release_sbds_version_number();
  void set_allocated_sbds_version_number(::std::string* sbds_version_number);

  // string sbds_serial_number = 11;
  void clear_sbds_serial_number();
  static const int kSbdsSerialNumberFieldNumber = 11;
  const ::std::string& sbds_serial_number() const;
  void set_sbds_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_serial_number(::std::string&& value);
  #endif
  void set_sbds_serial_number(const char* value);
  void set_sbds_serial_number(const char* value, size_t size);
  ::std::string* mutable_sbds_serial_number();
  ::std::string* release_sbds_serial_number();
  void set_allocated_sbds_serial_number(::std::string* sbds_serial_number);

  // string sbds_manufacture_date = 12;
  void clear_sbds_manufacture_date();
  static const int kSbdsManufactureDateFieldNumber = 12;
  const ::std::string& sbds_manufacture_date() const;
  void set_sbds_manufacture_date(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_manufacture_date(::std::string&& value);
  #endif
  void set_sbds_manufacture_date(const char* value);
  void set_sbds_manufacture_date(const char* value, size_t size);
  ::std::string* mutable_sbds_manufacture_date();
  ::std::string* release_sbds_manufacture_date();
  void set_allocated_sbds_manufacture_date(::std::string* sbds_manufacture_date);

  // string sbds_device_chemistry = 13;
  void clear_sbds_device_chemistry();
  static const int kSbdsDeviceChemistryFieldNumber = 13;
  const ::std::string& sbds_device_chemistry() const;
  void set_sbds_device_chemistry(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_device_chemistry(::std::string&& value);
  #endif
  void set_sbds_device_chemistry(const char* value);
  void set_sbds_device_chemistry(const char* value, size_t size);
  ::std::string* mutable_sbds_device_chemistry();
  ::std::string* release_sbds_device_chemistry();
  void set_allocated_sbds_device_chemistry(::std::string* sbds_device_chemistry);

  // .aspia.proto.DmiPortableBattery.Chemistry chemistry = 6;
  void clear_chemistry();
  static const int kChemistryFieldNumber = 6;
  ::aspia::proto::DmiPortableBattery_Chemistry chemistry() const;
  void set_chemistry(::aspia::proto::DmiPortableBattery_Chemistry value);

  // int32 design_capacity = 7;
  void clear_design_capacity();
  static const int kDesignCapacityFieldNumber = 7;
  ::google::protobuf::int32 design_capacity() const;
  void set_design_capacity(::google::protobuf::int32 value);

  // int32 design_voltage = 8;
  void clear_design_voltage();
  static const int kDesignVoltageFieldNumber = 8;
  ::google::protobuf::int32 design_voltage() const;
  void set_design_voltage(::google::protobuf::int32 value);

  // int32 max_error_in_battery_data = 10;
  void clear_max_error_in_battery_data();
  static const int kMaxErrorInBatteryDataFieldNumber = 10;
  ::google::protobuf::int32 max_error_in_battery_data() const;
  void set_max_error_in_battery_data(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortableBattery.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr manufacture_date_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  ::google::protobuf::internal::ArenaStringPtr sbds_version_number_;
  ::google::protobuf::internal::ArenaStringPtr sbds_serial_number_;
  ::google::protobuf::internal::ArenaStringPtr sbds_manufacture_date_;
  ::google::protobuf::internal::ArenaStringPtr sbds_device_chemistry_;
  int chemistry_;
  ::google::protobuf::int32 design_capacity_;
  ::google::protobuf::int32 design_voltage_;
  ::google::protobuf::int32 max_error_in_battery_data_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortableBattery_ItemImpl();
};
// -------------------------------------------------------------------

class DmiPortableBattery : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortableBattery) */ {
 public:
  DmiPortableBattery();
  virtual ~DmiPortableBattery();

  DmiPortableBattery(const DmiPortableBattery& from);

  inline DmiPortableBattery& operator=(const DmiPortableBattery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortableBattery(DmiPortableBattery&& from) noexcept
    : DmiPortableBattery() {
    *this = ::std::move(from);
  }

  inline DmiPortableBattery& operator=(DmiPortableBattery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortableBattery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortableBattery* internal_default_instance() {
    return reinterpret_cast<const DmiPortableBattery*>(
               &_DmiPortableBattery_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(DmiPortableBattery* other);
  friend void swap(DmiPortableBattery& a, DmiPortableBattery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortableBattery* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortableBattery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortableBattery& from);
  void MergeFrom(const DmiPortableBattery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortableBattery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiPortableBattery_Item Item;

  typedef DmiPortableBattery_Chemistry Chemistry;
  static const Chemistry CHEMISTRY_UNKNOWN =
    DmiPortableBattery_Chemistry_CHEMISTRY_UNKNOWN;
  static const Chemistry CHEMISTRY_OTHER =
    DmiPortableBattery_Chemistry_CHEMISTRY_OTHER;
  static const Chemistry CHEMISTRY_LEAD_ACID =
    DmiPortableBattery_Chemistry_CHEMISTRY_LEAD_ACID;
  static const Chemistry CHEMISTRY_NICKEL_CADMIUM =
    DmiPortableBattery_Chemistry_CHEMISTRY_NICKEL_CADMIUM;
  static const Chemistry CHEMISTRY_NICKEL_METAL_HYDRIDE =
    DmiPortableBattery_Chemistry_CHEMISTRY_NICKEL_METAL_HYDRIDE;
  static const Chemistry CHEMISTRY_LITHIUM_ION =
    DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_ION;
  static const Chemistry CHEMISTRY_ZINC_AIR =
    DmiPortableBattery_Chemistry_CHEMISTRY_ZINC_AIR;
  static const Chemistry CHEMISTRY_LITHIUM_POLYMER =
    DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_POLYMER;
  static inline bool Chemistry_IsValid(int value) {
    return DmiPortableBattery_Chemistry_IsValid(value);
  }
  static const Chemistry Chemistry_MIN =
    DmiPortableBattery_Chemistry_Chemistry_MIN;
  static const Chemistry Chemistry_MAX =
    DmiPortableBattery_Chemistry_Chemistry_MAX;
  static const int Chemistry_ARRAYSIZE =
    DmiPortableBattery_Chemistry_Chemistry_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiPortableBattery.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiPortableBattery_Item& item(int index) const;
  ::aspia::proto::DmiPortableBattery_Item* mutable_item(int index);
  ::aspia::proto::DmiPortableBattery_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortableBattery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortableBatteryImpl();
};
// -------------------------------------------------------------------

class Programs_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Programs.Item) */ {
 public:
  Programs_Item();
  virtual ~Programs_Item();

  Programs_Item(const Programs_Item& from);

  inline Programs_Item& operator=(const Programs_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Programs_Item(Programs_Item&& from) noexcept
    : Programs_Item() {
    *this = ::std::move(from);
  }

  inline Programs_Item& operator=(Programs_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Programs_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Programs_Item* internal_default_instance() {
    return reinterpret_cast<const Programs_Item*>(
               &_Programs_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(Programs_Item* other);
  friend void swap(Programs_Item& a, Programs_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Programs_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Programs_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Programs_Item& from);
  void MergeFrom(const Programs_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Programs_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string publisher = 3;
  void clear_publisher();
  static const int kPublisherFieldNumber = 3;
  const ::std::string& publisher() const;
  void set_publisher(const ::std::string& value);
  #if LANG_CXX11
  void set_publisher(::std::string&& value);
  #endif
  void set_publisher(const char* value);
  void set_publisher(const char* value, size_t size);
  ::std::string* mutable_publisher();
  ::std::string* release_publisher();
  void set_allocated_publisher(::std::string* publisher);

  // string install_date = 4;
  void clear_install_date();
  static const int kInstallDateFieldNumber = 4;
  const ::std::string& install_date() const;
  void set_install_date(const ::std::string& value);
  #if LANG_CXX11
  void set_install_date(::std::string&& value);
  #endif
  void set_install_date(const char* value);
  void set_install_date(const char* value, size_t size);
  ::std::string* mutable_install_date();
  ::std::string* release_install_date();
  void set_allocated_install_date(::std::string* install_date);

  // string install_location = 5;
  void clear_install_location();
  static const int kInstallLocationFieldNumber = 5;
  const ::std::string& install_location() const;
  void set_install_location(const ::std::string& value);
  #if LANG_CXX11
  void set_install_location(::std::string&& value);
  #endif
  void set_install_location(const char* value);
  void set_install_location(const char* value, size_t size);
  ::std::string* mutable_install_location();
  ::std::string* release_install_location();
  void set_allocated_install_location(::std::string* install_location);

  // @@protoc_insertion_point(class_scope:aspia.proto.Programs.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr publisher_;
  ::google::protobuf::internal::ArenaStringPtr install_date_;
  ::google::protobuf::internal::ArenaStringPtr install_location_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsPrograms_ItemImpl();
};
// -------------------------------------------------------------------

class Programs : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Programs) */ {
 public:
  Programs();
  virtual ~Programs();

  Programs(const Programs& from);

  inline Programs& operator=(const Programs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Programs(Programs&& from) noexcept
    : Programs() {
    *this = ::std::move(from);
  }

  inline Programs& operator=(Programs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Programs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Programs* internal_default_instance() {
    return reinterpret_cast<const Programs*>(
               &_Programs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(Programs* other);
  friend void swap(Programs& a, Programs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Programs* New() const PROTOBUF_FINAL { return New(NULL); }

  Programs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Programs& from);
  void MergeFrom(const Programs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Programs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Programs_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Programs.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Programs_Item& item(int index) const;
  ::aspia::proto::Programs_Item* mutable_item(int index);
  ::aspia::proto::Programs_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Programs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsProgramsImpl();
};
// -------------------------------------------------------------------

class Services_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Services.Item) */ {
 public:
  Services_Item();
  virtual ~Services_Item();

  Services_Item(const Services_Item& from);

  inline Services_Item& operator=(const Services_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Services_Item(Services_Item&& from) noexcept
    : Services_Item() {
    *this = ::std::move(from);
  }

  inline Services_Item& operator=(Services_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Services_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Services_Item* internal_default_instance() {
    return reinterpret_cast<const Services_Item*>(
               &_Services_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(Services_Item* other);
  friend void swap(Services_Item& a, Services_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Services_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Services_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Services_Item& from);
  void MergeFrom(const Services_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Services_Item_Status Status;
  static const Status STATUS_UNKNOWN =
    Services_Item_Status_STATUS_UNKNOWN;
  static const Status STATUS_CONTINUE_PENDING =
    Services_Item_Status_STATUS_CONTINUE_PENDING;
  static const Status STATUS_PAUSE_PENDING =
    Services_Item_Status_STATUS_PAUSE_PENDING;
  static const Status STATUS_PAUSED =
    Services_Item_Status_STATUS_PAUSED;
  static const Status STATUS_RUNNING =
    Services_Item_Status_STATUS_RUNNING;
  static const Status STATUS_START_PENDING =
    Services_Item_Status_STATUS_START_PENDING;
  static const Status STATUS_STOP_PENDING =
    Services_Item_Status_STATUS_STOP_PENDING;
  static const Status STATUS_STOPPED =
    Services_Item_Status_STATUS_STOPPED;
  static inline bool Status_IsValid(int value) {
    return Services_Item_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Services_Item_Status_Status_MIN;
  static const Status Status_MAX =
    Services_Item_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Services_Item_Status_Status_ARRAYSIZE;

  typedef Services_Item_StartupType StartupType;
  static const StartupType STARTUP_TYPE_UNKNOWN =
    Services_Item_StartupType_STARTUP_TYPE_UNKNOWN;
  static const StartupType STARTUP_TYPE_AUTO_START =
    Services_Item_StartupType_STARTUP_TYPE_AUTO_START;
  static const StartupType STARTUP_TYPE_DEMAND_START =
    Services_Item_StartupType_STARTUP_TYPE_DEMAND_START;
  static const StartupType STARTUP_TYPE_DISABLED =
    Services_Item_StartupType_STARTUP_TYPE_DISABLED;
  static const StartupType STARTUP_TYPE_BOOT_START =
    Services_Item_StartupType_STARTUP_TYPE_BOOT_START;
  static const StartupType STARTUP_TYPE_SYSTEM_START =
    Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START;
  static inline bool StartupType_IsValid(int value) {
    return Services_Item_StartupType_IsValid(value);
  }
  static const StartupType StartupType_MIN =
    Services_Item_StartupType_StartupType_MIN;
  static const StartupType StartupType_MAX =
    Services_Item_StartupType_StartupType_MAX;
  static const int StartupType_ARRAYSIZE =
    Services_Item_StartupType_StartupType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string display_name = 2;
  void clear_display_name();
  static const int kDisplayNameFieldNumber = 2;
  const ::std::string& display_name() const;
  void set_display_name(const ::std::string& value);
  #if LANG_CXX11
  void set_display_name(::std::string&& value);
  #endif
  void set_display_name(const char* value);
  void set_display_name(const char* value, size_t size);
  ::std::string* mutable_display_name();
  ::std::string* release_display_name();
  void set_allocated_display_name(::std::string* display_name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string binary_path = 6;
  void clear_binary_path();
  static const int kBinaryPathFieldNumber = 6;
  const ::std::string& binary_path() const;
  void set_binary_path(const ::std::string& value);
  #if LANG_CXX11
  void set_binary_path(::std::string&& value);
  #endif
  void set_binary_path(const char* value);
  void set_binary_path(const char* value, size_t size);
  ::std::string* mutable_binary_path();
  ::std::string* release_binary_path();
  void set_allocated_binary_path(::std::string* binary_path);

  // string start_name = 7;
  void clear_start_name();
  static const int kStartNameFieldNumber = 7;
  const ::std::string& start_name() const;
  void set_start_name(const ::std::string& value);
  #if LANG_CXX11
  void set_start_name(::std::string&& value);
  #endif
  void set_start_name(const char* value);
  void set_start_name(const char* value, size_t size);
  ::std::string* mutable_start_name();
  ::std::string* release_start_name();
  void set_allocated_start_name(::std::string* start_name);

  // .aspia.proto.Services.Item.Status status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::aspia::proto::Services_Item_Status status() const;
  void set_status(::aspia::proto::Services_Item_Status value);

  // .aspia.proto.Services.Item.StartupType startup_type = 5;
  void clear_startup_type();
  static const int kStartupTypeFieldNumber = 5;
  ::aspia::proto::Services_Item_StartupType startup_type() const;
  void set_startup_type(::aspia::proto::Services_Item_StartupType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Services.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr display_name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr binary_path_;
  ::google::protobuf::internal::ArenaStringPtr start_name_;
  int status_;
  int startup_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsServices_ItemImpl();
};
// -------------------------------------------------------------------

class Services : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Services) */ {
 public:
  Services();
  virtual ~Services();

  Services(const Services& from);

  inline Services& operator=(const Services& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Services(Services&& from) noexcept
    : Services() {
    *this = ::std::move(from);
  }

  inline Services& operator=(Services&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Services& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Services* internal_default_instance() {
    return reinterpret_cast<const Services*>(
               &_Services_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(Services* other);
  friend void swap(Services& a, Services& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Services* New() const PROTOBUF_FINAL { return New(NULL); }

  Services* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Services& from);
  void MergeFrom(const Services& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Services_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Services.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Services_Item& item(int index) const;
  ::aspia::proto::Services_Item* mutable_item(int index);
  ::aspia::proto::Services_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Services)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsServicesImpl();
};
// -------------------------------------------------------------------

class NetworkCards_Item_IpAddress : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.NetworkCards.Item.IpAddress) */ {
 public:
  NetworkCards_Item_IpAddress();
  virtual ~NetworkCards_Item_IpAddress();

  NetworkCards_Item_IpAddress(const NetworkCards_Item_IpAddress& from);

  inline NetworkCards_Item_IpAddress& operator=(const NetworkCards_Item_IpAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards_Item_IpAddress(NetworkCards_Item_IpAddress&& from) noexcept
    : NetworkCards_Item_IpAddress() {
    *this = ::std::move(from);
  }

  inline NetworkCards_Item_IpAddress& operator=(NetworkCards_Item_IpAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards_Item_IpAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkCards_Item_IpAddress* internal_default_instance() {
    return reinterpret_cast<const NetworkCards_Item_IpAddress*>(
               &_NetworkCards_Item_IpAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(NetworkCards_Item_IpAddress* other);
  friend void swap(NetworkCards_Item_IpAddress& a, NetworkCards_Item_IpAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards_Item_IpAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards_Item_IpAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards_Item_IpAddress& from);
  void MergeFrom(const NetworkCards_Item_IpAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards_Item_IpAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // string mask = 2;
  void clear_mask();
  static const int kMaskFieldNumber = 2;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // @@protoc_insertion_point(class_scope:aspia.proto.NetworkCards.Item.IpAddress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsNetworkCards_Item_IpAddressImpl();
};
// -------------------------------------------------------------------

class NetworkCards_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.NetworkCards.Item) */ {
 public:
  NetworkCards_Item();
  virtual ~NetworkCards_Item();

  NetworkCards_Item(const NetworkCards_Item& from);

  inline NetworkCards_Item& operator=(const NetworkCards_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards_Item(NetworkCards_Item&& from) noexcept
    : NetworkCards_Item() {
    *this = ::std::move(from);
  }

  inline NetworkCards_Item& operator=(NetworkCards_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkCards_Item* internal_default_instance() {
    return reinterpret_cast<const NetworkCards_Item*>(
               &_NetworkCards_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(NetworkCards_Item* other);
  friend void swap(NetworkCards_Item& a, NetworkCards_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards_Item& from);
  void MergeFrom(const NetworkCards_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NetworkCards_Item_IpAddress IpAddress;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.NetworkCards.Item.IpAddress ip_address = 11;
  int ip_address_size() const;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 11;
  const ::aspia::proto::NetworkCards_Item_IpAddress& ip_address(int index) const;
  ::aspia::proto::NetworkCards_Item_IpAddress* mutable_ip_address(int index);
  ::aspia::proto::NetworkCards_Item_IpAddress* add_ip_address();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >*
      mutable_ip_address();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >&
      ip_address() const;

  // repeated string gateway_address = 12;
  int gateway_address_size() const;
  void clear_gateway_address();
  static const int kGatewayAddressFieldNumber = 12;
  const ::std::string& gateway_address(int index) const;
  ::std::string* mutable_gateway_address(int index);
  void set_gateway_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_gateway_address(int index, ::std::string&& value);
  #endif
  void set_gateway_address(int index, const char* value);
  void set_gateway_address(int index, const char* value, size_t size);
  ::std::string* add_gateway_address();
  void add_gateway_address(const ::std::string& value);
  #if LANG_CXX11
  void add_gateway_address(::std::string&& value);
  #endif
  void add_gateway_address(const char* value);
  void add_gateway_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& gateway_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_gateway_address();

  // repeated string dhcp_server_address = 13;
  int dhcp_server_address_size() const;
  void clear_dhcp_server_address();
  static const int kDhcpServerAddressFieldNumber = 13;
  const ::std::string& dhcp_server_address(int index) const;
  ::std::string* mutable_dhcp_server_address(int index);
  void set_dhcp_server_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dhcp_server_address(int index, ::std::string&& value);
  #endif
  void set_dhcp_server_address(int index, const char* value);
  void set_dhcp_server_address(int index, const char* value, size_t size);
  ::std::string* add_dhcp_server_address();
  void add_dhcp_server_address(const ::std::string& value);
  #if LANG_CXX11
  void add_dhcp_server_address(::std::string&& value);
  #endif
  void add_dhcp_server_address(const char* value);
  void add_dhcp_server_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dhcp_server_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dhcp_server_address();

  // repeated string dns_server_address = 14;
  int dns_server_address_size() const;
  void clear_dns_server_address();
  static const int kDnsServerAddressFieldNumber = 14;
  const ::std::string& dns_server_address(int index) const;
  ::std::string* mutable_dns_server_address(int index);
  void set_dns_server_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dns_server_address(int index, ::std::string&& value);
  #endif
  void set_dns_server_address(int index, const char* value);
  void set_dns_server_address(int index, const char* value, size_t size);
  ::std::string* add_dns_server_address();
  void add_dns_server_address(const ::std::string& value);
  #if LANG_CXX11
  void add_dns_server_address(::std::string&& value);
  #endif
  void add_dns_server_address(const char* value);
  void add_dns_server_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dns_server_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dns_server_address();

  // string adapter_name = 1;
  void clear_adapter_name();
  static const int kAdapterNameFieldNumber = 1;
  const ::std::string& adapter_name() const;
  void set_adapter_name(const ::std::string& value);
  #if LANG_CXX11
  void set_adapter_name(::std::string&& value);
  #endif
  void set_adapter_name(const char* value);
  void set_adapter_name(const char* value, size_t size);
  ::std::string* mutable_adapter_name();
  ::std::string* release_adapter_name();
  void set_allocated_adapter_name(::std::string* adapter_name);

  // string connection_name = 2;
  void clear_connection_name();
  static const int kConnectionNameFieldNumber = 2;
  const ::std::string& connection_name() const;
  void set_connection_name(const ::std::string& value);
  #if LANG_CXX11
  void set_connection_name(::std::string&& value);
  #endif
  void set_connection_name(const char* value);
  void set_connection_name(const char* value, size_t size);
  ::std::string* mutable_connection_name();
  ::std::string* release_connection_name();
  void set_allocated_connection_name(::std::string* connection_name);

  // string interface_type = 3;
  void clear_interface_type();
  static const int kInterfaceTypeFieldNumber = 3;
  const ::std::string& interface_type() const;
  void set_interface_type(const ::std::string& value);
  #if LANG_CXX11
  void set_interface_type(::std::string&& value);
  #endif
  void set_interface_type(const char* value);
  void set_interface_type(const char* value, size_t size);
  ::std::string* mutable_interface_type();
  ::std::string* release_interface_type();
  void set_allocated_interface_type(::std::string* interface_type);

  // string mac_address = 6;
  void clear_mac_address();
  static const int kMacAddressFieldNumber = 6;
  const ::std::string& mac_address() const;
  void set_mac_address(const ::std::string& value);
  #if LANG_CXX11
  void set_mac_address(::std::string&& value);
  #endif
  void set_mac_address(const char* value);
  void set_mac_address(const char* value, size_t size);
  ::std::string* mutable_mac_address();
  ::std::string* release_mac_address();
  void set_allocated_mac_address(::std::string* mac_address);

  // string primary_wins_server = 8;
  void clear_primary_wins_server();
  static const int kPrimaryWinsServerFieldNumber = 8;
  const ::std::string& primary_wins_server() const;
  void set_primary_wins_server(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_wins_server(::std::string&& value);
  #endif
  void set_primary_wins_server(const char* value);
  void set_primary_wins_server(const char* value, size_t size);
  ::std::string* mutable_primary_wins_server();
  ::std::string* release_primary_wins_server();
  void set_allocated_primary_wins_server(::std::string* primary_wins_server);

  // string secondary_wins_server = 9;
  void clear_secondary_wins_server();
  static const int kSecondaryWinsServerFieldNumber = 9;
  const ::std::string& secondary_wins_server() const;
  void set_secondary_wins_server(const ::std::string& value);
  #if LANG_CXX11
  void set_secondary_wins_server(::std::string&& value);
  #endif
  void set_secondary_wins_server(const char* value);
  void set_secondary_wins_server(const char* value, size_t size);
  ::std::string* mutable_secondary_wins_server();
  ::std::string* release_secondary_wins_server();
  void set_allocated_secondary_wins_server(::std::string* secondary_wins_server);

  // uint32 mtu = 4;
  void clear_mtu();
  static const int kMtuFieldNumber = 4;
  ::google::protobuf::uint32 mtu() const;
  void set_mtu(::google::protobuf::uint32 value);

  // uint32 speed = 5;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  ::google::protobuf::uint32 speed() const;
  void set_speed(::google::protobuf::uint32 value);

  // bool is_wins_enabled = 7;
  void clear_is_wins_enabled();
  static const int kIsWinsEnabledFieldNumber = 7;
  bool is_wins_enabled() const;
  void set_is_wins_enabled(bool value);

  // bool is_dhcp_enabled = 10;
  void clear_is_dhcp_enabled();
  static const int kIsDhcpEnabledFieldNumber = 10;
  bool is_dhcp_enabled() const;
  void set_is_dhcp_enabled(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.NetworkCards.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress > ip_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> gateway_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dhcp_server_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dns_server_address_;
  ::google::protobuf::internal::ArenaStringPtr adapter_name_;
  ::google::protobuf::internal::ArenaStringPtr connection_name_;
  ::google::protobuf::internal::ArenaStringPtr interface_type_;
  ::google::protobuf::internal::ArenaStringPtr mac_address_;
  ::google::protobuf::internal::ArenaStringPtr primary_wins_server_;
  ::google::protobuf::internal::ArenaStringPtr secondary_wins_server_;
  ::google::protobuf::uint32 mtu_;
  ::google::protobuf::uint32 speed_;
  bool is_wins_enabled_;
  bool is_dhcp_enabled_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsNetworkCards_ItemImpl();
};
// -------------------------------------------------------------------

class NetworkCards : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.NetworkCards) */ {
 public:
  NetworkCards();
  virtual ~NetworkCards();

  NetworkCards(const NetworkCards& from);

  inline NetworkCards& operator=(const NetworkCards& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards(NetworkCards&& from) noexcept
    : NetworkCards() {
    *this = ::std::move(from);
  }

  inline NetworkCards& operator=(NetworkCards&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkCards* internal_default_instance() {
    return reinterpret_cast<const NetworkCards*>(
               &_NetworkCards_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(NetworkCards* other);
  friend void swap(NetworkCards& a, NetworkCards& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards& from);
  void MergeFrom(const NetworkCards& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NetworkCards_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.NetworkCards.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::NetworkCards_Item& item(int index) const;
  ::aspia::proto::NetworkCards_Item* mutable_item(int index);
  ::aspia::proto::NetworkCards_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.NetworkCards)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsNetworkCardsImpl();
};
// -------------------------------------------------------------------

class OpenConnections_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.OpenConnections.Item) */ {
 public:
  OpenConnections_Item();
  virtual ~OpenConnections_Item();

  OpenConnections_Item(const OpenConnections_Item& from);

  inline OpenConnections_Item& operator=(const OpenConnections_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenConnections_Item(OpenConnections_Item&& from) noexcept
    : OpenConnections_Item() {
    *this = ::std::move(from);
  }

  inline OpenConnections_Item& operator=(OpenConnections_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OpenConnections_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenConnections_Item* internal_default_instance() {
    return reinterpret_cast<const OpenConnections_Item*>(
               &_OpenConnections_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(OpenConnections_Item* other);
  friend void swap(OpenConnections_Item& a, OpenConnections_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenConnections_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  OpenConnections_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpenConnections_Item& from);
  void MergeFrom(const OpenConnections_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenConnections_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string process_name = 1;
  void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  const ::std::string& process_name() const;
  void set_process_name(const ::std::string& value);
  #if LANG_CXX11
  void set_process_name(::std::string&& value);
  #endif
  void set_process_name(const char* value);
  void set_process_name(const char* value, size_t size);
  ::std::string* mutable_process_name();
  ::std::string* release_process_name();
  void set_allocated_process_name(::std::string* process_name);

  // string local_address = 3;
  void clear_local_address();
  static const int kLocalAddressFieldNumber = 3;
  const ::std::string& local_address() const;
  void set_local_address(const ::std::string& value);
  #if LANG_CXX11
  void set_local_address(::std::string&& value);
  #endif
  void set_local_address(const char* value);
  void set_local_address(const char* value, size_t size);
  ::std::string* mutable_local_address();
  ::std::string* release_local_address();
  void set_allocated_local_address(::std::string* local_address);

  // string remote_address = 4;
  void clear_remote_address();
  static const int kRemoteAddressFieldNumber = 4;
  const ::std::string& remote_address() const;
  void set_remote_address(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_address(::std::string&& value);
  #endif
  void set_remote_address(const char* value);
  void set_remote_address(const char* value, size_t size);
  ::std::string* mutable_remote_address();
  ::std::string* release_remote_address();
  void set_allocated_remote_address(::std::string* remote_address);

  // .aspia.proto.OpenConnections.Protocol protocol = 2;
  void clear_protocol();
  static const int kProtocolFieldNumber = 2;
  ::aspia::proto::OpenConnections_Protocol protocol() const;
  void set_protocol(::aspia::proto::OpenConnections_Protocol value);

  // uint32 local_port = 5;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 5;
  ::google::protobuf::uint32 local_port() const;
  void set_local_port(::google::protobuf::uint32 value);

  // uint32 remote_port = 6;
  void clear_remote_port();
  static const int kRemotePortFieldNumber = 6;
  ::google::protobuf::uint32 remote_port() const;
  void set_remote_port(::google::protobuf::uint32 value);

  // .aspia.proto.OpenConnections.State state = 7;
  void clear_state();
  static const int kStateFieldNumber = 7;
  ::aspia::proto::OpenConnections_State state() const;
  void set_state(::aspia::proto::OpenConnections_State value);

  // @@protoc_insertion_point(class_scope:aspia.proto.OpenConnections.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr process_name_;
  ::google::protobuf::internal::ArenaStringPtr local_address_;
  ::google::protobuf::internal::ArenaStringPtr remote_address_;
  int protocol_;
  ::google::protobuf::uint32 local_port_;
  ::google::protobuf::uint32 remote_port_;
  int state_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsOpenConnections_ItemImpl();
};
// -------------------------------------------------------------------

class OpenConnections : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.OpenConnections) */ {
 public:
  OpenConnections();
  virtual ~OpenConnections();

  OpenConnections(const OpenConnections& from);

  inline OpenConnections& operator=(const OpenConnections& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenConnections(OpenConnections&& from) noexcept
    : OpenConnections() {
    *this = ::std::move(from);
  }

  inline OpenConnections& operator=(OpenConnections&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OpenConnections& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenConnections* internal_default_instance() {
    return reinterpret_cast<const OpenConnections*>(
               &_OpenConnections_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(OpenConnections* other);
  friend void swap(OpenConnections& a, OpenConnections& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenConnections* New() const PROTOBUF_FINAL { return New(NULL); }

  OpenConnections* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpenConnections& from);
  void MergeFrom(const OpenConnections& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenConnections* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef OpenConnections_Item Item;

  typedef OpenConnections_Protocol Protocol;
  static const Protocol PROTOCOL_UNKNOWN =
    OpenConnections_Protocol_PROTOCOL_UNKNOWN;
  static const Protocol PROTOCOL_TCP =
    OpenConnections_Protocol_PROTOCOL_TCP;
  static const Protocol PROTOCOL_UDP =
    OpenConnections_Protocol_PROTOCOL_UDP;
  static inline bool Protocol_IsValid(int value) {
    return OpenConnections_Protocol_IsValid(value);
  }
  static const Protocol Protocol_MIN =
    OpenConnections_Protocol_Protocol_MIN;
  static const Protocol Protocol_MAX =
    OpenConnections_Protocol_Protocol_MAX;
  static const int Protocol_ARRAYSIZE =
    OpenConnections_Protocol_Protocol_ARRAYSIZE;

  typedef OpenConnections_State State;
  static const State STATE_UNKNOWN =
    OpenConnections_State_STATE_UNKNOWN;
  static const State STATE_CLOSED =
    OpenConnections_State_STATE_CLOSED;
  static const State STATE_LISTENING =
    OpenConnections_State_STATE_LISTENING;
  static const State STATE_SYN_SENT =
    OpenConnections_State_STATE_SYN_SENT;
  static const State STATE_SYN_RCVD =
    OpenConnections_State_STATE_SYN_RCVD;
  static const State STATE_ESTABLISHED =
    OpenConnections_State_STATE_ESTABLISHED;
  static const State STATE_FIN_WAIT1 =
    OpenConnections_State_STATE_FIN_WAIT1;
  static const State STATE_FIN_WAIT2 =
    OpenConnections_State_STATE_FIN_WAIT2;
  static const State STATE_CLOSE_WAIT =
    OpenConnections_State_STATE_CLOSE_WAIT;
  static const State STATE_CLOSING =
    OpenConnections_State_STATE_CLOSING;
  static const State STATE_LAST_ACK =
    OpenConnections_State_STATE_LAST_ACK;
  static const State STATE_TIME_WAIT =
    OpenConnections_State_STATE_TIME_WAIT;
  static const State STATE_DELETE_TCB =
    OpenConnections_State_STATE_DELETE_TCB;
  static inline bool State_IsValid(int value) {
    return OpenConnections_State_IsValid(value);
  }
  static const State State_MIN =
    OpenConnections_State_State_MIN;
  static const State State_MAX =
    OpenConnections_State_State_MAX;
  static const int State_ARRAYSIZE =
    OpenConnections_State_State_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.OpenConnections.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::OpenConnections_Item& item(int index) const;
  ::aspia::proto::OpenConnections_Item* mutable_item(int index);
  ::aspia::proto::OpenConnections_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.OpenConnections)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsOpenConnectionsImpl();
};
// -------------------------------------------------------------------

class SharedResources_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.SharedResources.Item) */ {
 public:
  SharedResources_Item();
  virtual ~SharedResources_Item();

  SharedResources_Item(const SharedResources_Item& from);

  inline SharedResources_Item& operator=(const SharedResources_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SharedResources_Item(SharedResources_Item&& from) noexcept
    : SharedResources_Item() {
    *this = ::std::move(from);
  }

  inline SharedResources_Item& operator=(SharedResources_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SharedResources_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SharedResources_Item* internal_default_instance() {
    return reinterpret_cast<const SharedResources_Item*>(
               &_SharedResources_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(SharedResources_Item* other);
  friend void swap(SharedResources_Item& a, SharedResources_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SharedResources_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  SharedResources_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SharedResources_Item& from);
  void MergeFrom(const SharedResources_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedResources_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SharedResources_Item_Type Type;
  static const Type TYPE_UNKNOWN =
    SharedResources_Item_Type_TYPE_UNKNOWN;
  static const Type TYPE_DISK =
    SharedResources_Item_Type_TYPE_DISK;
  static const Type TYPE_PRINTER =
    SharedResources_Item_Type_TYPE_PRINTER;
  static const Type TYPE_DEVICE =
    SharedResources_Item_Type_TYPE_DEVICE;
  static const Type TYPE_IPC =
    SharedResources_Item_Type_TYPE_IPC;
  static const Type TYPE_SPECIAL =
    SharedResources_Item_Type_TYPE_SPECIAL;
  static const Type TYPE_TEMPORARY =
    SharedResources_Item_Type_TYPE_TEMPORARY;
  static inline bool Type_IsValid(int value) {
    return SharedResources_Item_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SharedResources_Item_Type_Type_MIN;
  static const Type Type_MAX =
    SharedResources_Item_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SharedResources_Item_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string local_path = 4;
  void clear_local_path();
  static const int kLocalPathFieldNumber = 4;
  const ::std::string& local_path() const;
  void set_local_path(const ::std::string& value);
  #if LANG_CXX11
  void set_local_path(::std::string&& value);
  #endif
  void set_local_path(const char* value);
  void set_local_path(const char* value, size_t size);
  ::std::string* mutable_local_path();
  ::std::string* release_local_path();
  void set_allocated_local_path(::std::string* local_path);

  // .aspia.proto.SharedResources.Item.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::aspia::proto::SharedResources_Item_Type type() const;
  void set_type(::aspia::proto::SharedResources_Item_Type value);

  // uint32 current_uses = 5;
  void clear_current_uses();
  static const int kCurrentUsesFieldNumber = 5;
  ::google::protobuf::uint32 current_uses() const;
  void set_current_uses(::google::protobuf::uint32 value);

  // uint32 maximum_uses = 6;
  void clear_maximum_uses();
  static const int kMaximumUsesFieldNumber = 6;
  ::google::protobuf::uint32 maximum_uses() const;
  void set_maximum_uses(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.SharedResources.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr local_path_;
  int type_;
  ::google::protobuf::uint32 current_uses_;
  ::google::protobuf::uint32 maximum_uses_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSharedResources_ItemImpl();
};
// -------------------------------------------------------------------

class SharedResources : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.SharedResources) */ {
 public:
  SharedResources();
  virtual ~SharedResources();

  SharedResources(const SharedResources& from);

  inline SharedResources& operator=(const SharedResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SharedResources(SharedResources&& from) noexcept
    : SharedResources() {
    *this = ::std::move(from);
  }

  inline SharedResources& operator=(SharedResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SharedResources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SharedResources* internal_default_instance() {
    return reinterpret_cast<const SharedResources*>(
               &_SharedResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(SharedResources* other);
  friend void swap(SharedResources& a, SharedResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SharedResources* New() const PROTOBUF_FINAL { return New(NULL); }

  SharedResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SharedResources& from);
  void MergeFrom(const SharedResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SharedResources_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.SharedResources.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::SharedResources_Item& item(int index) const;
  ::aspia::proto::SharedResources_Item* mutable_item(int index);
  ::aspia::proto::SharedResources_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.SharedResources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSharedResourcesImpl();
};
// -------------------------------------------------------------------

class Routes_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Routes.Item) */ {
 public:
  Routes_Item();
  virtual ~Routes_Item();

  Routes_Item(const Routes_Item& from);

  inline Routes_Item& operator=(const Routes_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Routes_Item(Routes_Item&& from) noexcept
    : Routes_Item() {
    *this = ::std::move(from);
  }

  inline Routes_Item& operator=(Routes_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Routes_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Routes_Item* internal_default_instance() {
    return reinterpret_cast<const Routes_Item*>(
               &_Routes_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(Routes_Item* other);
  friend void swap(Routes_Item& a, Routes_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Routes_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Routes_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Routes_Item& from);
  void MergeFrom(const Routes_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Routes_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string destonation = 1;
  void clear_destonation();
  static const int kDestonationFieldNumber = 1;
  const ::std::string& destonation() const;
  void set_destonation(const ::std::string& value);
  #if LANG_CXX11
  void set_destonation(::std::string&& value);
  #endif
  void set_destonation(const char* value);
  void set_destonation(const char* value, size_t size);
  ::std::string* mutable_destonation();
  ::std::string* release_destonation();
  void set_allocated_destonation(::std::string* destonation);

  // string mask = 2;
  void clear_mask();
  static const int kMaskFieldNumber = 2;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // string gateway = 3;
  void clear_gateway();
  static const int kGatewayFieldNumber = 3;
  const ::std::string& gateway() const;
  void set_gateway(const ::std::string& value);
  #if LANG_CXX11
  void set_gateway(::std::string&& value);
  #endif
  void set_gateway(const char* value);
  void set_gateway(const char* value, size_t size);
  ::std::string* mutable_gateway();
  ::std::string* release_gateway();
  void set_allocated_gateway(::std::string* gateway);

  // uint32 metric = 4;
  void clear_metric();
  static const int kMetricFieldNumber = 4;
  ::google::protobuf::uint32 metric() const;
  void set_metric(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Routes.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr destonation_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  ::google::protobuf::internal::ArenaStringPtr gateway_;
  ::google::protobuf::uint32 metric_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsRoutes_ItemImpl();
};
// -------------------------------------------------------------------

class Routes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Routes) */ {
 public:
  Routes();
  virtual ~Routes();

  Routes(const Routes& from);

  inline Routes& operator=(const Routes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Routes(Routes&& from) noexcept
    : Routes() {
    *this = ::std::move(from);
  }

  inline Routes& operator=(Routes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Routes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Routes* internal_default_instance() {
    return reinterpret_cast<const Routes*>(
               &_Routes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(Routes* other);
  friend void swap(Routes& a, Routes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Routes* New() const PROTOBUF_FINAL { return New(NULL); }

  Routes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Routes& from);
  void MergeFrom(const Routes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Routes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Routes_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Routes.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Routes_Item& item(int index) const;
  ::aspia::proto::Routes_Item* mutable_item(int index);
  ::aspia::proto::Routes_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Routes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsRoutesImpl();
};
// -------------------------------------------------------------------

class Users_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Users.Item) */ {
 public:
  Users_Item();
  virtual ~Users_Item();

  Users_Item(const Users_Item& from);

  inline Users_Item& operator=(const Users_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Users_Item(Users_Item&& from) noexcept
    : Users_Item() {
    *this = ::std::move(from);
  }

  inline Users_Item& operator=(Users_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Users_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Users_Item* internal_default_instance() {
    return reinterpret_cast<const Users_Item*>(
               &_Users_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(Users_Item* other);
  friend void swap(Users_Item& a, Users_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Users_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Users_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Users_Item& from);
  void MergeFrom(const Users_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Users_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string full_name = 2;
  void clear_full_name();
  static const int kFullNameFieldNumber = 2;
  const ::std::string& full_name() const;
  void set_full_name(const ::std::string& value);
  #if LANG_CXX11
  void set_full_name(::std::string&& value);
  #endif
  void set_full_name(const char* value);
  void set_full_name(const char* value, size_t size);
  ::std::string* mutable_full_name();
  ::std::string* release_full_name();
  void set_allocated_full_name(::std::string* full_name);

  // string comment = 3;
  void clear_comment();
  static const int kCommentFieldNumber = 3;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // bool is_disabled = 4;
  void clear_is_disabled();
  static const int kIsDisabledFieldNumber = 4;
  bool is_disabled() const;
  void set_is_disabled(bool value);

  // bool is_password_cant_change = 5;
  void clear_is_password_cant_change();
  static const int kIsPasswordCantChangeFieldNumber = 5;
  bool is_password_cant_change() const;
  void set_is_password_cant_change(bool value);

  // bool is_password_expired = 6;
  void clear_is_password_expired();
  static const int kIsPasswordExpiredFieldNumber = 6;
  bool is_password_expired() const;
  void set_is_password_expired(bool value);

  // bool is_dont_expire_password = 7;
  void clear_is_dont_expire_password();
  static const int kIsDontExpirePasswordFieldNumber = 7;
  bool is_dont_expire_password() const;
  void set_is_dont_expire_password(bool value);

  // bool is_lockout = 8;
  void clear_is_lockout();
  static const int kIsLockoutFieldNumber = 8;
  bool is_lockout() const;
  void set_is_lockout(bool value);

  // uint32 number_logons = 9;
  void clear_number_logons();
  static const int kNumberLogonsFieldNumber = 9;
  ::google::protobuf::uint32 number_logons() const;
  void set_number_logons(::google::protobuf::uint32 value);

  // uint32 bad_password_count = 10;
  void clear_bad_password_count();
  static const int kBadPasswordCountFieldNumber = 10;
  ::google::protobuf::uint32 bad_password_count() const;
  void set_bad_password_count(::google::protobuf::uint32 value);

  // int64 last_logon_time = 11;
  void clear_last_logon_time();
  static const int kLastLogonTimeFieldNumber = 11;
  ::google::protobuf::int64 last_logon_time() const;
  void set_last_logon_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Users.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr full_name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  bool is_disabled_;
  bool is_password_cant_change_;
  bool is_password_expired_;
  bool is_dont_expire_password_;
  bool is_lockout_;
  ::google::protobuf::uint32 number_logons_;
  ::google::protobuf::uint32 bad_password_count_;
  ::google::protobuf::int64 last_logon_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUsers_ItemImpl();
};
// -------------------------------------------------------------------

class Users : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Users) */ {
 public:
  Users();
  virtual ~Users();

  Users(const Users& from);

  inline Users& operator=(const Users& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Users(Users&& from) noexcept
    : Users() {
    *this = ::std::move(from);
  }

  inline Users& operator=(Users&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Users& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Users* internal_default_instance() {
    return reinterpret_cast<const Users*>(
               &_Users_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(Users* other);
  friend void swap(Users& a, Users& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Users* New() const PROTOBUF_FINAL { return New(NULL); }

  Users* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Users& from);
  void MergeFrom(const Users& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Users* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Users_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Users.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Users_Item& item(int index) const;
  ::aspia::proto::Users_Item* mutable_item(int index);
  ::aspia::proto::Users_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Users)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUsersImpl();
};
// -------------------------------------------------------------------

class UserGroups_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.UserGroups.Item) */ {
 public:
  UserGroups_Item();
  virtual ~UserGroups_Item();

  UserGroups_Item(const UserGroups_Item& from);

  inline UserGroups_Item& operator=(const UserGroups_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserGroups_Item(UserGroups_Item&& from) noexcept
    : UserGroups_Item() {
    *this = ::std::move(from);
  }

  inline UserGroups_Item& operator=(UserGroups_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const UserGroups_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserGroups_Item* internal_default_instance() {
    return reinterpret_cast<const UserGroups_Item*>(
               &_UserGroups_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(UserGroups_Item* other);
  friend void swap(UserGroups_Item& a, UserGroups_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserGroups_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  UserGroups_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserGroups_Item& from);
  void MergeFrom(const UserGroups_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserGroups_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string comment = 2;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:aspia.proto.UserGroups.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUserGroups_ItemImpl();
};
// -------------------------------------------------------------------

class UserGroups : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.UserGroups) */ {
 public:
  UserGroups();
  virtual ~UserGroups();

  UserGroups(const UserGroups& from);

  inline UserGroups& operator=(const UserGroups& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserGroups(UserGroups&& from) noexcept
    : UserGroups() {
    *this = ::std::move(from);
  }

  inline UserGroups& operator=(UserGroups&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const UserGroups& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserGroups* internal_default_instance() {
    return reinterpret_cast<const UserGroups*>(
               &_UserGroups_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(UserGroups* other);
  friend void swap(UserGroups& a, UserGroups& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserGroups* New() const PROTOBUF_FINAL { return New(NULL); }

  UserGroups* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserGroups& from);
  void MergeFrom(const UserGroups& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserGroups* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef UserGroups_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.UserGroups.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::UserGroups_Item& item(int index) const;
  ::aspia::proto::UserGroups_Item* mutable_item(int index);
  ::aspia::proto::UserGroups_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.UserGroups)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUserGroupsImpl();
};
// -------------------------------------------------------------------

class Sessions_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Sessions.Item) */ {
 public:
  Sessions_Item();
  virtual ~Sessions_Item();

  Sessions_Item(const Sessions_Item& from);

  inline Sessions_Item& operator=(const Sessions_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sessions_Item(Sessions_Item&& from) noexcept
    : Sessions_Item() {
    *this = ::std::move(from);
  }

  inline Sessions_Item& operator=(Sessions_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Sessions_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sessions_Item* internal_default_instance() {
    return reinterpret_cast<const Sessions_Item*>(
               &_Sessions_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(Sessions_Item* other);
  friend void swap(Sessions_Item& a, Sessions_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sessions_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Sessions_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Sessions_Item& from);
  void MergeFrom(const Sessions_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sessions_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_name = 1;
  void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& user_name() const;
  void set_user_name(const ::std::string& value);
  #if LANG_CXX11
  void set_user_name(::std::string&& value);
  #endif
  void set_user_name(const char* value);
  void set_user_name(const char* value, size_t size);
  ::std::string* mutable_user_name();
  ::std::string* release_user_name();
  void set_allocated_user_name(::std::string* user_name);

  // string domain_name = 2;
  void clear_domain_name();
  static const int kDomainNameFieldNumber = 2;
  const ::std::string& domain_name() const;
  void set_domain_name(const ::std::string& value);
  #if LANG_CXX11
  void set_domain_name(::std::string&& value);
  #endif
  void set_domain_name(const char* value);
  void set_domain_name(const char* value, size_t size);
  ::std::string* mutable_domain_name();
  ::std::string* release_domain_name();
  void set_allocated_domain_name(::std::string* domain_name);

  // string client_name = 5;
  void clear_client_name();
  static const int kClientNameFieldNumber = 5;
  const ::std::string& client_name() const;
  void set_client_name(const ::std::string& value);
  #if LANG_CXX11
  void set_client_name(::std::string&& value);
  #endif
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  ::std::string* mutable_client_name();
  ::std::string* release_client_name();
  void set_allocated_client_name(::std::string* client_name);

  // string winstation_name = 6;
  void clear_winstation_name();
  static const int kWinstationNameFieldNumber = 6;
  const ::std::string& winstation_name() const;
  void set_winstation_name(const ::std::string& value);
  #if LANG_CXX11
  void set_winstation_name(::std::string&& value);
  #endif
  void set_winstation_name(const char* value);
  void set_winstation_name(const char* value, size_t size);
  ::std::string* mutable_winstation_name();
  ::std::string* release_winstation_name();
  void set_allocated_winstation_name(::std::string* winstation_name);

  // uint32 session_id = 3;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  ::google::protobuf::uint32 session_id() const;
  void set_session_id(::google::protobuf::uint32 value);

  // .aspia.proto.Sessions.ConnectState connect_state = 4;
  void clear_connect_state();
  static const int kConnectStateFieldNumber = 4;
  ::aspia::proto::Sessions_ConnectState connect_state() const;
  void set_connect_state(::aspia::proto::Sessions_ConnectState value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Sessions.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  ::google::protobuf::internal::ArenaStringPtr domain_name_;
  ::google::protobuf::internal::ArenaStringPtr client_name_;
  ::google::protobuf::internal::ArenaStringPtr winstation_name_;
  ::google::protobuf::uint32 session_id_;
  int connect_state_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSessions_ItemImpl();
};
// -------------------------------------------------------------------

class Sessions : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Sessions) */ {
 public:
  Sessions();
  virtual ~Sessions();

  Sessions(const Sessions& from);

  inline Sessions& operator=(const Sessions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sessions(Sessions&& from) noexcept
    : Sessions() {
    *this = ::std::move(from);
  }

  inline Sessions& operator=(Sessions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Sessions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sessions* internal_default_instance() {
    return reinterpret_cast<const Sessions*>(
               &_Sessions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(Sessions* other);
  friend void swap(Sessions& a, Sessions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sessions* New() const PROTOBUF_FINAL { return New(NULL); }

  Sessions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Sessions& from);
  void MergeFrom(const Sessions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sessions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Sessions_Item Item;

  typedef Sessions_ConnectState ConnectState;
  static const ConnectState CONNECT_STATE_UNKNOWN =
    Sessions_ConnectState_CONNECT_STATE_UNKNOWN;
  static const ConnectState CONNECT_STATE_ACTIVE =
    Sessions_ConnectState_CONNECT_STATE_ACTIVE;
  static const ConnectState CONNECT_STATE_CONNECTED =
    Sessions_ConnectState_CONNECT_STATE_CONNECTED;
  static const ConnectState CONNECT_STATE_CONNECT_QUERY =
    Sessions_ConnectState_CONNECT_STATE_CONNECT_QUERY;
  static const ConnectState CONNECT_STATE_SHADOW =
    Sessions_ConnectState_CONNECT_STATE_SHADOW;
  static const ConnectState CONNECT_STATE_DISCONNECTED =
    Sessions_ConnectState_CONNECT_STATE_DISCONNECTED;
  static const ConnectState CONNECT_STATE_IDLE =
    Sessions_ConnectState_CONNECT_STATE_IDLE;
  static const ConnectState CONNECT_STATE_LISTEN =
    Sessions_ConnectState_CONNECT_STATE_LISTEN;
  static const ConnectState CONNECT_STATE_RESET =
    Sessions_ConnectState_CONNECT_STATE_RESET;
  static const ConnectState CONNECT_STATE_DOWN =
    Sessions_ConnectState_CONNECT_STATE_DOWN;
  static const ConnectState CONNECT_STATE_INIT =
    Sessions_ConnectState_CONNECT_STATE_INIT;
  static inline bool ConnectState_IsValid(int value) {
    return Sessions_ConnectState_IsValid(value);
  }
  static const ConnectState ConnectState_MIN =
    Sessions_ConnectState_ConnectState_MIN;
  static const ConnectState ConnectState_MAX =
    Sessions_ConnectState_ConnectState_MAX;
  static const int ConnectState_ARRAYSIZE =
    Sessions_ConnectState_ConnectState_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Sessions.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Sessions_Item& item(int index) const;
  ::aspia::proto::Sessions_Item* mutable_item(int index);
  ::aspia::proto::Sessions_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Sessions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSessionsImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DmiBios_Characteristics

// bool has_isa = 1;
inline void DmiBios_Characteristics::clear_has_isa() {
  has_isa_ = false;
}
inline bool DmiBios_Characteristics::has_isa() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_isa)
  return has_isa_;
}
inline void DmiBios_Characteristics::set_has_isa(bool value) {
  
  has_isa_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_isa)
}

// bool has_mca = 2;
inline void DmiBios_Characteristics::clear_has_mca() {
  has_mca_ = false;
}
inline bool DmiBios_Characteristics::has_mca() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_mca)
  return has_mca_;
}
inline void DmiBios_Characteristics::set_has_mca(bool value) {
  
  has_mca_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_mca)
}

// bool has_eisa = 3;
inline void DmiBios_Characteristics::clear_has_eisa() {
  has_eisa_ = false;
}
inline bool DmiBios_Characteristics::has_eisa() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_eisa)
  return has_eisa_;
}
inline void DmiBios_Characteristics::set_has_eisa(bool value) {
  
  has_eisa_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_eisa)
}

// bool has_pci = 4;
inline void DmiBios_Characteristics::clear_has_pci() {
  has_pci_ = false;
}
inline bool DmiBios_Characteristics::has_pci() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_pci)
  return has_pci_;
}
inline void DmiBios_Characteristics::set_has_pci(bool value) {
  
  has_pci_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_pci)
}

// bool has_pc_card = 5;
inline void DmiBios_Characteristics::clear_has_pc_card() {
  has_pc_card_ = false;
}
inline bool DmiBios_Characteristics::has_pc_card() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_pc_card)
  return has_pc_card_;
}
inline void DmiBios_Characteristics::set_has_pc_card(bool value) {
  
  has_pc_card_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_pc_card)
}

// bool has_pnp = 6;
inline void DmiBios_Characteristics::clear_has_pnp() {
  has_pnp_ = false;
}
inline bool DmiBios_Characteristics::has_pnp() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_pnp)
  return has_pnp_;
}
inline void DmiBios_Characteristics::set_has_pnp(bool value) {
  
  has_pnp_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_pnp)
}

// bool has_apm = 7;
inline void DmiBios_Characteristics::clear_has_apm() {
  has_apm_ = false;
}
inline bool DmiBios_Characteristics::has_apm() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_apm)
  return has_apm_;
}
inline void DmiBios_Characteristics::set_has_apm(bool value) {
  
  has_apm_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_apm)
}

// bool has_bios_upgradeable = 8;
inline void DmiBios_Characteristics::clear_has_bios_upgradeable() {
  has_bios_upgradeable_ = false;
}
inline bool DmiBios_Characteristics::has_bios_upgradeable() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_bios_upgradeable)
  return has_bios_upgradeable_;
}
inline void DmiBios_Characteristics::set_has_bios_upgradeable(bool value) {
  
  has_bios_upgradeable_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_bios_upgradeable)
}

// bool has_bios_shadowing = 9;
inline void DmiBios_Characteristics::clear_has_bios_shadowing() {
  has_bios_shadowing_ = false;
}
inline bool DmiBios_Characteristics::has_bios_shadowing() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_bios_shadowing)
  return has_bios_shadowing_;
}
inline void DmiBios_Characteristics::set_has_bios_shadowing(bool value) {
  
  has_bios_shadowing_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_bios_shadowing)
}

// bool has_vlb = 10;
inline void DmiBios_Characteristics::clear_has_vlb() {
  has_vlb_ = false;
}
inline bool DmiBios_Characteristics::has_vlb() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_vlb)
  return has_vlb_;
}
inline void DmiBios_Characteristics::set_has_vlb(bool value) {
  
  has_vlb_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_vlb)
}

// bool has_escd = 11;
inline void DmiBios_Characteristics::clear_has_escd() {
  has_escd_ = false;
}
inline bool DmiBios_Characteristics::has_escd() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_escd)
  return has_escd_;
}
inline void DmiBios_Characteristics::set_has_escd(bool value) {
  
  has_escd_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_escd)
}

// bool has_boot_from_cd = 12;
inline void DmiBios_Characteristics::clear_has_boot_from_cd() {
  has_boot_from_cd_ = false;
}
inline bool DmiBios_Characteristics::has_boot_from_cd() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_boot_from_cd)
  return has_boot_from_cd_;
}
inline void DmiBios_Characteristics::set_has_boot_from_cd(bool value) {
  
  has_boot_from_cd_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_boot_from_cd)
}

// bool has_selectable_boot = 13;
inline void DmiBios_Characteristics::clear_has_selectable_boot() {
  has_selectable_boot_ = false;
}
inline bool DmiBios_Characteristics::has_selectable_boot() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_selectable_boot)
  return has_selectable_boot_;
}
inline void DmiBios_Characteristics::set_has_selectable_boot(bool value) {
  
  has_selectable_boot_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_selectable_boot)
}

// bool has_socketed_boot_rom = 14;
inline void DmiBios_Characteristics::clear_has_socketed_boot_rom() {
  has_socketed_boot_rom_ = false;
}
inline bool DmiBios_Characteristics::has_socketed_boot_rom() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_socketed_boot_rom)
  return has_socketed_boot_rom_;
}
inline void DmiBios_Characteristics::set_has_socketed_boot_rom(bool value) {
  
  has_socketed_boot_rom_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_socketed_boot_rom)
}

// bool has_boot_from_pc_card = 15;
inline void DmiBios_Characteristics::clear_has_boot_from_pc_card() {
  has_boot_from_pc_card_ = false;
}
inline bool DmiBios_Characteristics::has_boot_from_pc_card() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_boot_from_pc_card)
  return has_boot_from_pc_card_;
}
inline void DmiBios_Characteristics::set_has_boot_from_pc_card(bool value) {
  
  has_boot_from_pc_card_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_boot_from_pc_card)
}

// bool has_edd = 16;
inline void DmiBios_Characteristics::clear_has_edd() {
  has_edd_ = false;
}
inline bool DmiBios_Characteristics::has_edd() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_edd)
  return has_edd_;
}
inline void DmiBios_Characteristics::set_has_edd(bool value) {
  
  has_edd_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_edd)
}

// bool has_japanese_floppy_for_nec9800 = 17;
inline void DmiBios_Characteristics::clear_has_japanese_floppy_for_nec9800() {
  has_japanese_floppy_for_nec9800_ = false;
}
inline bool DmiBios_Characteristics::has_japanese_floppy_for_nec9800() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_japanese_floppy_for_nec9800)
  return has_japanese_floppy_for_nec9800_;
}
inline void DmiBios_Characteristics::set_has_japanese_floppy_for_nec9800(bool value) {
  
  has_japanese_floppy_for_nec9800_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_japanese_floppy_for_nec9800)
}

// bool has_japanece_floppy_for_toshiba = 18;
inline void DmiBios_Characteristics::clear_has_japanece_floppy_for_toshiba() {
  has_japanece_floppy_for_toshiba_ = false;
}
inline bool DmiBios_Characteristics::has_japanece_floppy_for_toshiba() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_japanece_floppy_for_toshiba)
  return has_japanece_floppy_for_toshiba_;
}
inline void DmiBios_Characteristics::set_has_japanece_floppy_for_toshiba(bool value) {
  
  has_japanece_floppy_for_toshiba_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_japanece_floppy_for_toshiba)
}

// bool has_525_360kb_floppy = 19;
inline void DmiBios_Characteristics::clear_has_525_360kb_floppy() {
  has_525_360kb_floppy_ = false;
}
inline bool DmiBios_Characteristics::has_525_360kb_floppy() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_525_360kb_floppy)
  return has_525_360kb_floppy_;
}
inline void DmiBios_Characteristics::set_has_525_360kb_floppy(bool value) {
  
  has_525_360kb_floppy_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_525_360kb_floppy)
}

// bool has_525_12mb_floppy = 20;
inline void DmiBios_Characteristics::clear_has_525_12mb_floppy() {
  has_525_12mb_floppy_ = false;
}
inline bool DmiBios_Characteristics::has_525_12mb_floppy() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_525_12mb_floppy)
  return has_525_12mb_floppy_;
}
inline void DmiBios_Characteristics::set_has_525_12mb_floppy(bool value) {
  
  has_525_12mb_floppy_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_525_12mb_floppy)
}

// bool has_35_720kb_floppy = 21;
inline void DmiBios_Characteristics::clear_has_35_720kb_floppy() {
  has_35_720kb_floppy_ = false;
}
inline bool DmiBios_Characteristics::has_35_720kb_floppy() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_35_720kb_floppy)
  return has_35_720kb_floppy_;
}
inline void DmiBios_Characteristics::set_has_35_720kb_floppy(bool value) {
  
  has_35_720kb_floppy_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_35_720kb_floppy)
}

// bool has_35_288mb_floppy = 22;
inline void DmiBios_Characteristics::clear_has_35_288mb_floppy() {
  has_35_288mb_floppy_ = false;
}
inline bool DmiBios_Characteristics::has_35_288mb_floppy() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_35_288mb_floppy)
  return has_35_288mb_floppy_;
}
inline void DmiBios_Characteristics::set_has_35_288mb_floppy(bool value) {
  
  has_35_288mb_floppy_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_35_288mb_floppy)
}

// bool has_print_screen = 23;
inline void DmiBios_Characteristics::clear_has_print_screen() {
  has_print_screen_ = false;
}
inline bool DmiBios_Characteristics::has_print_screen() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_print_screen)
  return has_print_screen_;
}
inline void DmiBios_Characteristics::set_has_print_screen(bool value) {
  
  has_print_screen_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_print_screen)
}

// bool has_8042_keyboard = 24;
inline void DmiBios_Characteristics::clear_has_8042_keyboard() {
  has_8042_keyboard_ = false;
}
inline bool DmiBios_Characteristics::has_8042_keyboard() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_8042_keyboard)
  return has_8042_keyboard_;
}
inline void DmiBios_Characteristics::set_has_8042_keyboard(bool value) {
  
  has_8042_keyboard_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_8042_keyboard)
}

// bool has_serial = 25;
inline void DmiBios_Characteristics::clear_has_serial() {
  has_serial_ = false;
}
inline bool DmiBios_Characteristics::has_serial() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_serial)
  return has_serial_;
}
inline void DmiBios_Characteristics::set_has_serial(bool value) {
  
  has_serial_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_serial)
}

// bool has_printer = 26;
inline void DmiBios_Characteristics::clear_has_printer() {
  has_printer_ = false;
}
inline bool DmiBios_Characteristics::has_printer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_printer)
  return has_printer_;
}
inline void DmiBios_Characteristics::set_has_printer(bool value) {
  
  has_printer_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_printer)
}

// bool has_cga_video = 27;
inline void DmiBios_Characteristics::clear_has_cga_video() {
  has_cga_video_ = false;
}
inline bool DmiBios_Characteristics::has_cga_video() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_cga_video)
  return has_cga_video_;
}
inline void DmiBios_Characteristics::set_has_cga_video(bool value) {
  
  has_cga_video_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_cga_video)
}

// bool has_nec_pc98 = 28;
inline void DmiBios_Characteristics::clear_has_nec_pc98() {
  has_nec_pc98_ = false;
}
inline bool DmiBios_Characteristics::has_nec_pc98() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_nec_pc98)
  return has_nec_pc98_;
}
inline void DmiBios_Characteristics::set_has_nec_pc98(bool value) {
  
  has_nec_pc98_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_nec_pc98)
}

// bool has_acpi = 29;
inline void DmiBios_Characteristics::clear_has_acpi() {
  has_acpi_ = false;
}
inline bool DmiBios_Characteristics::has_acpi() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_acpi)
  return has_acpi_;
}
inline void DmiBios_Characteristics::set_has_acpi(bool value) {
  
  has_acpi_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_acpi)
}

// bool has_usb_legacy = 30;
inline void DmiBios_Characteristics::clear_has_usb_legacy() {
  has_usb_legacy_ = false;
}
inline bool DmiBios_Characteristics::has_usb_legacy() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_usb_legacy)
  return has_usb_legacy_;
}
inline void DmiBios_Characteristics::set_has_usb_legacy(bool value) {
  
  has_usb_legacy_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_usb_legacy)
}

// bool has_agp = 31;
inline void DmiBios_Characteristics::clear_has_agp() {
  has_agp_ = false;
}
inline bool DmiBios_Characteristics::has_agp() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_agp)
  return has_agp_;
}
inline void DmiBios_Characteristics::set_has_agp(bool value) {
  
  has_agp_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_agp)
}

// bool has_i2o_boot = 32;
inline void DmiBios_Characteristics::clear_has_i2o_boot() {
  has_i2o_boot_ = false;
}
inline bool DmiBios_Characteristics::has_i2o_boot() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_i2o_boot)
  return has_i2o_boot_;
}
inline void DmiBios_Characteristics::set_has_i2o_boot(bool value) {
  
  has_i2o_boot_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_i2o_boot)
}

// bool has_ls120_boot = 33;
inline void DmiBios_Characteristics::clear_has_ls120_boot() {
  has_ls120_boot_ = false;
}
inline bool DmiBios_Characteristics::has_ls120_boot() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_ls120_boot)
  return has_ls120_boot_;
}
inline void DmiBios_Characteristics::set_has_ls120_boot(bool value) {
  
  has_ls120_boot_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_ls120_boot)
}

// bool has_atapi_zip_drive_boot = 34;
inline void DmiBios_Characteristics::clear_has_atapi_zip_drive_boot() {
  has_atapi_zip_drive_boot_ = false;
}
inline bool DmiBios_Characteristics::has_atapi_zip_drive_boot() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_atapi_zip_drive_boot)
  return has_atapi_zip_drive_boot_;
}
inline void DmiBios_Characteristics::set_has_atapi_zip_drive_boot(bool value) {
  
  has_atapi_zip_drive_boot_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_atapi_zip_drive_boot)
}

// bool has_ieee1394_boot = 35;
inline void DmiBios_Characteristics::clear_has_ieee1394_boot() {
  has_ieee1394_boot_ = false;
}
inline bool DmiBios_Characteristics::has_ieee1394_boot() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_ieee1394_boot)
  return has_ieee1394_boot_;
}
inline void DmiBios_Characteristics::set_has_ieee1394_boot(bool value) {
  
  has_ieee1394_boot_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_ieee1394_boot)
}

// bool has_smart_battery = 36;
inline void DmiBios_Characteristics::clear_has_smart_battery() {
  has_smart_battery_ = false;
}
inline bool DmiBios_Characteristics::has_smart_battery() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_smart_battery)
  return has_smart_battery_;
}
inline void DmiBios_Characteristics::set_has_smart_battery(bool value) {
  
  has_smart_battery_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_smart_battery)
}

// bool has_bios_boot_specification = 37;
inline void DmiBios_Characteristics::clear_has_bios_boot_specification() {
  has_bios_boot_specification_ = false;
}
inline bool DmiBios_Characteristics::has_bios_boot_specification() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_bios_boot_specification)
  return has_bios_boot_specification_;
}
inline void DmiBios_Characteristics::set_has_bios_boot_specification(bool value) {
  
  has_bios_boot_specification_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_bios_boot_specification)
}

// bool has_key_init_network_boot = 38;
inline void DmiBios_Characteristics::clear_has_key_init_network_boot() {
  has_key_init_network_boot_ = false;
}
inline bool DmiBios_Characteristics::has_key_init_network_boot() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_key_init_network_boot)
  return has_key_init_network_boot_;
}
inline void DmiBios_Characteristics::set_has_key_init_network_boot(bool value) {
  
  has_key_init_network_boot_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_key_init_network_boot)
}

// bool has_targeted_content_distrib = 39;
inline void DmiBios_Characteristics::clear_has_targeted_content_distrib() {
  has_targeted_content_distrib_ = false;
}
inline bool DmiBios_Characteristics::has_targeted_content_distrib() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_targeted_content_distrib)
  return has_targeted_content_distrib_;
}
inline void DmiBios_Characteristics::set_has_targeted_content_distrib(bool value) {
  
  has_targeted_content_distrib_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_targeted_content_distrib)
}

// bool has_uefi = 40;
inline void DmiBios_Characteristics::clear_has_uefi() {
  has_uefi_ = false;
}
inline bool DmiBios_Characteristics::has_uefi() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_uefi)
  return has_uefi_;
}
inline void DmiBios_Characteristics::set_has_uefi(bool value) {
  
  has_uefi_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_uefi)
}

// bool has_virtual_machine = 41;
inline void DmiBios_Characteristics::clear_has_virtual_machine() {
  has_virtual_machine_ = false;
}
inline bool DmiBios_Characteristics::has_virtual_machine() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Characteristics.has_virtual_machine)
  return has_virtual_machine_;
}
inline void DmiBios_Characteristics::set_has_virtual_machine(bool value) {
  
  has_virtual_machine_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Characteristics.has_virtual_machine)
}

// -------------------------------------------------------------------

// DmiBios

// string manufacturer = 1;
inline void DmiBios::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiBios::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.manufacturer)
}
#if LANG_CXX11
inline void DmiBios::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.manufacturer)
}
#endif
inline void DmiBios::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.manufacturer)
}
inline void DmiBios::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.manufacturer)
}
inline ::std::string* DmiBios::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.manufacturer)
}

// string version = 2;
inline void DmiBios::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.version)
  return version_.GetNoArena();
}
inline void DmiBios::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.version)
}
#if LANG_CXX11
inline void DmiBios::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.version)
}
#endif
inline void DmiBios::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.version)
}
inline void DmiBios::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.version)
}
inline ::std::string* DmiBios::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.version)
}

// string date = 3;
inline void DmiBios::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.date)
  return date_.GetNoArena();
}
inline void DmiBios::set_date(const ::std::string& value) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.date)
}
#if LANG_CXX11
inline void DmiBios::set_date(::std::string&& value) {
  
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.date)
}
#endif
inline void DmiBios::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.date)
}
inline void DmiBios::set_date(const char* value, size_t size) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.date)
}
inline ::std::string* DmiBios::mutable_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.date)
  
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    
  } else {
    
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.date)
}

// uint64 size = 4;
inline void DmiBios::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DmiBios::size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.size)
  return size_;
}
inline void DmiBios::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.size)
}

// string bios_revision = 5;
inline void DmiBios::clear_bios_revision() {
  bios_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::bios_revision() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.bios_revision)
  return bios_revision_.GetNoArena();
}
inline void DmiBios::set_bios_revision(const ::std::string& value) {
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.bios_revision)
}
#if LANG_CXX11
inline void DmiBios::set_bios_revision(::std::string&& value) {
  
  bios_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.bios_revision)
}
#endif
inline void DmiBios::set_bios_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.bios_revision)
}
inline void DmiBios::set_bios_revision(const char* value, size_t size) {
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.bios_revision)
}
inline ::std::string* DmiBios::mutable_bios_revision() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.bios_revision)
  return bios_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_bios_revision() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.bios_revision)
  
  return bios_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_bios_revision(::std::string* bios_revision) {
  if (bios_revision != NULL) {
    
  } else {
    
  }
  bios_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bios_revision);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.bios_revision)
}

// string firmware_revision = 6;
inline void DmiBios::clear_firmware_revision() {
  firmware_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::firmware_revision() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.firmware_revision)
  return firmware_revision_.GetNoArena();
}
inline void DmiBios::set_firmware_revision(const ::std::string& value) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.firmware_revision)
}
#if LANG_CXX11
inline void DmiBios::set_firmware_revision(::std::string&& value) {
  
  firmware_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.firmware_revision)
}
#endif
inline void DmiBios::set_firmware_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.firmware_revision)
}
inline void DmiBios::set_firmware_revision(const char* value, size_t size) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.firmware_revision)
}
inline ::std::string* DmiBios::mutable_firmware_revision() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.firmware_revision)
  return firmware_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_firmware_revision() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.firmware_revision)
  
  return firmware_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_firmware_revision(::std::string* firmware_revision) {
  if (firmware_revision != NULL) {
    
  } else {
    
  }
  firmware_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_revision);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.firmware_revision)
}

// string address = 7;
inline void DmiBios::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.address)
  return address_.GetNoArena();
}
inline void DmiBios::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.address)
}
#if LANG_CXX11
inline void DmiBios::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.address)
}
#endif
inline void DmiBios::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.address)
}
inline void DmiBios::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.address)
}
inline ::std::string* DmiBios::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.address)
}

// int32 runtime_size = 8;
inline void DmiBios::clear_runtime_size() {
  runtime_size_ = 0;
}
inline ::google::protobuf::int32 DmiBios::runtime_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.runtime_size)
  return runtime_size_;
}
inline void DmiBios::set_runtime_size(::google::protobuf::int32 value) {
  
  runtime_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.runtime_size)
}

// .aspia.proto.DmiBios.Characteristics characteristics = 9;
inline bool DmiBios::has_characteristics() const {
  return this != internal_default_instance() && characteristics_ != NULL;
}
inline void DmiBios::clear_characteristics() {
  if (GetArenaNoVirtual() == NULL && characteristics_ != NULL) {
    delete characteristics_;
  }
  characteristics_ = NULL;
}
inline const ::aspia::proto::DmiBios_Characteristics& DmiBios::characteristics() const {
  const ::aspia::proto::DmiBios_Characteristics* p = characteristics_;
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.characteristics)
  return p != NULL ? *p : *reinterpret_cast<const ::aspia::proto::DmiBios_Characteristics*>(
      &::aspia::proto::_DmiBios_Characteristics_default_instance_);
}
inline ::aspia::proto::DmiBios_Characteristics* DmiBios::release_characteristics() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.characteristics)
  
  ::aspia::proto::DmiBios_Characteristics* temp = characteristics_;
  characteristics_ = NULL;
  return temp;
}
inline ::aspia::proto::DmiBios_Characteristics* DmiBios::mutable_characteristics() {
  
  if (characteristics_ == NULL) {
    characteristics_ = new ::aspia::proto::DmiBios_Characteristics;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.characteristics)
  return characteristics_;
}
inline void DmiBios::set_allocated_characteristics(::aspia::proto::DmiBios_Characteristics* characteristics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete characteristics_;
  }
  if (characteristics) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      characteristics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, characteristics, submessage_arena);
    }
    
  } else {
    
  }
  characteristics_ = characteristics;
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.characteristics)
}

// -------------------------------------------------------------------

// DmiSystem

// string manufacturer = 1;
inline void DmiSystem::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiSystem::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.manufacturer)
}
#if LANG_CXX11
inline void DmiSystem::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.manufacturer)
}
#endif
inline void DmiSystem::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.manufacturer)
}
inline void DmiSystem::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.manufacturer)
}
inline ::std::string* DmiSystem::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.manufacturer)
}

// string product_name = 2;
inline void DmiSystem::clear_product_name() {
  product_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::product_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.product_name)
  return product_name_.GetNoArena();
}
inline void DmiSystem::set_product_name(const ::std::string& value) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.product_name)
}
#if LANG_CXX11
inline void DmiSystem::set_product_name(::std::string&& value) {
  
  product_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.product_name)
}
#endif
inline void DmiSystem::set_product_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.product_name)
}
inline void DmiSystem::set_product_name(const char* value, size_t size) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.product_name)
}
inline ::std::string* DmiSystem::mutable_product_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.product_name)
  return product_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_product_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.product_name)
  
  return product_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_product_name(::std::string* product_name) {
  if (product_name != NULL) {
    
  } else {
    
  }
  product_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.product_name)
}

// string version = 3;
inline void DmiSystem::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.version)
  return version_.GetNoArena();
}
inline void DmiSystem::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.version)
}
#if LANG_CXX11
inline void DmiSystem::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.version)
}
#endif
inline void DmiSystem::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.version)
}
inline void DmiSystem::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.version)
}
inline ::std::string* DmiSystem::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.version)
}

// string serial_number = 4;
inline void DmiSystem::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiSystem::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.serial_number)
}
#if LANG_CXX11
inline void DmiSystem::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.serial_number)
}
#endif
inline void DmiSystem::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.serial_number)
}
inline void DmiSystem::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.serial_number)
}
inline ::std::string* DmiSystem::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.serial_number)
}

// string uuid = 5;
inline void DmiSystem::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::uuid() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.uuid)
  return uuid_.GetNoArena();
}
inline void DmiSystem::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.uuid)
}
#if LANG_CXX11
inline void DmiSystem::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.uuid)
}
#endif
inline void DmiSystem::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.uuid)
}
inline void DmiSystem::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.uuid)
}
inline ::std::string* DmiSystem::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_uuid() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.uuid)
}

// .aspia.proto.DmiSystem.WakeupType wakeup_type = 6;
inline void DmiSystem::clear_wakeup_type() {
  wakeup_type_ = 0;
}
inline ::aspia::proto::DmiSystem_WakeupType DmiSystem::wakeup_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.wakeup_type)
  return static_cast< ::aspia::proto::DmiSystem_WakeupType >(wakeup_type_);
}
inline void DmiSystem::set_wakeup_type(::aspia::proto::DmiSystem_WakeupType value) {
  
  wakeup_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.wakeup_type)
}

// string sku_number = 7;
inline void DmiSystem::clear_sku_number() {
  sku_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::sku_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.sku_number)
  return sku_number_.GetNoArena();
}
inline void DmiSystem::set_sku_number(const ::std::string& value) {
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.sku_number)
}
#if LANG_CXX11
inline void DmiSystem::set_sku_number(::std::string&& value) {
  
  sku_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.sku_number)
}
#endif
inline void DmiSystem::set_sku_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.sku_number)
}
inline void DmiSystem::set_sku_number(const char* value, size_t size) {
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.sku_number)
}
inline ::std::string* DmiSystem::mutable_sku_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.sku_number)
  return sku_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_sku_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.sku_number)
  
  return sku_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_sku_number(::std::string* sku_number) {
  if (sku_number != NULL) {
    
  } else {
    
  }
  sku_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sku_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.sku_number)
}

// string family = 8;
inline void DmiSystem::clear_family() {
  family_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::family() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.family)
  return family_.GetNoArena();
}
inline void DmiSystem::set_family(const ::std::string& value) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.family)
}
#if LANG_CXX11
inline void DmiSystem::set_family(::std::string&& value) {
  
  family_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.family)
}
#endif
inline void DmiSystem::set_family(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.family)
}
inline void DmiSystem::set_family(const char* value, size_t size) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.family)
}
inline ::std::string* DmiSystem::mutable_family() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.family)
  return family_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_family() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.family)
  
  return family_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_family(::std::string* family) {
  if (family != NULL) {
    
  } else {
    
  }
  family_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.family)
}

// -------------------------------------------------------------------

// DmiBaseboard_Features

// bool is_hosting_board = 1;
inline void DmiBaseboard_Features::clear_is_hosting_board() {
  is_hosting_board_ = false;
}
inline bool DmiBaseboard_Features::is_hosting_board() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Features.is_hosting_board)
  return is_hosting_board_;
}
inline void DmiBaseboard_Features::set_is_hosting_board(bool value) {
  
  is_hosting_board_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Features.is_hosting_board)
}

// bool is_requires_at_least_one_daughter_board = 2;
inline void DmiBaseboard_Features::clear_is_requires_at_least_one_daughter_board() {
  is_requires_at_least_one_daughter_board_ = false;
}
inline bool DmiBaseboard_Features::is_requires_at_least_one_daughter_board() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Features.is_requires_at_least_one_daughter_board)
  return is_requires_at_least_one_daughter_board_;
}
inline void DmiBaseboard_Features::set_is_requires_at_least_one_daughter_board(bool value) {
  
  is_requires_at_least_one_daughter_board_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Features.is_requires_at_least_one_daughter_board)
}

// bool is_removable = 3;
inline void DmiBaseboard_Features::clear_is_removable() {
  is_removable_ = false;
}
inline bool DmiBaseboard_Features::is_removable() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Features.is_removable)
  return is_removable_;
}
inline void DmiBaseboard_Features::set_is_removable(bool value) {
  
  is_removable_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Features.is_removable)
}

// bool is_replaceable = 4;
inline void DmiBaseboard_Features::clear_is_replaceable() {
  is_replaceable_ = false;
}
inline bool DmiBaseboard_Features::is_replaceable() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Features.is_replaceable)
  return is_replaceable_;
}
inline void DmiBaseboard_Features::set_is_replaceable(bool value) {
  
  is_replaceable_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Features.is_replaceable)
}

// bool is_hot_swappable = 5;
inline void DmiBaseboard_Features::clear_is_hot_swappable() {
  is_hot_swappable_ = false;
}
inline bool DmiBaseboard_Features::is_hot_swappable() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Features.is_hot_swappable)
  return is_hot_swappable_;
}
inline void DmiBaseboard_Features::set_is_hot_swappable(bool value) {
  
  is_hot_swappable_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Features.is_hot_swappable)
}

// -------------------------------------------------------------------

// DmiBaseboard_Item

// string manufacturer = 1;
inline void DmiBaseboard_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiBaseboard_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.manufacturer)
}
#endif
inline void DmiBaseboard_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.manufacturer)
}
inline void DmiBaseboard_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.manufacturer)
}
inline ::std::string* DmiBaseboard_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.manufacturer)
}

// string product_name = 2;
inline void DmiBaseboard_Item::clear_product_name() {
  product_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::product_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.product_name)
  return product_name_.GetNoArena();
}
inline void DmiBaseboard_Item::set_product_name(const ::std::string& value) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.product_name)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_product_name(::std::string&& value) {
  
  product_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.product_name)
}
#endif
inline void DmiBaseboard_Item::set_product_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.product_name)
}
inline void DmiBaseboard_Item::set_product_name(const char* value, size_t size) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.product_name)
}
inline ::std::string* DmiBaseboard_Item::mutable_product_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.product_name)
  return product_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_product_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.product_name)
  
  return product_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_product_name(::std::string* product_name) {
  if (product_name != NULL) {
    
  } else {
    
  }
  product_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.product_name)
}

// string version = 3;
inline void DmiBaseboard_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.version)
  return version_.GetNoArena();
}
inline void DmiBaseboard_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.version)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.version)
}
#endif
inline void DmiBaseboard_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.version)
}
inline void DmiBaseboard_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.version)
}
inline ::std::string* DmiBaseboard_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.version)
}

// string serial_number = 4;
inline void DmiBaseboard_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiBaseboard_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.serial_number)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.serial_number)
}
#endif
inline void DmiBaseboard_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.serial_number)
}
inline void DmiBaseboard_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.serial_number)
}
inline ::std::string* DmiBaseboard_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.serial_number)
}

// string asset_tag = 5;
inline void DmiBaseboard_Item::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void DmiBaseboard_Item::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.asset_tag)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.asset_tag)
}
#endif
inline void DmiBaseboard_Item::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.asset_tag)
}
inline void DmiBaseboard_Item::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.asset_tag)
}
inline ::std::string* DmiBaseboard_Item::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.asset_tag)
}

// .aspia.proto.DmiBaseboard.Features features = 6;
inline bool DmiBaseboard_Item::has_features() const {
  return this != internal_default_instance() && features_ != NULL;
}
inline void DmiBaseboard_Item::clear_features() {
  if (GetArenaNoVirtual() == NULL && features_ != NULL) {
    delete features_;
  }
  features_ = NULL;
}
inline const ::aspia::proto::DmiBaseboard_Features& DmiBaseboard_Item::features() const {
  const ::aspia::proto::DmiBaseboard_Features* p = features_;
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.features)
  return p != NULL ? *p : *reinterpret_cast<const ::aspia::proto::DmiBaseboard_Features*>(
      &::aspia::proto::_DmiBaseboard_Features_default_instance_);
}
inline ::aspia::proto::DmiBaseboard_Features* DmiBaseboard_Item::release_features() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.features)
  
  ::aspia::proto::DmiBaseboard_Features* temp = features_;
  features_ = NULL;
  return temp;
}
inline ::aspia::proto::DmiBaseboard_Features* DmiBaseboard_Item::mutable_features() {
  
  if (features_ == NULL) {
    features_ = new ::aspia::proto::DmiBaseboard_Features;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.features)
  return features_;
}
inline void DmiBaseboard_Item::set_allocated_features(::aspia::proto::DmiBaseboard_Features* features) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete features_;
  }
  if (features) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      features = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, features, submessage_arena);
    }
    
  } else {
    
  }
  features_ = features;
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.features)
}

// string location_in_chassis = 7;
inline void DmiBaseboard_Item::clear_location_in_chassis() {
  location_in_chassis_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::location_in_chassis() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.location_in_chassis)
  return location_in_chassis_.GetNoArena();
}
inline void DmiBaseboard_Item::set_location_in_chassis(const ::std::string& value) {
  
  location_in_chassis_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_location_in_chassis(::std::string&& value) {
  
  location_in_chassis_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}
#endif
inline void DmiBaseboard_Item::set_location_in_chassis(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_in_chassis_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}
inline void DmiBaseboard_Item::set_location_in_chassis(const char* value, size_t size) {
  
  location_in_chassis_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}
inline ::std::string* DmiBaseboard_Item::mutable_location_in_chassis() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.location_in_chassis)
  return location_in_chassis_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_location_in_chassis() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.location_in_chassis)
  
  return location_in_chassis_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_location_in_chassis(::std::string* location_in_chassis) {
  if (location_in_chassis != NULL) {
    
  } else {
    
  }
  location_in_chassis_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location_in_chassis);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}

// .aspia.proto.DmiBaseboard.BoardType type = 8;
inline void DmiBaseboard_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiBaseboard_BoardType DmiBaseboard_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.type)
  return static_cast< ::aspia::proto::DmiBaseboard_BoardType >(type_);
}
inline void DmiBaseboard_Item::set_type(::aspia::proto::DmiBaseboard_BoardType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.type)
}

// -------------------------------------------------------------------

// DmiBaseboard

// repeated .aspia.proto.DmiBaseboard.Item item = 1;
inline int DmiBaseboard::item_size() const {
  return item_.size();
}
inline void DmiBaseboard::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiBaseboard_Item& DmiBaseboard::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiBaseboard_Item* DmiBaseboard::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiBaseboard_Item* DmiBaseboard::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiBaseboard.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item >*
DmiBaseboard::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiBaseboard.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item >&
DmiBaseboard::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiBaseboard.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiChassis_Item

// string manufacturer = 1;
inline void DmiChassis_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiChassis_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.manufacturer)
}
#endif
inline void DmiChassis_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.manufacturer)
}
inline void DmiChassis_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.manufacturer)
}
inline ::std::string* DmiChassis_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.manufacturer)
}

// string version = 2;
inline void DmiChassis_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.version)
  return version_.GetNoArena();
}
inline void DmiChassis_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.version)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.version)
}
#endif
inline void DmiChassis_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.version)
}
inline void DmiChassis_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.version)
}
inline ::std::string* DmiChassis_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.version)
}

// string serial_number = 3;
inline void DmiChassis_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiChassis_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.serial_number)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.serial_number)
}
#endif
inline void DmiChassis_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.serial_number)
}
inline void DmiChassis_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.serial_number)
}
inline ::std::string* DmiChassis_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.serial_number)
}

// string asset_tag = 4;
inline void DmiChassis_Item::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void DmiChassis_Item::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.asset_tag)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.asset_tag)
}
#endif
inline void DmiChassis_Item::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.asset_tag)
}
inline void DmiChassis_Item::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.asset_tag)
}
inline ::std::string* DmiChassis_Item::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.asset_tag)
}

// .aspia.proto.DmiChassis.Type type = 5;
inline void DmiChassis_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiChassis_Type DmiChassis_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.type)
  return static_cast< ::aspia::proto::DmiChassis_Type >(type_);
}
inline void DmiChassis_Item::set_type(::aspia::proto::DmiChassis_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.type)
}

// .aspia.proto.DmiChassis.Status os_load_status = 6;
inline void DmiChassis_Item::clear_os_load_status() {
  os_load_status_ = 0;
}
inline ::aspia::proto::DmiChassis_Status DmiChassis_Item::os_load_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.os_load_status)
  return static_cast< ::aspia::proto::DmiChassis_Status >(os_load_status_);
}
inline void DmiChassis_Item::set_os_load_status(::aspia::proto::DmiChassis_Status value) {
  
  os_load_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.os_load_status)
}

// .aspia.proto.DmiChassis.Status power_source_status = 7;
inline void DmiChassis_Item::clear_power_source_status() {
  power_source_status_ = 0;
}
inline ::aspia::proto::DmiChassis_Status DmiChassis_Item::power_source_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.power_source_status)
  return static_cast< ::aspia::proto::DmiChassis_Status >(power_source_status_);
}
inline void DmiChassis_Item::set_power_source_status(::aspia::proto::DmiChassis_Status value) {
  
  power_source_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.power_source_status)
}

// .aspia.proto.DmiChassis.Status temparature_status = 8;
inline void DmiChassis_Item::clear_temparature_status() {
  temparature_status_ = 0;
}
inline ::aspia::proto::DmiChassis_Status DmiChassis_Item::temparature_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.temparature_status)
  return static_cast< ::aspia::proto::DmiChassis_Status >(temparature_status_);
}
inline void DmiChassis_Item::set_temparature_status(::aspia::proto::DmiChassis_Status value) {
  
  temparature_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.temparature_status)
}

// .aspia.proto.DmiChassis.SecurityStatus security_status = 9;
inline void DmiChassis_Item::clear_security_status() {
  security_status_ = 0;
}
inline ::aspia::proto::DmiChassis_SecurityStatus DmiChassis_Item::security_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.security_status)
  return static_cast< ::aspia::proto::DmiChassis_SecurityStatus >(security_status_);
}
inline void DmiChassis_Item::set_security_status(::aspia::proto::DmiChassis_SecurityStatus value) {
  
  security_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.security_status)
}

// int32 height = 10;
inline void DmiChassis_Item::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 DmiChassis_Item::height() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.height)
  return height_;
}
inline void DmiChassis_Item::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.height)
}

// int32 number_of_power_cords = 11;
inline void DmiChassis_Item::clear_number_of_power_cords() {
  number_of_power_cords_ = 0;
}
inline ::google::protobuf::int32 DmiChassis_Item::number_of_power_cords() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.number_of_power_cords)
  return number_of_power_cords_;
}
inline void DmiChassis_Item::set_number_of_power_cords(::google::protobuf::int32 value) {
  
  number_of_power_cords_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.number_of_power_cords)
}

// -------------------------------------------------------------------

// DmiChassis

// repeated .aspia.proto.DmiChassis.Item item = 1;
inline int DmiChassis::item_size() const {
  return item_.size();
}
inline void DmiChassis::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiChassis_Item& DmiChassis::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiChassis_Item* DmiChassis::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiChassis_Item* DmiChassis::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiChassis.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item >*
DmiChassis::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiChassis.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item >&
DmiChassis::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiChassis.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiCaches_Item

// string name = 1;
inline void DmiCaches_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiCaches_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.name)
  return name_.GetNoArena();
}
inline void DmiCaches_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.name)
}
#if LANG_CXX11
inline void DmiCaches_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiCaches.Item.name)
}
#endif
inline void DmiCaches_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiCaches.Item.name)
}
inline void DmiCaches_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiCaches.Item.name)
}
inline ::std::string* DmiCaches_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiCaches_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiCaches.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiCaches_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiCaches.Item.name)
}

// .aspia.proto.DmiCaches.Location location = 2;
inline void DmiCaches_Item::clear_location() {
  location_ = 0;
}
inline ::aspia::proto::DmiCaches_Location DmiCaches_Item::location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.location)
  return static_cast< ::aspia::proto::DmiCaches_Location >(location_);
}
inline void DmiCaches_Item::set_location(::aspia::proto::DmiCaches_Location value) {
  
  location_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.location)
}

// .aspia.proto.DmiCaches.Status status = 3;
inline void DmiCaches_Item::clear_status() {
  status_ = 0;
}
inline ::aspia::proto::DmiCaches_Status DmiCaches_Item::status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.status)
  return static_cast< ::aspia::proto::DmiCaches_Status >(status_);
}
inline void DmiCaches_Item::set_status(::aspia::proto::DmiCaches_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.status)
}

// .aspia.proto.DmiCaches.Mode mode = 4;
inline void DmiCaches_Item::clear_mode() {
  mode_ = 0;
}
inline ::aspia::proto::DmiCaches_Mode DmiCaches_Item::mode() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.mode)
  return static_cast< ::aspia::proto::DmiCaches_Mode >(mode_);
}
inline void DmiCaches_Item::set_mode(::aspia::proto::DmiCaches_Mode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.mode)
}

// int32 level = 5;
inline void DmiCaches_Item::clear_level() {
  level_ = 0;
}
inline ::google::protobuf::int32 DmiCaches_Item::level() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.level)
  return level_;
}
inline void DmiCaches_Item::set_level(::google::protobuf::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.level)
}

// int32 maximum_size = 6;
inline void DmiCaches_Item::clear_maximum_size() {
  maximum_size_ = 0;
}
inline ::google::protobuf::int32 DmiCaches_Item::maximum_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.maximum_size)
  return maximum_size_;
}
inline void DmiCaches_Item::set_maximum_size(::google::protobuf::int32 value) {
  
  maximum_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.maximum_size)
}

// int32 current_size = 7;
inline void DmiCaches_Item::clear_current_size() {
  current_size_ = 0;
}
inline ::google::protobuf::int32 DmiCaches_Item::current_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.current_size)
  return current_size_;
}
inline void DmiCaches_Item::set_current_size(::google::protobuf::int32 value) {
  
  current_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.current_size)
}

// uint32 supported_sram_types = 8;
inline void DmiCaches_Item::clear_supported_sram_types() {
  supported_sram_types_ = 0u;
}
inline ::google::protobuf::uint32 DmiCaches_Item::supported_sram_types() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.supported_sram_types)
  return supported_sram_types_;
}
inline void DmiCaches_Item::set_supported_sram_types(::google::protobuf::uint32 value) {
  
  supported_sram_types_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.supported_sram_types)
}

// .aspia.proto.DmiCaches.SRAMType current_sram_type = 9;
inline void DmiCaches_Item::clear_current_sram_type() {
  current_sram_type_ = 0;
}
inline ::aspia::proto::DmiCaches_SRAMType DmiCaches_Item::current_sram_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.current_sram_type)
  return static_cast< ::aspia::proto::DmiCaches_SRAMType >(current_sram_type_);
}
inline void DmiCaches_Item::set_current_sram_type(::aspia::proto::DmiCaches_SRAMType value) {
  
  current_sram_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.current_sram_type)
}

// int32 speed = 10;
inline void DmiCaches_Item::clear_speed() {
  speed_ = 0;
}
inline ::google::protobuf::int32 DmiCaches_Item::speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.speed)
  return speed_;
}
inline void DmiCaches_Item::set_speed(::google::protobuf::int32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.speed)
}

// .aspia.proto.DmiCaches.ErrorCorrectionType error_correction_type = 11;
inline void DmiCaches_Item::clear_error_correction_type() {
  error_correction_type_ = 0;
}
inline ::aspia::proto::DmiCaches_ErrorCorrectionType DmiCaches_Item::error_correction_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.error_correction_type)
  return static_cast< ::aspia::proto::DmiCaches_ErrorCorrectionType >(error_correction_type_);
}
inline void DmiCaches_Item::set_error_correction_type(::aspia::proto::DmiCaches_ErrorCorrectionType value) {
  
  error_correction_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.error_correction_type)
}

// .aspia.proto.DmiCaches.Type type = 12;
inline void DmiCaches_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiCaches_Type DmiCaches_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.type)
  return static_cast< ::aspia::proto::DmiCaches_Type >(type_);
}
inline void DmiCaches_Item::set_type(::aspia::proto::DmiCaches_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.type)
}

// .aspia.proto.DmiCaches.Associativity associativity = 13;
inline void DmiCaches_Item::clear_associativity() {
  associativity_ = 0;
}
inline ::aspia::proto::DmiCaches_Associativity DmiCaches_Item::associativity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.associativity)
  return static_cast< ::aspia::proto::DmiCaches_Associativity >(associativity_);
}
inline void DmiCaches_Item::set_associativity(::aspia::proto::DmiCaches_Associativity value) {
  
  associativity_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.associativity)
}

// -------------------------------------------------------------------

// DmiCaches

// repeated .aspia.proto.DmiCaches.Item item = 1;
inline int DmiCaches::item_size() const {
  return item_.size();
}
inline void DmiCaches::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiCaches_Item& DmiCaches::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiCaches_Item* DmiCaches::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiCaches_Item* DmiCaches::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiCaches.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item >*
DmiCaches::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiCaches.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item >&
DmiCaches::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiCaches.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiProcessors_Item

// string manufacturer = 1;
inline void DmiProcessors_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiProcessors_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.manufacturer)
}
#endif
inline void DmiProcessors_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.manufacturer)
}
inline void DmiProcessors_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.manufacturer)
}
inline ::std::string* DmiProcessors_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.manufacturer)
}

// string version = 2;
inline void DmiProcessors_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.version)
  return version_.GetNoArena();
}
inline void DmiProcessors_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.version)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.version)
}
#endif
inline void DmiProcessors_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.version)
}
inline void DmiProcessors_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.version)
}
inline ::std::string* DmiProcessors_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.version)
}

// .aspia.proto.DmiProcessors.Family family = 3;
inline void DmiProcessors_Item::clear_family() {
  family_ = 0;
}
inline ::aspia::proto::DmiProcessors_Family DmiProcessors_Item::family() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.family)
  return static_cast< ::aspia::proto::DmiProcessors_Family >(family_);
}
inline void DmiProcessors_Item::set_family(::aspia::proto::DmiProcessors_Family value) {
  
  family_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.family)
}

// .aspia.proto.DmiProcessors.Type type = 4;
inline void DmiProcessors_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiProcessors_Type DmiProcessors_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.type)
  return static_cast< ::aspia::proto::DmiProcessors_Type >(type_);
}
inline void DmiProcessors_Item::set_type(::aspia::proto::DmiProcessors_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.type)
}

// .aspia.proto.DmiProcessors.Status status = 5;
inline void DmiProcessors_Item::clear_status() {
  status_ = 0;
}
inline ::aspia::proto::DmiProcessors_Status DmiProcessors_Item::status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.status)
  return static_cast< ::aspia::proto::DmiProcessors_Status >(status_);
}
inline void DmiProcessors_Item::set_status(::aspia::proto::DmiProcessors_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.status)
}

// string socket = 6;
inline void DmiProcessors_Item::clear_socket() {
  socket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::socket() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.socket)
  return socket_.GetNoArena();
}
inline void DmiProcessors_Item::set_socket(const ::std::string& value) {
  
  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.socket)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_socket(::std::string&& value) {
  
  socket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.socket)
}
#endif
inline void DmiProcessors_Item::set_socket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.socket)
}
inline void DmiProcessors_Item::set_socket(const char* value, size_t size) {
  
  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.socket)
}
inline ::std::string* DmiProcessors_Item::mutable_socket() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.socket)
  return socket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_socket() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.socket)
  
  return socket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_socket(::std::string* socket) {
  if (socket != NULL) {
    
  } else {
    
  }
  socket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), socket);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.socket)
}

// .aspia.proto.DmiProcessors.Upgrade upgrade = 7;
inline void DmiProcessors_Item::clear_upgrade() {
  upgrade_ = 0;
}
inline ::aspia::proto::DmiProcessors_Upgrade DmiProcessors_Item::upgrade() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.upgrade)
  return static_cast< ::aspia::proto::DmiProcessors_Upgrade >(upgrade_);
}
inline void DmiProcessors_Item::set_upgrade(::aspia::proto::DmiProcessors_Upgrade value) {
  
  upgrade_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.upgrade)
}

// int32 external_clock = 8;
inline void DmiProcessors_Item::clear_external_clock() {
  external_clock_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::external_clock() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.external_clock)
  return external_clock_;
}
inline void DmiProcessors_Item::set_external_clock(::google::protobuf::int32 value) {
  
  external_clock_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.external_clock)
}

// int32 current_speed = 9;
inline void DmiProcessors_Item::clear_current_speed() {
  current_speed_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::current_speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.current_speed)
  return current_speed_;
}
inline void DmiProcessors_Item::set_current_speed(::google::protobuf::int32 value) {
  
  current_speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.current_speed)
}

// int32 maximum_speed = 10;
inline void DmiProcessors_Item::clear_maximum_speed() {
  maximum_speed_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::maximum_speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.maximum_speed)
  return maximum_speed_;
}
inline void DmiProcessors_Item::set_maximum_speed(::google::protobuf::int32 value) {
  
  maximum_speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.maximum_speed)
}

// double voltage = 11;
inline void DmiProcessors_Item::clear_voltage() {
  voltage_ = 0;
}
inline double DmiProcessors_Item::voltage() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.voltage)
  return voltage_;
}
inline void DmiProcessors_Item::set_voltage(double value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.voltage)
}

// string serial_number = 12;
inline void DmiProcessors_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiProcessors_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.serial_number)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.serial_number)
}
#endif
inline void DmiProcessors_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.serial_number)
}
inline void DmiProcessors_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.serial_number)
}
inline ::std::string* DmiProcessors_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.serial_number)
}

// string asset_tag = 13;
inline void DmiProcessors_Item::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void DmiProcessors_Item::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.asset_tag)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.asset_tag)
}
#endif
inline void DmiProcessors_Item::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.asset_tag)
}
inline void DmiProcessors_Item::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.asset_tag)
}
inline ::std::string* DmiProcessors_Item::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.asset_tag)
}

// string part_number = 14;
inline void DmiProcessors_Item::clear_part_number() {
  part_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::part_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.part_number)
  return part_number_.GetNoArena();
}
inline void DmiProcessors_Item::set_part_number(const ::std::string& value) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.part_number)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_part_number(::std::string&& value) {
  
  part_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.part_number)
}
#endif
inline void DmiProcessors_Item::set_part_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.part_number)
}
inline void DmiProcessors_Item::set_part_number(const char* value, size_t size) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.part_number)
}
inline ::std::string* DmiProcessors_Item::mutable_part_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.part_number)
  return part_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_part_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.part_number)
  
  return part_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_part_number(::std::string* part_number) {
  if (part_number != NULL) {
    
  } else {
    
  }
  part_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), part_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.part_number)
}

// int32 core_count = 15;
inline void DmiProcessors_Item::clear_core_count() {
  core_count_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::core_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.core_count)
  return core_count_;
}
inline void DmiProcessors_Item::set_core_count(::google::protobuf::int32 value) {
  
  core_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.core_count)
}

// int32 core_enabled = 16;
inline void DmiProcessors_Item::clear_core_enabled() {
  core_enabled_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::core_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.core_enabled)
  return core_enabled_;
}
inline void DmiProcessors_Item::set_core_enabled(::google::protobuf::int32 value) {
  
  core_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.core_enabled)
}

// int32 thread_count = 17;
inline void DmiProcessors_Item::clear_thread_count() {
  thread_count_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::thread_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.thread_count)
  return thread_count_;
}
inline void DmiProcessors_Item::set_thread_count(::google::protobuf::int32 value) {
  
  thread_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.thread_count)
}

// uint32 characteristics = 18;
inline void DmiProcessors_Item::clear_characteristics() {
  characteristics_ = 0u;
}
inline ::google::protobuf::uint32 DmiProcessors_Item::characteristics() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.characteristics)
  return characteristics_;
}
inline void DmiProcessors_Item::set_characteristics(::google::protobuf::uint32 value) {
  
  characteristics_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.characteristics)
}

// -------------------------------------------------------------------

// DmiProcessors

// repeated .aspia.proto.DmiProcessors.Item item = 1;
inline int DmiProcessors::item_size() const {
  return item_.size();
}
inline void DmiProcessors::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiProcessors_Item& DmiProcessors::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiProcessors_Item* DmiProcessors::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiProcessors_Item* DmiProcessors::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiProcessors.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item >*
DmiProcessors::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiProcessors.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item >&
DmiProcessors::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiProcessors.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiMemoryDevices_Item

// string device_locator = 1;
inline void DmiMemoryDevices_Item::clear_device_locator() {
  device_locator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::device_locator() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.device_locator)
  return device_locator_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_device_locator(const ::std::string& value) {
  
  device_locator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.device_locator)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_device_locator(::std::string&& value) {
  
  device_locator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.device_locator)
}
#endif
inline void DmiMemoryDevices_Item::set_device_locator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_locator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.device_locator)
}
inline void DmiMemoryDevices_Item::set_device_locator(const char* value, size_t size) {
  
  device_locator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.device_locator)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_device_locator() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.device_locator)
  return device_locator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_device_locator() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.device_locator)
  
  return device_locator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_device_locator(::std::string* device_locator) {
  if (device_locator != NULL) {
    
  } else {
    
  }
  device_locator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_locator);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.device_locator)
}

// int32 size = 2;
inline void DmiMemoryDevices_Item::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 DmiMemoryDevices_Item::size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.size)
  return size_;
}
inline void DmiMemoryDevices_Item::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.size)
}

// .aspia.proto.DmiMemoryDevices.Type type = 3;
inline void DmiMemoryDevices_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiMemoryDevices_Type DmiMemoryDevices_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.type)
  return static_cast< ::aspia::proto::DmiMemoryDevices_Type >(type_);
}
inline void DmiMemoryDevices_Item::set_type(::aspia::proto::DmiMemoryDevices_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.type)
}

// int32 speed = 4;
inline void DmiMemoryDevices_Item::clear_speed() {
  speed_ = 0;
}
inline ::google::protobuf::int32 DmiMemoryDevices_Item::speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.speed)
  return speed_;
}
inline void DmiMemoryDevices_Item::set_speed(::google::protobuf::int32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.speed)
}

// .aspia.proto.DmiMemoryDevices.FormFactor form_factor = 5;
inline void DmiMemoryDevices_Item::clear_form_factor() {
  form_factor_ = 0;
}
inline ::aspia::proto::DmiMemoryDevices_FormFactor DmiMemoryDevices_Item::form_factor() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.form_factor)
  return static_cast< ::aspia::proto::DmiMemoryDevices_FormFactor >(form_factor_);
}
inline void DmiMemoryDevices_Item::set_form_factor(::aspia::proto::DmiMemoryDevices_FormFactor value) {
  
  form_factor_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.form_factor)
}

// string serial_number = 6;
inline void DmiMemoryDevices_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.serial_number)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.serial_number)
}
#endif
inline void DmiMemoryDevices_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.serial_number)
}
inline void DmiMemoryDevices_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.serial_number)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.serial_number)
}

// string part_number = 7;
inline void DmiMemoryDevices_Item::clear_part_number() {
  part_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::part_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.part_number)
  return part_number_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_part_number(const ::std::string& value) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.part_number)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_part_number(::std::string&& value) {
  
  part_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.part_number)
}
#endif
inline void DmiMemoryDevices_Item::set_part_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.part_number)
}
inline void DmiMemoryDevices_Item::set_part_number(const char* value, size_t size) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.part_number)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_part_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.part_number)
  return part_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_part_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.part_number)
  
  return part_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_part_number(::std::string* part_number) {
  if (part_number != NULL) {
    
  } else {
    
  }
  part_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), part_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.part_number)
}

// string manufactorer = 8;
inline void DmiMemoryDevices_Item::clear_manufactorer() {
  manufactorer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::manufactorer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.manufactorer)
  return manufactorer_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_manufactorer(const ::std::string& value) {
  
  manufactorer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_manufactorer(::std::string&& value) {
  
  manufactorer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}
#endif
inline void DmiMemoryDevices_Item::set_manufactorer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufactorer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}
inline void DmiMemoryDevices_Item::set_manufactorer(const char* value, size_t size) {
  
  manufactorer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_manufactorer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.manufactorer)
  return manufactorer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_manufactorer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.manufactorer)
  
  return manufactorer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_manufactorer(::std::string* manufactorer) {
  if (manufactorer != NULL) {
    
  } else {
    
  }
  manufactorer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufactorer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}

// string bank = 9;
inline void DmiMemoryDevices_Item::clear_bank() {
  bank_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::bank() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.bank)
  return bank_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_bank(const ::std::string& value) {
  
  bank_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.bank)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_bank(::std::string&& value) {
  
  bank_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.bank)
}
#endif
inline void DmiMemoryDevices_Item::set_bank(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bank_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.bank)
}
inline void DmiMemoryDevices_Item::set_bank(const char* value, size_t size) {
  
  bank_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.bank)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_bank() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.bank)
  return bank_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_bank() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.bank)
  
  return bank_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_bank(::std::string* bank) {
  if (bank != NULL) {
    
  } else {
    
  }
  bank_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bank);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.bank)
}

// int32 total_width = 10;
inline void DmiMemoryDevices_Item::clear_total_width() {
  total_width_ = 0;
}
inline ::google::protobuf::int32 DmiMemoryDevices_Item::total_width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.total_width)
  return total_width_;
}
inline void DmiMemoryDevices_Item::set_total_width(::google::protobuf::int32 value) {
  
  total_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.total_width)
}

// int32 data_width = 11;
inline void DmiMemoryDevices_Item::clear_data_width() {
  data_width_ = 0;
}
inline ::google::protobuf::int32 DmiMemoryDevices_Item::data_width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.data_width)
  return data_width_;
}
inline void DmiMemoryDevices_Item::set_data_width(::google::protobuf::int32 value) {
  
  data_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.data_width)
}

// -------------------------------------------------------------------

// DmiMemoryDevices

// repeated .aspia.proto.DmiMemoryDevices.Item item = 1;
inline int DmiMemoryDevices::item_size() const {
  return item_.size();
}
inline void DmiMemoryDevices::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiMemoryDevices_Item& DmiMemoryDevices::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiMemoryDevices_Item* DmiMemoryDevices::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiMemoryDevices_Item* DmiMemoryDevices::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiMemoryDevices.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item >*
DmiMemoryDevices::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiMemoryDevices.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item >&
DmiMemoryDevices::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiMemoryDevices.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiSystemSlots_Item

// string slot_designation = 1;
inline void DmiSystemSlots_Item::clear_slot_designation() {
  slot_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystemSlots_Item::slot_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.slot_designation)
  return slot_designation_.GetNoArena();
}
inline void DmiSystemSlots_Item::set_slot_designation(const ::std::string& value) {
  
  slot_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.slot_designation)
}
#if LANG_CXX11
inline void DmiSystemSlots_Item::set_slot_designation(::std::string&& value) {
  
  slot_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystemSlots.Item.slot_designation)
}
#endif
inline void DmiSystemSlots_Item::set_slot_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  slot_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystemSlots.Item.slot_designation)
}
inline void DmiSystemSlots_Item::set_slot_designation(const char* value, size_t size) {
  
  slot_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystemSlots.Item.slot_designation)
}
inline ::std::string* DmiSystemSlots_Item::mutable_slot_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystemSlots.Item.slot_designation)
  return slot_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystemSlots_Item::release_slot_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystemSlots.Item.slot_designation)
  
  return slot_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystemSlots_Item::set_allocated_slot_designation(::std::string* slot_designation) {
  if (slot_designation != NULL) {
    
  } else {
    
  }
  slot_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), slot_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystemSlots.Item.slot_designation)
}

// .aspia.proto.DmiSystemSlots.Type type = 2;
inline void DmiSystemSlots_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiSystemSlots_Type DmiSystemSlots_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.type)
  return static_cast< ::aspia::proto::DmiSystemSlots_Type >(type_);
}
inline void DmiSystemSlots_Item::set_type(::aspia::proto::DmiSystemSlots_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.type)
}

// .aspia.proto.DmiSystemSlots.Usage usage = 3;
inline void DmiSystemSlots_Item::clear_usage() {
  usage_ = 0;
}
inline ::aspia::proto::DmiSystemSlots_Usage DmiSystemSlots_Item::usage() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.usage)
  return static_cast< ::aspia::proto::DmiSystemSlots_Usage >(usage_);
}
inline void DmiSystemSlots_Item::set_usage(::aspia::proto::DmiSystemSlots_Usage value) {
  
  usage_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.usage)
}

// .aspia.proto.DmiSystemSlots.BusWidth bus_width = 4;
inline void DmiSystemSlots_Item::clear_bus_width() {
  bus_width_ = 0;
}
inline ::aspia::proto::DmiSystemSlots_BusWidth DmiSystemSlots_Item::bus_width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.bus_width)
  return static_cast< ::aspia::proto::DmiSystemSlots_BusWidth >(bus_width_);
}
inline void DmiSystemSlots_Item::set_bus_width(::aspia::proto::DmiSystemSlots_BusWidth value) {
  
  bus_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.bus_width)
}

// .aspia.proto.DmiSystemSlots.Length length = 5;
inline void DmiSystemSlots_Item::clear_length() {
  length_ = 0;
}
inline ::aspia::proto::DmiSystemSlots_Length DmiSystemSlots_Item::length() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.length)
  return static_cast< ::aspia::proto::DmiSystemSlots_Length >(length_);
}
inline void DmiSystemSlots_Item::set_length(::aspia::proto::DmiSystemSlots_Length value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.length)
}

// -------------------------------------------------------------------

// DmiSystemSlots

// repeated .aspia.proto.DmiSystemSlots.Item item = 1;
inline int DmiSystemSlots::item_size() const {
  return item_.size();
}
inline void DmiSystemSlots::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiSystemSlots_Item& DmiSystemSlots::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiSystemSlots_Item* DmiSystemSlots::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystemSlots.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiSystemSlots_Item* DmiSystemSlots::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiSystemSlots.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item >*
DmiSystemSlots::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiSystemSlots.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item >&
DmiSystemSlots::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiSystemSlots.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiPortConnectors_Item

// string internal_designation = 1;
inline void DmiPortConnectors_Item::clear_internal_designation() {
  internal_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnectors_Item::internal_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.internal_designation)
  return internal_designation_.GetNoArena();
}
inline void DmiPortConnectors_Item::set_internal_designation(const ::std::string& value) {
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
#if LANG_CXX11
inline void DmiPortConnectors_Item::set_internal_designation(::std::string&& value) {
  
  internal_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
#endif
inline void DmiPortConnectors_Item::set_internal_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
inline void DmiPortConnectors_Item::set_internal_designation(const char* value, size_t size) {
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
inline ::std::string* DmiPortConnectors_Item::mutable_internal_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.Item.internal_designation)
  return internal_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnectors_Item::release_internal_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnectors.Item.internal_designation)
  
  return internal_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnectors_Item::set_allocated_internal_designation(::std::string* internal_designation) {
  if (internal_designation != NULL) {
    
  } else {
    
  }
  internal_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), internal_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnectors.Item.internal_designation)
}

// string external_designation = 2;
inline void DmiPortConnectors_Item::clear_external_designation() {
  external_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnectors_Item::external_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.external_designation)
  return external_designation_.GetNoArena();
}
inline void DmiPortConnectors_Item::set_external_designation(const ::std::string& value) {
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.external_designation)
}
#if LANG_CXX11
inline void DmiPortConnectors_Item::set_external_designation(::std::string&& value) {
  
  external_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnectors.Item.external_designation)
}
#endif
inline void DmiPortConnectors_Item::set_external_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnectors.Item.external_designation)
}
inline void DmiPortConnectors_Item::set_external_designation(const char* value, size_t size) {
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnectors.Item.external_designation)
}
inline ::std::string* DmiPortConnectors_Item::mutable_external_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.Item.external_designation)
  return external_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnectors_Item::release_external_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnectors.Item.external_designation)
  
  return external_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnectors_Item::set_allocated_external_designation(::std::string* external_designation) {
  if (external_designation != NULL) {
    
  } else {
    
  }
  external_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), external_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnectors.Item.external_designation)
}

// .aspia.proto.DmiPortConnectors.Type type = 3;
inline void DmiPortConnectors_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiPortConnectors_Type DmiPortConnectors_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.type)
  return static_cast< ::aspia::proto::DmiPortConnectors_Type >(type_);
}
inline void DmiPortConnectors_Item::set_type(::aspia::proto::DmiPortConnectors_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.type)
}

// .aspia.proto.DmiPortConnectors.ConnectorType internal_connector_type = 4;
inline void DmiPortConnectors_Item::clear_internal_connector_type() {
  internal_connector_type_ = 0;
}
inline ::aspia::proto::DmiPortConnectors_ConnectorType DmiPortConnectors_Item::internal_connector_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
  return static_cast< ::aspia::proto::DmiPortConnectors_ConnectorType >(internal_connector_type_);
}
inline void DmiPortConnectors_Item::set_internal_connector_type(::aspia::proto::DmiPortConnectors_ConnectorType value) {
  
  internal_connector_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
}

// .aspia.proto.DmiPortConnectors.ConnectorType external_connector_type = 5;
inline void DmiPortConnectors_Item::clear_external_connector_type() {
  external_connector_type_ = 0;
}
inline ::aspia::proto::DmiPortConnectors_ConnectorType DmiPortConnectors_Item::external_connector_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.external_connector_type)
  return static_cast< ::aspia::proto::DmiPortConnectors_ConnectorType >(external_connector_type_);
}
inline void DmiPortConnectors_Item::set_external_connector_type(::aspia::proto::DmiPortConnectors_ConnectorType value) {
  
  external_connector_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.external_connector_type)
}

// -------------------------------------------------------------------

// DmiPortConnectors

// repeated .aspia.proto.DmiPortConnectors.Item item = 1;
inline int DmiPortConnectors::item_size() const {
  return item_.size();
}
inline void DmiPortConnectors::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiPortConnectors_Item& DmiPortConnectors::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiPortConnectors_Item* DmiPortConnectors::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiPortConnectors_Item* DmiPortConnectors::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiPortConnectors.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >*
DmiPortConnectors::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiPortConnectors.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >&
DmiPortConnectors::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiPortConnectors.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiOnBoardDevices_Item

// string description = 1;
inline void DmiOnBoardDevices_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiOnBoardDevices_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.Item.description)
  return description_.GetNoArena();
}
inline void DmiOnBoardDevices_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiOnBoardDevices.Item.description)
}
#if LANG_CXX11
inline void DmiOnBoardDevices_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiOnBoardDevices.Item.description)
}
#endif
inline void DmiOnBoardDevices_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiOnBoardDevices.Item.description)
}
inline void DmiOnBoardDevices_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiOnBoardDevices.Item.description)
}
inline ::std::string* DmiOnBoardDevices_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiOnBoardDevices.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiOnBoardDevices_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiOnBoardDevices.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiOnBoardDevices_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiOnBoardDevices.Item.description)
}

// .aspia.proto.DmiOnBoardDevices.Type type = 2;
inline void DmiOnBoardDevices_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiOnBoardDevices_Type DmiOnBoardDevices_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.Item.type)
  return static_cast< ::aspia::proto::DmiOnBoardDevices_Type >(type_);
}
inline void DmiOnBoardDevices_Item::set_type(::aspia::proto::DmiOnBoardDevices_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiOnBoardDevices.Item.type)
}

// bool enabled = 3;
inline void DmiOnBoardDevices_Item::clear_enabled() {
  enabled_ = false;
}
inline bool DmiOnBoardDevices_Item::enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.Item.enabled)
  return enabled_;
}
inline void DmiOnBoardDevices_Item::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiOnBoardDevices.Item.enabled)
}

// -------------------------------------------------------------------

// DmiOnBoardDevices

// repeated .aspia.proto.DmiOnBoardDevices.Item item = 1;
inline int DmiOnBoardDevices::item_size() const {
  return item_.size();
}
inline void DmiOnBoardDevices::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiOnBoardDevices_Item& DmiOnBoardDevices::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiOnBoardDevices_Item* DmiOnBoardDevices::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiOnBoardDevices.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiOnBoardDevices_Item* DmiOnBoardDevices::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiOnBoardDevices.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >*
DmiOnBoardDevices::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiOnBoardDevices.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >&
DmiOnBoardDevices::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiOnBoardDevices.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiPointingDevices_Item

// .aspia.proto.DmiPointingDevices.Type device_type = 1;
inline void DmiPointingDevices_Item::clear_device_type() {
  device_type_ = 0;
}
inline ::aspia::proto::DmiPointingDevices_Type DmiPointingDevices_Item::device_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPointingDevices.Item.device_type)
  return static_cast< ::aspia::proto::DmiPointingDevices_Type >(device_type_);
}
inline void DmiPointingDevices_Item::set_device_type(::aspia::proto::DmiPointingDevices_Type value) {
  
  device_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPointingDevices.Item.device_type)
}

// .aspia.proto.DmiPointingDevices.Interface device_interface = 2;
inline void DmiPointingDevices_Item::clear_device_interface() {
  device_interface_ = 0;
}
inline ::aspia::proto::DmiPointingDevices_Interface DmiPointingDevices_Item::device_interface() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPointingDevices.Item.device_interface)
  return static_cast< ::aspia::proto::DmiPointingDevices_Interface >(device_interface_);
}
inline void DmiPointingDevices_Item::set_device_interface(::aspia::proto::DmiPointingDevices_Interface value) {
  
  device_interface_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPointingDevices.Item.device_interface)
}

// int32 button_count = 3;
inline void DmiPointingDevices_Item::clear_button_count() {
  button_count_ = 0;
}
inline ::google::protobuf::int32 DmiPointingDevices_Item::button_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPointingDevices.Item.button_count)
  return button_count_;
}
inline void DmiPointingDevices_Item::set_button_count(::google::protobuf::int32 value) {
  
  button_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPointingDevices.Item.button_count)
}

// -------------------------------------------------------------------

// DmiPointingDevices

// repeated .aspia.proto.DmiPointingDevices.Item item = 1;
inline int DmiPointingDevices::item_size() const {
  return item_.size();
}
inline void DmiPointingDevices::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiPointingDevices_Item& DmiPointingDevices::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPointingDevices.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiPointingDevices_Item* DmiPointingDevices::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPointingDevices.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiPointingDevices_Item* DmiPointingDevices::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiPointingDevices.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevices_Item >*
DmiPointingDevices::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiPointingDevices.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevices_Item >&
DmiPointingDevices::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiPointingDevices.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiPortableBattery_Item

// string location = 1;
inline void DmiPortableBattery_Item::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.location)
  return location_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.location)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.location)
}
#endif
inline void DmiPortableBattery_Item::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.location)
}
inline void DmiPortableBattery_Item::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.location)
}
inline ::std::string* DmiPortableBattery_Item::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_location() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.location)
}

// string manufacturer = 2;
inline void DmiPortableBattery_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
#endif
inline void DmiPortableBattery_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
inline void DmiPortableBattery_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
inline ::std::string* DmiPortableBattery_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.manufacturer)
}

// string manufacture_date = 3;
inline void DmiPortableBattery_Item::clear_manufacture_date() {
  manufacture_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::manufacture_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.manufacture_date)
  return manufacture_date_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_manufacture_date(const ::std::string& value) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_manufacture_date(::std::string&& value) {
  
  manufacture_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
#endif
inline void DmiPortableBattery_Item::set_manufacture_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
inline void DmiPortableBattery_Item::set_manufacture_date(const char* value, size_t size) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
inline ::std::string* DmiPortableBattery_Item::mutable_manufacture_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.manufacture_date)
  return manufacture_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_manufacture_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.manufacture_date)
  
  return manufacture_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_manufacture_date(::std::string* manufacture_date) {
  if (manufacture_date != NULL) {
    
  } else {
    
  }
  manufacture_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacture_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}

// string serial_number = 4;
inline void DmiPortableBattery_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.serial_number)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.serial_number)
}
#endif
inline void DmiPortableBattery_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.serial_number)
}
inline void DmiPortableBattery_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.serial_number)
}
inline ::std::string* DmiPortableBattery_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.serial_number)
}

// string device_name = 5;
inline void DmiPortableBattery_Item::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::device_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.device_name)
  return device_name_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_device_name(const ::std::string& value) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.device_name)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_device_name(::std::string&& value) {
  
  device_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.device_name)
}
#endif
inline void DmiPortableBattery_Item::set_device_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.device_name)
}
inline void DmiPortableBattery_Item::set_device_name(const char* value, size_t size) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.device_name)
}
inline ::std::string* DmiPortableBattery_Item::mutable_device_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_device_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.device_name)
  
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    
  } else {
    
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.device_name)
}

// .aspia.proto.DmiPortableBattery.Chemistry chemistry = 6;
inline void DmiPortableBattery_Item::clear_chemistry() {
  chemistry_ = 0;
}
inline ::aspia::proto::DmiPortableBattery_Chemistry DmiPortableBattery_Item::chemistry() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.chemistry)
  return static_cast< ::aspia::proto::DmiPortableBattery_Chemistry >(chemistry_);
}
inline void DmiPortableBattery_Item::set_chemistry(::aspia::proto::DmiPortableBattery_Chemistry value) {
  
  chemistry_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.chemistry)
}

// int32 design_capacity = 7;
inline void DmiPortableBattery_Item::clear_design_capacity() {
  design_capacity_ = 0;
}
inline ::google::protobuf::int32 DmiPortableBattery_Item::design_capacity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.design_capacity)
  return design_capacity_;
}
inline void DmiPortableBattery_Item::set_design_capacity(::google::protobuf::int32 value) {
  
  design_capacity_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.design_capacity)
}

// int32 design_voltage = 8;
inline void DmiPortableBattery_Item::clear_design_voltage() {
  design_voltage_ = 0;
}
inline ::google::protobuf::int32 DmiPortableBattery_Item::design_voltage() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.design_voltage)
  return design_voltage_;
}
inline void DmiPortableBattery_Item::set_design_voltage(::google::protobuf::int32 value) {
  
  design_voltage_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.design_voltage)
}

// string sbds_version_number = 9;
inline void DmiPortableBattery_Item::clear_sbds_version_number() {
  sbds_version_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_version_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
  return sbds_version_number_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_version_number(const ::std::string& value) {
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_version_number(::std::string&& value) {
  
  sbds_version_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_version_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
inline void DmiPortableBattery_Item::set_sbds_version_number(const char* value, size_t size) {
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_version_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
  return sbds_version_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_version_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
  
  return sbds_version_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_version_number(::std::string* sbds_version_number) {
  if (sbds_version_number != NULL) {
    
  } else {
    
  }
  sbds_version_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_version_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}

// int32 max_error_in_battery_data = 10;
inline void DmiPortableBattery_Item::clear_max_error_in_battery_data() {
  max_error_in_battery_data_ = 0;
}
inline ::google::protobuf::int32 DmiPortableBattery_Item::max_error_in_battery_data() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.max_error_in_battery_data)
  return max_error_in_battery_data_;
}
inline void DmiPortableBattery_Item::set_max_error_in_battery_data(::google::protobuf::int32 value) {
  
  max_error_in_battery_data_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.max_error_in_battery_data)
}

// string sbds_serial_number = 11;
inline void DmiPortableBattery_Item::clear_sbds_serial_number() {
  sbds_serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
  return sbds_serial_number_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_serial_number(const ::std::string& value) {
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_serial_number(::std::string&& value) {
  
  sbds_serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
inline void DmiPortableBattery_Item::set_sbds_serial_number(const char* value, size_t size) {
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
  return sbds_serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
  
  return sbds_serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_serial_number(::std::string* sbds_serial_number) {
  if (sbds_serial_number != NULL) {
    
  } else {
    
  }
  sbds_serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}

// string sbds_manufacture_date = 12;
inline void DmiPortableBattery_Item::clear_sbds_manufacture_date() {
  sbds_manufacture_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_manufacture_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
  return sbds_manufacture_date_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(const ::std::string& value) {
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(::std::string&& value) {
  
  sbds_manufacture_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(const char* value, size_t size) {
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_manufacture_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
  return sbds_manufacture_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_manufacture_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
  
  return sbds_manufacture_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_manufacture_date(::std::string* sbds_manufacture_date) {
  if (sbds_manufacture_date != NULL) {
    
  } else {
    
  }
  sbds_manufacture_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_manufacture_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}

// string sbds_device_chemistry = 13;
inline void DmiPortableBattery_Item::clear_sbds_device_chemistry() {
  sbds_device_chemistry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_device_chemistry() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
  return sbds_device_chemistry_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(const ::std::string& value) {
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(::std::string&& value) {
  
  sbds_device_chemistry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(const char* value, size_t size) {
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_device_chemistry() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
  return sbds_device_chemistry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_device_chemistry() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
  
  return sbds_device_chemistry_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_device_chemistry(::std::string* sbds_device_chemistry) {
  if (sbds_device_chemistry != NULL) {
    
  } else {
    
  }
  sbds_device_chemistry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_device_chemistry);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}

// -------------------------------------------------------------------

// DmiPortableBattery

// repeated .aspia.proto.DmiPortableBattery.Item item = 1;
inline int DmiPortableBattery::item_size() const {
  return item_.size();
}
inline void DmiPortableBattery::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiPortableBattery_Item& DmiPortableBattery::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiPortableBattery_Item* DmiPortableBattery::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiPortableBattery_Item* DmiPortableBattery::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiPortableBattery.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >*
DmiPortableBattery::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiPortableBattery.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >&
DmiPortableBattery::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiPortableBattery.item)
  return item_;
}

// -------------------------------------------------------------------

// Programs_Item

// string name = 1;
inline void Programs_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.name)
  return name_.GetNoArena();
}
inline void Programs_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.name)
}
#if LANG_CXX11
inline void Programs_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.name)
}
#endif
inline void Programs_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.name)
}
inline void Programs_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.name)
}
inline ::std::string* Programs_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.name)
}

// string version = 2;
inline void Programs_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.version)
  return version_.GetNoArena();
}
inline void Programs_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.version)
}
#if LANG_CXX11
inline void Programs_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.version)
}
#endif
inline void Programs_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.version)
}
inline void Programs_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.version)
}
inline ::std::string* Programs_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.version)
}

// string publisher = 3;
inline void Programs_Item::clear_publisher() {
  publisher_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::publisher() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.publisher)
  return publisher_.GetNoArena();
}
inline void Programs_Item::set_publisher(const ::std::string& value) {
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.publisher)
}
#if LANG_CXX11
inline void Programs_Item::set_publisher(::std::string&& value) {
  
  publisher_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.publisher)
}
#endif
inline void Programs_Item::set_publisher(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.publisher)
}
inline void Programs_Item::set_publisher(const char* value, size_t size) {
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.publisher)
}
inline ::std::string* Programs_Item::mutable_publisher() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.publisher)
  return publisher_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_publisher() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.publisher)
  
  return publisher_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_publisher(::std::string* publisher) {
  if (publisher != NULL) {
    
  } else {
    
  }
  publisher_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publisher);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.publisher)
}

// string install_date = 4;
inline void Programs_Item::clear_install_date() {
  install_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::install_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.install_date)
  return install_date_.GetNoArena();
}
inline void Programs_Item::set_install_date(const ::std::string& value) {
  
  install_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.install_date)
}
#if LANG_CXX11
inline void Programs_Item::set_install_date(::std::string&& value) {
  
  install_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.install_date)
}
#endif
inline void Programs_Item::set_install_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  install_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.install_date)
}
inline void Programs_Item::set_install_date(const char* value, size_t size) {
  
  install_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.install_date)
}
inline ::std::string* Programs_Item::mutable_install_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.install_date)
  return install_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_install_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.install_date)
  
  return install_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_install_date(::std::string* install_date) {
  if (install_date != NULL) {
    
  } else {
    
  }
  install_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), install_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.install_date)
}

// string install_location = 5;
inline void Programs_Item::clear_install_location() {
  install_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::install_location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.install_location)
  return install_location_.GetNoArena();
}
inline void Programs_Item::set_install_location(const ::std::string& value) {
  
  install_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.install_location)
}
#if LANG_CXX11
inline void Programs_Item::set_install_location(::std::string&& value) {
  
  install_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.install_location)
}
#endif
inline void Programs_Item::set_install_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  install_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.install_location)
}
inline void Programs_Item::set_install_location(const char* value, size_t size) {
  
  install_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.install_location)
}
inline ::std::string* Programs_Item::mutable_install_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.install_location)
  return install_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_install_location() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.install_location)
  
  return install_location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_install_location(::std::string* install_location) {
  if (install_location != NULL) {
    
  } else {
    
  }
  install_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), install_location);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.install_location)
}

// -------------------------------------------------------------------

// Programs

// repeated .aspia.proto.Programs.Item item = 1;
inline int Programs::item_size() const {
  return item_.size();
}
inline void Programs::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Programs_Item& Programs::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.item)
  return item_.Get(index);
}
inline ::aspia::proto::Programs_Item* Programs::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Programs_Item* Programs::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Programs.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >*
Programs::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Programs.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >&
Programs::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Programs.item)
  return item_;
}

// -------------------------------------------------------------------

// Services_Item

// string name = 1;
inline void Services_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.name)
  return name_.GetNoArena();
}
inline void Services_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.name)
}
#if LANG_CXX11
inline void Services_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.name)
}
#endif
inline void Services_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.name)
}
inline void Services_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.name)
}
inline ::std::string* Services_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.name)
}

// string display_name = 2;
inline void Services_Item::clear_display_name() {
  display_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::display_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.display_name)
  return display_name_.GetNoArena();
}
inline void Services_Item::set_display_name(const ::std::string& value) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.display_name)
}
#if LANG_CXX11
inline void Services_Item::set_display_name(::std::string&& value) {
  
  display_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.display_name)
}
#endif
inline void Services_Item::set_display_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.display_name)
}
inline void Services_Item::set_display_name(const char* value, size_t size) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.display_name)
}
inline ::std::string* Services_Item::mutable_display_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.display_name)
  return display_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_display_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.display_name)
  
  return display_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_display_name(::std::string* display_name) {
  if (display_name != NULL) {
    
  } else {
    
  }
  display_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.display_name)
}

// string description = 3;
inline void Services_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.description)
  return description_.GetNoArena();
}
inline void Services_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.description)
}
#if LANG_CXX11
inline void Services_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.description)
}
#endif
inline void Services_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.description)
}
inline void Services_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.description)
}
inline ::std::string* Services_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.description)
}

// .aspia.proto.Services.Item.Status status = 4;
inline void Services_Item::clear_status() {
  status_ = 0;
}
inline ::aspia::proto::Services_Item_Status Services_Item::status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.status)
  return static_cast< ::aspia::proto::Services_Item_Status >(status_);
}
inline void Services_Item::set_status(::aspia::proto::Services_Item_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.status)
}

// .aspia.proto.Services.Item.StartupType startup_type = 5;
inline void Services_Item::clear_startup_type() {
  startup_type_ = 0;
}
inline ::aspia::proto::Services_Item_StartupType Services_Item::startup_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.startup_type)
  return static_cast< ::aspia::proto::Services_Item_StartupType >(startup_type_);
}
inline void Services_Item::set_startup_type(::aspia::proto::Services_Item_StartupType value) {
  
  startup_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.startup_type)
}

// string binary_path = 6;
inline void Services_Item::clear_binary_path() {
  binary_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::binary_path() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.binary_path)
  return binary_path_.GetNoArena();
}
inline void Services_Item::set_binary_path(const ::std::string& value) {
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.binary_path)
}
#if LANG_CXX11
inline void Services_Item::set_binary_path(::std::string&& value) {
  
  binary_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.binary_path)
}
#endif
inline void Services_Item::set_binary_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.binary_path)
}
inline void Services_Item::set_binary_path(const char* value, size_t size) {
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.binary_path)
}
inline ::std::string* Services_Item::mutable_binary_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.binary_path)
  return binary_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_binary_path() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.binary_path)
  
  return binary_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_binary_path(::std::string* binary_path) {
  if (binary_path != NULL) {
    
  } else {
    
  }
  binary_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), binary_path);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.binary_path)
}

// string start_name = 7;
inline void Services_Item::clear_start_name() {
  start_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::start_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.start_name)
  return start_name_.GetNoArena();
}
inline void Services_Item::set_start_name(const ::std::string& value) {
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.start_name)
}
#if LANG_CXX11
inline void Services_Item::set_start_name(::std::string&& value) {
  
  start_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.start_name)
}
#endif
inline void Services_Item::set_start_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.start_name)
}
inline void Services_Item::set_start_name(const char* value, size_t size) {
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.start_name)
}
inline ::std::string* Services_Item::mutable_start_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.start_name)
  return start_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_start_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.start_name)
  
  return start_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_start_name(::std::string* start_name) {
  if (start_name != NULL) {
    
  } else {
    
  }
  start_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.start_name)
}

// -------------------------------------------------------------------

// Services

// repeated .aspia.proto.Services.Item item = 1;
inline int Services::item_size() const {
  return item_.size();
}
inline void Services::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Services_Item& Services::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.item)
  return item_.Get(index);
}
inline ::aspia::proto::Services_Item* Services::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Services_Item* Services::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Services.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >*
Services::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Services.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >&
Services::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Services.item)
  return item_;
}

// -------------------------------------------------------------------

// NetworkCards_Item_IpAddress

// string address = 1;
inline void NetworkCards_Item_IpAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item_IpAddress::address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.IpAddress.address)
  return address_.GetNoArena();
}
inline void NetworkCards_Item_IpAddress::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.IpAddress.address)
}
#if LANG_CXX11
inline void NetworkCards_Item_IpAddress::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.IpAddress.address)
}
#endif
inline void NetworkCards_Item_IpAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.IpAddress.address)
}
inline void NetworkCards_Item_IpAddress::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.IpAddress.address)
}
inline ::std::string* NetworkCards_Item_IpAddress::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.IpAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item_IpAddress::release_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.IpAddress.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item_IpAddress::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.IpAddress.address)
}

// string mask = 2;
inline void NetworkCards_Item_IpAddress::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item_IpAddress::mask() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.IpAddress.mask)
  return mask_.GetNoArena();
}
inline void NetworkCards_Item_IpAddress::set_mask(const ::std::string& value) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
#if LANG_CXX11
inline void NetworkCards_Item_IpAddress::set_mask(::std::string&& value) {
  
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
#endif
inline void NetworkCards_Item_IpAddress::set_mask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
inline void NetworkCards_Item_IpAddress::set_mask(const char* value, size_t size) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
inline ::std::string* NetworkCards_Item_IpAddress::mutable_mask() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.IpAddress.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item_IpAddress::release_mask() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.IpAddress.mask)
  
  return mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item_IpAddress::set_allocated_mask(::std::string* mask) {
  if (mask != NULL) {
    
  } else {
    
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.IpAddress.mask)
}

// -------------------------------------------------------------------

// NetworkCards_Item

// string adapter_name = 1;
inline void NetworkCards_Item::clear_adapter_name() {
  adapter_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::adapter_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.adapter_name)
  return adapter_name_.GetNoArena();
}
inline void NetworkCards_Item::set_adapter_name(const ::std::string& value) {
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.adapter_name)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_adapter_name(::std::string&& value) {
  
  adapter_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.adapter_name)
}
#endif
inline void NetworkCards_Item::set_adapter_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.adapter_name)
}
inline void NetworkCards_Item::set_adapter_name(const char* value, size_t size) {
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.adapter_name)
}
inline ::std::string* NetworkCards_Item::mutable_adapter_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.adapter_name)
  return adapter_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_adapter_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.adapter_name)
  
  return adapter_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_adapter_name(::std::string* adapter_name) {
  if (adapter_name != NULL) {
    
  } else {
    
  }
  adapter_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adapter_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.adapter_name)
}

// string connection_name = 2;
inline void NetworkCards_Item::clear_connection_name() {
  connection_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::connection_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.connection_name)
  return connection_name_.GetNoArena();
}
inline void NetworkCards_Item::set_connection_name(const ::std::string& value) {
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.connection_name)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_connection_name(::std::string&& value) {
  
  connection_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.connection_name)
}
#endif
inline void NetworkCards_Item::set_connection_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.connection_name)
}
inline void NetworkCards_Item::set_connection_name(const char* value, size_t size) {
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.connection_name)
}
inline ::std::string* NetworkCards_Item::mutable_connection_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.connection_name)
  return connection_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_connection_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.connection_name)
  
  return connection_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_connection_name(::std::string* connection_name) {
  if (connection_name != NULL) {
    
  } else {
    
  }
  connection_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connection_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.connection_name)
}

// string interface_type = 3;
inline void NetworkCards_Item::clear_interface_type() {
  interface_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::interface_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.interface_type)
  return interface_type_.GetNoArena();
}
inline void NetworkCards_Item::set_interface_type(const ::std::string& value) {
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.interface_type)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_interface_type(::std::string&& value) {
  
  interface_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.interface_type)
}
#endif
inline void NetworkCards_Item::set_interface_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.interface_type)
}
inline void NetworkCards_Item::set_interface_type(const char* value, size_t size) {
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.interface_type)
}
inline ::std::string* NetworkCards_Item::mutable_interface_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.interface_type)
  return interface_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_interface_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.interface_type)
  
  return interface_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_interface_type(::std::string* interface_type) {
  if (interface_type != NULL) {
    
  } else {
    
  }
  interface_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), interface_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.interface_type)
}

// uint32 mtu = 4;
inline void NetworkCards_Item::clear_mtu() {
  mtu_ = 0u;
}
inline ::google::protobuf::uint32 NetworkCards_Item::mtu() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.mtu)
  return mtu_;
}
inline void NetworkCards_Item::set_mtu(::google::protobuf::uint32 value) {
  
  mtu_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.mtu)
}

// uint32 speed = 5;
inline void NetworkCards_Item::clear_speed() {
  speed_ = 0u;
}
inline ::google::protobuf::uint32 NetworkCards_Item::speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.speed)
  return speed_;
}
inline void NetworkCards_Item::set_speed(::google::protobuf::uint32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.speed)
}

// string mac_address = 6;
inline void NetworkCards_Item::clear_mac_address() {
  mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::mac_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.mac_address)
  return mac_address_.GetNoArena();
}
inline void NetworkCards_Item::set_mac_address(const ::std::string& value) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.mac_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_mac_address(::std::string&& value) {
  
  mac_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.mac_address)
}
#endif
inline void NetworkCards_Item::set_mac_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.mac_address)
}
inline void NetworkCards_Item::set_mac_address(const char* value, size_t size) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.mac_address)
}
inline ::std::string* NetworkCards_Item::mutable_mac_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.mac_address)
  return mac_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_mac_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.mac_address)
  
  return mac_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_mac_address(::std::string* mac_address) {
  if (mac_address != NULL) {
    
  } else {
    
  }
  mac_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.mac_address)
}

// bool is_wins_enabled = 7;
inline void NetworkCards_Item::clear_is_wins_enabled() {
  is_wins_enabled_ = false;
}
inline bool NetworkCards_Item::is_wins_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.is_wins_enabled)
  return is_wins_enabled_;
}
inline void NetworkCards_Item::set_is_wins_enabled(bool value) {
  
  is_wins_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.is_wins_enabled)
}

// string primary_wins_server = 8;
inline void NetworkCards_Item::clear_primary_wins_server() {
  primary_wins_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::primary_wins_server() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.primary_wins_server)
  return primary_wins_server_.GetNoArena();
}
inline void NetworkCards_Item::set_primary_wins_server(const ::std::string& value) {
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.primary_wins_server)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_primary_wins_server(::std::string&& value) {
  
  primary_wins_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.primary_wins_server)
}
#endif
inline void NetworkCards_Item::set_primary_wins_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.primary_wins_server)
}
inline void NetworkCards_Item::set_primary_wins_server(const char* value, size_t size) {
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.primary_wins_server)
}
inline ::std::string* NetworkCards_Item::mutable_primary_wins_server() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.primary_wins_server)
  return primary_wins_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_primary_wins_server() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.primary_wins_server)
  
  return primary_wins_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_primary_wins_server(::std::string* primary_wins_server) {
  if (primary_wins_server != NULL) {
    
  } else {
    
  }
  primary_wins_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_wins_server);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.primary_wins_server)
}

// string secondary_wins_server = 9;
inline void NetworkCards_Item::clear_secondary_wins_server() {
  secondary_wins_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::secondary_wins_server() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.secondary_wins_server)
  return secondary_wins_server_.GetNoArena();
}
inline void NetworkCards_Item::set_secondary_wins_server(const ::std::string& value) {
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_secondary_wins_server(::std::string&& value) {
  
  secondary_wins_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
#endif
inline void NetworkCards_Item::set_secondary_wins_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
inline void NetworkCards_Item::set_secondary_wins_server(const char* value, size_t size) {
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
inline ::std::string* NetworkCards_Item::mutable_secondary_wins_server() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.secondary_wins_server)
  return secondary_wins_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_secondary_wins_server() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.secondary_wins_server)
  
  return secondary_wins_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_secondary_wins_server(::std::string* secondary_wins_server) {
  if (secondary_wins_server != NULL) {
    
  } else {
    
  }
  secondary_wins_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secondary_wins_server);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.secondary_wins_server)
}

// bool is_dhcp_enabled = 10;
inline void NetworkCards_Item::clear_is_dhcp_enabled() {
  is_dhcp_enabled_ = false;
}
inline bool NetworkCards_Item::is_dhcp_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.is_dhcp_enabled)
  return is_dhcp_enabled_;
}
inline void NetworkCards_Item::set_is_dhcp_enabled(bool value) {
  
  is_dhcp_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.is_dhcp_enabled)
}

// repeated .aspia.proto.NetworkCards.Item.IpAddress ip_address = 11;
inline int NetworkCards_Item::ip_address_size() const {
  return ip_address_.size();
}
inline void NetworkCards_Item::clear_ip_address() {
  ip_address_.Clear();
}
inline const ::aspia::proto::NetworkCards_Item_IpAddress& NetworkCards_Item::ip_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_.Get(index);
}
inline ::aspia::proto::NetworkCards_Item_IpAddress* NetworkCards_Item::mutable_ip_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_.Mutable(index);
}
inline ::aspia::proto::NetworkCards_Item_IpAddress* NetworkCards_Item::add_ip_address() {
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >*
NetworkCards_Item::mutable_ip_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.ip_address)
  return &ip_address_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >&
NetworkCards_Item::ip_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_;
}

// repeated string gateway_address = 12;
inline int NetworkCards_Item::gateway_address_size() const {
  return gateway_address_.size();
}
inline void NetworkCards_Item::clear_gateway_address() {
  gateway_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::gateway_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_gateway_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_.Mutable(index);
}
inline void NetworkCards_Item::set_gateway_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.gateway_address)
  gateway_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_gateway_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.gateway_address)
  gateway_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_gateway_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  gateway_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.gateway_address)
}
inline void NetworkCards_Item::set_gateway_address(int index, const char* value, size_t size) {
  gateway_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.gateway_address)
}
inline ::std::string* NetworkCards_Item::add_gateway_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_.Add();
}
inline void NetworkCards_Item::add_gateway_address(const ::std::string& value) {
  gateway_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.gateway_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_gateway_address(::std::string&& value) {
  gateway_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.gateway_address)
}
#endif
inline void NetworkCards_Item::add_gateway_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  gateway_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.proto.NetworkCards.Item.gateway_address)
}
inline void NetworkCards_Item::add_gateway_address(const char* value, size_t size) {
  gateway_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.proto.NetworkCards.Item.gateway_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::gateway_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_gateway_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.gateway_address)
  return &gateway_address_;
}

// repeated string dhcp_server_address = 13;
inline int NetworkCards_Item::dhcp_server_address_size() const {
  return dhcp_server_address_.size();
}
inline void NetworkCards_Item::clear_dhcp_server_address() {
  dhcp_server_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::dhcp_server_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_dhcp_server_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Mutable(index);
}
inline void NetworkCards_Item::set_dhcp_server_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dhcp_server_address)
  dhcp_server_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_dhcp_server_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dhcp_server_address)
  dhcp_server_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_dhcp_server_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dhcp_server_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline void NetworkCards_Item::set_dhcp_server_address(int index, const char* value, size_t size) {
  dhcp_server_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline ::std::string* NetworkCards_Item::add_dhcp_server_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Add();
}
inline void NetworkCards_Item::add_dhcp_server_address(const ::std::string& value) {
  dhcp_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_dhcp_server_address(::std::string&& value) {
  dhcp_server_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
#endif
inline void NetworkCards_Item::add_dhcp_server_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dhcp_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline void NetworkCards_Item::add_dhcp_server_address(const char* value, size_t size) {
  dhcp_server_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::dhcp_server_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_dhcp_server_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return &dhcp_server_address_;
}

// repeated string dns_server_address = 14;
inline int NetworkCards_Item::dns_server_address_size() const {
  return dns_server_address_.size();
}
inline void NetworkCards_Item::clear_dns_server_address() {
  dns_server_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::dns_server_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_dns_server_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Mutable(index);
}
inline void NetworkCards_Item::set_dns_server_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dns_server_address)
  dns_server_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_dns_server_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dns_server_address)
  dns_server_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_dns_server_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_server_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline void NetworkCards_Item::set_dns_server_address(int index, const char* value, size_t size) {
  dns_server_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline ::std::string* NetworkCards_Item::add_dns_server_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Add();
}
inline void NetworkCards_Item::add_dns_server_address(const ::std::string& value) {
  dns_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dns_server_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_dns_server_address(::std::string&& value) {
  dns_server_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dns_server_address)
}
#endif
inline void NetworkCards_Item::add_dns_server_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline void NetworkCards_Item::add_dns_server_address(const char* value, size_t size) {
  dns_server_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::dns_server_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_dns_server_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.dns_server_address)
  return &dns_server_address_;
}

// -------------------------------------------------------------------

// NetworkCards

// repeated .aspia.proto.NetworkCards.Item item = 1;
inline int NetworkCards::item_size() const {
  return item_.size();
}
inline void NetworkCards::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::NetworkCards_Item& NetworkCards::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.item)
  return item_.Get(index);
}
inline ::aspia::proto::NetworkCards_Item* NetworkCards::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::NetworkCards_Item* NetworkCards::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >*
NetworkCards::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >&
NetworkCards::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.item)
  return item_;
}

// -------------------------------------------------------------------

// OpenConnections_Item

// string process_name = 1;
inline void OpenConnections_Item::clear_process_name() {
  process_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::process_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.process_name)
  return process_name_.GetNoArena();
}
inline void OpenConnections_Item::set_process_name(const ::std::string& value) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.process_name)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_process_name(::std::string&& value) {
  
  process_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.process_name)
}
#endif
inline void OpenConnections_Item::set_process_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.process_name)
}
inline void OpenConnections_Item::set_process_name(const char* value, size_t size) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.process_name)
}
inline ::std::string* OpenConnections_Item::mutable_process_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.process_name)
  return process_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_process_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.process_name)
  
  return process_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_process_name(::std::string* process_name) {
  if (process_name != NULL) {
    
  } else {
    
  }
  process_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.process_name)
}

// .aspia.proto.OpenConnections.Protocol protocol = 2;
inline void OpenConnections_Item::clear_protocol() {
  protocol_ = 0;
}
inline ::aspia::proto::OpenConnections_Protocol OpenConnections_Item::protocol() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.protocol)
  return static_cast< ::aspia::proto::OpenConnections_Protocol >(protocol_);
}
inline void OpenConnections_Item::set_protocol(::aspia::proto::OpenConnections_Protocol value) {
  
  protocol_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.protocol)
}

// string local_address = 3;
inline void OpenConnections_Item::clear_local_address() {
  local_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::local_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.local_address)
  return local_address_.GetNoArena();
}
inline void OpenConnections_Item::set_local_address(const ::std::string& value) {
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.local_address)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_local_address(::std::string&& value) {
  
  local_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.local_address)
}
#endif
inline void OpenConnections_Item::set_local_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.local_address)
}
inline void OpenConnections_Item::set_local_address(const char* value, size_t size) {
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.local_address)
}
inline ::std::string* OpenConnections_Item::mutable_local_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.local_address)
  return local_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_local_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.local_address)
  
  return local_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_local_address(::std::string* local_address) {
  if (local_address != NULL) {
    
  } else {
    
  }
  local_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.local_address)
}

// string remote_address = 4;
inline void OpenConnections_Item::clear_remote_address() {
  remote_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::remote_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.remote_address)
  return remote_address_.GetNoArena();
}
inline void OpenConnections_Item::set_remote_address(const ::std::string& value) {
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.remote_address)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_remote_address(::std::string&& value) {
  
  remote_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.remote_address)
}
#endif
inline void OpenConnections_Item::set_remote_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.remote_address)
}
inline void OpenConnections_Item::set_remote_address(const char* value, size_t size) {
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.remote_address)
}
inline ::std::string* OpenConnections_Item::mutable_remote_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.remote_address)
  return remote_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_remote_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.remote_address)
  
  return remote_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_remote_address(::std::string* remote_address) {
  if (remote_address != NULL) {
    
  } else {
    
  }
  remote_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.remote_address)
}

// uint32 local_port = 5;
inline void OpenConnections_Item::clear_local_port() {
  local_port_ = 0u;
}
inline ::google::protobuf::uint32 OpenConnections_Item::local_port() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.local_port)
  return local_port_;
}
inline void OpenConnections_Item::set_local_port(::google::protobuf::uint32 value) {
  
  local_port_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.local_port)
}

// uint32 remote_port = 6;
inline void OpenConnections_Item::clear_remote_port() {
  remote_port_ = 0u;
}
inline ::google::protobuf::uint32 OpenConnections_Item::remote_port() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.remote_port)
  return remote_port_;
}
inline void OpenConnections_Item::set_remote_port(::google::protobuf::uint32 value) {
  
  remote_port_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.remote_port)
}

// .aspia.proto.OpenConnections.State state = 7;
inline void OpenConnections_Item::clear_state() {
  state_ = 0;
}
inline ::aspia::proto::OpenConnections_State OpenConnections_Item::state() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.state)
  return static_cast< ::aspia::proto::OpenConnections_State >(state_);
}
inline void OpenConnections_Item::set_state(::aspia::proto::OpenConnections_State value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.state)
}

// -------------------------------------------------------------------

// OpenConnections

// repeated .aspia.proto.OpenConnections.Item item = 1;
inline int OpenConnections::item_size() const {
  return item_.size();
}
inline void OpenConnections::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::OpenConnections_Item& OpenConnections::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.item)
  return item_.Get(index);
}
inline ::aspia::proto::OpenConnections_Item* OpenConnections::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::OpenConnections_Item* OpenConnections::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.OpenConnections.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >*
OpenConnections::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.OpenConnections.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >&
OpenConnections::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.OpenConnections.item)
  return item_;
}

// -------------------------------------------------------------------

// SharedResources_Item

// string name = 1;
inline void SharedResources_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.name)
  return name_.GetNoArena();
}
inline void SharedResources_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.name)
}
#if LANG_CXX11
inline void SharedResources_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SharedResources.Item.name)
}
#endif
inline void SharedResources_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SharedResources.Item.name)
}
inline void SharedResources_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SharedResources.Item.name)
}
inline ::std::string* SharedResources_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.SharedResources.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SharedResources.Item.name)
}

// .aspia.proto.SharedResources.Item.Type type = 2;
inline void SharedResources_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::SharedResources_Item_Type SharedResources_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.type)
  return static_cast< ::aspia::proto::SharedResources_Item_Type >(type_);
}
inline void SharedResources_Item::set_type(::aspia::proto::SharedResources_Item_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.type)
}

// string description = 3;
inline void SharedResources_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.description)
  return description_.GetNoArena();
}
inline void SharedResources_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.description)
}
#if LANG_CXX11
inline void SharedResources_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SharedResources.Item.description)
}
#endif
inline void SharedResources_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SharedResources.Item.description)
}
inline void SharedResources_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SharedResources.Item.description)
}
inline ::std::string* SharedResources_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.SharedResources.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SharedResources.Item.description)
}

// string local_path = 4;
inline void SharedResources_Item::clear_local_path() {
  local_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::local_path() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.local_path)
  return local_path_.GetNoArena();
}
inline void SharedResources_Item::set_local_path(const ::std::string& value) {
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.local_path)
}
#if LANG_CXX11
inline void SharedResources_Item::set_local_path(::std::string&& value) {
  
  local_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SharedResources.Item.local_path)
}
#endif
inline void SharedResources_Item::set_local_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SharedResources.Item.local_path)
}
inline void SharedResources_Item::set_local_path(const char* value, size_t size) {
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SharedResources.Item.local_path)
}
inline ::std::string* SharedResources_Item::mutable_local_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.Item.local_path)
  return local_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_local_path() {
  // @@protoc_insertion_point(field_release:aspia.proto.SharedResources.Item.local_path)
  
  return local_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_local_path(::std::string* local_path) {
  if (local_path != NULL) {
    
  } else {
    
  }
  local_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_path);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SharedResources.Item.local_path)
}

// uint32 current_uses = 5;
inline void SharedResources_Item::clear_current_uses() {
  current_uses_ = 0u;
}
inline ::google::protobuf::uint32 SharedResources_Item::current_uses() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.current_uses)
  return current_uses_;
}
inline void SharedResources_Item::set_current_uses(::google::protobuf::uint32 value) {
  
  current_uses_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.current_uses)
}

// uint32 maximum_uses = 6;
inline void SharedResources_Item::clear_maximum_uses() {
  maximum_uses_ = 0u;
}
inline ::google::protobuf::uint32 SharedResources_Item::maximum_uses() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.maximum_uses)
  return maximum_uses_;
}
inline void SharedResources_Item::set_maximum_uses(::google::protobuf::uint32 value) {
  
  maximum_uses_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.maximum_uses)
}

// -------------------------------------------------------------------

// SharedResources

// repeated .aspia.proto.SharedResources.Item item = 1;
inline int SharedResources::item_size() const {
  return item_.size();
}
inline void SharedResources::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::SharedResources_Item& SharedResources::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.item)
  return item_.Get(index);
}
inline ::aspia::proto::SharedResources_Item* SharedResources::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::SharedResources_Item* SharedResources::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.SharedResources.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >*
SharedResources::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.SharedResources.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >&
SharedResources::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.SharedResources.item)
  return item_;
}

// -------------------------------------------------------------------

// Routes_Item

// string destonation = 1;
inline void Routes_Item::clear_destonation() {
  destonation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::destonation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.destonation)
  return destonation_.GetNoArena();
}
inline void Routes_Item::set_destonation(const ::std::string& value) {
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.destonation)
}
#if LANG_CXX11
inline void Routes_Item::set_destonation(::std::string&& value) {
  
  destonation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Routes.Item.destonation)
}
#endif
inline void Routes_Item::set_destonation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Routes.Item.destonation)
}
inline void Routes_Item::set_destonation(const char* value, size_t size) {
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Routes.Item.destonation)
}
inline ::std::string* Routes_Item::mutable_destonation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.Item.destonation)
  return destonation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_destonation() {
  // @@protoc_insertion_point(field_release:aspia.proto.Routes.Item.destonation)
  
  return destonation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_destonation(::std::string* destonation) {
  if (destonation != NULL) {
    
  } else {
    
  }
  destonation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destonation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Routes.Item.destonation)
}

// string mask = 2;
inline void Routes_Item::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::mask() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.mask)
  return mask_.GetNoArena();
}
inline void Routes_Item::set_mask(const ::std::string& value) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.mask)
}
#if LANG_CXX11
inline void Routes_Item::set_mask(::std::string&& value) {
  
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Routes.Item.mask)
}
#endif
inline void Routes_Item::set_mask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Routes.Item.mask)
}
inline void Routes_Item::set_mask(const char* value, size_t size) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Routes.Item.mask)
}
inline ::std::string* Routes_Item::mutable_mask() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.Item.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_mask() {
  // @@protoc_insertion_point(field_release:aspia.proto.Routes.Item.mask)
  
  return mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_mask(::std::string* mask) {
  if (mask != NULL) {
    
  } else {
    
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Routes.Item.mask)
}

// string gateway = 3;
inline void Routes_Item::clear_gateway() {
  gateway_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::gateway() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.gateway)
  return gateway_.GetNoArena();
}
inline void Routes_Item::set_gateway(const ::std::string& value) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.gateway)
}
#if LANG_CXX11
inline void Routes_Item::set_gateway(::std::string&& value) {
  
  gateway_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Routes.Item.gateway)
}
#endif
inline void Routes_Item::set_gateway(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Routes.Item.gateway)
}
inline void Routes_Item::set_gateway(const char* value, size_t size) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Routes.Item.gateway)
}
inline ::std::string* Routes_Item::mutable_gateway() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.Item.gateway)
  return gateway_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_gateway() {
  // @@protoc_insertion_point(field_release:aspia.proto.Routes.Item.gateway)
  
  return gateway_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_gateway(::std::string* gateway) {
  if (gateway != NULL) {
    
  } else {
    
  }
  gateway_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gateway);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Routes.Item.gateway)
}

// uint32 metric = 4;
inline void Routes_Item::clear_metric() {
  metric_ = 0u;
}
inline ::google::protobuf::uint32 Routes_Item::metric() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.metric)
  return metric_;
}
inline void Routes_Item::set_metric(::google::protobuf::uint32 value) {
  
  metric_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.metric)
}

// -------------------------------------------------------------------

// Routes

// repeated .aspia.proto.Routes.Item item = 1;
inline int Routes::item_size() const {
  return item_.size();
}
inline void Routes::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Routes_Item& Routes::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.item)
  return item_.Get(index);
}
inline ::aspia::proto::Routes_Item* Routes::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Routes_Item* Routes::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Routes.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >*
Routes::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Routes.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >&
Routes::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Routes.item)
  return item_;
}

// -------------------------------------------------------------------

// Users_Item

// string name = 1;
inline void Users_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.name)
  return name_.GetNoArena();
}
inline void Users_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.name)
}
#if LANG_CXX11
inline void Users_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Users.Item.name)
}
#endif
inline void Users_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Users.Item.name)
}
inline void Users_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Users.Item.name)
}
inline ::std::string* Users_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Users.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Users.Item.name)
}

// string full_name = 2;
inline void Users_Item::clear_full_name() {
  full_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::full_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.full_name)
  return full_name_.GetNoArena();
}
inline void Users_Item::set_full_name(const ::std::string& value) {
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.full_name)
}
#if LANG_CXX11
inline void Users_Item::set_full_name(::std::string&& value) {
  
  full_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Users.Item.full_name)
}
#endif
inline void Users_Item::set_full_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Users.Item.full_name)
}
inline void Users_Item::set_full_name(const char* value, size_t size) {
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Users.Item.full_name)
}
inline ::std::string* Users_Item::mutable_full_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.Item.full_name)
  return full_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_full_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Users.Item.full_name)
  
  return full_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_full_name(::std::string* full_name) {
  if (full_name != NULL) {
    
  } else {
    
  }
  full_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), full_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Users.Item.full_name)
}

// string comment = 3;
inline void Users_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.comment)
  return comment_.GetNoArena();
}
inline void Users_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.comment)
}
#if LANG_CXX11
inline void Users_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Users.Item.comment)
}
#endif
inline void Users_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Users.Item.comment)
}
inline void Users_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Users.Item.comment)
}
inline ::std::string* Users_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.proto.Users.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Users.Item.comment)
}

// bool is_disabled = 4;
inline void Users_Item::clear_is_disabled() {
  is_disabled_ = false;
}
inline bool Users_Item::is_disabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_disabled)
  return is_disabled_;
}
inline void Users_Item::set_is_disabled(bool value) {
  
  is_disabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_disabled)
}

// bool is_password_cant_change = 5;
inline void Users_Item::clear_is_password_cant_change() {
  is_password_cant_change_ = false;
}
inline bool Users_Item::is_password_cant_change() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_password_cant_change)
  return is_password_cant_change_;
}
inline void Users_Item::set_is_password_cant_change(bool value) {
  
  is_password_cant_change_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_password_cant_change)
}

// bool is_password_expired = 6;
inline void Users_Item::clear_is_password_expired() {
  is_password_expired_ = false;
}
inline bool Users_Item::is_password_expired() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_password_expired)
  return is_password_expired_;
}
inline void Users_Item::set_is_password_expired(bool value) {
  
  is_password_expired_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_password_expired)
}

// bool is_dont_expire_password = 7;
inline void Users_Item::clear_is_dont_expire_password() {
  is_dont_expire_password_ = false;
}
inline bool Users_Item::is_dont_expire_password() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_dont_expire_password)
  return is_dont_expire_password_;
}
inline void Users_Item::set_is_dont_expire_password(bool value) {
  
  is_dont_expire_password_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_dont_expire_password)
}

// bool is_lockout = 8;
inline void Users_Item::clear_is_lockout() {
  is_lockout_ = false;
}
inline bool Users_Item::is_lockout() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_lockout)
  return is_lockout_;
}
inline void Users_Item::set_is_lockout(bool value) {
  
  is_lockout_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_lockout)
}

// uint32 number_logons = 9;
inline void Users_Item::clear_number_logons() {
  number_logons_ = 0u;
}
inline ::google::protobuf::uint32 Users_Item::number_logons() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.number_logons)
  return number_logons_;
}
inline void Users_Item::set_number_logons(::google::protobuf::uint32 value) {
  
  number_logons_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.number_logons)
}

// uint32 bad_password_count = 10;
inline void Users_Item::clear_bad_password_count() {
  bad_password_count_ = 0u;
}
inline ::google::protobuf::uint32 Users_Item::bad_password_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.bad_password_count)
  return bad_password_count_;
}
inline void Users_Item::set_bad_password_count(::google::protobuf::uint32 value) {
  
  bad_password_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.bad_password_count)
}

// int64 last_logon_time = 11;
inline void Users_Item::clear_last_logon_time() {
  last_logon_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Users_Item::last_logon_time() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.last_logon_time)
  return last_logon_time_;
}
inline void Users_Item::set_last_logon_time(::google::protobuf::int64 value) {
  
  last_logon_time_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.last_logon_time)
}

// -------------------------------------------------------------------

// Users

// repeated .aspia.proto.Users.Item item = 1;
inline int Users::item_size() const {
  return item_.size();
}
inline void Users::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Users_Item& Users::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.item)
  return item_.Get(index);
}
inline ::aspia::proto::Users_Item* Users::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Users_Item* Users::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Users.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >*
Users::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Users.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >&
Users::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Users.item)
  return item_;
}

// -------------------------------------------------------------------

// UserGroups_Item

// string name = 1;
inline void UserGroups_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserGroups_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.UserGroups.Item.name)
  return name_.GetNoArena();
}
inline void UserGroups_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.UserGroups.Item.name)
}
#if LANG_CXX11
inline void UserGroups_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.UserGroups.Item.name)
}
#endif
inline void UserGroups_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.UserGroups.Item.name)
}
inline void UserGroups_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.UserGroups.Item.name)
}
inline ::std::string* UserGroups_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.UserGroups.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserGroups_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.UserGroups.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserGroups_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.UserGroups.Item.name)
}

// string comment = 2;
inline void UserGroups_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserGroups_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.proto.UserGroups.Item.comment)
  return comment_.GetNoArena();
}
inline void UserGroups_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.UserGroups.Item.comment)
}
#if LANG_CXX11
inline void UserGroups_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.UserGroups.Item.comment)
}
#endif
inline void UserGroups_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.UserGroups.Item.comment)
}
inline void UserGroups_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.UserGroups.Item.comment)
}
inline ::std::string* UserGroups_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.UserGroups.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserGroups_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.proto.UserGroups.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserGroups_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.UserGroups.Item.comment)
}

// -------------------------------------------------------------------

// UserGroups

// repeated .aspia.proto.UserGroups.Item item = 1;
inline int UserGroups::item_size() const {
  return item_.size();
}
inline void UserGroups::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::UserGroups_Item& UserGroups::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.UserGroups.item)
  return item_.Get(index);
}
inline ::aspia::proto::UserGroups_Item* UserGroups::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.UserGroups.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::UserGroups_Item* UserGroups::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.UserGroups.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >*
UserGroups::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.UserGroups.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >&
UserGroups::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.UserGroups.item)
  return item_;
}

// -------------------------------------------------------------------

// Sessions_Item

// string user_name = 1;
inline void Sessions_Item::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::user_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.user_name)
  return user_name_.GetNoArena();
}
inline void Sessions_Item::set_user_name(const ::std::string& value) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.user_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_user_name(::std::string&& value) {
  
  user_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.user_name)
}
#endif
inline void Sessions_Item::set_user_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.user_name)
}
inline void Sessions_Item::set_user_name(const char* value, size_t size) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.user_name)
}
inline ::std::string* Sessions_Item::mutable_user_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_user_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.user_name)
  
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    
  } else {
    
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.user_name)
}

// string domain_name = 2;
inline void Sessions_Item::clear_domain_name() {
  domain_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::domain_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.domain_name)
  return domain_name_.GetNoArena();
}
inline void Sessions_Item::set_domain_name(const ::std::string& value) {
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.domain_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_domain_name(::std::string&& value) {
  
  domain_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.domain_name)
}
#endif
inline void Sessions_Item::set_domain_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.domain_name)
}
inline void Sessions_Item::set_domain_name(const char* value, size_t size) {
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.domain_name)
}
inline ::std::string* Sessions_Item::mutable_domain_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.domain_name)
  return domain_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_domain_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.domain_name)
  
  return domain_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_domain_name(::std::string* domain_name) {
  if (domain_name != NULL) {
    
  } else {
    
  }
  domain_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.domain_name)
}

// uint32 session_id = 3;
inline void Sessions_Item::clear_session_id() {
  session_id_ = 0u;
}
inline ::google::protobuf::uint32 Sessions_Item::session_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.session_id)
  return session_id_;
}
inline void Sessions_Item::set_session_id(::google::protobuf::uint32 value) {
  
  session_id_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.session_id)
}

// .aspia.proto.Sessions.ConnectState connect_state = 4;
inline void Sessions_Item::clear_connect_state() {
  connect_state_ = 0;
}
inline ::aspia::proto::Sessions_ConnectState Sessions_Item::connect_state() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.connect_state)
  return static_cast< ::aspia::proto::Sessions_ConnectState >(connect_state_);
}
inline void Sessions_Item::set_connect_state(::aspia::proto::Sessions_ConnectState value) {
  
  connect_state_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.connect_state)
}

// string client_name = 5;
inline void Sessions_Item::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::client_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.client_name)
  return client_name_.GetNoArena();
}
inline void Sessions_Item::set_client_name(const ::std::string& value) {
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.client_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_client_name(::std::string&& value) {
  
  client_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.client_name)
}
#endif
inline void Sessions_Item::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.client_name)
}
inline void Sessions_Item::set_client_name(const char* value, size_t size) {
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.client_name)
}
inline ::std::string* Sessions_Item::mutable_client_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.client_name)
  return client_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_client_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.client_name)
  
  return client_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_client_name(::std::string* client_name) {
  if (client_name != NULL) {
    
  } else {
    
  }
  client_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.client_name)
}

// string winstation_name = 6;
inline void Sessions_Item::clear_winstation_name() {
  winstation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::winstation_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.winstation_name)
  return winstation_name_.GetNoArena();
}
inline void Sessions_Item::set_winstation_name(const ::std::string& value) {
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.winstation_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_winstation_name(::std::string&& value) {
  
  winstation_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.winstation_name)
}
#endif
inline void Sessions_Item::set_winstation_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.winstation_name)
}
inline void Sessions_Item::set_winstation_name(const char* value, size_t size) {
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.winstation_name)
}
inline ::std::string* Sessions_Item::mutable_winstation_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.winstation_name)
  return winstation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_winstation_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.winstation_name)
  
  return winstation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_winstation_name(::std::string* winstation_name) {
  if (winstation_name != NULL) {
    
  } else {
    
  }
  winstation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), winstation_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.winstation_name)
}

// -------------------------------------------------------------------

// Sessions

// repeated .aspia.proto.Sessions.Item item = 1;
inline int Sessions::item_size() const {
  return item_.size();
}
inline void Sessions::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Sessions_Item& Sessions::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.item)
  return item_.Get(index);
}
inline ::aspia::proto::Sessions_Item* Sessions::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Sessions_Item* Sessions::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Sessions.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >*
Sessions::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Sessions.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >&
Sessions::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Sessions.item)
  return item_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace aspia

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aspia::proto::DmiSystem_WakeupType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiBaseboard_BoardType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiChassis_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiChassis_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiChassis_SecurityStatus> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_Location> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_Mode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_SRAMType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_ErrorCorrectionType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_Associativity> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiProcessors_Family> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiProcessors_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiProcessors_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiProcessors_Upgrade> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiProcessors_Characteristics> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiMemoryDevices_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiMemoryDevices_FormFactor> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiSystemSlots_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiSystemSlots_Usage> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiSystemSlots_BusWidth> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiSystemSlots_Length> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPortConnectors_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPortConnectors_ConnectorType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiOnBoardDevices_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPointingDevices_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPointingDevices_Interface> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPortableBattery_Chemistry> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Services_Item_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Services_Item_StartupType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::OpenConnections_Protocol> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::OpenConnections_State> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::SharedResources_Item_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Sessions_ConnectState> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED

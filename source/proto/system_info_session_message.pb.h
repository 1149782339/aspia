// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system_info_session_message.proto

#ifndef PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED
#define PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
namespace aspia {
namespace system_info {
class DmiBaseboard;
class DmiBaseboardDefaultTypeInternal;
extern DmiBaseboardDefaultTypeInternal _DmiBaseboard_default_instance_;
class DmiBaseboard_Item;
class DmiBaseboard_ItemDefaultTypeInternal;
extern DmiBaseboard_ItemDefaultTypeInternal _DmiBaseboard_Item_default_instance_;
class DmiBaseboard_Item_Feature;
class DmiBaseboard_Item_FeatureDefaultTypeInternal;
extern DmiBaseboard_Item_FeatureDefaultTypeInternal _DmiBaseboard_Item_Feature_default_instance_;
class DmiBios;
class DmiBiosDefaultTypeInternal;
extern DmiBiosDefaultTypeInternal _DmiBios_default_instance_;
class DmiBios_Feature;
class DmiBios_FeatureDefaultTypeInternal;
extern DmiBios_FeatureDefaultTypeInternal _DmiBios_Feature_default_instance_;
class DmiChassis;
class DmiChassisDefaultTypeInternal;
extern DmiChassisDefaultTypeInternal _DmiChassis_default_instance_;
class DmiChassis_Item;
class DmiChassis_ItemDefaultTypeInternal;
extern DmiChassis_ItemDefaultTypeInternal _DmiChassis_Item_default_instance_;
class DmiSystem;
class DmiSystemDefaultTypeInternal;
extern DmiSystemDefaultTypeInternal _DmiSystem_default_instance_;
class Monitors;
class MonitorsDefaultTypeInternal;
extern MonitorsDefaultTypeInternal _Monitors_default_instance_;
class Monitors_Item;
class Monitors_ItemDefaultTypeInternal;
extern Monitors_ItemDefaultTypeInternal _Monitors_Item_default_instance_;
class Monitors_Item_Timing;
class Monitors_Item_TimingDefaultTypeInternal;
extern Monitors_Item_TimingDefaultTypeInternal _Monitors_Item_Timing_default_instance_;
class NetworkCards;
class NetworkCardsDefaultTypeInternal;
extern NetworkCardsDefaultTypeInternal _NetworkCards_default_instance_;
class NetworkCards_Item;
class NetworkCards_ItemDefaultTypeInternal;
extern NetworkCards_ItemDefaultTypeInternal _NetworkCards_Item_default_instance_;
class NetworkCards_Item_IpAddress;
class NetworkCards_Item_IpAddressDefaultTypeInternal;
extern NetworkCards_Item_IpAddressDefaultTypeInternal _NetworkCards_Item_IpAddress_default_instance_;
class OpenConnections;
class OpenConnectionsDefaultTypeInternal;
extern OpenConnectionsDefaultTypeInternal _OpenConnections_default_instance_;
class OpenConnections_Item;
class OpenConnections_ItemDefaultTypeInternal;
extern OpenConnections_ItemDefaultTypeInternal _OpenConnections_Item_default_instance_;
class Printers;
class PrintersDefaultTypeInternal;
extern PrintersDefaultTypeInternal _Printers_default_instance_;
class Printers_Item;
class Printers_ItemDefaultTypeInternal;
extern Printers_ItemDefaultTypeInternal _Printers_Item_default_instance_;
class Routes;
class RoutesDefaultTypeInternal;
extern RoutesDefaultTypeInternal _Routes_default_instance_;
class Routes_Item;
class Routes_ItemDefaultTypeInternal;
extern Routes_ItemDefaultTypeInternal _Routes_Item_default_instance_;
class Services;
class ServicesDefaultTypeInternal;
extern ServicesDefaultTypeInternal _Services_default_instance_;
class Services_Item;
class Services_ItemDefaultTypeInternal;
extern Services_ItemDefaultTypeInternal _Services_Item_default_instance_;
class Sessions;
class SessionsDefaultTypeInternal;
extern SessionsDefaultTypeInternal _Sessions_default_instance_;
class Sessions_Item;
class Sessions_ItemDefaultTypeInternal;
extern Sessions_ItemDefaultTypeInternal _Sessions_Item_default_instance_;
class SharedResources;
class SharedResourcesDefaultTypeInternal;
extern SharedResourcesDefaultTypeInternal _SharedResources_default_instance_;
class SharedResources_Item;
class SharedResources_ItemDefaultTypeInternal;
extern SharedResources_ItemDefaultTypeInternal _SharedResources_Item_default_instance_;
class UserGroups;
class UserGroupsDefaultTypeInternal;
extern UserGroupsDefaultTypeInternal _UserGroups_default_instance_;
class UserGroups_Item;
class UserGroups_ItemDefaultTypeInternal;
extern UserGroups_ItemDefaultTypeInternal _UserGroups_Item_default_instance_;
class Users;
class UsersDefaultTypeInternal;
extern UsersDefaultTypeInternal _Users_default_instance_;
class Users_Item;
class Users_ItemDefaultTypeInternal;
extern Users_ItemDefaultTypeInternal _Users_Item_default_instance_;
}  // namespace system_info
}  // namespace aspia

namespace aspia {
namespace system_info {

namespace protobuf_system_5finfo_5fsession_5fmessage_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_system_5finfo_5fsession_5fmessage_2eproto

enum DmiBaseboard_Item_BoardType {
  DmiBaseboard_Item_BoardType_BOARD_TYPE_UNKNOWN = 0,
  DmiBaseboard_Item_BoardType_BOARD_TYPE_OTHER = 1,
  DmiBaseboard_Item_BoardType_BOARD_TYPE_SERVER_BLADE = 2,
  DmiBaseboard_Item_BoardType_BOARD_TYPE_CONNECTIVITY_SWITCH = 3,
  DmiBaseboard_Item_BoardType_BOARD_TYPE_SYSTEM_MANAGEMENT_MODULE = 4,
  DmiBaseboard_Item_BoardType_BOARD_TYPE_PROCESSOR_MODULE = 5,
  DmiBaseboard_Item_BoardType_BOARD_TYPE_IO_MODULE = 6,
  DmiBaseboard_Item_BoardType_BOARD_TYPE_MEMORY_MODULE = 7,
  DmiBaseboard_Item_BoardType_BOARD_TYPE_DAUGHTER_BOARD = 8,
  DmiBaseboard_Item_BoardType_BOARD_TYPE_MOTHERBOARD = 9,
  DmiBaseboard_Item_BoardType_BOARD_TYPE_PROCESSOR_PLUS_MEMORY_MODULE = 10,
  DmiBaseboard_Item_BoardType_BOARD_TYPE_PROCESSOR_PLUS_IO_MODULE = 11,
  DmiBaseboard_Item_BoardType_BOARD_TYPE_INTERCONNECT_BOARD = 12,
  DmiBaseboard_Item_BoardType_DmiBaseboard_Item_BoardType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiBaseboard_Item_BoardType_DmiBaseboard_Item_BoardType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiBaseboard_Item_BoardType_IsValid(int value);
const DmiBaseboard_Item_BoardType DmiBaseboard_Item_BoardType_BoardType_MIN = DmiBaseboard_Item_BoardType_BOARD_TYPE_UNKNOWN;
const DmiBaseboard_Item_BoardType DmiBaseboard_Item_BoardType_BoardType_MAX = DmiBaseboard_Item_BoardType_BOARD_TYPE_INTERCONNECT_BOARD;
const int DmiBaseboard_Item_BoardType_BoardType_ARRAYSIZE = DmiBaseboard_Item_BoardType_BoardType_MAX + 1;

enum DmiChassis_Item_Type {
  DmiChassis_Item_Type_TYPE_UNKNOWN = 0,
  DmiChassis_Item_Type_TYPE_OTHER = 1,
  DmiChassis_Item_Type_TYPE_DESKTOP = 2,
  DmiChassis_Item_Type_TYPE_LOW_PROFILE_DESKTOP = 3,
  DmiChassis_Item_Type_TYPE_PIZZA_BOX = 4,
  DmiChassis_Item_Type_TYPE_MINI_TOWER = 5,
  DmiChassis_Item_Type_TYPE_TOWER = 6,
  DmiChassis_Item_Type_TYPE_PORTABLE = 7,
  DmiChassis_Item_Type_TYPE_LAPTOP = 8,
  DmiChassis_Item_Type_TYPE_NOTEBOOK = 9,
  DmiChassis_Item_Type_TYPE_HAND_HELD = 10,
  DmiChassis_Item_Type_TYPE_DOCKING_STATION = 11,
  DmiChassis_Item_Type_TYPE_ALL_IN_ONE = 12,
  DmiChassis_Item_Type_TYPE_SUB_NOTEBOOK = 13,
  DmiChassis_Item_Type_TYPE_SPACE_SAVING = 14,
  DmiChassis_Item_Type_TYPE_LUNCH_BOX = 15,
  DmiChassis_Item_Type_TYPE_MAIN_SERVER_CHASSIS = 16,
  DmiChassis_Item_Type_TYPE_EXPANSION_CHASSIS = 17,
  DmiChassis_Item_Type_TYPE_SUB_CHASSIS = 18,
  DmiChassis_Item_Type_TYPE_BUS_EXPANSION_CHASSIS = 19,
  DmiChassis_Item_Type_TYPE_PERIPHERIAL_CHASSIS = 20,
  DmiChassis_Item_Type_TYPE_RAID_CHASSIS = 21,
  DmiChassis_Item_Type_TYPE_RACK_MOUNT_CHASSIS = 22,
  DmiChassis_Item_Type_TYPE_SEALED_CASE_PC = 23,
  DmiChassis_Item_Type_TYPE_MULTI_SYSTEM_CHASSIS = 24,
  DmiChassis_Item_Type_TYPE_COMPACT_PCI = 25,
  DmiChassis_Item_Type_TYPE_ADVANCED_TCA = 26,
  DmiChassis_Item_Type_TYPE_BLADE = 27,
  DmiChassis_Item_Type_TYPE_BLADE_ENCLOSURE = 28,
  DmiChassis_Item_Type_DmiChassis_Item_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiChassis_Item_Type_DmiChassis_Item_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiChassis_Item_Type_IsValid(int value);
const DmiChassis_Item_Type DmiChassis_Item_Type_Type_MIN = DmiChassis_Item_Type_TYPE_UNKNOWN;
const DmiChassis_Item_Type DmiChassis_Item_Type_Type_MAX = DmiChassis_Item_Type_TYPE_BLADE_ENCLOSURE;
const int DmiChassis_Item_Type_Type_ARRAYSIZE = DmiChassis_Item_Type_Type_MAX + 1;

enum DmiChassis_Item_Status {
  DmiChassis_Item_Status_STATUS_UNKNOWN = 0,
  DmiChassis_Item_Status_STATUS_OTHER = 1,
  DmiChassis_Item_Status_STATUS_SAFE = 2,
  DmiChassis_Item_Status_STATUS_WARNING = 3,
  DmiChassis_Item_Status_STATUS_CRITICAL = 4,
  DmiChassis_Item_Status_STATUS_NON_RECOVERABLE = 5,
  DmiChassis_Item_Status_DmiChassis_Item_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiChassis_Item_Status_DmiChassis_Item_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiChassis_Item_Status_IsValid(int value);
const DmiChassis_Item_Status DmiChassis_Item_Status_Status_MIN = DmiChassis_Item_Status_STATUS_UNKNOWN;
const DmiChassis_Item_Status DmiChassis_Item_Status_Status_MAX = DmiChassis_Item_Status_STATUS_NON_RECOVERABLE;
const int DmiChassis_Item_Status_Status_ARRAYSIZE = DmiChassis_Item_Status_Status_MAX + 1;

enum DmiChassis_Item_SecurityStatus {
  DmiChassis_Item_SecurityStatus_SECURITY_STATUS_UNKNOWN = 0,
  DmiChassis_Item_SecurityStatus_SECURITY_STATUS_OTHER = 1,
  DmiChassis_Item_SecurityStatus_SECURITY_STATUS_NONE = 2,
  DmiChassis_Item_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_LOCKED_OUT = 3,
  DmiChassis_Item_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED = 4,
  DmiChassis_Item_SecurityStatus_DmiChassis_Item_SecurityStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiChassis_Item_SecurityStatus_DmiChassis_Item_SecurityStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiChassis_Item_SecurityStatus_IsValid(int value);
const DmiChassis_Item_SecurityStatus DmiChassis_Item_SecurityStatus_SecurityStatus_MIN = DmiChassis_Item_SecurityStatus_SECURITY_STATUS_UNKNOWN;
const DmiChassis_Item_SecurityStatus DmiChassis_Item_SecurityStatus_SecurityStatus_MAX = DmiChassis_Item_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED;
const int DmiChassis_Item_SecurityStatus_SecurityStatus_ARRAYSIZE = DmiChassis_Item_SecurityStatus_SecurityStatus_MAX + 1;

enum Monitors_Item_InputSignalType {
  Monitors_Item_InputSignalType_INPUT_SIGNAL_TYPE_UNKNOWN = 0,
  Monitors_Item_InputSignalType_INPUT_SIGNAL_TYPE_ANALOG = 1,
  Monitors_Item_InputSignalType_INPUT_SIGNAL_TYPE_DIGITAL = 2,
  Monitors_Item_InputSignalType_Monitors_Item_InputSignalType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Monitors_Item_InputSignalType_Monitors_Item_InputSignalType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Monitors_Item_InputSignalType_IsValid(int value);
const Monitors_Item_InputSignalType Monitors_Item_InputSignalType_InputSignalType_MIN = Monitors_Item_InputSignalType_INPUT_SIGNAL_TYPE_UNKNOWN;
const Monitors_Item_InputSignalType Monitors_Item_InputSignalType_InputSignalType_MAX = Monitors_Item_InputSignalType_INPUT_SIGNAL_TYPE_DIGITAL;
const int Monitors_Item_InputSignalType_InputSignalType_ARRAYSIZE = Monitors_Item_InputSignalType_InputSignalType_MAX + 1;

enum Printers_Item_Orientation {
  Printers_Item_Orientation_ORIENTATION_UNKNOWN = 0,
  Printers_Item_Orientation_ORIENTATION_PORTRAIT = 1,
  Printers_Item_Orientation_ORIENTATION_LANDSCAPE = 2,
  Printers_Item_Orientation_Printers_Item_Orientation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Printers_Item_Orientation_Printers_Item_Orientation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Printers_Item_Orientation_IsValid(int value);
const Printers_Item_Orientation Printers_Item_Orientation_Orientation_MIN = Printers_Item_Orientation_ORIENTATION_UNKNOWN;
const Printers_Item_Orientation Printers_Item_Orientation_Orientation_MAX = Printers_Item_Orientation_ORIENTATION_LANDSCAPE;
const int Printers_Item_Orientation_Orientation_ARRAYSIZE = Printers_Item_Orientation_Orientation_MAX + 1;

enum Services_Item_Status {
  Services_Item_Status_STATUS_UNKNOWN = 0,
  Services_Item_Status_STATUS_CONTINUE_PENDING = 1,
  Services_Item_Status_STATUS_PAUSE_PENDING = 2,
  Services_Item_Status_STATUS_PAUSED = 3,
  Services_Item_Status_STATUS_RUNNING = 4,
  Services_Item_Status_STATUS_START_PENDING = 5,
  Services_Item_Status_STATUS_STOP_PENDING = 6,
  Services_Item_Status_STATUS_STOPPED = 7,
  Services_Item_Status_Services_Item_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Services_Item_Status_Services_Item_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Services_Item_Status_IsValid(int value);
const Services_Item_Status Services_Item_Status_Status_MIN = Services_Item_Status_STATUS_UNKNOWN;
const Services_Item_Status Services_Item_Status_Status_MAX = Services_Item_Status_STATUS_STOPPED;
const int Services_Item_Status_Status_ARRAYSIZE = Services_Item_Status_Status_MAX + 1;

enum Services_Item_StartupType {
  Services_Item_StartupType_STARTUP_TYPE_UNKNOWN = 0,
  Services_Item_StartupType_STARTUP_TYPE_AUTO_START = 1,
  Services_Item_StartupType_STARTUP_TYPE_DEMAND_START = 2,
  Services_Item_StartupType_STARTUP_TYPE_DISABLED = 3,
  Services_Item_StartupType_STARTUP_TYPE_BOOT_START = 4,
  Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START = 5,
  Services_Item_StartupType_Services_Item_StartupType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Services_Item_StartupType_Services_Item_StartupType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Services_Item_StartupType_IsValid(int value);
const Services_Item_StartupType Services_Item_StartupType_StartupType_MIN = Services_Item_StartupType_STARTUP_TYPE_UNKNOWN;
const Services_Item_StartupType Services_Item_StartupType_StartupType_MAX = Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START;
const int Services_Item_StartupType_StartupType_ARRAYSIZE = Services_Item_StartupType_StartupType_MAX + 1;

enum SharedResources_Item_Type {
  SharedResources_Item_Type_TYPE_UNKNOWN = 0,
  SharedResources_Item_Type_TYPE_DISK = 1,
  SharedResources_Item_Type_TYPE_PRINTER = 2,
  SharedResources_Item_Type_TYPE_DEVICE = 3,
  SharedResources_Item_Type_TYPE_IPC = 4,
  SharedResources_Item_Type_TYPE_SPECIAL = 5,
  SharedResources_Item_Type_TYPE_TEMPORARY = 6,
  SharedResources_Item_Type_SharedResources_Item_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SharedResources_Item_Type_SharedResources_Item_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SharedResources_Item_Type_IsValid(int value);
const SharedResources_Item_Type SharedResources_Item_Type_Type_MIN = SharedResources_Item_Type_TYPE_UNKNOWN;
const SharedResources_Item_Type SharedResources_Item_Type_Type_MAX = SharedResources_Item_Type_TYPE_TEMPORARY;
const int SharedResources_Item_Type_Type_ARRAYSIZE = SharedResources_Item_Type_Type_MAX + 1;

// ===================================================================

class DmiBios_Feature : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.DmiBios.Feature) */ {
 public:
  DmiBios_Feature();
  virtual ~DmiBios_Feature();

  DmiBios_Feature(const DmiBios_Feature& from);

  inline DmiBios_Feature& operator=(const DmiBios_Feature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBios_Feature(DmiBios_Feature&& from) noexcept
    : DmiBios_Feature() {
    *this = ::std::move(from);
  }

  inline DmiBios_Feature& operator=(DmiBios_Feature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBios_Feature& default_instance();

  static inline const DmiBios_Feature* internal_default_instance() {
    return reinterpret_cast<const DmiBios_Feature*>(
               &_DmiBios_Feature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DmiBios_Feature* other);
  friend void swap(DmiBios_Feature& a, DmiBios_Feature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBios_Feature* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBios_Feature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBios_Feature& from);
  void MergeFrom(const DmiBios_Feature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBios_Feature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool supported = 2;
  void clear_supported();
  static const int kSupportedFieldNumber = 2;
  bool supported() const;
  void set_supported(bool value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.DmiBios.Feature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool supported_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DmiBios : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.DmiBios) */ {
 public:
  DmiBios();
  virtual ~DmiBios();

  DmiBios(const DmiBios& from);

  inline DmiBios& operator=(const DmiBios& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBios(DmiBios&& from) noexcept
    : DmiBios() {
    *this = ::std::move(from);
  }

  inline DmiBios& operator=(DmiBios&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBios& default_instance();

  static inline const DmiBios* internal_default_instance() {
    return reinterpret_cast<const DmiBios*>(
               &_DmiBios_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DmiBios* other);
  friend void swap(DmiBios& a, DmiBios& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBios* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBios* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBios& from);
  void MergeFrom(const DmiBios& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBios* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiBios_Feature Feature;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.DmiBios.Feature feature = 9;
  int feature_size() const;
  void clear_feature();
  static const int kFeatureFieldNumber = 9;
  const ::aspia::system_info::DmiBios_Feature& feature(int index) const;
  ::aspia::system_info::DmiBios_Feature* mutable_feature(int index);
  ::aspia::system_info::DmiBios_Feature* add_feature();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBios_Feature >*
      mutable_feature();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBios_Feature >&
      feature() const;

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string date = 3;
  void clear_date();
  static const int kDateFieldNumber = 3;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // string bios_revision = 5;
  void clear_bios_revision();
  static const int kBiosRevisionFieldNumber = 5;
  const ::std::string& bios_revision() const;
  void set_bios_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_bios_revision(::std::string&& value);
  #endif
  void set_bios_revision(const char* value);
  void set_bios_revision(const char* value, size_t size);
  ::std::string* mutable_bios_revision();
  ::std::string* release_bios_revision();
  void set_allocated_bios_revision(::std::string* bios_revision);

  // string firmware_revision = 6;
  void clear_firmware_revision();
  static const int kFirmwareRevisionFieldNumber = 6;
  const ::std::string& firmware_revision() const;
  void set_firmware_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_firmware_revision(::std::string&& value);
  #endif
  void set_firmware_revision(const char* value);
  void set_firmware_revision(const char* value, size_t size);
  ::std::string* mutable_firmware_revision();
  ::std::string* release_firmware_revision();
  void set_allocated_firmware_revision(::std::string* firmware_revision);

  // string address = 7;
  void clear_address();
  static const int kAddressFieldNumber = 7;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // int32 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // int32 runtime_size = 8;
  void clear_runtime_size();
  static const int kRuntimeSizeFieldNumber = 8;
  ::google::protobuf::int32 runtime_size() const;
  void set_runtime_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.DmiBios)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBios_Feature > feature_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr bios_revision_;
  ::google::protobuf::internal::ArenaStringPtr firmware_revision_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 runtime_size_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DmiSystem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.DmiSystem) */ {
 public:
  DmiSystem();
  virtual ~DmiSystem();

  DmiSystem(const DmiSystem& from);

  inline DmiSystem& operator=(const DmiSystem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiSystem(DmiSystem&& from) noexcept
    : DmiSystem() {
    *this = ::std::move(from);
  }

  inline DmiSystem& operator=(DmiSystem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiSystem& default_instance();

  static inline const DmiSystem* internal_default_instance() {
    return reinterpret_cast<const DmiSystem*>(
               &_DmiSystem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DmiSystem* other);
  friend void swap(DmiSystem& a, DmiSystem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiSystem* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiSystem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiSystem& from);
  void MergeFrom(const DmiSystem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiSystem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string product_name = 2;
  void clear_product_name();
  static const int kProductNameFieldNumber = 2;
  const ::std::string& product_name() const;
  void set_product_name(const ::std::string& value);
  #if LANG_CXX11
  void set_product_name(::std::string&& value);
  #endif
  void set_product_name(const char* value);
  void set_product_name(const char* value, size_t size);
  ::std::string* mutable_product_name();
  ::std::string* release_product_name();
  void set_allocated_product_name(::std::string* product_name);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string uuid = 5;
  void clear_uuid();
  static const int kUuidFieldNumber = 5;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // string wakeup_type = 6;
  void clear_wakeup_type();
  static const int kWakeupTypeFieldNumber = 6;
  const ::std::string& wakeup_type() const;
  void set_wakeup_type(const ::std::string& value);
  #if LANG_CXX11
  void set_wakeup_type(::std::string&& value);
  #endif
  void set_wakeup_type(const char* value);
  void set_wakeup_type(const char* value, size_t size);
  ::std::string* mutable_wakeup_type();
  ::std::string* release_wakeup_type();
  void set_allocated_wakeup_type(::std::string* wakeup_type);

  // string sku_number = 7;
  void clear_sku_number();
  static const int kSkuNumberFieldNumber = 7;
  const ::std::string& sku_number() const;
  void set_sku_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sku_number(::std::string&& value);
  #endif
  void set_sku_number(const char* value);
  void set_sku_number(const char* value, size_t size);
  ::std::string* mutable_sku_number();
  ::std::string* release_sku_number();
  void set_allocated_sku_number(::std::string* sku_number);

  // string family = 8;
  void clear_family();
  static const int kFamilyFieldNumber = 8;
  const ::std::string& family() const;
  void set_family(const ::std::string& value);
  #if LANG_CXX11
  void set_family(::std::string&& value);
  #endif
  void set_family(const char* value);
  void set_family(const char* value, size_t size);
  ::std::string* mutable_family();
  ::std::string* release_family();
  void set_allocated_family(::std::string* family);

  // @@protoc_insertion_point(class_scope:aspia.system_info.DmiSystem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr product_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr wakeup_type_;
  ::google::protobuf::internal::ArenaStringPtr sku_number_;
  ::google::protobuf::internal::ArenaStringPtr family_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DmiBaseboard_Item_Feature : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.DmiBaseboard.Item.Feature) */ {
 public:
  DmiBaseboard_Item_Feature();
  virtual ~DmiBaseboard_Item_Feature();

  DmiBaseboard_Item_Feature(const DmiBaseboard_Item_Feature& from);

  inline DmiBaseboard_Item_Feature& operator=(const DmiBaseboard_Item_Feature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBaseboard_Item_Feature(DmiBaseboard_Item_Feature&& from) noexcept
    : DmiBaseboard_Item_Feature() {
    *this = ::std::move(from);
  }

  inline DmiBaseboard_Item_Feature& operator=(DmiBaseboard_Item_Feature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBaseboard_Item_Feature& default_instance();

  static inline const DmiBaseboard_Item_Feature* internal_default_instance() {
    return reinterpret_cast<const DmiBaseboard_Item_Feature*>(
               &_DmiBaseboard_Item_Feature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DmiBaseboard_Item_Feature* other);
  friend void swap(DmiBaseboard_Item_Feature& a, DmiBaseboard_Item_Feature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBaseboard_Item_Feature* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBaseboard_Item_Feature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBaseboard_Item_Feature& from);
  void MergeFrom(const DmiBaseboard_Item_Feature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBaseboard_Item_Feature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool supported = 2;
  void clear_supported();
  static const int kSupportedFieldNumber = 2;
  bool supported() const;
  void set_supported(bool value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.DmiBaseboard.Item.Feature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool supported_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DmiBaseboard_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.DmiBaseboard.Item) */ {
 public:
  DmiBaseboard_Item();
  virtual ~DmiBaseboard_Item();

  DmiBaseboard_Item(const DmiBaseboard_Item& from);

  inline DmiBaseboard_Item& operator=(const DmiBaseboard_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBaseboard_Item(DmiBaseboard_Item&& from) noexcept
    : DmiBaseboard_Item() {
    *this = ::std::move(from);
  }

  inline DmiBaseboard_Item& operator=(DmiBaseboard_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBaseboard_Item& default_instance();

  static inline const DmiBaseboard_Item* internal_default_instance() {
    return reinterpret_cast<const DmiBaseboard_Item*>(
               &_DmiBaseboard_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DmiBaseboard_Item* other);
  friend void swap(DmiBaseboard_Item& a, DmiBaseboard_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBaseboard_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBaseboard_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBaseboard_Item& from);
  void MergeFrom(const DmiBaseboard_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBaseboard_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiBaseboard_Item_Feature Feature;

  typedef DmiBaseboard_Item_BoardType BoardType;
  static const BoardType BOARD_TYPE_UNKNOWN =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_UNKNOWN;
  static const BoardType BOARD_TYPE_OTHER =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_OTHER;
  static const BoardType BOARD_TYPE_SERVER_BLADE =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_SERVER_BLADE;
  static const BoardType BOARD_TYPE_CONNECTIVITY_SWITCH =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_CONNECTIVITY_SWITCH;
  static const BoardType BOARD_TYPE_SYSTEM_MANAGEMENT_MODULE =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_SYSTEM_MANAGEMENT_MODULE;
  static const BoardType BOARD_TYPE_PROCESSOR_MODULE =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_PROCESSOR_MODULE;
  static const BoardType BOARD_TYPE_IO_MODULE =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_IO_MODULE;
  static const BoardType BOARD_TYPE_MEMORY_MODULE =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_MEMORY_MODULE;
  static const BoardType BOARD_TYPE_DAUGHTER_BOARD =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_DAUGHTER_BOARD;
  static const BoardType BOARD_TYPE_MOTHERBOARD =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_MOTHERBOARD;
  static const BoardType BOARD_TYPE_PROCESSOR_PLUS_MEMORY_MODULE =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_PROCESSOR_PLUS_MEMORY_MODULE;
  static const BoardType BOARD_TYPE_PROCESSOR_PLUS_IO_MODULE =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_PROCESSOR_PLUS_IO_MODULE;
  static const BoardType BOARD_TYPE_INTERCONNECT_BOARD =
    DmiBaseboard_Item_BoardType_BOARD_TYPE_INTERCONNECT_BOARD;
  static inline bool BoardType_IsValid(int value) {
    return DmiBaseboard_Item_BoardType_IsValid(value);
  }
  static const BoardType BoardType_MIN =
    DmiBaseboard_Item_BoardType_BoardType_MIN;
  static const BoardType BoardType_MAX =
    DmiBaseboard_Item_BoardType_BoardType_MAX;
  static const int BoardType_ARRAYSIZE =
    DmiBaseboard_Item_BoardType_BoardType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.DmiBaseboard.Item.Feature feature = 6;
  int feature_size() const;
  void clear_feature();
  static const int kFeatureFieldNumber = 6;
  const ::aspia::system_info::DmiBaseboard_Item_Feature& feature(int index) const;
  ::aspia::system_info::DmiBaseboard_Item_Feature* mutable_feature(int index);
  ::aspia::system_info::DmiBaseboard_Item_Feature* add_feature();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBaseboard_Item_Feature >*
      mutable_feature();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBaseboard_Item_Feature >&
      feature() const;

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string product_name = 2;
  void clear_product_name();
  static const int kProductNameFieldNumber = 2;
  const ::std::string& product_name() const;
  void set_product_name(const ::std::string& value);
  #if LANG_CXX11
  void set_product_name(::std::string&& value);
  #endif
  void set_product_name(const char* value);
  void set_product_name(const char* value, size_t size);
  ::std::string* mutable_product_name();
  ::std::string* release_product_name();
  void set_allocated_product_name(::std::string* product_name);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 5;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 5;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // string location_in_chassis = 7;
  void clear_location_in_chassis();
  static const int kLocationInChassisFieldNumber = 7;
  const ::std::string& location_in_chassis() const;
  void set_location_in_chassis(const ::std::string& value);
  #if LANG_CXX11
  void set_location_in_chassis(::std::string&& value);
  #endif
  void set_location_in_chassis(const char* value);
  void set_location_in_chassis(const char* value, size_t size);
  ::std::string* mutable_location_in_chassis();
  ::std::string* release_location_in_chassis();
  void set_allocated_location_in_chassis(::std::string* location_in_chassis);

  // .aspia.system_info.DmiBaseboard.Item.BoardType type = 8;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  ::aspia::system_info::DmiBaseboard_Item_BoardType type() const;
  void set_type(::aspia::system_info::DmiBaseboard_Item_BoardType value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.DmiBaseboard.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBaseboard_Item_Feature > feature_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr product_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  ::google::protobuf::internal::ArenaStringPtr location_in_chassis_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DmiBaseboard : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.DmiBaseboard) */ {
 public:
  DmiBaseboard();
  virtual ~DmiBaseboard();

  DmiBaseboard(const DmiBaseboard& from);

  inline DmiBaseboard& operator=(const DmiBaseboard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBaseboard(DmiBaseboard&& from) noexcept
    : DmiBaseboard() {
    *this = ::std::move(from);
  }

  inline DmiBaseboard& operator=(DmiBaseboard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBaseboard& default_instance();

  static inline const DmiBaseboard* internal_default_instance() {
    return reinterpret_cast<const DmiBaseboard*>(
               &_DmiBaseboard_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(DmiBaseboard* other);
  friend void swap(DmiBaseboard& a, DmiBaseboard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBaseboard* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBaseboard* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBaseboard& from);
  void MergeFrom(const DmiBaseboard& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBaseboard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiBaseboard_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.DmiBaseboard.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::system_info::DmiBaseboard_Item& item(int index) const;
  ::aspia::system_info::DmiBaseboard_Item* mutable_item(int index);
  ::aspia::system_info::DmiBaseboard_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBaseboard_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBaseboard_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.DmiBaseboard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBaseboard_Item > item_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DmiChassis_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.DmiChassis.Item) */ {
 public:
  DmiChassis_Item();
  virtual ~DmiChassis_Item();

  DmiChassis_Item(const DmiChassis_Item& from);

  inline DmiChassis_Item& operator=(const DmiChassis_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiChassis_Item(DmiChassis_Item&& from) noexcept
    : DmiChassis_Item() {
    *this = ::std::move(from);
  }

  inline DmiChassis_Item& operator=(DmiChassis_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiChassis_Item& default_instance();

  static inline const DmiChassis_Item* internal_default_instance() {
    return reinterpret_cast<const DmiChassis_Item*>(
               &_DmiChassis_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(DmiChassis_Item* other);
  friend void swap(DmiChassis_Item& a, DmiChassis_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiChassis_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiChassis_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiChassis_Item& from);
  void MergeFrom(const DmiChassis_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiChassis_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiChassis_Item_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiChassis_Item_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiChassis_Item_Type_TYPE_OTHER;
  static const Type TYPE_DESKTOP =
    DmiChassis_Item_Type_TYPE_DESKTOP;
  static const Type TYPE_LOW_PROFILE_DESKTOP =
    DmiChassis_Item_Type_TYPE_LOW_PROFILE_DESKTOP;
  static const Type TYPE_PIZZA_BOX =
    DmiChassis_Item_Type_TYPE_PIZZA_BOX;
  static const Type TYPE_MINI_TOWER =
    DmiChassis_Item_Type_TYPE_MINI_TOWER;
  static const Type TYPE_TOWER =
    DmiChassis_Item_Type_TYPE_TOWER;
  static const Type TYPE_PORTABLE =
    DmiChassis_Item_Type_TYPE_PORTABLE;
  static const Type TYPE_LAPTOP =
    DmiChassis_Item_Type_TYPE_LAPTOP;
  static const Type TYPE_NOTEBOOK =
    DmiChassis_Item_Type_TYPE_NOTEBOOK;
  static const Type TYPE_HAND_HELD =
    DmiChassis_Item_Type_TYPE_HAND_HELD;
  static const Type TYPE_DOCKING_STATION =
    DmiChassis_Item_Type_TYPE_DOCKING_STATION;
  static const Type TYPE_ALL_IN_ONE =
    DmiChassis_Item_Type_TYPE_ALL_IN_ONE;
  static const Type TYPE_SUB_NOTEBOOK =
    DmiChassis_Item_Type_TYPE_SUB_NOTEBOOK;
  static const Type TYPE_SPACE_SAVING =
    DmiChassis_Item_Type_TYPE_SPACE_SAVING;
  static const Type TYPE_LUNCH_BOX =
    DmiChassis_Item_Type_TYPE_LUNCH_BOX;
  static const Type TYPE_MAIN_SERVER_CHASSIS =
    DmiChassis_Item_Type_TYPE_MAIN_SERVER_CHASSIS;
  static const Type TYPE_EXPANSION_CHASSIS =
    DmiChassis_Item_Type_TYPE_EXPANSION_CHASSIS;
  static const Type TYPE_SUB_CHASSIS =
    DmiChassis_Item_Type_TYPE_SUB_CHASSIS;
  static const Type TYPE_BUS_EXPANSION_CHASSIS =
    DmiChassis_Item_Type_TYPE_BUS_EXPANSION_CHASSIS;
  static const Type TYPE_PERIPHERIAL_CHASSIS =
    DmiChassis_Item_Type_TYPE_PERIPHERIAL_CHASSIS;
  static const Type TYPE_RAID_CHASSIS =
    DmiChassis_Item_Type_TYPE_RAID_CHASSIS;
  static const Type TYPE_RACK_MOUNT_CHASSIS =
    DmiChassis_Item_Type_TYPE_RACK_MOUNT_CHASSIS;
  static const Type TYPE_SEALED_CASE_PC =
    DmiChassis_Item_Type_TYPE_SEALED_CASE_PC;
  static const Type TYPE_MULTI_SYSTEM_CHASSIS =
    DmiChassis_Item_Type_TYPE_MULTI_SYSTEM_CHASSIS;
  static const Type TYPE_COMPACT_PCI =
    DmiChassis_Item_Type_TYPE_COMPACT_PCI;
  static const Type TYPE_ADVANCED_TCA =
    DmiChassis_Item_Type_TYPE_ADVANCED_TCA;
  static const Type TYPE_BLADE =
    DmiChassis_Item_Type_TYPE_BLADE;
  static const Type TYPE_BLADE_ENCLOSURE =
    DmiChassis_Item_Type_TYPE_BLADE_ENCLOSURE;
  static inline bool Type_IsValid(int value) {
    return DmiChassis_Item_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiChassis_Item_Type_Type_MIN;
  static const Type Type_MAX =
    DmiChassis_Item_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiChassis_Item_Type_Type_ARRAYSIZE;

  typedef DmiChassis_Item_Status Status;
  static const Status STATUS_UNKNOWN =
    DmiChassis_Item_Status_STATUS_UNKNOWN;
  static const Status STATUS_OTHER =
    DmiChassis_Item_Status_STATUS_OTHER;
  static const Status STATUS_SAFE =
    DmiChassis_Item_Status_STATUS_SAFE;
  static const Status STATUS_WARNING =
    DmiChassis_Item_Status_STATUS_WARNING;
  static const Status STATUS_CRITICAL =
    DmiChassis_Item_Status_STATUS_CRITICAL;
  static const Status STATUS_NON_RECOVERABLE =
    DmiChassis_Item_Status_STATUS_NON_RECOVERABLE;
  static inline bool Status_IsValid(int value) {
    return DmiChassis_Item_Status_IsValid(value);
  }
  static const Status Status_MIN =
    DmiChassis_Item_Status_Status_MIN;
  static const Status Status_MAX =
    DmiChassis_Item_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    DmiChassis_Item_Status_Status_ARRAYSIZE;

  typedef DmiChassis_Item_SecurityStatus SecurityStatus;
  static const SecurityStatus SECURITY_STATUS_UNKNOWN =
    DmiChassis_Item_SecurityStatus_SECURITY_STATUS_UNKNOWN;
  static const SecurityStatus SECURITY_STATUS_OTHER =
    DmiChassis_Item_SecurityStatus_SECURITY_STATUS_OTHER;
  static const SecurityStatus SECURITY_STATUS_NONE =
    DmiChassis_Item_SecurityStatus_SECURITY_STATUS_NONE;
  static const SecurityStatus SECURITY_STATUS_EXTERNAL_INTERFACE_LOCKED_OUT =
    DmiChassis_Item_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_LOCKED_OUT;
  static const SecurityStatus SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED =
    DmiChassis_Item_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED;
  static inline bool SecurityStatus_IsValid(int value) {
    return DmiChassis_Item_SecurityStatus_IsValid(value);
  }
  static const SecurityStatus SecurityStatus_MIN =
    DmiChassis_Item_SecurityStatus_SecurityStatus_MIN;
  static const SecurityStatus SecurityStatus_MAX =
    DmiChassis_Item_SecurityStatus_SecurityStatus_MAX;
  static const int SecurityStatus_ARRAYSIZE =
    DmiChassis_Item_SecurityStatus_SecurityStatus_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 3;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 3;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 4;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 4;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // .aspia.system_info.DmiChassis.Item.Type type = 5;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::aspia::system_info::DmiChassis_Item_Type type() const;
  void set_type(::aspia::system_info::DmiChassis_Item_Type value);

  // .aspia.system_info.DmiChassis.Item.Status os_load_status = 6;
  void clear_os_load_status();
  static const int kOsLoadStatusFieldNumber = 6;
  ::aspia::system_info::DmiChassis_Item_Status os_load_status() const;
  void set_os_load_status(::aspia::system_info::DmiChassis_Item_Status value);

  // .aspia.system_info.DmiChassis.Item.Status power_source_status = 7;
  void clear_power_source_status();
  static const int kPowerSourceStatusFieldNumber = 7;
  ::aspia::system_info::DmiChassis_Item_Status power_source_status() const;
  void set_power_source_status(::aspia::system_info::DmiChassis_Item_Status value);

  // .aspia.system_info.DmiChassis.Item.Status temparature_status = 8;
  void clear_temparature_status();
  static const int kTemparatureStatusFieldNumber = 8;
  ::aspia::system_info::DmiChassis_Item_Status temparature_status() const;
  void set_temparature_status(::aspia::system_info::DmiChassis_Item_Status value);

  // .aspia.system_info.DmiChassis.Item.SecurityStatus security_status = 9;
  void clear_security_status();
  static const int kSecurityStatusFieldNumber = 9;
  ::aspia::system_info::DmiChassis_Item_SecurityStatus security_status() const;
  void set_security_status(::aspia::system_info::DmiChassis_Item_SecurityStatus value);

  // int32 height = 10;
  void clear_height();
  static const int kHeightFieldNumber = 10;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // int32 number_of_power_cords = 11;
  void clear_number_of_power_cords();
  static const int kNumberOfPowerCordsFieldNumber = 11;
  ::google::protobuf::int32 number_of_power_cords() const;
  void set_number_of_power_cords(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.DmiChassis.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  int type_;
  int os_load_status_;
  int power_source_status_;
  int temparature_status_;
  int security_status_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 number_of_power_cords_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DmiChassis : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.DmiChassis) */ {
 public:
  DmiChassis();
  virtual ~DmiChassis();

  DmiChassis(const DmiChassis& from);

  inline DmiChassis& operator=(const DmiChassis& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiChassis(DmiChassis&& from) noexcept
    : DmiChassis() {
    *this = ::std::move(from);
  }

  inline DmiChassis& operator=(DmiChassis&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiChassis& default_instance();

  static inline const DmiChassis* internal_default_instance() {
    return reinterpret_cast<const DmiChassis*>(
               &_DmiChassis_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(DmiChassis* other);
  friend void swap(DmiChassis& a, DmiChassis& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiChassis* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiChassis* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiChassis& from);
  void MergeFrom(const DmiChassis& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiChassis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiChassis_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.DmiChassis.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::system_info::DmiChassis_Item& item(int index) const;
  ::aspia::system_info::DmiChassis_Item* mutable_item(int index);
  ::aspia::system_info::DmiChassis_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiChassis_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiChassis_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.DmiChassis)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiChassis_Item > item_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Monitors_Item_Timing : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Monitors.Item.Timing) */ {
 public:
  Monitors_Item_Timing();
  virtual ~Monitors_Item_Timing();

  Monitors_Item_Timing(const Monitors_Item_Timing& from);

  inline Monitors_Item_Timing& operator=(const Monitors_Item_Timing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Monitors_Item_Timing(Monitors_Item_Timing&& from) noexcept
    : Monitors_Item_Timing() {
    *this = ::std::move(from);
  }

  inline Monitors_Item_Timing& operator=(Monitors_Item_Timing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Monitors_Item_Timing& default_instance();

  static inline const Monitors_Item_Timing* internal_default_instance() {
    return reinterpret_cast<const Monitors_Item_Timing*>(
               &_Monitors_Item_Timing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Monitors_Item_Timing* other);
  friend void swap(Monitors_Item_Timing& a, Monitors_Item_Timing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Monitors_Item_Timing* New() const PROTOBUF_FINAL { return New(NULL); }

  Monitors_Item_Timing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Monitors_Item_Timing& from);
  void MergeFrom(const Monitors_Item_Timing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Monitors_Item_Timing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // int32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // int32 frequency = 3;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 3;
  ::google::protobuf::int32 frequency() const;
  void set_frequency(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.Monitors.Item.Timing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 frequency_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Monitors_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Monitors.Item) */ {
 public:
  Monitors_Item();
  virtual ~Monitors_Item();

  Monitors_Item(const Monitors_Item& from);

  inline Monitors_Item& operator=(const Monitors_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Monitors_Item(Monitors_Item&& from) noexcept
    : Monitors_Item() {
    *this = ::std::move(from);
  }

  inline Monitors_Item& operator=(Monitors_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Monitors_Item& default_instance();

  static inline const Monitors_Item* internal_default_instance() {
    return reinterpret_cast<const Monitors_Item*>(
               &_Monitors_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Monitors_Item* other);
  friend void swap(Monitors_Item& a, Monitors_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Monitors_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Monitors_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Monitors_Item& from);
  void MergeFrom(const Monitors_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Monitors_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Monitors_Item_Timing Timing;

  typedef Monitors_Item_InputSignalType InputSignalType;
  static const InputSignalType INPUT_SIGNAL_TYPE_UNKNOWN =
    Monitors_Item_InputSignalType_INPUT_SIGNAL_TYPE_UNKNOWN;
  static const InputSignalType INPUT_SIGNAL_TYPE_ANALOG =
    Monitors_Item_InputSignalType_INPUT_SIGNAL_TYPE_ANALOG;
  static const InputSignalType INPUT_SIGNAL_TYPE_DIGITAL =
    Monitors_Item_InputSignalType_INPUT_SIGNAL_TYPE_DIGITAL;
  static inline bool InputSignalType_IsValid(int value) {
    return Monitors_Item_InputSignalType_IsValid(value);
  }
  static const InputSignalType InputSignalType_MIN =
    Monitors_Item_InputSignalType_InputSignalType_MIN;
  static const InputSignalType InputSignalType_MAX =
    Monitors_Item_InputSignalType_InputSignalType_MAX;
  static const int InputSignalType_ARRAYSIZE =
    Monitors_Item_InputSignalType_InputSignalType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.Monitors.Item.Timing timings = 28;
  int timings_size() const;
  void clear_timings();
  static const int kTimingsFieldNumber = 28;
  const ::aspia::system_info::Monitors_Item_Timing& timings(int index) const;
  ::aspia::system_info::Monitors_Item_Timing* mutable_timings(int index);
  ::aspia::system_info::Monitors_Item_Timing* add_timings();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Monitors_Item_Timing >*
      mutable_timings();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Monitors_Item_Timing >&
      timings() const;

  // string system_name = 1;
  void clear_system_name();
  static const int kSystemNameFieldNumber = 1;
  const ::std::string& system_name() const;
  void set_system_name(const ::std::string& value);
  #if LANG_CXX11
  void set_system_name(::std::string&& value);
  #endif
  void set_system_name(const char* value);
  void set_system_name(const char* value, size_t size);
  ::std::string* mutable_system_name();
  ::std::string* release_system_name();
  void set_allocated_system_name(::std::string* system_name);

  // string monitor_name = 2;
  void clear_monitor_name();
  static const int kMonitorNameFieldNumber = 2;
  const ::std::string& monitor_name() const;
  void set_monitor_name(const ::std::string& value);
  #if LANG_CXX11
  void set_monitor_name(::std::string&& value);
  #endif
  void set_monitor_name(const char* value);
  void set_monitor_name(const char* value, size_t size);
  ::std::string* mutable_monitor_name();
  ::std::string* release_monitor_name();
  void set_allocated_monitor_name(::std::string* monitor_name);

  // string manufacturer_name = 3;
  void clear_manufacturer_name();
  static const int kManufacturerNameFieldNumber = 3;
  const ::std::string& manufacturer_name() const;
  void set_manufacturer_name(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer_name(::std::string&& value);
  #endif
  void set_manufacturer_name(const char* value);
  void set_manufacturer_name(const char* value, size_t size);
  ::std::string* mutable_manufacturer_name();
  ::std::string* release_manufacturer_name();
  void set_allocated_manufacturer_name(::std::string* manufacturer_name);

  // string monitor_id = 4;
  void clear_monitor_id();
  static const int kMonitorIdFieldNumber = 4;
  const ::std::string& monitor_id() const;
  void set_monitor_id(const ::std::string& value);
  #if LANG_CXX11
  void set_monitor_id(::std::string&& value);
  #endif
  void set_monitor_id(const char* value);
  void set_monitor_id(const char* value, size_t size);
  ::std::string* mutable_monitor_id();
  ::std::string* release_monitor_id();
  void set_allocated_monitor_id(::std::string* monitor_id);

  // string serial_number = 5;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 5;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // int32 edid_version = 6;
  void clear_edid_version();
  static const int kEdidVersionFieldNumber = 6;
  ::google::protobuf::int32 edid_version() const;
  void set_edid_version(::google::protobuf::int32 value);

  // int32 edid_revision = 7;
  void clear_edid_revision();
  static const int kEdidRevisionFieldNumber = 7;
  ::google::protobuf::int32 edid_revision() const;
  void set_edid_revision(::google::protobuf::int32 value);

  // int32 week_of_manufacture = 8;
  void clear_week_of_manufacture();
  static const int kWeekOfManufactureFieldNumber = 8;
  ::google::protobuf::int32 week_of_manufacture() const;
  void set_week_of_manufacture(::google::protobuf::int32 value);

  // int32 year_of_manufacture = 9;
  void clear_year_of_manufacture();
  static const int kYearOfManufactureFieldNumber = 9;
  ::google::protobuf::int32 year_of_manufacture() const;
  void set_year_of_manufacture(::google::protobuf::int32 value);

  // int32 max_horizontal_image_size = 10;
  void clear_max_horizontal_image_size();
  static const int kMaxHorizontalImageSizeFieldNumber = 10;
  ::google::protobuf::int32 max_horizontal_image_size() const;
  void set_max_horizontal_image_size(::google::protobuf::int32 value);

  // int32 max_vertical_image_size = 11;
  void clear_max_vertical_image_size();
  static const int kMaxVerticalImageSizeFieldNumber = 11;
  ::google::protobuf::int32 max_vertical_image_size() const;
  void set_max_vertical_image_size(::google::protobuf::int32 value);

  // int32 horizontal_resolution = 12;
  void clear_horizontal_resolution();
  static const int kHorizontalResolutionFieldNumber = 12;
  ::google::protobuf::int32 horizontal_resolution() const;
  void set_horizontal_resolution(::google::protobuf::int32 value);

  // int32 vertical_resoulution = 13;
  void clear_vertical_resoulution();
  static const int kVerticalResoulutionFieldNumber = 13;
  ::google::protobuf::int32 vertical_resoulution() const;
  void set_vertical_resoulution(::google::protobuf::int32 value);

  // double gamma = 14;
  void clear_gamma();
  static const int kGammaFieldNumber = 14;
  double gamma() const;
  void set_gamma(double value);

  // int32 min_horizontal_rate = 15;
  void clear_min_horizontal_rate();
  static const int kMinHorizontalRateFieldNumber = 15;
  ::google::protobuf::int32 min_horizontal_rate() const;
  void set_min_horizontal_rate(::google::protobuf::int32 value);

  // int32 max_horizontal_rate = 16;
  void clear_max_horizontal_rate();
  static const int kMaxHorizontalRateFieldNumber = 16;
  ::google::protobuf::int32 max_horizontal_rate() const;
  void set_max_horizontal_rate(::google::protobuf::int32 value);

  // int32 min_vertical_rate = 17;
  void clear_min_vertical_rate();
  static const int kMinVerticalRateFieldNumber = 17;
  ::google::protobuf::int32 min_vertical_rate() const;
  void set_min_vertical_rate(::google::protobuf::int32 value);

  // int32 max_vertical_rate = 18;
  void clear_max_vertical_rate();
  static const int kMaxVerticalRateFieldNumber = 18;
  ::google::protobuf::int32 max_vertical_rate() const;
  void set_max_vertical_rate(::google::protobuf::int32 value);

  // double pixel_clock = 19;
  void clear_pixel_clock();
  static const int kPixelClockFieldNumber = 19;
  double pixel_clock() const;
  void set_pixel_clock(double value);

  // int32 max_pixel_clock = 20;
  void clear_max_pixel_clock();
  static const int kMaxPixelClockFieldNumber = 20;
  ::google::protobuf::int32 max_pixel_clock() const;
  void set_max_pixel_clock(::google::protobuf::int32 value);

  // .aspia.system_info.Monitors.Item.InputSignalType input_signal_type = 21;
  void clear_input_signal_type();
  static const int kInputSignalTypeFieldNumber = 21;
  ::aspia::system_info::Monitors_Item_InputSignalType input_signal_type() const;
  void set_input_signal_type(::aspia::system_info::Monitors_Item_InputSignalType value);

  // bool default_gtf_supported = 22;
  void clear_default_gtf_supported();
  static const int kDefaultGtfSupportedFieldNumber = 22;
  bool default_gtf_supported() const;
  void set_default_gtf_supported(bool value);

  // bool suspend_supported = 23;
  void clear_suspend_supported();
  static const int kSuspendSupportedFieldNumber = 23;
  bool suspend_supported() const;
  void set_suspend_supported(bool value);

  // bool standby_supported = 24;
  void clear_standby_supported();
  static const int kStandbySupportedFieldNumber = 24;
  bool standby_supported() const;
  void set_standby_supported(bool value);

  // bool active_off_supported = 25;
  void clear_active_off_supported();
  static const int kActiveOffSupportedFieldNumber = 25;
  bool active_off_supported() const;
  void set_active_off_supported(bool value);

  // bool preferred_timing_mode_supported = 26;
  void clear_preferred_timing_mode_supported();
  static const int kPreferredTimingModeSupportedFieldNumber = 26;
  bool preferred_timing_mode_supported() const;
  void set_preferred_timing_mode_supported(bool value);

  // bool srgb_supported = 27;
  void clear_srgb_supported();
  static const int kSrgbSupportedFieldNumber = 27;
  bool srgb_supported() const;
  void set_srgb_supported(bool value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.Monitors.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Monitors_Item_Timing > timings_;
  ::google::protobuf::internal::ArenaStringPtr system_name_;
  ::google::protobuf::internal::ArenaStringPtr monitor_name_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_name_;
  ::google::protobuf::internal::ArenaStringPtr monitor_id_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::int32 edid_version_;
  ::google::protobuf::int32 edid_revision_;
  ::google::protobuf::int32 week_of_manufacture_;
  ::google::protobuf::int32 year_of_manufacture_;
  ::google::protobuf::int32 max_horizontal_image_size_;
  ::google::protobuf::int32 max_vertical_image_size_;
  ::google::protobuf::int32 horizontal_resolution_;
  ::google::protobuf::int32 vertical_resoulution_;
  double gamma_;
  ::google::protobuf::int32 min_horizontal_rate_;
  ::google::protobuf::int32 max_horizontal_rate_;
  ::google::protobuf::int32 min_vertical_rate_;
  ::google::protobuf::int32 max_vertical_rate_;
  double pixel_clock_;
  ::google::protobuf::int32 max_pixel_clock_;
  int input_signal_type_;
  bool default_gtf_supported_;
  bool suspend_supported_;
  bool standby_supported_;
  bool active_off_supported_;
  bool preferred_timing_mode_supported_;
  bool srgb_supported_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Monitors : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Monitors) */ {
 public:
  Monitors();
  virtual ~Monitors();

  Monitors(const Monitors& from);

  inline Monitors& operator=(const Monitors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Monitors(Monitors&& from) noexcept
    : Monitors() {
    *this = ::std::move(from);
  }

  inline Monitors& operator=(Monitors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Monitors& default_instance();

  static inline const Monitors* internal_default_instance() {
    return reinterpret_cast<const Monitors*>(
               &_Monitors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Monitors* other);
  friend void swap(Monitors& a, Monitors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Monitors* New() const PROTOBUF_FINAL { return New(NULL); }

  Monitors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Monitors& from);
  void MergeFrom(const Monitors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Monitors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Monitors_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.Monitors.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::system_info::Monitors_Item& item(int index) const;
  ::aspia::system_info::Monitors_Item* mutable_item(int index);
  ::aspia::system_info::Monitors_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Monitors_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Monitors_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.Monitors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Monitors_Item > item_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Printers_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Printers.Item) */ {
 public:
  Printers_Item();
  virtual ~Printers_Item();

  Printers_Item(const Printers_Item& from);

  inline Printers_Item& operator=(const Printers_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Printers_Item(Printers_Item&& from) noexcept
    : Printers_Item() {
    *this = ::std::move(from);
  }

  inline Printers_Item& operator=(Printers_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Printers_Item& default_instance();

  static inline const Printers_Item* internal_default_instance() {
    return reinterpret_cast<const Printers_Item*>(
               &_Printers_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Printers_Item* other);
  friend void swap(Printers_Item& a, Printers_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Printers_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Printers_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Printers_Item& from);
  void MergeFrom(const Printers_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Printers_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Printers_Item_Orientation Orientation;
  static const Orientation ORIENTATION_UNKNOWN =
    Printers_Item_Orientation_ORIENTATION_UNKNOWN;
  static const Orientation ORIENTATION_PORTRAIT =
    Printers_Item_Orientation_ORIENTATION_PORTRAIT;
  static const Orientation ORIENTATION_LANDSCAPE =
    Printers_Item_Orientation_ORIENTATION_LANDSCAPE;
  static inline bool Orientation_IsValid(int value) {
    return Printers_Item_Orientation_IsValid(value);
  }
  static const Orientation Orientation_MIN =
    Printers_Item_Orientation_Orientation_MIN;
  static const Orientation Orientation_MAX =
    Printers_Item_Orientation_Orientation_MAX;
  static const int Orientation_ARRAYSIZE =
    Printers_Item_Orientation_Orientation_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string share_name = 4;
  void clear_share_name();
  static const int kShareNameFieldNumber = 4;
  const ::std::string& share_name() const;
  void set_share_name(const ::std::string& value);
  #if LANG_CXX11
  void set_share_name(::std::string&& value);
  #endif
  void set_share_name(const char* value);
  void set_share_name(const char* value, size_t size);
  ::std::string* mutable_share_name();
  ::std::string* release_share_name();
  void set_allocated_share_name(::std::string* share_name);

  // string port_name = 5;
  void clear_port_name();
  static const int kPortNameFieldNumber = 5;
  const ::std::string& port_name() const;
  void set_port_name(const ::std::string& value);
  #if LANG_CXX11
  void set_port_name(::std::string&& value);
  #endif
  void set_port_name(const char* value);
  void set_port_name(const char* value, size_t size);
  ::std::string* mutable_port_name();
  ::std::string* release_port_name();
  void set_allocated_port_name(::std::string* port_name);

  // string driver_name = 6;
  void clear_driver_name();
  static const int kDriverNameFieldNumber = 6;
  const ::std::string& driver_name() const;
  void set_driver_name(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_name(::std::string&& value);
  #endif
  void set_driver_name(const char* value);
  void set_driver_name(const char* value, size_t size);
  ::std::string* mutable_driver_name();
  ::std::string* release_driver_name();
  void set_allocated_driver_name(::std::string* driver_name);

  // string device_name = 7;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 7;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  #if LANG_CXX11
  void set_device_name(::std::string&& value);
  #endif
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // string print_processor = 8;
  void clear_print_processor();
  static const int kPrintProcessorFieldNumber = 8;
  const ::std::string& print_processor() const;
  void set_print_processor(const ::std::string& value);
  #if LANG_CXX11
  void set_print_processor(::std::string&& value);
  #endif
  void set_print_processor(const char* value);
  void set_print_processor(const char* value, size_t size);
  ::std::string* mutable_print_processor();
  ::std::string* release_print_processor();
  void set_allocated_print_processor(::std::string* print_processor);

  // string data_type = 9;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 9;
  const ::std::string& data_type() const;
  void set_data_type(const ::std::string& value);
  #if LANG_CXX11
  void set_data_type(::std::string&& value);
  #endif
  void set_data_type(const char* value);
  void set_data_type(const char* value, size_t size);
  ::std::string* mutable_data_type();
  ::std::string* release_data_type();
  void set_allocated_data_type(::std::string* data_type);

  // string server_name = 10;
  void clear_server_name();
  static const int kServerNameFieldNumber = 10;
  const ::std::string& server_name() const;
  void set_server_name(const ::std::string& value);
  #if LANG_CXX11
  void set_server_name(::std::string&& value);
  #endif
  void set_server_name(const char* value);
  void set_server_name(const char* value, size_t size);
  ::std::string* mutable_server_name();
  ::std::string* release_server_name();
  void set_allocated_server_name(::std::string* server_name);

  // string location = 11;
  void clear_location();
  static const int kLocationFieldNumber = 11;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // string comment = 12;
  void clear_comment();
  static const int kCommentFieldNumber = 12;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // bool is_default = 2;
  void clear_is_default();
  static const int kIsDefaultFieldNumber = 2;
  bool is_default() const;
  void set_is_default(bool value);

  // bool is_shared = 3;
  void clear_is_shared();
  static const int kIsSharedFieldNumber = 3;
  bool is_shared() const;
  void set_is_shared(bool value);

  // int32 jobs_count = 13;
  void clear_jobs_count();
  static const int kJobsCountFieldNumber = 13;
  ::google::protobuf::int32 jobs_count() const;
  void set_jobs_count(::google::protobuf::int32 value);

  // int32 paper_width = 14;
  void clear_paper_width();
  static const int kPaperWidthFieldNumber = 14;
  ::google::protobuf::int32 paper_width() const;
  void set_paper_width(::google::protobuf::int32 value);

  // int32 paper_length = 15;
  void clear_paper_length();
  static const int kPaperLengthFieldNumber = 15;
  ::google::protobuf::int32 paper_length() const;
  void set_paper_length(::google::protobuf::int32 value);

  // int32 print_quality = 16;
  void clear_print_quality();
  static const int kPrintQualityFieldNumber = 16;
  ::google::protobuf::int32 print_quality() const;
  void set_print_quality(::google::protobuf::int32 value);

  // .aspia.system_info.Printers.Item.Orientation orientation = 17;
  void clear_orientation();
  static const int kOrientationFieldNumber = 17;
  ::aspia::system_info::Printers_Item_Orientation orientation() const;
  void set_orientation(::aspia::system_info::Printers_Item_Orientation value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.Printers.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr share_name_;
  ::google::protobuf::internal::ArenaStringPtr port_name_;
  ::google::protobuf::internal::ArenaStringPtr driver_name_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  ::google::protobuf::internal::ArenaStringPtr print_processor_;
  ::google::protobuf::internal::ArenaStringPtr data_type_;
  ::google::protobuf::internal::ArenaStringPtr server_name_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  bool is_default_;
  bool is_shared_;
  ::google::protobuf::int32 jobs_count_;
  ::google::protobuf::int32 paper_width_;
  ::google::protobuf::int32 paper_length_;
  ::google::protobuf::int32 print_quality_;
  int orientation_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Printers : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Printers) */ {
 public:
  Printers();
  virtual ~Printers();

  Printers(const Printers& from);

  inline Printers& operator=(const Printers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Printers(Printers&& from) noexcept
    : Printers() {
    *this = ::std::move(from);
  }

  inline Printers& operator=(Printers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Printers& default_instance();

  static inline const Printers* internal_default_instance() {
    return reinterpret_cast<const Printers*>(
               &_Printers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Printers* other);
  friend void swap(Printers& a, Printers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Printers* New() const PROTOBUF_FINAL { return New(NULL); }

  Printers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Printers& from);
  void MergeFrom(const Printers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Printers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Printers_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.Printers.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::system_info::Printers_Item& item(int index) const;
  ::aspia::system_info::Printers_Item* mutable_item(int index);
  ::aspia::system_info::Printers_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Printers_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Printers_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.Printers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Printers_Item > item_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Services_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Services.Item) */ {
 public:
  Services_Item();
  virtual ~Services_Item();

  Services_Item(const Services_Item& from);

  inline Services_Item& operator=(const Services_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Services_Item(Services_Item&& from) noexcept
    : Services_Item() {
    *this = ::std::move(from);
  }

  inline Services_Item& operator=(Services_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Services_Item& default_instance();

  static inline const Services_Item* internal_default_instance() {
    return reinterpret_cast<const Services_Item*>(
               &_Services_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Services_Item* other);
  friend void swap(Services_Item& a, Services_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Services_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Services_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Services_Item& from);
  void MergeFrom(const Services_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Services_Item_Status Status;
  static const Status STATUS_UNKNOWN =
    Services_Item_Status_STATUS_UNKNOWN;
  static const Status STATUS_CONTINUE_PENDING =
    Services_Item_Status_STATUS_CONTINUE_PENDING;
  static const Status STATUS_PAUSE_PENDING =
    Services_Item_Status_STATUS_PAUSE_PENDING;
  static const Status STATUS_PAUSED =
    Services_Item_Status_STATUS_PAUSED;
  static const Status STATUS_RUNNING =
    Services_Item_Status_STATUS_RUNNING;
  static const Status STATUS_START_PENDING =
    Services_Item_Status_STATUS_START_PENDING;
  static const Status STATUS_STOP_PENDING =
    Services_Item_Status_STATUS_STOP_PENDING;
  static const Status STATUS_STOPPED =
    Services_Item_Status_STATUS_STOPPED;
  static inline bool Status_IsValid(int value) {
    return Services_Item_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Services_Item_Status_Status_MIN;
  static const Status Status_MAX =
    Services_Item_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Services_Item_Status_Status_ARRAYSIZE;

  typedef Services_Item_StartupType StartupType;
  static const StartupType STARTUP_TYPE_UNKNOWN =
    Services_Item_StartupType_STARTUP_TYPE_UNKNOWN;
  static const StartupType STARTUP_TYPE_AUTO_START =
    Services_Item_StartupType_STARTUP_TYPE_AUTO_START;
  static const StartupType STARTUP_TYPE_DEMAND_START =
    Services_Item_StartupType_STARTUP_TYPE_DEMAND_START;
  static const StartupType STARTUP_TYPE_DISABLED =
    Services_Item_StartupType_STARTUP_TYPE_DISABLED;
  static const StartupType STARTUP_TYPE_BOOT_START =
    Services_Item_StartupType_STARTUP_TYPE_BOOT_START;
  static const StartupType STARTUP_TYPE_SYSTEM_START =
    Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START;
  static inline bool StartupType_IsValid(int value) {
    return Services_Item_StartupType_IsValid(value);
  }
  static const StartupType StartupType_MIN =
    Services_Item_StartupType_StartupType_MIN;
  static const StartupType StartupType_MAX =
    Services_Item_StartupType_StartupType_MAX;
  static const int StartupType_ARRAYSIZE =
    Services_Item_StartupType_StartupType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string display_name = 2;
  void clear_display_name();
  static const int kDisplayNameFieldNumber = 2;
  const ::std::string& display_name() const;
  void set_display_name(const ::std::string& value);
  #if LANG_CXX11
  void set_display_name(::std::string&& value);
  #endif
  void set_display_name(const char* value);
  void set_display_name(const char* value, size_t size);
  ::std::string* mutable_display_name();
  ::std::string* release_display_name();
  void set_allocated_display_name(::std::string* display_name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string binary_path = 6;
  void clear_binary_path();
  static const int kBinaryPathFieldNumber = 6;
  const ::std::string& binary_path() const;
  void set_binary_path(const ::std::string& value);
  #if LANG_CXX11
  void set_binary_path(::std::string&& value);
  #endif
  void set_binary_path(const char* value);
  void set_binary_path(const char* value, size_t size);
  ::std::string* mutable_binary_path();
  ::std::string* release_binary_path();
  void set_allocated_binary_path(::std::string* binary_path);

  // string start_name = 7;
  void clear_start_name();
  static const int kStartNameFieldNumber = 7;
  const ::std::string& start_name() const;
  void set_start_name(const ::std::string& value);
  #if LANG_CXX11
  void set_start_name(::std::string&& value);
  #endif
  void set_start_name(const char* value);
  void set_start_name(const char* value, size_t size);
  ::std::string* mutable_start_name();
  ::std::string* release_start_name();
  void set_allocated_start_name(::std::string* start_name);

  // .aspia.system_info.Services.Item.Status status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::aspia::system_info::Services_Item_Status status() const;
  void set_status(::aspia::system_info::Services_Item_Status value);

  // .aspia.system_info.Services.Item.StartupType startup_type = 5;
  void clear_startup_type();
  static const int kStartupTypeFieldNumber = 5;
  ::aspia::system_info::Services_Item_StartupType startup_type() const;
  void set_startup_type(::aspia::system_info::Services_Item_StartupType value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.Services.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr display_name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr binary_path_;
  ::google::protobuf::internal::ArenaStringPtr start_name_;
  int status_;
  int startup_type_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Services : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Services) */ {
 public:
  Services();
  virtual ~Services();

  Services(const Services& from);

  inline Services& operator=(const Services& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Services(Services&& from) noexcept
    : Services() {
    *this = ::std::move(from);
  }

  inline Services& operator=(Services&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Services& default_instance();

  static inline const Services* internal_default_instance() {
    return reinterpret_cast<const Services*>(
               &_Services_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Services* other);
  friend void swap(Services& a, Services& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Services* New() const PROTOBUF_FINAL { return New(NULL); }

  Services* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Services& from);
  void MergeFrom(const Services& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Services_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.Services.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::system_info::Services_Item& item(int index) const;
  ::aspia::system_info::Services_Item* mutable_item(int index);
  ::aspia::system_info::Services_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Services_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Services_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.Services)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Services_Item > item_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NetworkCards_Item_IpAddress : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.NetworkCards.Item.IpAddress) */ {
 public:
  NetworkCards_Item_IpAddress();
  virtual ~NetworkCards_Item_IpAddress();

  NetworkCards_Item_IpAddress(const NetworkCards_Item_IpAddress& from);

  inline NetworkCards_Item_IpAddress& operator=(const NetworkCards_Item_IpAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards_Item_IpAddress(NetworkCards_Item_IpAddress&& from) noexcept
    : NetworkCards_Item_IpAddress() {
    *this = ::std::move(from);
  }

  inline NetworkCards_Item_IpAddress& operator=(NetworkCards_Item_IpAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards_Item_IpAddress& default_instance();

  static inline const NetworkCards_Item_IpAddress* internal_default_instance() {
    return reinterpret_cast<const NetworkCards_Item_IpAddress*>(
               &_NetworkCards_Item_IpAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(NetworkCards_Item_IpAddress* other);
  friend void swap(NetworkCards_Item_IpAddress& a, NetworkCards_Item_IpAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards_Item_IpAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards_Item_IpAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards_Item_IpAddress& from);
  void MergeFrom(const NetworkCards_Item_IpAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards_Item_IpAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // string mask = 2;
  void clear_mask();
  static const int kMaskFieldNumber = 2;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // @@protoc_insertion_point(class_scope:aspia.system_info.NetworkCards.Item.IpAddress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NetworkCards_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.NetworkCards.Item) */ {
 public:
  NetworkCards_Item();
  virtual ~NetworkCards_Item();

  NetworkCards_Item(const NetworkCards_Item& from);

  inline NetworkCards_Item& operator=(const NetworkCards_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards_Item(NetworkCards_Item&& from) noexcept
    : NetworkCards_Item() {
    *this = ::std::move(from);
  }

  inline NetworkCards_Item& operator=(NetworkCards_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards_Item& default_instance();

  static inline const NetworkCards_Item* internal_default_instance() {
    return reinterpret_cast<const NetworkCards_Item*>(
               &_NetworkCards_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(NetworkCards_Item* other);
  friend void swap(NetworkCards_Item& a, NetworkCards_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards_Item& from);
  void MergeFrom(const NetworkCards_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NetworkCards_Item_IpAddress IpAddress;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.NetworkCards.Item.IpAddress ip_address = 11;
  int ip_address_size() const;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 11;
  const ::aspia::system_info::NetworkCards_Item_IpAddress& ip_address(int index) const;
  ::aspia::system_info::NetworkCards_Item_IpAddress* mutable_ip_address(int index);
  ::aspia::system_info::NetworkCards_Item_IpAddress* add_ip_address();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::NetworkCards_Item_IpAddress >*
      mutable_ip_address();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::NetworkCards_Item_IpAddress >&
      ip_address() const;

  // repeated string gateway_address = 12;
  int gateway_address_size() const;
  void clear_gateway_address();
  static const int kGatewayAddressFieldNumber = 12;
  const ::std::string& gateway_address(int index) const;
  ::std::string* mutable_gateway_address(int index);
  void set_gateway_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_gateway_address(int index, ::std::string&& value);
  #endif
  void set_gateway_address(int index, const char* value);
  void set_gateway_address(int index, const char* value, size_t size);
  ::std::string* add_gateway_address();
  void add_gateway_address(const ::std::string& value);
  #if LANG_CXX11
  void add_gateway_address(::std::string&& value);
  #endif
  void add_gateway_address(const char* value);
  void add_gateway_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& gateway_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_gateway_address();

  // repeated string dhcp_server_address = 13;
  int dhcp_server_address_size() const;
  void clear_dhcp_server_address();
  static const int kDhcpServerAddressFieldNumber = 13;
  const ::std::string& dhcp_server_address(int index) const;
  ::std::string* mutable_dhcp_server_address(int index);
  void set_dhcp_server_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dhcp_server_address(int index, ::std::string&& value);
  #endif
  void set_dhcp_server_address(int index, const char* value);
  void set_dhcp_server_address(int index, const char* value, size_t size);
  ::std::string* add_dhcp_server_address();
  void add_dhcp_server_address(const ::std::string& value);
  #if LANG_CXX11
  void add_dhcp_server_address(::std::string&& value);
  #endif
  void add_dhcp_server_address(const char* value);
  void add_dhcp_server_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dhcp_server_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dhcp_server_address();

  // repeated string dns_server_address = 14;
  int dns_server_address_size() const;
  void clear_dns_server_address();
  static const int kDnsServerAddressFieldNumber = 14;
  const ::std::string& dns_server_address(int index) const;
  ::std::string* mutable_dns_server_address(int index);
  void set_dns_server_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dns_server_address(int index, ::std::string&& value);
  #endif
  void set_dns_server_address(int index, const char* value);
  void set_dns_server_address(int index, const char* value, size_t size);
  ::std::string* add_dns_server_address();
  void add_dns_server_address(const ::std::string& value);
  #if LANG_CXX11
  void add_dns_server_address(::std::string&& value);
  #endif
  void add_dns_server_address(const char* value);
  void add_dns_server_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dns_server_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dns_server_address();

  // string adapter_name = 1;
  void clear_adapter_name();
  static const int kAdapterNameFieldNumber = 1;
  const ::std::string& adapter_name() const;
  void set_adapter_name(const ::std::string& value);
  #if LANG_CXX11
  void set_adapter_name(::std::string&& value);
  #endif
  void set_adapter_name(const char* value);
  void set_adapter_name(const char* value, size_t size);
  ::std::string* mutable_adapter_name();
  ::std::string* release_adapter_name();
  void set_allocated_adapter_name(::std::string* adapter_name);

  // string connection_name = 2;
  void clear_connection_name();
  static const int kConnectionNameFieldNumber = 2;
  const ::std::string& connection_name() const;
  void set_connection_name(const ::std::string& value);
  #if LANG_CXX11
  void set_connection_name(::std::string&& value);
  #endif
  void set_connection_name(const char* value);
  void set_connection_name(const char* value, size_t size);
  ::std::string* mutable_connection_name();
  ::std::string* release_connection_name();
  void set_allocated_connection_name(::std::string* connection_name);

  // string interface_type = 3;
  void clear_interface_type();
  static const int kInterfaceTypeFieldNumber = 3;
  const ::std::string& interface_type() const;
  void set_interface_type(const ::std::string& value);
  #if LANG_CXX11
  void set_interface_type(::std::string&& value);
  #endif
  void set_interface_type(const char* value);
  void set_interface_type(const char* value, size_t size);
  ::std::string* mutable_interface_type();
  ::std::string* release_interface_type();
  void set_allocated_interface_type(::std::string* interface_type);

  // string mac_address = 6;
  void clear_mac_address();
  static const int kMacAddressFieldNumber = 6;
  const ::std::string& mac_address() const;
  void set_mac_address(const ::std::string& value);
  #if LANG_CXX11
  void set_mac_address(::std::string&& value);
  #endif
  void set_mac_address(const char* value);
  void set_mac_address(const char* value, size_t size);
  ::std::string* mutable_mac_address();
  ::std::string* release_mac_address();
  void set_allocated_mac_address(::std::string* mac_address);

  // string primary_wins_server = 8;
  void clear_primary_wins_server();
  static const int kPrimaryWinsServerFieldNumber = 8;
  const ::std::string& primary_wins_server() const;
  void set_primary_wins_server(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_wins_server(::std::string&& value);
  #endif
  void set_primary_wins_server(const char* value);
  void set_primary_wins_server(const char* value, size_t size);
  ::std::string* mutable_primary_wins_server();
  ::std::string* release_primary_wins_server();
  void set_allocated_primary_wins_server(::std::string* primary_wins_server);

  // string secondary_wins_server = 9;
  void clear_secondary_wins_server();
  static const int kSecondaryWinsServerFieldNumber = 9;
  const ::std::string& secondary_wins_server() const;
  void set_secondary_wins_server(const ::std::string& value);
  #if LANG_CXX11
  void set_secondary_wins_server(::std::string&& value);
  #endif
  void set_secondary_wins_server(const char* value);
  void set_secondary_wins_server(const char* value, size_t size);
  ::std::string* mutable_secondary_wins_server();
  ::std::string* release_secondary_wins_server();
  void set_allocated_secondary_wins_server(::std::string* secondary_wins_server);

  // uint32 mtu = 4;
  void clear_mtu();
  static const int kMtuFieldNumber = 4;
  ::google::protobuf::uint32 mtu() const;
  void set_mtu(::google::protobuf::uint32 value);

  // uint32 speed = 5;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  ::google::protobuf::uint32 speed() const;
  void set_speed(::google::protobuf::uint32 value);

  // bool is_wins_enabled = 7;
  void clear_is_wins_enabled();
  static const int kIsWinsEnabledFieldNumber = 7;
  bool is_wins_enabled() const;
  void set_is_wins_enabled(bool value);

  // bool is_dhcp_enabled = 10;
  void clear_is_dhcp_enabled();
  static const int kIsDhcpEnabledFieldNumber = 10;
  bool is_dhcp_enabled() const;
  void set_is_dhcp_enabled(bool value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.NetworkCards.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::NetworkCards_Item_IpAddress > ip_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> gateway_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dhcp_server_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dns_server_address_;
  ::google::protobuf::internal::ArenaStringPtr adapter_name_;
  ::google::protobuf::internal::ArenaStringPtr connection_name_;
  ::google::protobuf::internal::ArenaStringPtr interface_type_;
  ::google::protobuf::internal::ArenaStringPtr mac_address_;
  ::google::protobuf::internal::ArenaStringPtr primary_wins_server_;
  ::google::protobuf::internal::ArenaStringPtr secondary_wins_server_;
  ::google::protobuf::uint32 mtu_;
  ::google::protobuf::uint32 speed_;
  bool is_wins_enabled_;
  bool is_dhcp_enabled_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NetworkCards : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.NetworkCards) */ {
 public:
  NetworkCards();
  virtual ~NetworkCards();

  NetworkCards(const NetworkCards& from);

  inline NetworkCards& operator=(const NetworkCards& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards(NetworkCards&& from) noexcept
    : NetworkCards() {
    *this = ::std::move(from);
  }

  inline NetworkCards& operator=(NetworkCards&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards& default_instance();

  static inline const NetworkCards* internal_default_instance() {
    return reinterpret_cast<const NetworkCards*>(
               &_NetworkCards_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(NetworkCards* other);
  friend void swap(NetworkCards& a, NetworkCards& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards& from);
  void MergeFrom(const NetworkCards& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NetworkCards_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.NetworkCards.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::system_info::NetworkCards_Item& item(int index) const;
  ::aspia::system_info::NetworkCards_Item* mutable_item(int index);
  ::aspia::system_info::NetworkCards_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::NetworkCards_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::NetworkCards_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.NetworkCards)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::NetworkCards_Item > item_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpenConnections_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.OpenConnections.Item) */ {
 public:
  OpenConnections_Item();
  virtual ~OpenConnections_Item();

  OpenConnections_Item(const OpenConnections_Item& from);

  inline OpenConnections_Item& operator=(const OpenConnections_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenConnections_Item(OpenConnections_Item&& from) noexcept
    : OpenConnections_Item() {
    *this = ::std::move(from);
  }

  inline OpenConnections_Item& operator=(OpenConnections_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OpenConnections_Item& default_instance();

  static inline const OpenConnections_Item* internal_default_instance() {
    return reinterpret_cast<const OpenConnections_Item*>(
               &_OpenConnections_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(OpenConnections_Item* other);
  friend void swap(OpenConnections_Item& a, OpenConnections_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenConnections_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  OpenConnections_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpenConnections_Item& from);
  void MergeFrom(const OpenConnections_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenConnections_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string process_name = 1;
  void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  const ::std::string& process_name() const;
  void set_process_name(const ::std::string& value);
  #if LANG_CXX11
  void set_process_name(::std::string&& value);
  #endif
  void set_process_name(const char* value);
  void set_process_name(const char* value, size_t size);
  ::std::string* mutable_process_name();
  ::std::string* release_process_name();
  void set_allocated_process_name(::std::string* process_name);

  // string local_address = 2;
  void clear_local_address();
  static const int kLocalAddressFieldNumber = 2;
  const ::std::string& local_address() const;
  void set_local_address(const ::std::string& value);
  #if LANG_CXX11
  void set_local_address(::std::string&& value);
  #endif
  void set_local_address(const char* value);
  void set_local_address(const char* value, size_t size);
  ::std::string* mutable_local_address();
  ::std::string* release_local_address();
  void set_allocated_local_address(::std::string* local_address);

  // string remote_address = 3;
  void clear_remote_address();
  static const int kRemoteAddressFieldNumber = 3;
  const ::std::string& remote_address() const;
  void set_remote_address(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_address(::std::string&& value);
  #endif
  void set_remote_address(const char* value);
  void set_remote_address(const char* value, size_t size);
  ::std::string* mutable_remote_address();
  ::std::string* release_remote_address();
  void set_allocated_remote_address(::std::string* remote_address);

  // string state = 6;
  void clear_state();
  static const int kStateFieldNumber = 6;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  #if LANG_CXX11
  void set_state(::std::string&& value);
  #endif
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // uint32 local_port = 4;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 4;
  ::google::protobuf::uint32 local_port() const;
  void set_local_port(::google::protobuf::uint32 value);

  // uint32 remote_port = 5;
  void clear_remote_port();
  static const int kRemotePortFieldNumber = 5;
  ::google::protobuf::uint32 remote_port() const;
  void set_remote_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.OpenConnections.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr process_name_;
  ::google::protobuf::internal::ArenaStringPtr local_address_;
  ::google::protobuf::internal::ArenaStringPtr remote_address_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::google::protobuf::uint32 local_port_;
  ::google::protobuf::uint32 remote_port_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpenConnections : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.OpenConnections) */ {
 public:
  OpenConnections();
  virtual ~OpenConnections();

  OpenConnections(const OpenConnections& from);

  inline OpenConnections& operator=(const OpenConnections& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenConnections(OpenConnections&& from) noexcept
    : OpenConnections() {
    *this = ::std::move(from);
  }

  inline OpenConnections& operator=(OpenConnections&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OpenConnections& default_instance();

  static inline const OpenConnections* internal_default_instance() {
    return reinterpret_cast<const OpenConnections*>(
               &_OpenConnections_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(OpenConnections* other);
  friend void swap(OpenConnections& a, OpenConnections& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenConnections* New() const PROTOBUF_FINAL { return New(NULL); }

  OpenConnections* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpenConnections& from);
  void MergeFrom(const OpenConnections& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenConnections* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef OpenConnections_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.OpenConnections.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::system_info::OpenConnections_Item& item(int index) const;
  ::aspia::system_info::OpenConnections_Item* mutable_item(int index);
  ::aspia::system_info::OpenConnections_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::OpenConnections_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::OpenConnections_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.OpenConnections)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::OpenConnections_Item > item_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SharedResources_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.SharedResources.Item) */ {
 public:
  SharedResources_Item();
  virtual ~SharedResources_Item();

  SharedResources_Item(const SharedResources_Item& from);

  inline SharedResources_Item& operator=(const SharedResources_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SharedResources_Item(SharedResources_Item&& from) noexcept
    : SharedResources_Item() {
    *this = ::std::move(from);
  }

  inline SharedResources_Item& operator=(SharedResources_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SharedResources_Item& default_instance();

  static inline const SharedResources_Item* internal_default_instance() {
    return reinterpret_cast<const SharedResources_Item*>(
               &_SharedResources_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(SharedResources_Item* other);
  friend void swap(SharedResources_Item& a, SharedResources_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SharedResources_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  SharedResources_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SharedResources_Item& from);
  void MergeFrom(const SharedResources_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedResources_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SharedResources_Item_Type Type;
  static const Type TYPE_UNKNOWN =
    SharedResources_Item_Type_TYPE_UNKNOWN;
  static const Type TYPE_DISK =
    SharedResources_Item_Type_TYPE_DISK;
  static const Type TYPE_PRINTER =
    SharedResources_Item_Type_TYPE_PRINTER;
  static const Type TYPE_DEVICE =
    SharedResources_Item_Type_TYPE_DEVICE;
  static const Type TYPE_IPC =
    SharedResources_Item_Type_TYPE_IPC;
  static const Type TYPE_SPECIAL =
    SharedResources_Item_Type_TYPE_SPECIAL;
  static const Type TYPE_TEMPORARY =
    SharedResources_Item_Type_TYPE_TEMPORARY;
  static inline bool Type_IsValid(int value) {
    return SharedResources_Item_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SharedResources_Item_Type_Type_MIN;
  static const Type Type_MAX =
    SharedResources_Item_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SharedResources_Item_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string local_path = 4;
  void clear_local_path();
  static const int kLocalPathFieldNumber = 4;
  const ::std::string& local_path() const;
  void set_local_path(const ::std::string& value);
  #if LANG_CXX11
  void set_local_path(::std::string&& value);
  #endif
  void set_local_path(const char* value);
  void set_local_path(const char* value, size_t size);
  ::std::string* mutable_local_path();
  ::std::string* release_local_path();
  void set_allocated_local_path(::std::string* local_path);

  // .aspia.system_info.SharedResources.Item.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::aspia::system_info::SharedResources_Item_Type type() const;
  void set_type(::aspia::system_info::SharedResources_Item_Type value);

  // uint32 current_uses = 5;
  void clear_current_uses();
  static const int kCurrentUsesFieldNumber = 5;
  ::google::protobuf::uint32 current_uses() const;
  void set_current_uses(::google::protobuf::uint32 value);

  // uint32 maximum_uses = 6;
  void clear_maximum_uses();
  static const int kMaximumUsesFieldNumber = 6;
  ::google::protobuf::uint32 maximum_uses() const;
  void set_maximum_uses(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.SharedResources.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr local_path_;
  int type_;
  ::google::protobuf::uint32 current_uses_;
  ::google::protobuf::uint32 maximum_uses_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SharedResources : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.SharedResources) */ {
 public:
  SharedResources();
  virtual ~SharedResources();

  SharedResources(const SharedResources& from);

  inline SharedResources& operator=(const SharedResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SharedResources(SharedResources&& from) noexcept
    : SharedResources() {
    *this = ::std::move(from);
  }

  inline SharedResources& operator=(SharedResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SharedResources& default_instance();

  static inline const SharedResources* internal_default_instance() {
    return reinterpret_cast<const SharedResources*>(
               &_SharedResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(SharedResources* other);
  friend void swap(SharedResources& a, SharedResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SharedResources* New() const PROTOBUF_FINAL { return New(NULL); }

  SharedResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SharedResources& from);
  void MergeFrom(const SharedResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SharedResources_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.SharedResources.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::system_info::SharedResources_Item& item(int index) const;
  ::aspia::system_info::SharedResources_Item* mutable_item(int index);
  ::aspia::system_info::SharedResources_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::SharedResources_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::SharedResources_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.SharedResources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::SharedResources_Item > item_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Routes_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Routes.Item) */ {
 public:
  Routes_Item();
  virtual ~Routes_Item();

  Routes_Item(const Routes_Item& from);

  inline Routes_Item& operator=(const Routes_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Routes_Item(Routes_Item&& from) noexcept
    : Routes_Item() {
    *this = ::std::move(from);
  }

  inline Routes_Item& operator=(Routes_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Routes_Item& default_instance();

  static inline const Routes_Item* internal_default_instance() {
    return reinterpret_cast<const Routes_Item*>(
               &_Routes_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Routes_Item* other);
  friend void swap(Routes_Item& a, Routes_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Routes_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Routes_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Routes_Item& from);
  void MergeFrom(const Routes_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Routes_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string destonation = 1;
  void clear_destonation();
  static const int kDestonationFieldNumber = 1;
  const ::std::string& destonation() const;
  void set_destonation(const ::std::string& value);
  #if LANG_CXX11
  void set_destonation(::std::string&& value);
  #endif
  void set_destonation(const char* value);
  void set_destonation(const char* value, size_t size);
  ::std::string* mutable_destonation();
  ::std::string* release_destonation();
  void set_allocated_destonation(::std::string* destonation);

  // string mask = 2;
  void clear_mask();
  static const int kMaskFieldNumber = 2;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // string gateway = 3;
  void clear_gateway();
  static const int kGatewayFieldNumber = 3;
  const ::std::string& gateway() const;
  void set_gateway(const ::std::string& value);
  #if LANG_CXX11
  void set_gateway(::std::string&& value);
  #endif
  void set_gateway(const char* value);
  void set_gateway(const char* value, size_t size);
  ::std::string* mutable_gateway();
  ::std::string* release_gateway();
  void set_allocated_gateway(::std::string* gateway);

  // uint32 metric = 4;
  void clear_metric();
  static const int kMetricFieldNumber = 4;
  ::google::protobuf::uint32 metric() const;
  void set_metric(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.Routes.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr destonation_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  ::google::protobuf::internal::ArenaStringPtr gateway_;
  ::google::protobuf::uint32 metric_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Routes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Routes) */ {
 public:
  Routes();
  virtual ~Routes();

  Routes(const Routes& from);

  inline Routes& operator=(const Routes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Routes(Routes&& from) noexcept
    : Routes() {
    *this = ::std::move(from);
  }

  inline Routes& operator=(Routes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Routes& default_instance();

  static inline const Routes* internal_default_instance() {
    return reinterpret_cast<const Routes*>(
               &_Routes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(Routes* other);
  friend void swap(Routes& a, Routes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Routes* New() const PROTOBUF_FINAL { return New(NULL); }

  Routes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Routes& from);
  void MergeFrom(const Routes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Routes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Routes_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.Routes.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::system_info::Routes_Item& item(int index) const;
  ::aspia::system_info::Routes_Item* mutable_item(int index);
  ::aspia::system_info::Routes_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Routes_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Routes_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.Routes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Routes_Item > item_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Users_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Users.Item) */ {
 public:
  Users_Item();
  virtual ~Users_Item();

  Users_Item(const Users_Item& from);

  inline Users_Item& operator=(const Users_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Users_Item(Users_Item&& from) noexcept
    : Users_Item() {
    *this = ::std::move(from);
  }

  inline Users_Item& operator=(Users_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Users_Item& default_instance();

  static inline const Users_Item* internal_default_instance() {
    return reinterpret_cast<const Users_Item*>(
               &_Users_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(Users_Item* other);
  friend void swap(Users_Item& a, Users_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Users_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Users_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Users_Item& from);
  void MergeFrom(const Users_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Users_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string full_name = 2;
  void clear_full_name();
  static const int kFullNameFieldNumber = 2;
  const ::std::string& full_name() const;
  void set_full_name(const ::std::string& value);
  #if LANG_CXX11
  void set_full_name(::std::string&& value);
  #endif
  void set_full_name(const char* value);
  void set_full_name(const char* value, size_t size);
  ::std::string* mutable_full_name();
  ::std::string* release_full_name();
  void set_allocated_full_name(::std::string* full_name);

  // string comment = 3;
  void clear_comment();
  static const int kCommentFieldNumber = 3;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // bool is_disabled = 4;
  void clear_is_disabled();
  static const int kIsDisabledFieldNumber = 4;
  bool is_disabled() const;
  void set_is_disabled(bool value);

  // bool is_password_cant_change = 5;
  void clear_is_password_cant_change();
  static const int kIsPasswordCantChangeFieldNumber = 5;
  bool is_password_cant_change() const;
  void set_is_password_cant_change(bool value);

  // bool is_password_expired = 6;
  void clear_is_password_expired();
  static const int kIsPasswordExpiredFieldNumber = 6;
  bool is_password_expired() const;
  void set_is_password_expired(bool value);

  // bool is_dont_expire_password = 7;
  void clear_is_dont_expire_password();
  static const int kIsDontExpirePasswordFieldNumber = 7;
  bool is_dont_expire_password() const;
  void set_is_dont_expire_password(bool value);

  // bool is_lockout = 8;
  void clear_is_lockout();
  static const int kIsLockoutFieldNumber = 8;
  bool is_lockout() const;
  void set_is_lockout(bool value);

  // uint32 number_logons = 9;
  void clear_number_logons();
  static const int kNumberLogonsFieldNumber = 9;
  ::google::protobuf::uint32 number_logons() const;
  void set_number_logons(::google::protobuf::uint32 value);

  // uint32 bad_password_count = 10;
  void clear_bad_password_count();
  static const int kBadPasswordCountFieldNumber = 10;
  ::google::protobuf::uint32 bad_password_count() const;
  void set_bad_password_count(::google::protobuf::uint32 value);

  // int64 last_logon_time = 11;
  void clear_last_logon_time();
  static const int kLastLogonTimeFieldNumber = 11;
  ::google::protobuf::int64 last_logon_time() const;
  void set_last_logon_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.Users.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr full_name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  bool is_disabled_;
  bool is_password_cant_change_;
  bool is_password_expired_;
  bool is_dont_expire_password_;
  bool is_lockout_;
  ::google::protobuf::uint32 number_logons_;
  ::google::protobuf::uint32 bad_password_count_;
  ::google::protobuf::int64 last_logon_time_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Users : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Users) */ {
 public:
  Users();
  virtual ~Users();

  Users(const Users& from);

  inline Users& operator=(const Users& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Users(Users&& from) noexcept
    : Users() {
    *this = ::std::move(from);
  }

  inline Users& operator=(Users&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Users& default_instance();

  static inline const Users* internal_default_instance() {
    return reinterpret_cast<const Users*>(
               &_Users_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(Users* other);
  friend void swap(Users& a, Users& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Users* New() const PROTOBUF_FINAL { return New(NULL); }

  Users* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Users& from);
  void MergeFrom(const Users& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Users* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Users_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.Users.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::system_info::Users_Item& item(int index) const;
  ::aspia::system_info::Users_Item* mutable_item(int index);
  ::aspia::system_info::Users_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Users_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Users_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.Users)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Users_Item > item_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserGroups_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.UserGroups.Item) */ {
 public:
  UserGroups_Item();
  virtual ~UserGroups_Item();

  UserGroups_Item(const UserGroups_Item& from);

  inline UserGroups_Item& operator=(const UserGroups_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserGroups_Item(UserGroups_Item&& from) noexcept
    : UserGroups_Item() {
    *this = ::std::move(from);
  }

  inline UserGroups_Item& operator=(UserGroups_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const UserGroups_Item& default_instance();

  static inline const UserGroups_Item* internal_default_instance() {
    return reinterpret_cast<const UserGroups_Item*>(
               &_UserGroups_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(UserGroups_Item* other);
  friend void swap(UserGroups_Item& a, UserGroups_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserGroups_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  UserGroups_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserGroups_Item& from);
  void MergeFrom(const UserGroups_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserGroups_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string comment = 2;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:aspia.system_info.UserGroups.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserGroups : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.UserGroups) */ {
 public:
  UserGroups();
  virtual ~UserGroups();

  UserGroups(const UserGroups& from);

  inline UserGroups& operator=(const UserGroups& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserGroups(UserGroups&& from) noexcept
    : UserGroups() {
    *this = ::std::move(from);
  }

  inline UserGroups& operator=(UserGroups&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const UserGroups& default_instance();

  static inline const UserGroups* internal_default_instance() {
    return reinterpret_cast<const UserGroups*>(
               &_UserGroups_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(UserGroups* other);
  friend void swap(UserGroups& a, UserGroups& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserGroups* New() const PROTOBUF_FINAL { return New(NULL); }

  UserGroups* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserGroups& from);
  void MergeFrom(const UserGroups& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserGroups* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef UserGroups_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.UserGroups.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::system_info::UserGroups_Item& item(int index) const;
  ::aspia::system_info::UserGroups_Item* mutable_item(int index);
  ::aspia::system_info::UserGroups_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::UserGroups_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::UserGroups_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.UserGroups)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::UserGroups_Item > item_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sessions_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Sessions.Item) */ {
 public:
  Sessions_Item();
  virtual ~Sessions_Item();

  Sessions_Item(const Sessions_Item& from);

  inline Sessions_Item& operator=(const Sessions_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sessions_Item(Sessions_Item&& from) noexcept
    : Sessions_Item() {
    *this = ::std::move(from);
  }

  inline Sessions_Item& operator=(Sessions_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Sessions_Item& default_instance();

  static inline const Sessions_Item* internal_default_instance() {
    return reinterpret_cast<const Sessions_Item*>(
               &_Sessions_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(Sessions_Item* other);
  friend void swap(Sessions_Item& a, Sessions_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sessions_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Sessions_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Sessions_Item& from);
  void MergeFrom(const Sessions_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sessions_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_name = 1;
  void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& user_name() const;
  void set_user_name(const ::std::string& value);
  #if LANG_CXX11
  void set_user_name(::std::string&& value);
  #endif
  void set_user_name(const char* value);
  void set_user_name(const char* value, size_t size);
  ::std::string* mutable_user_name();
  ::std::string* release_user_name();
  void set_allocated_user_name(::std::string* user_name);

  // string domain_name = 2;
  void clear_domain_name();
  static const int kDomainNameFieldNumber = 2;
  const ::std::string& domain_name() const;
  void set_domain_name(const ::std::string& value);
  #if LANG_CXX11
  void set_domain_name(::std::string&& value);
  #endif
  void set_domain_name(const char* value);
  void set_domain_name(const char* value, size_t size);
  ::std::string* mutable_domain_name();
  ::std::string* release_domain_name();
  void set_allocated_domain_name(::std::string* domain_name);

  // string connect_state = 4;
  void clear_connect_state();
  static const int kConnectStateFieldNumber = 4;
  const ::std::string& connect_state() const;
  void set_connect_state(const ::std::string& value);
  #if LANG_CXX11
  void set_connect_state(::std::string&& value);
  #endif
  void set_connect_state(const char* value);
  void set_connect_state(const char* value, size_t size);
  ::std::string* mutable_connect_state();
  ::std::string* release_connect_state();
  void set_allocated_connect_state(::std::string* connect_state);

  // string client_name = 5;
  void clear_client_name();
  static const int kClientNameFieldNumber = 5;
  const ::std::string& client_name() const;
  void set_client_name(const ::std::string& value);
  #if LANG_CXX11
  void set_client_name(::std::string&& value);
  #endif
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  ::std::string* mutable_client_name();
  ::std::string* release_client_name();
  void set_allocated_client_name(::std::string* client_name);

  // string winstation_name = 6;
  void clear_winstation_name();
  static const int kWinstationNameFieldNumber = 6;
  const ::std::string& winstation_name() const;
  void set_winstation_name(const ::std::string& value);
  #if LANG_CXX11
  void set_winstation_name(::std::string&& value);
  #endif
  void set_winstation_name(const char* value);
  void set_winstation_name(const char* value, size_t size);
  ::std::string* mutable_winstation_name();
  ::std::string* release_winstation_name();
  void set_allocated_winstation_name(::std::string* winstation_name);

  // uint32 session_id = 3;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  ::google::protobuf::uint32 session_id() const;
  void set_session_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.Sessions.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  ::google::protobuf::internal::ArenaStringPtr domain_name_;
  ::google::protobuf::internal::ArenaStringPtr connect_state_;
  ::google::protobuf::internal::ArenaStringPtr client_name_;
  ::google::protobuf::internal::ArenaStringPtr winstation_name_;
  ::google::protobuf::uint32 session_id_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sessions : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.Sessions) */ {
 public:
  Sessions();
  virtual ~Sessions();

  Sessions(const Sessions& from);

  inline Sessions& operator=(const Sessions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sessions(Sessions&& from) noexcept
    : Sessions() {
    *this = ::std::move(from);
  }

  inline Sessions& operator=(Sessions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Sessions& default_instance();

  static inline const Sessions* internal_default_instance() {
    return reinterpret_cast<const Sessions*>(
               &_Sessions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(Sessions* other);
  friend void swap(Sessions& a, Sessions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sessions* New() const PROTOBUF_FINAL { return New(NULL); }

  Sessions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Sessions& from);
  void MergeFrom(const Sessions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sessions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Sessions_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.Sessions.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::system_info::Sessions_Item& item(int index) const;
  ::aspia::system_info::Sessions_Item* mutable_item(int index);
  ::aspia::system_info::Sessions_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Sessions_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Sessions_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.Sessions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Sessions_Item > item_;
  mutable int _cached_size_;
  friend struct protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DmiBios_Feature

// string name = 1;
inline void DmiBios_Feature::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios_Feature::name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBios.Feature.name)
  return name_.GetNoArena();
}
inline void DmiBios_Feature::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBios.Feature.name)
}
#if LANG_CXX11
inline void DmiBios_Feature::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBios.Feature.name)
}
#endif
inline void DmiBios_Feature::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBios.Feature.name)
}
inline void DmiBios_Feature::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBios.Feature.name)
}
inline ::std::string* DmiBios_Feature::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBios.Feature.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios_Feature::release_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBios.Feature.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios_Feature::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBios.Feature.name)
}

// bool supported = 2;
inline void DmiBios_Feature::clear_supported() {
  supported_ = false;
}
inline bool DmiBios_Feature::supported() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBios.Feature.supported)
  return supported_;
}
inline void DmiBios_Feature::set_supported(bool value) {
  
  supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBios.Feature.supported)
}

// -------------------------------------------------------------------

// DmiBios

// string manufacturer = 1;
inline void DmiBios::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBios.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiBios::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBios.manufacturer)
}
#if LANG_CXX11
inline void DmiBios::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBios.manufacturer)
}
#endif
inline void DmiBios::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBios.manufacturer)
}
inline void DmiBios::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBios.manufacturer)
}
inline ::std::string* DmiBios::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBios.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBios.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBios.manufacturer)
}

// string version = 2;
inline void DmiBios::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::version() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBios.version)
  return version_.GetNoArena();
}
inline void DmiBios::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBios.version)
}
#if LANG_CXX11
inline void DmiBios::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBios.version)
}
#endif
inline void DmiBios::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBios.version)
}
inline void DmiBios::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBios.version)
}
inline ::std::string* DmiBios::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBios.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_version() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBios.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBios.version)
}

// string date = 3;
inline void DmiBios::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::date() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBios.date)
  return date_.GetNoArena();
}
inline void DmiBios::set_date(const ::std::string& value) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBios.date)
}
#if LANG_CXX11
inline void DmiBios::set_date(::std::string&& value) {
  
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBios.date)
}
#endif
inline void DmiBios::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBios.date)
}
inline void DmiBios::set_date(const char* value, size_t size) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBios.date)
}
inline ::std::string* DmiBios::mutable_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBios.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_date() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBios.date)
  
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    
  } else {
    
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBios.date)
}

// int32 size = 4;
inline void DmiBios::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 DmiBios::size() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBios.size)
  return size_;
}
inline void DmiBios::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBios.size)
}

// string bios_revision = 5;
inline void DmiBios::clear_bios_revision() {
  bios_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::bios_revision() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBios.bios_revision)
  return bios_revision_.GetNoArena();
}
inline void DmiBios::set_bios_revision(const ::std::string& value) {
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBios.bios_revision)
}
#if LANG_CXX11
inline void DmiBios::set_bios_revision(::std::string&& value) {
  
  bios_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBios.bios_revision)
}
#endif
inline void DmiBios::set_bios_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBios.bios_revision)
}
inline void DmiBios::set_bios_revision(const char* value, size_t size) {
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBios.bios_revision)
}
inline ::std::string* DmiBios::mutable_bios_revision() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBios.bios_revision)
  return bios_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_bios_revision() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBios.bios_revision)
  
  return bios_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_bios_revision(::std::string* bios_revision) {
  if (bios_revision != NULL) {
    
  } else {
    
  }
  bios_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bios_revision);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBios.bios_revision)
}

// string firmware_revision = 6;
inline void DmiBios::clear_firmware_revision() {
  firmware_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::firmware_revision() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBios.firmware_revision)
  return firmware_revision_.GetNoArena();
}
inline void DmiBios::set_firmware_revision(const ::std::string& value) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBios.firmware_revision)
}
#if LANG_CXX11
inline void DmiBios::set_firmware_revision(::std::string&& value) {
  
  firmware_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBios.firmware_revision)
}
#endif
inline void DmiBios::set_firmware_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBios.firmware_revision)
}
inline void DmiBios::set_firmware_revision(const char* value, size_t size) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBios.firmware_revision)
}
inline ::std::string* DmiBios::mutable_firmware_revision() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBios.firmware_revision)
  return firmware_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_firmware_revision() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBios.firmware_revision)
  
  return firmware_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_firmware_revision(::std::string* firmware_revision) {
  if (firmware_revision != NULL) {
    
  } else {
    
  }
  firmware_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_revision);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBios.firmware_revision)
}

// string address = 7;
inline void DmiBios::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::address() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBios.address)
  return address_.GetNoArena();
}
inline void DmiBios::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBios.address)
}
#if LANG_CXX11
inline void DmiBios::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBios.address)
}
#endif
inline void DmiBios::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBios.address)
}
inline void DmiBios::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBios.address)
}
inline ::std::string* DmiBios::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBios.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_address() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBios.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBios.address)
}

// int32 runtime_size = 8;
inline void DmiBios::clear_runtime_size() {
  runtime_size_ = 0;
}
inline ::google::protobuf::int32 DmiBios::runtime_size() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBios.runtime_size)
  return runtime_size_;
}
inline void DmiBios::set_runtime_size(::google::protobuf::int32 value) {
  
  runtime_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBios.runtime_size)
}

// repeated .aspia.system_info.DmiBios.Feature feature = 9;
inline int DmiBios::feature_size() const {
  return feature_.size();
}
inline void DmiBios::clear_feature() {
  feature_.Clear();
}
inline const ::aspia::system_info::DmiBios_Feature& DmiBios::feature(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBios.feature)
  return feature_.Get(index);
}
inline ::aspia::system_info::DmiBios_Feature* DmiBios::mutable_feature(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBios.feature)
  return feature_.Mutable(index);
}
inline ::aspia::system_info::DmiBios_Feature* DmiBios::add_feature() {
  // @@protoc_insertion_point(field_add:aspia.system_info.DmiBios.feature)
  return feature_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBios_Feature >*
DmiBios::mutable_feature() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.DmiBios.feature)
  return &feature_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBios_Feature >&
DmiBios::feature() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.DmiBios.feature)
  return feature_;
}

// -------------------------------------------------------------------

// DmiSystem

// string manufacturer = 1;
inline void DmiSystem::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiSystem.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiSystem::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiSystem.manufacturer)
}
#if LANG_CXX11
inline void DmiSystem::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiSystem.manufacturer)
}
#endif
inline void DmiSystem::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiSystem.manufacturer)
}
inline void DmiSystem::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiSystem.manufacturer)
}
inline ::std::string* DmiSystem::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiSystem.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiSystem.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiSystem.manufacturer)
}

// string product_name = 2;
inline void DmiSystem::clear_product_name() {
  product_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::product_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiSystem.product_name)
  return product_name_.GetNoArena();
}
inline void DmiSystem::set_product_name(const ::std::string& value) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiSystem.product_name)
}
#if LANG_CXX11
inline void DmiSystem::set_product_name(::std::string&& value) {
  
  product_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiSystem.product_name)
}
#endif
inline void DmiSystem::set_product_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiSystem.product_name)
}
inline void DmiSystem::set_product_name(const char* value, size_t size) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiSystem.product_name)
}
inline ::std::string* DmiSystem::mutable_product_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiSystem.product_name)
  return product_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_product_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiSystem.product_name)
  
  return product_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_product_name(::std::string* product_name) {
  if (product_name != NULL) {
    
  } else {
    
  }
  product_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiSystem.product_name)
}

// string version = 3;
inline void DmiSystem::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::version() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiSystem.version)
  return version_.GetNoArena();
}
inline void DmiSystem::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiSystem.version)
}
#if LANG_CXX11
inline void DmiSystem::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiSystem.version)
}
#endif
inline void DmiSystem::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiSystem.version)
}
inline void DmiSystem::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiSystem.version)
}
inline ::std::string* DmiSystem::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiSystem.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_version() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiSystem.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiSystem.version)
}

// string serial_number = 4;
inline void DmiSystem::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiSystem.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiSystem::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiSystem.serial_number)
}
#if LANG_CXX11
inline void DmiSystem::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiSystem.serial_number)
}
#endif
inline void DmiSystem::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiSystem.serial_number)
}
inline void DmiSystem::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiSystem.serial_number)
}
inline ::std::string* DmiSystem::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiSystem.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiSystem.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiSystem.serial_number)
}

// string uuid = 5;
inline void DmiSystem::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::uuid() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiSystem.uuid)
  return uuid_.GetNoArena();
}
inline void DmiSystem::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiSystem.uuid)
}
#if LANG_CXX11
inline void DmiSystem::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiSystem.uuid)
}
#endif
inline void DmiSystem::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiSystem.uuid)
}
inline void DmiSystem::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiSystem.uuid)
}
inline ::std::string* DmiSystem::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiSystem.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_uuid() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiSystem.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiSystem.uuid)
}

// string wakeup_type = 6;
inline void DmiSystem::clear_wakeup_type() {
  wakeup_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::wakeup_type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiSystem.wakeup_type)
  return wakeup_type_.GetNoArena();
}
inline void DmiSystem::set_wakeup_type(const ::std::string& value) {
  
  wakeup_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiSystem.wakeup_type)
}
#if LANG_CXX11
inline void DmiSystem::set_wakeup_type(::std::string&& value) {
  
  wakeup_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiSystem.wakeup_type)
}
#endif
inline void DmiSystem::set_wakeup_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  wakeup_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiSystem.wakeup_type)
}
inline void DmiSystem::set_wakeup_type(const char* value, size_t size) {
  
  wakeup_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiSystem.wakeup_type)
}
inline ::std::string* DmiSystem::mutable_wakeup_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiSystem.wakeup_type)
  return wakeup_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_wakeup_type() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiSystem.wakeup_type)
  
  return wakeup_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_wakeup_type(::std::string* wakeup_type) {
  if (wakeup_type != NULL) {
    
  } else {
    
  }
  wakeup_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wakeup_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiSystem.wakeup_type)
}

// string sku_number = 7;
inline void DmiSystem::clear_sku_number() {
  sku_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::sku_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiSystem.sku_number)
  return sku_number_.GetNoArena();
}
inline void DmiSystem::set_sku_number(const ::std::string& value) {
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiSystem.sku_number)
}
#if LANG_CXX11
inline void DmiSystem::set_sku_number(::std::string&& value) {
  
  sku_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiSystem.sku_number)
}
#endif
inline void DmiSystem::set_sku_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiSystem.sku_number)
}
inline void DmiSystem::set_sku_number(const char* value, size_t size) {
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiSystem.sku_number)
}
inline ::std::string* DmiSystem::mutable_sku_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiSystem.sku_number)
  return sku_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_sku_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiSystem.sku_number)
  
  return sku_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_sku_number(::std::string* sku_number) {
  if (sku_number != NULL) {
    
  } else {
    
  }
  sku_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sku_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiSystem.sku_number)
}

// string family = 8;
inline void DmiSystem::clear_family() {
  family_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::family() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiSystem.family)
  return family_.GetNoArena();
}
inline void DmiSystem::set_family(const ::std::string& value) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiSystem.family)
}
#if LANG_CXX11
inline void DmiSystem::set_family(::std::string&& value) {
  
  family_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiSystem.family)
}
#endif
inline void DmiSystem::set_family(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiSystem.family)
}
inline void DmiSystem::set_family(const char* value, size_t size) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiSystem.family)
}
inline ::std::string* DmiSystem::mutable_family() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiSystem.family)
  return family_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_family() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiSystem.family)
  
  return family_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_family(::std::string* family) {
  if (family != NULL) {
    
  } else {
    
  }
  family_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiSystem.family)
}

// -------------------------------------------------------------------

// DmiBaseboard_Item_Feature

// string name = 1;
inline void DmiBaseboard_Item_Feature::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item_Feature::name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBaseboard.Item.Feature.name)
  return name_.GetNoArena();
}
inline void DmiBaseboard_Item_Feature::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBaseboard.Item.Feature.name)
}
#if LANG_CXX11
inline void DmiBaseboard_Item_Feature::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBaseboard.Item.Feature.name)
}
#endif
inline void DmiBaseboard_Item_Feature::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBaseboard.Item.Feature.name)
}
inline void DmiBaseboard_Item_Feature::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBaseboard.Item.Feature.name)
}
inline ::std::string* DmiBaseboard_Item_Feature::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBaseboard.Item.Feature.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item_Feature::release_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBaseboard.Item.Feature.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item_Feature::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBaseboard.Item.Feature.name)
}

// bool supported = 2;
inline void DmiBaseboard_Item_Feature::clear_supported() {
  supported_ = false;
}
inline bool DmiBaseboard_Item_Feature::supported() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBaseboard.Item.Feature.supported)
  return supported_;
}
inline void DmiBaseboard_Item_Feature::set_supported(bool value) {
  
  supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBaseboard.Item.Feature.supported)
}

// -------------------------------------------------------------------

// DmiBaseboard_Item

// string manufacturer = 1;
inline void DmiBaseboard_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBaseboard.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiBaseboard_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBaseboard.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBaseboard.Item.manufacturer)
}
#endif
inline void DmiBaseboard_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBaseboard.Item.manufacturer)
}
inline void DmiBaseboard_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBaseboard.Item.manufacturer)
}
inline ::std::string* DmiBaseboard_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBaseboard.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBaseboard.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBaseboard.Item.manufacturer)
}

// string product_name = 2;
inline void DmiBaseboard_Item::clear_product_name() {
  product_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::product_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBaseboard.Item.product_name)
  return product_name_.GetNoArena();
}
inline void DmiBaseboard_Item::set_product_name(const ::std::string& value) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBaseboard.Item.product_name)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_product_name(::std::string&& value) {
  
  product_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBaseboard.Item.product_name)
}
#endif
inline void DmiBaseboard_Item::set_product_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBaseboard.Item.product_name)
}
inline void DmiBaseboard_Item::set_product_name(const char* value, size_t size) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBaseboard.Item.product_name)
}
inline ::std::string* DmiBaseboard_Item::mutable_product_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBaseboard.Item.product_name)
  return product_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_product_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBaseboard.Item.product_name)
  
  return product_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_product_name(::std::string* product_name) {
  if (product_name != NULL) {
    
  } else {
    
  }
  product_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBaseboard.Item.product_name)
}

// string version = 3;
inline void DmiBaseboard_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBaseboard.Item.version)
  return version_.GetNoArena();
}
inline void DmiBaseboard_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBaseboard.Item.version)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBaseboard.Item.version)
}
#endif
inline void DmiBaseboard_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBaseboard.Item.version)
}
inline void DmiBaseboard_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBaseboard.Item.version)
}
inline ::std::string* DmiBaseboard_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBaseboard.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBaseboard.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBaseboard.Item.version)
}

// string serial_number = 4;
inline void DmiBaseboard_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBaseboard.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiBaseboard_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBaseboard.Item.serial_number)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBaseboard.Item.serial_number)
}
#endif
inline void DmiBaseboard_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBaseboard.Item.serial_number)
}
inline void DmiBaseboard_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBaseboard.Item.serial_number)
}
inline ::std::string* DmiBaseboard_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBaseboard.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBaseboard.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBaseboard.Item.serial_number)
}

// string asset_tag = 5;
inline void DmiBaseboard_Item::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBaseboard.Item.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void DmiBaseboard_Item::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBaseboard.Item.asset_tag)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBaseboard.Item.asset_tag)
}
#endif
inline void DmiBaseboard_Item::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBaseboard.Item.asset_tag)
}
inline void DmiBaseboard_Item::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBaseboard.Item.asset_tag)
}
inline ::std::string* DmiBaseboard_Item::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBaseboard.Item.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBaseboard.Item.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBaseboard.Item.asset_tag)
}

// repeated .aspia.system_info.DmiBaseboard.Item.Feature feature = 6;
inline int DmiBaseboard_Item::feature_size() const {
  return feature_.size();
}
inline void DmiBaseboard_Item::clear_feature() {
  feature_.Clear();
}
inline const ::aspia::system_info::DmiBaseboard_Item_Feature& DmiBaseboard_Item::feature(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBaseboard.Item.feature)
  return feature_.Get(index);
}
inline ::aspia::system_info::DmiBaseboard_Item_Feature* DmiBaseboard_Item::mutable_feature(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBaseboard.Item.feature)
  return feature_.Mutable(index);
}
inline ::aspia::system_info::DmiBaseboard_Item_Feature* DmiBaseboard_Item::add_feature() {
  // @@protoc_insertion_point(field_add:aspia.system_info.DmiBaseboard.Item.feature)
  return feature_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBaseboard_Item_Feature >*
DmiBaseboard_Item::mutable_feature() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.DmiBaseboard.Item.feature)
  return &feature_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBaseboard_Item_Feature >&
DmiBaseboard_Item::feature() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.DmiBaseboard.Item.feature)
  return feature_;
}

// string location_in_chassis = 7;
inline void DmiBaseboard_Item::clear_location_in_chassis() {
  location_in_chassis_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::location_in_chassis() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBaseboard.Item.location_in_chassis)
  return location_in_chassis_.GetNoArena();
}
inline void DmiBaseboard_Item::set_location_in_chassis(const ::std::string& value) {
  
  location_in_chassis_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBaseboard.Item.location_in_chassis)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_location_in_chassis(::std::string&& value) {
  
  location_in_chassis_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiBaseboard.Item.location_in_chassis)
}
#endif
inline void DmiBaseboard_Item::set_location_in_chassis(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_in_chassis_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiBaseboard.Item.location_in_chassis)
}
inline void DmiBaseboard_Item::set_location_in_chassis(const char* value, size_t size) {
  
  location_in_chassis_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiBaseboard.Item.location_in_chassis)
}
inline ::std::string* DmiBaseboard_Item::mutable_location_in_chassis() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBaseboard.Item.location_in_chassis)
  return location_in_chassis_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_location_in_chassis() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiBaseboard.Item.location_in_chassis)
  
  return location_in_chassis_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_location_in_chassis(::std::string* location_in_chassis) {
  if (location_in_chassis != NULL) {
    
  } else {
    
  }
  location_in_chassis_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location_in_chassis);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiBaseboard.Item.location_in_chassis)
}

// .aspia.system_info.DmiBaseboard.Item.BoardType type = 8;
inline void DmiBaseboard_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::system_info::DmiBaseboard_Item_BoardType DmiBaseboard_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBaseboard.Item.type)
  return static_cast< ::aspia::system_info::DmiBaseboard_Item_BoardType >(type_);
}
inline void DmiBaseboard_Item::set_type(::aspia::system_info::DmiBaseboard_Item_BoardType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiBaseboard.Item.type)
}

// -------------------------------------------------------------------

// DmiBaseboard

// repeated .aspia.system_info.DmiBaseboard.Item item = 1;
inline int DmiBaseboard::item_size() const {
  return item_.size();
}
inline void DmiBaseboard::clear_item() {
  item_.Clear();
}
inline const ::aspia::system_info::DmiBaseboard_Item& DmiBaseboard::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiBaseboard.item)
  return item_.Get(index);
}
inline ::aspia::system_info::DmiBaseboard_Item* DmiBaseboard::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiBaseboard.item)
  return item_.Mutable(index);
}
inline ::aspia::system_info::DmiBaseboard_Item* DmiBaseboard::add_item() {
  // @@protoc_insertion_point(field_add:aspia.system_info.DmiBaseboard.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBaseboard_Item >*
DmiBaseboard::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.DmiBaseboard.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiBaseboard_Item >&
DmiBaseboard::item() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.DmiBaseboard.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiChassis_Item

// string manufacturer = 1;
inline void DmiChassis_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiChassis.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiChassis_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiChassis.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiChassis.Item.manufacturer)
}
#endif
inline void DmiChassis_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiChassis.Item.manufacturer)
}
inline void DmiChassis_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiChassis.Item.manufacturer)
}
inline ::std::string* DmiChassis_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiChassis.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiChassis.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiChassis.Item.manufacturer)
}

// string version = 2;
inline void DmiChassis_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiChassis.Item.version)
  return version_.GetNoArena();
}
inline void DmiChassis_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiChassis.Item.version)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiChassis.Item.version)
}
#endif
inline void DmiChassis_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiChassis.Item.version)
}
inline void DmiChassis_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiChassis.Item.version)
}
inline ::std::string* DmiChassis_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiChassis.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiChassis.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiChassis.Item.version)
}

// string serial_number = 3;
inline void DmiChassis_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiChassis.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiChassis_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiChassis.Item.serial_number)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiChassis.Item.serial_number)
}
#endif
inline void DmiChassis_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiChassis.Item.serial_number)
}
inline void DmiChassis_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiChassis.Item.serial_number)
}
inline ::std::string* DmiChassis_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiChassis.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiChassis.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiChassis.Item.serial_number)
}

// string asset_tag = 4;
inline void DmiChassis_Item::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiChassis.Item.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void DmiChassis_Item::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiChassis.Item.asset_tag)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.DmiChassis.Item.asset_tag)
}
#endif
inline void DmiChassis_Item::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.DmiChassis.Item.asset_tag)
}
inline void DmiChassis_Item::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.DmiChassis.Item.asset_tag)
}
inline ::std::string* DmiChassis_Item::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiChassis.Item.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.system_info.DmiChassis.Item.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.DmiChassis.Item.asset_tag)
}

// .aspia.system_info.DmiChassis.Item.Type type = 5;
inline void DmiChassis_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::system_info::DmiChassis_Item_Type DmiChassis_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiChassis.Item.type)
  return static_cast< ::aspia::system_info::DmiChassis_Item_Type >(type_);
}
inline void DmiChassis_Item::set_type(::aspia::system_info::DmiChassis_Item_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiChassis.Item.type)
}

// .aspia.system_info.DmiChassis.Item.Status os_load_status = 6;
inline void DmiChassis_Item::clear_os_load_status() {
  os_load_status_ = 0;
}
inline ::aspia::system_info::DmiChassis_Item_Status DmiChassis_Item::os_load_status() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiChassis.Item.os_load_status)
  return static_cast< ::aspia::system_info::DmiChassis_Item_Status >(os_load_status_);
}
inline void DmiChassis_Item::set_os_load_status(::aspia::system_info::DmiChassis_Item_Status value) {
  
  os_load_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiChassis.Item.os_load_status)
}

// .aspia.system_info.DmiChassis.Item.Status power_source_status = 7;
inline void DmiChassis_Item::clear_power_source_status() {
  power_source_status_ = 0;
}
inline ::aspia::system_info::DmiChassis_Item_Status DmiChassis_Item::power_source_status() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiChassis.Item.power_source_status)
  return static_cast< ::aspia::system_info::DmiChassis_Item_Status >(power_source_status_);
}
inline void DmiChassis_Item::set_power_source_status(::aspia::system_info::DmiChassis_Item_Status value) {
  
  power_source_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiChassis.Item.power_source_status)
}

// .aspia.system_info.DmiChassis.Item.Status temparature_status = 8;
inline void DmiChassis_Item::clear_temparature_status() {
  temparature_status_ = 0;
}
inline ::aspia::system_info::DmiChassis_Item_Status DmiChassis_Item::temparature_status() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiChassis.Item.temparature_status)
  return static_cast< ::aspia::system_info::DmiChassis_Item_Status >(temparature_status_);
}
inline void DmiChassis_Item::set_temparature_status(::aspia::system_info::DmiChassis_Item_Status value) {
  
  temparature_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiChassis.Item.temparature_status)
}

// .aspia.system_info.DmiChassis.Item.SecurityStatus security_status = 9;
inline void DmiChassis_Item::clear_security_status() {
  security_status_ = 0;
}
inline ::aspia::system_info::DmiChassis_Item_SecurityStatus DmiChassis_Item::security_status() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiChassis.Item.security_status)
  return static_cast< ::aspia::system_info::DmiChassis_Item_SecurityStatus >(security_status_);
}
inline void DmiChassis_Item::set_security_status(::aspia::system_info::DmiChassis_Item_SecurityStatus value) {
  
  security_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiChassis.Item.security_status)
}

// int32 height = 10;
inline void DmiChassis_Item::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 DmiChassis_Item::height() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiChassis.Item.height)
  return height_;
}
inline void DmiChassis_Item::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiChassis.Item.height)
}

// int32 number_of_power_cords = 11;
inline void DmiChassis_Item::clear_number_of_power_cords() {
  number_of_power_cords_ = 0;
}
inline ::google::protobuf::int32 DmiChassis_Item::number_of_power_cords() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiChassis.Item.number_of_power_cords)
  return number_of_power_cords_;
}
inline void DmiChassis_Item::set_number_of_power_cords(::google::protobuf::int32 value) {
  
  number_of_power_cords_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.DmiChassis.Item.number_of_power_cords)
}

// -------------------------------------------------------------------

// DmiChassis

// repeated .aspia.system_info.DmiChassis.Item item = 1;
inline int DmiChassis::item_size() const {
  return item_.size();
}
inline void DmiChassis::clear_item() {
  item_.Clear();
}
inline const ::aspia::system_info::DmiChassis_Item& DmiChassis::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.DmiChassis.item)
  return item_.Get(index);
}
inline ::aspia::system_info::DmiChassis_Item* DmiChassis::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.DmiChassis.item)
  return item_.Mutable(index);
}
inline ::aspia::system_info::DmiChassis_Item* DmiChassis::add_item() {
  // @@protoc_insertion_point(field_add:aspia.system_info.DmiChassis.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiChassis_Item >*
DmiChassis::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.DmiChassis.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::DmiChassis_Item >&
DmiChassis::item() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.DmiChassis.item)
  return item_;
}

// -------------------------------------------------------------------

// Monitors_Item_Timing

// int32 width = 1;
inline void Monitors_Item_Timing::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item_Timing::width() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.Timing.width)
  return width_;
}
inline void Monitors_Item_Timing::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.Timing.width)
}

// int32 height = 2;
inline void Monitors_Item_Timing::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item_Timing::height() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.Timing.height)
  return height_;
}
inline void Monitors_Item_Timing::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.Timing.height)
}

// int32 frequency = 3;
inline void Monitors_Item_Timing::clear_frequency() {
  frequency_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item_Timing::frequency() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.Timing.frequency)
  return frequency_;
}
inline void Monitors_Item_Timing::set_frequency(::google::protobuf::int32 value) {
  
  frequency_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.Timing.frequency)
}

// -------------------------------------------------------------------

// Monitors_Item

// string system_name = 1;
inline void Monitors_Item::clear_system_name() {
  system_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::system_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.system_name)
  return system_name_.GetNoArena();
}
inline void Monitors_Item::set_system_name(const ::std::string& value) {
  
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.system_name)
}
#if LANG_CXX11
inline void Monitors_Item::set_system_name(::std::string&& value) {
  
  system_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Monitors.Item.system_name)
}
#endif
inline void Monitors_Item::set_system_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Monitors.Item.system_name)
}
inline void Monitors_Item::set_system_name(const char* value, size_t size) {
  
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Monitors.Item.system_name)
}
inline ::std::string* Monitors_Item::mutable_system_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Monitors.Item.system_name)
  return system_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_system_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Monitors.Item.system_name)
  
  return system_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_system_name(::std::string* system_name) {
  if (system_name != NULL) {
    
  } else {
    
  }
  system_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Monitors.Item.system_name)
}

// string monitor_name = 2;
inline void Monitors_Item::clear_monitor_name() {
  monitor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::monitor_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.monitor_name)
  return monitor_name_.GetNoArena();
}
inline void Monitors_Item::set_monitor_name(const ::std::string& value) {
  
  monitor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.monitor_name)
}
#if LANG_CXX11
inline void Monitors_Item::set_monitor_name(::std::string&& value) {
  
  monitor_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Monitors.Item.monitor_name)
}
#endif
inline void Monitors_Item::set_monitor_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  monitor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Monitors.Item.monitor_name)
}
inline void Monitors_Item::set_monitor_name(const char* value, size_t size) {
  
  monitor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Monitors.Item.monitor_name)
}
inline ::std::string* Monitors_Item::mutable_monitor_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Monitors.Item.monitor_name)
  return monitor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_monitor_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Monitors.Item.monitor_name)
  
  return monitor_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_monitor_name(::std::string* monitor_name) {
  if (monitor_name != NULL) {
    
  } else {
    
  }
  monitor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), monitor_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Monitors.Item.monitor_name)
}

// string manufacturer_name = 3;
inline void Monitors_Item::clear_manufacturer_name() {
  manufacturer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::manufacturer_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.manufacturer_name)
  return manufacturer_name_.GetNoArena();
}
inline void Monitors_Item::set_manufacturer_name(const ::std::string& value) {
  
  manufacturer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.manufacturer_name)
}
#if LANG_CXX11
inline void Monitors_Item::set_manufacturer_name(::std::string&& value) {
  
  manufacturer_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Monitors.Item.manufacturer_name)
}
#endif
inline void Monitors_Item::set_manufacturer_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Monitors.Item.manufacturer_name)
}
inline void Monitors_Item::set_manufacturer_name(const char* value, size_t size) {
  
  manufacturer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Monitors.Item.manufacturer_name)
}
inline ::std::string* Monitors_Item::mutable_manufacturer_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Monitors.Item.manufacturer_name)
  return manufacturer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_manufacturer_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Monitors.Item.manufacturer_name)
  
  return manufacturer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_manufacturer_name(::std::string* manufacturer_name) {
  if (manufacturer_name != NULL) {
    
  } else {
    
  }
  manufacturer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Monitors.Item.manufacturer_name)
}

// string monitor_id = 4;
inline void Monitors_Item::clear_monitor_id() {
  monitor_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::monitor_id() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.monitor_id)
  return monitor_id_.GetNoArena();
}
inline void Monitors_Item::set_monitor_id(const ::std::string& value) {
  
  monitor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.monitor_id)
}
#if LANG_CXX11
inline void Monitors_Item::set_monitor_id(::std::string&& value) {
  
  monitor_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Monitors.Item.monitor_id)
}
#endif
inline void Monitors_Item::set_monitor_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  monitor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Monitors.Item.monitor_id)
}
inline void Monitors_Item::set_monitor_id(const char* value, size_t size) {
  
  monitor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Monitors.Item.monitor_id)
}
inline ::std::string* Monitors_Item::mutable_monitor_id() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Monitors.Item.monitor_id)
  return monitor_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_monitor_id() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Monitors.Item.monitor_id)
  
  return monitor_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_monitor_id(::std::string* monitor_id) {
  if (monitor_id != NULL) {
    
  } else {
    
  }
  monitor_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), monitor_id);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Monitors.Item.monitor_id)
}

// string serial_number = 5;
inline void Monitors_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void Monitors_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.serial_number)
}
#if LANG_CXX11
inline void Monitors_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Monitors.Item.serial_number)
}
#endif
inline void Monitors_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Monitors.Item.serial_number)
}
inline void Monitors_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Monitors.Item.serial_number)
}
inline ::std::string* Monitors_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Monitors.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Monitors.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Monitors.Item.serial_number)
}

// int32 edid_version = 6;
inline void Monitors_Item::clear_edid_version() {
  edid_version_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::edid_version() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.edid_version)
  return edid_version_;
}
inline void Monitors_Item::set_edid_version(::google::protobuf::int32 value) {
  
  edid_version_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.edid_version)
}

// int32 edid_revision = 7;
inline void Monitors_Item::clear_edid_revision() {
  edid_revision_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::edid_revision() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.edid_revision)
  return edid_revision_;
}
inline void Monitors_Item::set_edid_revision(::google::protobuf::int32 value) {
  
  edid_revision_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.edid_revision)
}

// int32 week_of_manufacture = 8;
inline void Monitors_Item::clear_week_of_manufacture() {
  week_of_manufacture_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::week_of_manufacture() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.week_of_manufacture)
  return week_of_manufacture_;
}
inline void Monitors_Item::set_week_of_manufacture(::google::protobuf::int32 value) {
  
  week_of_manufacture_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.week_of_manufacture)
}

// int32 year_of_manufacture = 9;
inline void Monitors_Item::clear_year_of_manufacture() {
  year_of_manufacture_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::year_of_manufacture() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.year_of_manufacture)
  return year_of_manufacture_;
}
inline void Monitors_Item::set_year_of_manufacture(::google::protobuf::int32 value) {
  
  year_of_manufacture_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.year_of_manufacture)
}

// int32 max_horizontal_image_size = 10;
inline void Monitors_Item::clear_max_horizontal_image_size() {
  max_horizontal_image_size_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_horizontal_image_size() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.max_horizontal_image_size)
  return max_horizontal_image_size_;
}
inline void Monitors_Item::set_max_horizontal_image_size(::google::protobuf::int32 value) {
  
  max_horizontal_image_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.max_horizontal_image_size)
}

// int32 max_vertical_image_size = 11;
inline void Monitors_Item::clear_max_vertical_image_size() {
  max_vertical_image_size_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_vertical_image_size() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.max_vertical_image_size)
  return max_vertical_image_size_;
}
inline void Monitors_Item::set_max_vertical_image_size(::google::protobuf::int32 value) {
  
  max_vertical_image_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.max_vertical_image_size)
}

// int32 horizontal_resolution = 12;
inline void Monitors_Item::clear_horizontal_resolution() {
  horizontal_resolution_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::horizontal_resolution() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.horizontal_resolution)
  return horizontal_resolution_;
}
inline void Monitors_Item::set_horizontal_resolution(::google::protobuf::int32 value) {
  
  horizontal_resolution_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.horizontal_resolution)
}

// int32 vertical_resoulution = 13;
inline void Monitors_Item::clear_vertical_resoulution() {
  vertical_resoulution_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::vertical_resoulution() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.vertical_resoulution)
  return vertical_resoulution_;
}
inline void Monitors_Item::set_vertical_resoulution(::google::protobuf::int32 value) {
  
  vertical_resoulution_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.vertical_resoulution)
}

// double gamma = 14;
inline void Monitors_Item::clear_gamma() {
  gamma_ = 0;
}
inline double Monitors_Item::gamma() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.gamma)
  return gamma_;
}
inline void Monitors_Item::set_gamma(double value) {
  
  gamma_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.gamma)
}

// int32 min_horizontal_rate = 15;
inline void Monitors_Item::clear_min_horizontal_rate() {
  min_horizontal_rate_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::min_horizontal_rate() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.min_horizontal_rate)
  return min_horizontal_rate_;
}
inline void Monitors_Item::set_min_horizontal_rate(::google::protobuf::int32 value) {
  
  min_horizontal_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.min_horizontal_rate)
}

// int32 max_horizontal_rate = 16;
inline void Monitors_Item::clear_max_horizontal_rate() {
  max_horizontal_rate_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_horizontal_rate() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.max_horizontal_rate)
  return max_horizontal_rate_;
}
inline void Monitors_Item::set_max_horizontal_rate(::google::protobuf::int32 value) {
  
  max_horizontal_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.max_horizontal_rate)
}

// int32 min_vertical_rate = 17;
inline void Monitors_Item::clear_min_vertical_rate() {
  min_vertical_rate_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::min_vertical_rate() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.min_vertical_rate)
  return min_vertical_rate_;
}
inline void Monitors_Item::set_min_vertical_rate(::google::protobuf::int32 value) {
  
  min_vertical_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.min_vertical_rate)
}

// int32 max_vertical_rate = 18;
inline void Monitors_Item::clear_max_vertical_rate() {
  max_vertical_rate_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_vertical_rate() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.max_vertical_rate)
  return max_vertical_rate_;
}
inline void Monitors_Item::set_max_vertical_rate(::google::protobuf::int32 value) {
  
  max_vertical_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.max_vertical_rate)
}

// double pixel_clock = 19;
inline void Monitors_Item::clear_pixel_clock() {
  pixel_clock_ = 0;
}
inline double Monitors_Item::pixel_clock() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.pixel_clock)
  return pixel_clock_;
}
inline void Monitors_Item::set_pixel_clock(double value) {
  
  pixel_clock_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.pixel_clock)
}

// int32 max_pixel_clock = 20;
inline void Monitors_Item::clear_max_pixel_clock() {
  max_pixel_clock_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_pixel_clock() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.max_pixel_clock)
  return max_pixel_clock_;
}
inline void Monitors_Item::set_max_pixel_clock(::google::protobuf::int32 value) {
  
  max_pixel_clock_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.max_pixel_clock)
}

// .aspia.system_info.Monitors.Item.InputSignalType input_signal_type = 21;
inline void Monitors_Item::clear_input_signal_type() {
  input_signal_type_ = 0;
}
inline ::aspia::system_info::Monitors_Item_InputSignalType Monitors_Item::input_signal_type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.input_signal_type)
  return static_cast< ::aspia::system_info::Monitors_Item_InputSignalType >(input_signal_type_);
}
inline void Monitors_Item::set_input_signal_type(::aspia::system_info::Monitors_Item_InputSignalType value) {
  
  input_signal_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.input_signal_type)
}

// bool default_gtf_supported = 22;
inline void Monitors_Item::clear_default_gtf_supported() {
  default_gtf_supported_ = false;
}
inline bool Monitors_Item::default_gtf_supported() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.default_gtf_supported)
  return default_gtf_supported_;
}
inline void Monitors_Item::set_default_gtf_supported(bool value) {
  
  default_gtf_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.default_gtf_supported)
}

// bool suspend_supported = 23;
inline void Monitors_Item::clear_suspend_supported() {
  suspend_supported_ = false;
}
inline bool Monitors_Item::suspend_supported() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.suspend_supported)
  return suspend_supported_;
}
inline void Monitors_Item::set_suspend_supported(bool value) {
  
  suspend_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.suspend_supported)
}

// bool standby_supported = 24;
inline void Monitors_Item::clear_standby_supported() {
  standby_supported_ = false;
}
inline bool Monitors_Item::standby_supported() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.standby_supported)
  return standby_supported_;
}
inline void Monitors_Item::set_standby_supported(bool value) {
  
  standby_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.standby_supported)
}

// bool active_off_supported = 25;
inline void Monitors_Item::clear_active_off_supported() {
  active_off_supported_ = false;
}
inline bool Monitors_Item::active_off_supported() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.active_off_supported)
  return active_off_supported_;
}
inline void Monitors_Item::set_active_off_supported(bool value) {
  
  active_off_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.active_off_supported)
}

// bool preferred_timing_mode_supported = 26;
inline void Monitors_Item::clear_preferred_timing_mode_supported() {
  preferred_timing_mode_supported_ = false;
}
inline bool Monitors_Item::preferred_timing_mode_supported() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.preferred_timing_mode_supported)
  return preferred_timing_mode_supported_;
}
inline void Monitors_Item::set_preferred_timing_mode_supported(bool value) {
  
  preferred_timing_mode_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.preferred_timing_mode_supported)
}

// bool srgb_supported = 27;
inline void Monitors_Item::clear_srgb_supported() {
  srgb_supported_ = false;
}
inline bool Monitors_Item::srgb_supported() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.srgb_supported)
  return srgb_supported_;
}
inline void Monitors_Item::set_srgb_supported(bool value) {
  
  srgb_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Monitors.Item.srgb_supported)
}

// repeated .aspia.system_info.Monitors.Item.Timing timings = 28;
inline int Monitors_Item::timings_size() const {
  return timings_.size();
}
inline void Monitors_Item::clear_timings() {
  timings_.Clear();
}
inline const ::aspia::system_info::Monitors_Item_Timing& Monitors_Item::timings(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.Item.timings)
  return timings_.Get(index);
}
inline ::aspia::system_info::Monitors_Item_Timing* Monitors_Item::mutable_timings(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Monitors.Item.timings)
  return timings_.Mutable(index);
}
inline ::aspia::system_info::Monitors_Item_Timing* Monitors_Item::add_timings() {
  // @@protoc_insertion_point(field_add:aspia.system_info.Monitors.Item.timings)
  return timings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Monitors_Item_Timing >*
Monitors_Item::mutable_timings() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.Monitors.Item.timings)
  return &timings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Monitors_Item_Timing >&
Monitors_Item::timings() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.Monitors.Item.timings)
  return timings_;
}

// -------------------------------------------------------------------

// Monitors

// repeated .aspia.system_info.Monitors.Item item = 1;
inline int Monitors::item_size() const {
  return item_.size();
}
inline void Monitors::clear_item() {
  item_.Clear();
}
inline const ::aspia::system_info::Monitors_Item& Monitors::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Monitors.item)
  return item_.Get(index);
}
inline ::aspia::system_info::Monitors_Item* Monitors::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Monitors.item)
  return item_.Mutable(index);
}
inline ::aspia::system_info::Monitors_Item* Monitors::add_item() {
  // @@protoc_insertion_point(field_add:aspia.system_info.Monitors.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Monitors_Item >*
Monitors::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.Monitors.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Monitors_Item >&
Monitors::item() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.Monitors.item)
  return item_;
}

// -------------------------------------------------------------------

// Printers_Item

// string name = 1;
inline void Printers_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.name)
  return name_.GetNoArena();
}
inline void Printers_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.name)
}
#if LANG_CXX11
inline void Printers_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Printers.Item.name)
}
#endif
inline void Printers_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Printers.Item.name)
}
inline void Printers_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Printers.Item.name)
}
inline ::std::string* Printers_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Printers.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Printers.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Printers.Item.name)
}

// bool is_default = 2;
inline void Printers_Item::clear_is_default() {
  is_default_ = false;
}
inline bool Printers_Item::is_default() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.is_default)
  return is_default_;
}
inline void Printers_Item::set_is_default(bool value) {
  
  is_default_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.is_default)
}

// bool is_shared = 3;
inline void Printers_Item::clear_is_shared() {
  is_shared_ = false;
}
inline bool Printers_Item::is_shared() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.is_shared)
  return is_shared_;
}
inline void Printers_Item::set_is_shared(bool value) {
  
  is_shared_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.is_shared)
}

// string share_name = 4;
inline void Printers_Item::clear_share_name() {
  share_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::share_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.share_name)
  return share_name_.GetNoArena();
}
inline void Printers_Item::set_share_name(const ::std::string& value) {
  
  share_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.share_name)
}
#if LANG_CXX11
inline void Printers_Item::set_share_name(::std::string&& value) {
  
  share_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Printers.Item.share_name)
}
#endif
inline void Printers_Item::set_share_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  share_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Printers.Item.share_name)
}
inline void Printers_Item::set_share_name(const char* value, size_t size) {
  
  share_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Printers.Item.share_name)
}
inline ::std::string* Printers_Item::mutable_share_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Printers.Item.share_name)
  return share_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_share_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Printers.Item.share_name)
  
  return share_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_share_name(::std::string* share_name) {
  if (share_name != NULL) {
    
  } else {
    
  }
  share_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), share_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Printers.Item.share_name)
}

// string port_name = 5;
inline void Printers_Item::clear_port_name() {
  port_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::port_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.port_name)
  return port_name_.GetNoArena();
}
inline void Printers_Item::set_port_name(const ::std::string& value) {
  
  port_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.port_name)
}
#if LANG_CXX11
inline void Printers_Item::set_port_name(::std::string&& value) {
  
  port_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Printers.Item.port_name)
}
#endif
inline void Printers_Item::set_port_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Printers.Item.port_name)
}
inline void Printers_Item::set_port_name(const char* value, size_t size) {
  
  port_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Printers.Item.port_name)
}
inline ::std::string* Printers_Item::mutable_port_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Printers.Item.port_name)
  return port_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_port_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Printers.Item.port_name)
  
  return port_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_port_name(::std::string* port_name) {
  if (port_name != NULL) {
    
  } else {
    
  }
  port_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Printers.Item.port_name)
}

// string driver_name = 6;
inline void Printers_Item::clear_driver_name() {
  driver_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::driver_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.driver_name)
  return driver_name_.GetNoArena();
}
inline void Printers_Item::set_driver_name(const ::std::string& value) {
  
  driver_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.driver_name)
}
#if LANG_CXX11
inline void Printers_Item::set_driver_name(::std::string&& value) {
  
  driver_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Printers.Item.driver_name)
}
#endif
inline void Printers_Item::set_driver_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Printers.Item.driver_name)
}
inline void Printers_Item::set_driver_name(const char* value, size_t size) {
  
  driver_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Printers.Item.driver_name)
}
inline ::std::string* Printers_Item::mutable_driver_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Printers.Item.driver_name)
  return driver_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_driver_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Printers.Item.driver_name)
  
  return driver_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_driver_name(::std::string* driver_name) {
  if (driver_name != NULL) {
    
  } else {
    
  }
  driver_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Printers.Item.driver_name)
}

// string device_name = 7;
inline void Printers_Item::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::device_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.device_name)
  return device_name_.GetNoArena();
}
inline void Printers_Item::set_device_name(const ::std::string& value) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.device_name)
}
#if LANG_CXX11
inline void Printers_Item::set_device_name(::std::string&& value) {
  
  device_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Printers.Item.device_name)
}
#endif
inline void Printers_Item::set_device_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Printers.Item.device_name)
}
inline void Printers_Item::set_device_name(const char* value, size_t size) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Printers.Item.device_name)
}
inline ::std::string* Printers_Item::mutable_device_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Printers.Item.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_device_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Printers.Item.device_name)
  
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    
  } else {
    
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Printers.Item.device_name)
}

// string print_processor = 8;
inline void Printers_Item::clear_print_processor() {
  print_processor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::print_processor() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.print_processor)
  return print_processor_.GetNoArena();
}
inline void Printers_Item::set_print_processor(const ::std::string& value) {
  
  print_processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.print_processor)
}
#if LANG_CXX11
inline void Printers_Item::set_print_processor(::std::string&& value) {
  
  print_processor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Printers.Item.print_processor)
}
#endif
inline void Printers_Item::set_print_processor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  print_processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Printers.Item.print_processor)
}
inline void Printers_Item::set_print_processor(const char* value, size_t size) {
  
  print_processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Printers.Item.print_processor)
}
inline ::std::string* Printers_Item::mutable_print_processor() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Printers.Item.print_processor)
  return print_processor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_print_processor() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Printers.Item.print_processor)
  
  return print_processor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_print_processor(::std::string* print_processor) {
  if (print_processor != NULL) {
    
  } else {
    
  }
  print_processor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), print_processor);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Printers.Item.print_processor)
}

// string data_type = 9;
inline void Printers_Item::clear_data_type() {
  data_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::data_type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.data_type)
  return data_type_.GetNoArena();
}
inline void Printers_Item::set_data_type(const ::std::string& value) {
  
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.data_type)
}
#if LANG_CXX11
inline void Printers_Item::set_data_type(::std::string&& value) {
  
  data_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Printers.Item.data_type)
}
#endif
inline void Printers_Item::set_data_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Printers.Item.data_type)
}
inline void Printers_Item::set_data_type(const char* value, size_t size) {
  
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Printers.Item.data_type)
}
inline ::std::string* Printers_Item::mutable_data_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Printers.Item.data_type)
  return data_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_data_type() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Printers.Item.data_type)
  
  return data_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_data_type(::std::string* data_type) {
  if (data_type != NULL) {
    
  } else {
    
  }
  data_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Printers.Item.data_type)
}

// string server_name = 10;
inline void Printers_Item::clear_server_name() {
  server_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::server_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.server_name)
  return server_name_.GetNoArena();
}
inline void Printers_Item::set_server_name(const ::std::string& value) {
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.server_name)
}
#if LANG_CXX11
inline void Printers_Item::set_server_name(::std::string&& value) {
  
  server_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Printers.Item.server_name)
}
#endif
inline void Printers_Item::set_server_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Printers.Item.server_name)
}
inline void Printers_Item::set_server_name(const char* value, size_t size) {
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Printers.Item.server_name)
}
inline ::std::string* Printers_Item::mutable_server_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Printers.Item.server_name)
  return server_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_server_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Printers.Item.server_name)
  
  return server_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_server_name(::std::string* server_name) {
  if (server_name != NULL) {
    
  } else {
    
  }
  server_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Printers.Item.server_name)
}

// string location = 11;
inline void Printers_Item::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::location() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.location)
  return location_.GetNoArena();
}
inline void Printers_Item::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.location)
}
#if LANG_CXX11
inline void Printers_Item::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Printers.Item.location)
}
#endif
inline void Printers_Item::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Printers.Item.location)
}
inline void Printers_Item::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Printers.Item.location)
}
inline ::std::string* Printers_Item::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Printers.Item.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_location() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Printers.Item.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Printers.Item.location)
}

// string comment = 12;
inline void Printers_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.comment)
  return comment_.GetNoArena();
}
inline void Printers_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.comment)
}
#if LANG_CXX11
inline void Printers_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Printers.Item.comment)
}
#endif
inline void Printers_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Printers.Item.comment)
}
inline void Printers_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Printers.Item.comment)
}
inline ::std::string* Printers_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Printers.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Printers.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Printers.Item.comment)
}

// int32 jobs_count = 13;
inline void Printers_Item::clear_jobs_count() {
  jobs_count_ = 0;
}
inline ::google::protobuf::int32 Printers_Item::jobs_count() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.jobs_count)
  return jobs_count_;
}
inline void Printers_Item::set_jobs_count(::google::protobuf::int32 value) {
  
  jobs_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.jobs_count)
}

// int32 paper_width = 14;
inline void Printers_Item::clear_paper_width() {
  paper_width_ = 0;
}
inline ::google::protobuf::int32 Printers_Item::paper_width() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.paper_width)
  return paper_width_;
}
inline void Printers_Item::set_paper_width(::google::protobuf::int32 value) {
  
  paper_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.paper_width)
}

// int32 paper_length = 15;
inline void Printers_Item::clear_paper_length() {
  paper_length_ = 0;
}
inline ::google::protobuf::int32 Printers_Item::paper_length() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.paper_length)
  return paper_length_;
}
inline void Printers_Item::set_paper_length(::google::protobuf::int32 value) {
  
  paper_length_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.paper_length)
}

// int32 print_quality = 16;
inline void Printers_Item::clear_print_quality() {
  print_quality_ = 0;
}
inline ::google::protobuf::int32 Printers_Item::print_quality() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.print_quality)
  return print_quality_;
}
inline void Printers_Item::set_print_quality(::google::protobuf::int32 value) {
  
  print_quality_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.print_quality)
}

// .aspia.system_info.Printers.Item.Orientation orientation = 17;
inline void Printers_Item::clear_orientation() {
  orientation_ = 0;
}
inline ::aspia::system_info::Printers_Item_Orientation Printers_Item::orientation() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.Item.orientation)
  return static_cast< ::aspia::system_info::Printers_Item_Orientation >(orientation_);
}
inline void Printers_Item::set_orientation(::aspia::system_info::Printers_Item_Orientation value) {
  
  orientation_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Printers.Item.orientation)
}

// -------------------------------------------------------------------

// Printers

// repeated .aspia.system_info.Printers.Item item = 1;
inline int Printers::item_size() const {
  return item_.size();
}
inline void Printers::clear_item() {
  item_.Clear();
}
inline const ::aspia::system_info::Printers_Item& Printers::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Printers.item)
  return item_.Get(index);
}
inline ::aspia::system_info::Printers_Item* Printers::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Printers.item)
  return item_.Mutable(index);
}
inline ::aspia::system_info::Printers_Item* Printers::add_item() {
  // @@protoc_insertion_point(field_add:aspia.system_info.Printers.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Printers_Item >*
Printers::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.Printers.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Printers_Item >&
Printers::item() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.Printers.item)
  return item_;
}

// -------------------------------------------------------------------

// Services_Item

// string name = 1;
inline void Services_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Services.Item.name)
  return name_.GetNoArena();
}
inline void Services_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Services.Item.name)
}
#if LANG_CXX11
inline void Services_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Services.Item.name)
}
#endif
inline void Services_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Services.Item.name)
}
inline void Services_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Services.Item.name)
}
inline ::std::string* Services_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Services.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Services.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Services.Item.name)
}

// string display_name = 2;
inline void Services_Item::clear_display_name() {
  display_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::display_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Services.Item.display_name)
  return display_name_.GetNoArena();
}
inline void Services_Item::set_display_name(const ::std::string& value) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Services.Item.display_name)
}
#if LANG_CXX11
inline void Services_Item::set_display_name(::std::string&& value) {
  
  display_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Services.Item.display_name)
}
#endif
inline void Services_Item::set_display_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Services.Item.display_name)
}
inline void Services_Item::set_display_name(const char* value, size_t size) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Services.Item.display_name)
}
inline ::std::string* Services_Item::mutable_display_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Services.Item.display_name)
  return display_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_display_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Services.Item.display_name)
  
  return display_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_display_name(::std::string* display_name) {
  if (display_name != NULL) {
    
  } else {
    
  }
  display_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Services.Item.display_name)
}

// string description = 3;
inline void Services_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Services.Item.description)
  return description_.GetNoArena();
}
inline void Services_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Services.Item.description)
}
#if LANG_CXX11
inline void Services_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Services.Item.description)
}
#endif
inline void Services_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Services.Item.description)
}
inline void Services_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Services.Item.description)
}
inline ::std::string* Services_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Services.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Services.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Services.Item.description)
}

// .aspia.system_info.Services.Item.Status status = 4;
inline void Services_Item::clear_status() {
  status_ = 0;
}
inline ::aspia::system_info::Services_Item_Status Services_Item::status() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Services.Item.status)
  return static_cast< ::aspia::system_info::Services_Item_Status >(status_);
}
inline void Services_Item::set_status(::aspia::system_info::Services_Item_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Services.Item.status)
}

// .aspia.system_info.Services.Item.StartupType startup_type = 5;
inline void Services_Item::clear_startup_type() {
  startup_type_ = 0;
}
inline ::aspia::system_info::Services_Item_StartupType Services_Item::startup_type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Services.Item.startup_type)
  return static_cast< ::aspia::system_info::Services_Item_StartupType >(startup_type_);
}
inline void Services_Item::set_startup_type(::aspia::system_info::Services_Item_StartupType value) {
  
  startup_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Services.Item.startup_type)
}

// string binary_path = 6;
inline void Services_Item::clear_binary_path() {
  binary_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::binary_path() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Services.Item.binary_path)
  return binary_path_.GetNoArena();
}
inline void Services_Item::set_binary_path(const ::std::string& value) {
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Services.Item.binary_path)
}
#if LANG_CXX11
inline void Services_Item::set_binary_path(::std::string&& value) {
  
  binary_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Services.Item.binary_path)
}
#endif
inline void Services_Item::set_binary_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Services.Item.binary_path)
}
inline void Services_Item::set_binary_path(const char* value, size_t size) {
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Services.Item.binary_path)
}
inline ::std::string* Services_Item::mutable_binary_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Services.Item.binary_path)
  return binary_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_binary_path() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Services.Item.binary_path)
  
  return binary_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_binary_path(::std::string* binary_path) {
  if (binary_path != NULL) {
    
  } else {
    
  }
  binary_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), binary_path);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Services.Item.binary_path)
}

// string start_name = 7;
inline void Services_Item::clear_start_name() {
  start_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::start_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Services.Item.start_name)
  return start_name_.GetNoArena();
}
inline void Services_Item::set_start_name(const ::std::string& value) {
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Services.Item.start_name)
}
#if LANG_CXX11
inline void Services_Item::set_start_name(::std::string&& value) {
  
  start_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Services.Item.start_name)
}
#endif
inline void Services_Item::set_start_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Services.Item.start_name)
}
inline void Services_Item::set_start_name(const char* value, size_t size) {
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Services.Item.start_name)
}
inline ::std::string* Services_Item::mutable_start_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Services.Item.start_name)
  return start_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_start_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Services.Item.start_name)
  
  return start_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_start_name(::std::string* start_name) {
  if (start_name != NULL) {
    
  } else {
    
  }
  start_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Services.Item.start_name)
}

// -------------------------------------------------------------------

// Services

// repeated .aspia.system_info.Services.Item item = 1;
inline int Services::item_size() const {
  return item_.size();
}
inline void Services::clear_item() {
  item_.Clear();
}
inline const ::aspia::system_info::Services_Item& Services::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Services.item)
  return item_.Get(index);
}
inline ::aspia::system_info::Services_Item* Services::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Services.item)
  return item_.Mutable(index);
}
inline ::aspia::system_info::Services_Item* Services::add_item() {
  // @@protoc_insertion_point(field_add:aspia.system_info.Services.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Services_Item >*
Services::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.Services.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Services_Item >&
Services::item() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.Services.item)
  return item_;
}

// -------------------------------------------------------------------

// NetworkCards_Item_IpAddress

// string address = 1;
inline void NetworkCards_Item_IpAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item_IpAddress::address() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.IpAddress.address)
  return address_.GetNoArena();
}
inline void NetworkCards_Item_IpAddress::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.IpAddress.address)
}
#if LANG_CXX11
inline void NetworkCards_Item_IpAddress::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.NetworkCards.Item.IpAddress.address)
}
#endif
inline void NetworkCards_Item_IpAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.NetworkCards.Item.IpAddress.address)
}
inline void NetworkCards_Item_IpAddress::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.NetworkCards.Item.IpAddress.address)
}
inline ::std::string* NetworkCards_Item_IpAddress::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.Item.IpAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item_IpAddress::release_address() {
  // @@protoc_insertion_point(field_release:aspia.system_info.NetworkCards.Item.IpAddress.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item_IpAddress::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.NetworkCards.Item.IpAddress.address)
}

// string mask = 2;
inline void NetworkCards_Item_IpAddress::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item_IpAddress::mask() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.IpAddress.mask)
  return mask_.GetNoArena();
}
inline void NetworkCards_Item_IpAddress::set_mask(const ::std::string& value) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.IpAddress.mask)
}
#if LANG_CXX11
inline void NetworkCards_Item_IpAddress::set_mask(::std::string&& value) {
  
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.NetworkCards.Item.IpAddress.mask)
}
#endif
inline void NetworkCards_Item_IpAddress::set_mask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.NetworkCards.Item.IpAddress.mask)
}
inline void NetworkCards_Item_IpAddress::set_mask(const char* value, size_t size) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.NetworkCards.Item.IpAddress.mask)
}
inline ::std::string* NetworkCards_Item_IpAddress::mutable_mask() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.Item.IpAddress.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item_IpAddress::release_mask() {
  // @@protoc_insertion_point(field_release:aspia.system_info.NetworkCards.Item.IpAddress.mask)
  
  return mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item_IpAddress::set_allocated_mask(::std::string* mask) {
  if (mask != NULL) {
    
  } else {
    
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.NetworkCards.Item.IpAddress.mask)
}

// -------------------------------------------------------------------

// NetworkCards_Item

// string adapter_name = 1;
inline void NetworkCards_Item::clear_adapter_name() {
  adapter_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::adapter_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.adapter_name)
  return adapter_name_.GetNoArena();
}
inline void NetworkCards_Item::set_adapter_name(const ::std::string& value) {
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.adapter_name)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_adapter_name(::std::string&& value) {
  
  adapter_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.NetworkCards.Item.adapter_name)
}
#endif
inline void NetworkCards_Item::set_adapter_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.NetworkCards.Item.adapter_name)
}
inline void NetworkCards_Item::set_adapter_name(const char* value, size_t size) {
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.NetworkCards.Item.adapter_name)
}
inline ::std::string* NetworkCards_Item::mutable_adapter_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.Item.adapter_name)
  return adapter_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_adapter_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.NetworkCards.Item.adapter_name)
  
  return adapter_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_adapter_name(::std::string* adapter_name) {
  if (adapter_name != NULL) {
    
  } else {
    
  }
  adapter_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adapter_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.NetworkCards.Item.adapter_name)
}

// string connection_name = 2;
inline void NetworkCards_Item::clear_connection_name() {
  connection_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::connection_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.connection_name)
  return connection_name_.GetNoArena();
}
inline void NetworkCards_Item::set_connection_name(const ::std::string& value) {
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.connection_name)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_connection_name(::std::string&& value) {
  
  connection_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.NetworkCards.Item.connection_name)
}
#endif
inline void NetworkCards_Item::set_connection_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.NetworkCards.Item.connection_name)
}
inline void NetworkCards_Item::set_connection_name(const char* value, size_t size) {
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.NetworkCards.Item.connection_name)
}
inline ::std::string* NetworkCards_Item::mutable_connection_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.Item.connection_name)
  return connection_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_connection_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.NetworkCards.Item.connection_name)
  
  return connection_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_connection_name(::std::string* connection_name) {
  if (connection_name != NULL) {
    
  } else {
    
  }
  connection_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connection_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.NetworkCards.Item.connection_name)
}

// string interface_type = 3;
inline void NetworkCards_Item::clear_interface_type() {
  interface_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::interface_type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.interface_type)
  return interface_type_.GetNoArena();
}
inline void NetworkCards_Item::set_interface_type(const ::std::string& value) {
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.interface_type)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_interface_type(::std::string&& value) {
  
  interface_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.NetworkCards.Item.interface_type)
}
#endif
inline void NetworkCards_Item::set_interface_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.NetworkCards.Item.interface_type)
}
inline void NetworkCards_Item::set_interface_type(const char* value, size_t size) {
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.NetworkCards.Item.interface_type)
}
inline ::std::string* NetworkCards_Item::mutable_interface_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.Item.interface_type)
  return interface_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_interface_type() {
  // @@protoc_insertion_point(field_release:aspia.system_info.NetworkCards.Item.interface_type)
  
  return interface_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_interface_type(::std::string* interface_type) {
  if (interface_type != NULL) {
    
  } else {
    
  }
  interface_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), interface_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.NetworkCards.Item.interface_type)
}

// uint32 mtu = 4;
inline void NetworkCards_Item::clear_mtu() {
  mtu_ = 0u;
}
inline ::google::protobuf::uint32 NetworkCards_Item::mtu() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.mtu)
  return mtu_;
}
inline void NetworkCards_Item::set_mtu(::google::protobuf::uint32 value) {
  
  mtu_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.mtu)
}

// uint32 speed = 5;
inline void NetworkCards_Item::clear_speed() {
  speed_ = 0u;
}
inline ::google::protobuf::uint32 NetworkCards_Item::speed() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.speed)
  return speed_;
}
inline void NetworkCards_Item::set_speed(::google::protobuf::uint32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.speed)
}

// string mac_address = 6;
inline void NetworkCards_Item::clear_mac_address() {
  mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::mac_address() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.mac_address)
  return mac_address_.GetNoArena();
}
inline void NetworkCards_Item::set_mac_address(const ::std::string& value) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.mac_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_mac_address(::std::string&& value) {
  
  mac_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.NetworkCards.Item.mac_address)
}
#endif
inline void NetworkCards_Item::set_mac_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.NetworkCards.Item.mac_address)
}
inline void NetworkCards_Item::set_mac_address(const char* value, size_t size) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.NetworkCards.Item.mac_address)
}
inline ::std::string* NetworkCards_Item::mutable_mac_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.Item.mac_address)
  return mac_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_mac_address() {
  // @@protoc_insertion_point(field_release:aspia.system_info.NetworkCards.Item.mac_address)
  
  return mac_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_mac_address(::std::string* mac_address) {
  if (mac_address != NULL) {
    
  } else {
    
  }
  mac_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.NetworkCards.Item.mac_address)
}

// bool is_wins_enabled = 7;
inline void NetworkCards_Item::clear_is_wins_enabled() {
  is_wins_enabled_ = false;
}
inline bool NetworkCards_Item::is_wins_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.is_wins_enabled)
  return is_wins_enabled_;
}
inline void NetworkCards_Item::set_is_wins_enabled(bool value) {
  
  is_wins_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.is_wins_enabled)
}

// string primary_wins_server = 8;
inline void NetworkCards_Item::clear_primary_wins_server() {
  primary_wins_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::primary_wins_server() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.primary_wins_server)
  return primary_wins_server_.GetNoArena();
}
inline void NetworkCards_Item::set_primary_wins_server(const ::std::string& value) {
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.primary_wins_server)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_primary_wins_server(::std::string&& value) {
  
  primary_wins_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.NetworkCards.Item.primary_wins_server)
}
#endif
inline void NetworkCards_Item::set_primary_wins_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.NetworkCards.Item.primary_wins_server)
}
inline void NetworkCards_Item::set_primary_wins_server(const char* value, size_t size) {
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.NetworkCards.Item.primary_wins_server)
}
inline ::std::string* NetworkCards_Item::mutable_primary_wins_server() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.Item.primary_wins_server)
  return primary_wins_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_primary_wins_server() {
  // @@protoc_insertion_point(field_release:aspia.system_info.NetworkCards.Item.primary_wins_server)
  
  return primary_wins_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_primary_wins_server(::std::string* primary_wins_server) {
  if (primary_wins_server != NULL) {
    
  } else {
    
  }
  primary_wins_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_wins_server);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.NetworkCards.Item.primary_wins_server)
}

// string secondary_wins_server = 9;
inline void NetworkCards_Item::clear_secondary_wins_server() {
  secondary_wins_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::secondary_wins_server() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.secondary_wins_server)
  return secondary_wins_server_.GetNoArena();
}
inline void NetworkCards_Item::set_secondary_wins_server(const ::std::string& value) {
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.secondary_wins_server)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_secondary_wins_server(::std::string&& value) {
  
  secondary_wins_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.NetworkCards.Item.secondary_wins_server)
}
#endif
inline void NetworkCards_Item::set_secondary_wins_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.NetworkCards.Item.secondary_wins_server)
}
inline void NetworkCards_Item::set_secondary_wins_server(const char* value, size_t size) {
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.NetworkCards.Item.secondary_wins_server)
}
inline ::std::string* NetworkCards_Item::mutable_secondary_wins_server() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.Item.secondary_wins_server)
  return secondary_wins_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_secondary_wins_server() {
  // @@protoc_insertion_point(field_release:aspia.system_info.NetworkCards.Item.secondary_wins_server)
  
  return secondary_wins_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_secondary_wins_server(::std::string* secondary_wins_server) {
  if (secondary_wins_server != NULL) {
    
  } else {
    
  }
  secondary_wins_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secondary_wins_server);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.NetworkCards.Item.secondary_wins_server)
}

// bool is_dhcp_enabled = 10;
inline void NetworkCards_Item::clear_is_dhcp_enabled() {
  is_dhcp_enabled_ = false;
}
inline bool NetworkCards_Item::is_dhcp_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.is_dhcp_enabled)
  return is_dhcp_enabled_;
}
inline void NetworkCards_Item::set_is_dhcp_enabled(bool value) {
  
  is_dhcp_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.is_dhcp_enabled)
}

// repeated .aspia.system_info.NetworkCards.Item.IpAddress ip_address = 11;
inline int NetworkCards_Item::ip_address_size() const {
  return ip_address_.size();
}
inline void NetworkCards_Item::clear_ip_address() {
  ip_address_.Clear();
}
inline const ::aspia::system_info::NetworkCards_Item_IpAddress& NetworkCards_Item::ip_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.ip_address)
  return ip_address_.Get(index);
}
inline ::aspia::system_info::NetworkCards_Item_IpAddress* NetworkCards_Item::mutable_ip_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.Item.ip_address)
  return ip_address_.Mutable(index);
}
inline ::aspia::system_info::NetworkCards_Item_IpAddress* NetworkCards_Item::add_ip_address() {
  // @@protoc_insertion_point(field_add:aspia.system_info.NetworkCards.Item.ip_address)
  return ip_address_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::NetworkCards_Item_IpAddress >*
NetworkCards_Item::mutable_ip_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.NetworkCards.Item.ip_address)
  return &ip_address_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::NetworkCards_Item_IpAddress >&
NetworkCards_Item::ip_address() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.NetworkCards.Item.ip_address)
  return ip_address_;
}

// repeated string gateway_address = 12;
inline int NetworkCards_Item::gateway_address_size() const {
  return gateway_address_.size();
}
inline void NetworkCards_Item::clear_gateway_address() {
  gateway_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::gateway_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.gateway_address)
  return gateway_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_gateway_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.Item.gateway_address)
  return gateway_address_.Mutable(index);
}
inline void NetworkCards_Item::set_gateway_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.gateway_address)
  gateway_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_gateway_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.gateway_address)
  gateway_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_gateway_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  gateway_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.system_info.NetworkCards.Item.gateway_address)
}
inline void NetworkCards_Item::set_gateway_address(int index, const char* value, size_t size) {
  gateway_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.NetworkCards.Item.gateway_address)
}
inline ::std::string* NetworkCards_Item::add_gateway_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.system_info.NetworkCards.Item.gateway_address)
  return gateway_address_.Add();
}
inline void NetworkCards_Item::add_gateway_address(const ::std::string& value) {
  gateway_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.system_info.NetworkCards.Item.gateway_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_gateway_address(::std::string&& value) {
  gateway_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.system_info.NetworkCards.Item.gateway_address)
}
#endif
inline void NetworkCards_Item::add_gateway_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  gateway_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.system_info.NetworkCards.Item.gateway_address)
}
inline void NetworkCards_Item::add_gateway_address(const char* value, size_t size) {
  gateway_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.system_info.NetworkCards.Item.gateway_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::gateway_address() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.NetworkCards.Item.gateway_address)
  return gateway_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_gateway_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.NetworkCards.Item.gateway_address)
  return &gateway_address_;
}

// repeated string dhcp_server_address = 13;
inline int NetworkCards_Item::dhcp_server_address_size() const {
  return dhcp_server_address_.size();
}
inline void NetworkCards_Item::clear_dhcp_server_address() {
  dhcp_server_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::dhcp_server_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_dhcp_server_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Mutable(index);
}
inline void NetworkCards_Item::set_dhcp_server_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.dhcp_server_address)
  dhcp_server_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_dhcp_server_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.dhcp_server_address)
  dhcp_server_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_dhcp_server_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dhcp_server_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.system_info.NetworkCards.Item.dhcp_server_address)
}
inline void NetworkCards_Item::set_dhcp_server_address(int index, const char* value, size_t size) {
  dhcp_server_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.NetworkCards.Item.dhcp_server_address)
}
inline ::std::string* NetworkCards_Item::add_dhcp_server_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.system_info.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Add();
}
inline void NetworkCards_Item::add_dhcp_server_address(const ::std::string& value) {
  dhcp_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.system_info.NetworkCards.Item.dhcp_server_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_dhcp_server_address(::std::string&& value) {
  dhcp_server_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.system_info.NetworkCards.Item.dhcp_server_address)
}
#endif
inline void NetworkCards_Item::add_dhcp_server_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dhcp_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.system_info.NetworkCards.Item.dhcp_server_address)
}
inline void NetworkCards_Item::add_dhcp_server_address(const char* value, size_t size) {
  dhcp_server_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.system_info.NetworkCards.Item.dhcp_server_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::dhcp_server_address() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_dhcp_server_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.NetworkCards.Item.dhcp_server_address)
  return &dhcp_server_address_;
}

// repeated string dns_server_address = 14;
inline int NetworkCards_Item::dns_server_address_size() const {
  return dns_server_address_.size();
}
inline void NetworkCards_Item::clear_dns_server_address() {
  dns_server_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::dns_server_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_dns_server_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Mutable(index);
}
inline void NetworkCards_Item::set_dns_server_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.dns_server_address)
  dns_server_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_dns_server_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.system_info.NetworkCards.Item.dns_server_address)
  dns_server_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_dns_server_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_server_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.system_info.NetworkCards.Item.dns_server_address)
}
inline void NetworkCards_Item::set_dns_server_address(int index, const char* value, size_t size) {
  dns_server_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.NetworkCards.Item.dns_server_address)
}
inline ::std::string* NetworkCards_Item::add_dns_server_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.system_info.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Add();
}
inline void NetworkCards_Item::add_dns_server_address(const ::std::string& value) {
  dns_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.system_info.NetworkCards.Item.dns_server_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_dns_server_address(::std::string&& value) {
  dns_server_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.system_info.NetworkCards.Item.dns_server_address)
}
#endif
inline void NetworkCards_Item::add_dns_server_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.system_info.NetworkCards.Item.dns_server_address)
}
inline void NetworkCards_Item::add_dns_server_address(const char* value, size_t size) {
  dns_server_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.system_info.NetworkCards.Item.dns_server_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::dns_server_address() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.NetworkCards.Item.dns_server_address)
  return dns_server_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_dns_server_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.NetworkCards.Item.dns_server_address)
  return &dns_server_address_;
}

// -------------------------------------------------------------------

// NetworkCards

// repeated .aspia.system_info.NetworkCards.Item item = 1;
inline int NetworkCards::item_size() const {
  return item_.size();
}
inline void NetworkCards::clear_item() {
  item_.Clear();
}
inline const ::aspia::system_info::NetworkCards_Item& NetworkCards::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.NetworkCards.item)
  return item_.Get(index);
}
inline ::aspia::system_info::NetworkCards_Item* NetworkCards::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.NetworkCards.item)
  return item_.Mutable(index);
}
inline ::aspia::system_info::NetworkCards_Item* NetworkCards::add_item() {
  // @@protoc_insertion_point(field_add:aspia.system_info.NetworkCards.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::NetworkCards_Item >*
NetworkCards::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.NetworkCards.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::NetworkCards_Item >&
NetworkCards::item() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.NetworkCards.item)
  return item_;
}

// -------------------------------------------------------------------

// OpenConnections_Item

// string process_name = 1;
inline void OpenConnections_Item::clear_process_name() {
  process_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::process_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.OpenConnections.Item.process_name)
  return process_name_.GetNoArena();
}
inline void OpenConnections_Item::set_process_name(const ::std::string& value) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.OpenConnections.Item.process_name)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_process_name(::std::string&& value) {
  
  process_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.OpenConnections.Item.process_name)
}
#endif
inline void OpenConnections_Item::set_process_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.OpenConnections.Item.process_name)
}
inline void OpenConnections_Item::set_process_name(const char* value, size_t size) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.OpenConnections.Item.process_name)
}
inline ::std::string* OpenConnections_Item::mutable_process_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.OpenConnections.Item.process_name)
  return process_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_process_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.OpenConnections.Item.process_name)
  
  return process_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_process_name(::std::string* process_name) {
  if (process_name != NULL) {
    
  } else {
    
  }
  process_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.OpenConnections.Item.process_name)
}

// string local_address = 2;
inline void OpenConnections_Item::clear_local_address() {
  local_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::local_address() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.OpenConnections.Item.local_address)
  return local_address_.GetNoArena();
}
inline void OpenConnections_Item::set_local_address(const ::std::string& value) {
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.OpenConnections.Item.local_address)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_local_address(::std::string&& value) {
  
  local_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.OpenConnections.Item.local_address)
}
#endif
inline void OpenConnections_Item::set_local_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.OpenConnections.Item.local_address)
}
inline void OpenConnections_Item::set_local_address(const char* value, size_t size) {
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.OpenConnections.Item.local_address)
}
inline ::std::string* OpenConnections_Item::mutable_local_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.OpenConnections.Item.local_address)
  return local_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_local_address() {
  // @@protoc_insertion_point(field_release:aspia.system_info.OpenConnections.Item.local_address)
  
  return local_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_local_address(::std::string* local_address) {
  if (local_address != NULL) {
    
  } else {
    
  }
  local_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.OpenConnections.Item.local_address)
}

// string remote_address = 3;
inline void OpenConnections_Item::clear_remote_address() {
  remote_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::remote_address() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.OpenConnections.Item.remote_address)
  return remote_address_.GetNoArena();
}
inline void OpenConnections_Item::set_remote_address(const ::std::string& value) {
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.OpenConnections.Item.remote_address)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_remote_address(::std::string&& value) {
  
  remote_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.OpenConnections.Item.remote_address)
}
#endif
inline void OpenConnections_Item::set_remote_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.OpenConnections.Item.remote_address)
}
inline void OpenConnections_Item::set_remote_address(const char* value, size_t size) {
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.OpenConnections.Item.remote_address)
}
inline ::std::string* OpenConnections_Item::mutable_remote_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.OpenConnections.Item.remote_address)
  return remote_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_remote_address() {
  // @@protoc_insertion_point(field_release:aspia.system_info.OpenConnections.Item.remote_address)
  
  return remote_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_remote_address(::std::string* remote_address) {
  if (remote_address != NULL) {
    
  } else {
    
  }
  remote_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.OpenConnections.Item.remote_address)
}

// uint32 local_port = 4;
inline void OpenConnections_Item::clear_local_port() {
  local_port_ = 0u;
}
inline ::google::protobuf::uint32 OpenConnections_Item::local_port() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.OpenConnections.Item.local_port)
  return local_port_;
}
inline void OpenConnections_Item::set_local_port(::google::protobuf::uint32 value) {
  
  local_port_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.OpenConnections.Item.local_port)
}

// uint32 remote_port = 5;
inline void OpenConnections_Item::clear_remote_port() {
  remote_port_ = 0u;
}
inline ::google::protobuf::uint32 OpenConnections_Item::remote_port() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.OpenConnections.Item.remote_port)
  return remote_port_;
}
inline void OpenConnections_Item::set_remote_port(::google::protobuf::uint32 value) {
  
  remote_port_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.OpenConnections.Item.remote_port)
}

// string state = 6;
inline void OpenConnections_Item::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::state() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.OpenConnections.Item.state)
  return state_.GetNoArena();
}
inline void OpenConnections_Item::set_state(const ::std::string& value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.OpenConnections.Item.state)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_state(::std::string&& value) {
  
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.OpenConnections.Item.state)
}
#endif
inline void OpenConnections_Item::set_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.OpenConnections.Item.state)
}
inline void OpenConnections_Item::set_state(const char* value, size_t size) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.OpenConnections.Item.state)
}
inline ::std::string* OpenConnections_Item::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.OpenConnections.Item.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_state() {
  // @@protoc_insertion_point(field_release:aspia.system_info.OpenConnections.Item.state)
  
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.OpenConnections.Item.state)
}

// -------------------------------------------------------------------

// OpenConnections

// repeated .aspia.system_info.OpenConnections.Item item = 1;
inline int OpenConnections::item_size() const {
  return item_.size();
}
inline void OpenConnections::clear_item() {
  item_.Clear();
}
inline const ::aspia::system_info::OpenConnections_Item& OpenConnections::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.OpenConnections.item)
  return item_.Get(index);
}
inline ::aspia::system_info::OpenConnections_Item* OpenConnections::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.OpenConnections.item)
  return item_.Mutable(index);
}
inline ::aspia::system_info::OpenConnections_Item* OpenConnections::add_item() {
  // @@protoc_insertion_point(field_add:aspia.system_info.OpenConnections.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::OpenConnections_Item >*
OpenConnections::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.OpenConnections.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::OpenConnections_Item >&
OpenConnections::item() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.OpenConnections.item)
  return item_;
}

// -------------------------------------------------------------------

// SharedResources_Item

// string name = 1;
inline void SharedResources_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.SharedResources.Item.name)
  return name_.GetNoArena();
}
inline void SharedResources_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.SharedResources.Item.name)
}
#if LANG_CXX11
inline void SharedResources_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.SharedResources.Item.name)
}
#endif
inline void SharedResources_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.SharedResources.Item.name)
}
inline void SharedResources_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.SharedResources.Item.name)
}
inline ::std::string* SharedResources_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.SharedResources.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.SharedResources.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.SharedResources.Item.name)
}

// .aspia.system_info.SharedResources.Item.Type type = 2;
inline void SharedResources_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::system_info::SharedResources_Item_Type SharedResources_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.SharedResources.Item.type)
  return static_cast< ::aspia::system_info::SharedResources_Item_Type >(type_);
}
inline void SharedResources_Item::set_type(::aspia::system_info::SharedResources_Item_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.SharedResources.Item.type)
}

// string description = 3;
inline void SharedResources_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.SharedResources.Item.description)
  return description_.GetNoArena();
}
inline void SharedResources_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.SharedResources.Item.description)
}
#if LANG_CXX11
inline void SharedResources_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.SharedResources.Item.description)
}
#endif
inline void SharedResources_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.SharedResources.Item.description)
}
inline void SharedResources_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.SharedResources.Item.description)
}
inline ::std::string* SharedResources_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.SharedResources.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.system_info.SharedResources.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.SharedResources.Item.description)
}

// string local_path = 4;
inline void SharedResources_Item::clear_local_path() {
  local_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::local_path() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.SharedResources.Item.local_path)
  return local_path_.GetNoArena();
}
inline void SharedResources_Item::set_local_path(const ::std::string& value) {
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.SharedResources.Item.local_path)
}
#if LANG_CXX11
inline void SharedResources_Item::set_local_path(::std::string&& value) {
  
  local_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.SharedResources.Item.local_path)
}
#endif
inline void SharedResources_Item::set_local_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.SharedResources.Item.local_path)
}
inline void SharedResources_Item::set_local_path(const char* value, size_t size) {
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.SharedResources.Item.local_path)
}
inline ::std::string* SharedResources_Item::mutable_local_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.SharedResources.Item.local_path)
  return local_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_local_path() {
  // @@protoc_insertion_point(field_release:aspia.system_info.SharedResources.Item.local_path)
  
  return local_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_local_path(::std::string* local_path) {
  if (local_path != NULL) {
    
  } else {
    
  }
  local_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_path);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.SharedResources.Item.local_path)
}

// uint32 current_uses = 5;
inline void SharedResources_Item::clear_current_uses() {
  current_uses_ = 0u;
}
inline ::google::protobuf::uint32 SharedResources_Item::current_uses() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.SharedResources.Item.current_uses)
  return current_uses_;
}
inline void SharedResources_Item::set_current_uses(::google::protobuf::uint32 value) {
  
  current_uses_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.SharedResources.Item.current_uses)
}

// uint32 maximum_uses = 6;
inline void SharedResources_Item::clear_maximum_uses() {
  maximum_uses_ = 0u;
}
inline ::google::protobuf::uint32 SharedResources_Item::maximum_uses() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.SharedResources.Item.maximum_uses)
  return maximum_uses_;
}
inline void SharedResources_Item::set_maximum_uses(::google::protobuf::uint32 value) {
  
  maximum_uses_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.SharedResources.Item.maximum_uses)
}

// -------------------------------------------------------------------

// SharedResources

// repeated .aspia.system_info.SharedResources.Item item = 1;
inline int SharedResources::item_size() const {
  return item_.size();
}
inline void SharedResources::clear_item() {
  item_.Clear();
}
inline const ::aspia::system_info::SharedResources_Item& SharedResources::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.SharedResources.item)
  return item_.Get(index);
}
inline ::aspia::system_info::SharedResources_Item* SharedResources::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.SharedResources.item)
  return item_.Mutable(index);
}
inline ::aspia::system_info::SharedResources_Item* SharedResources::add_item() {
  // @@protoc_insertion_point(field_add:aspia.system_info.SharedResources.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::SharedResources_Item >*
SharedResources::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.SharedResources.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::SharedResources_Item >&
SharedResources::item() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.SharedResources.item)
  return item_;
}

// -------------------------------------------------------------------

// Routes_Item

// string destonation = 1;
inline void Routes_Item::clear_destonation() {
  destonation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::destonation() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Routes.Item.destonation)
  return destonation_.GetNoArena();
}
inline void Routes_Item::set_destonation(const ::std::string& value) {
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Routes.Item.destonation)
}
#if LANG_CXX11
inline void Routes_Item::set_destonation(::std::string&& value) {
  
  destonation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Routes.Item.destonation)
}
#endif
inline void Routes_Item::set_destonation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Routes.Item.destonation)
}
inline void Routes_Item::set_destonation(const char* value, size_t size) {
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Routes.Item.destonation)
}
inline ::std::string* Routes_Item::mutable_destonation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Routes.Item.destonation)
  return destonation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_destonation() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Routes.Item.destonation)
  
  return destonation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_destonation(::std::string* destonation) {
  if (destonation != NULL) {
    
  } else {
    
  }
  destonation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destonation);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Routes.Item.destonation)
}

// string mask = 2;
inline void Routes_Item::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::mask() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Routes.Item.mask)
  return mask_.GetNoArena();
}
inline void Routes_Item::set_mask(const ::std::string& value) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Routes.Item.mask)
}
#if LANG_CXX11
inline void Routes_Item::set_mask(::std::string&& value) {
  
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Routes.Item.mask)
}
#endif
inline void Routes_Item::set_mask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Routes.Item.mask)
}
inline void Routes_Item::set_mask(const char* value, size_t size) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Routes.Item.mask)
}
inline ::std::string* Routes_Item::mutable_mask() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Routes.Item.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_mask() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Routes.Item.mask)
  
  return mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_mask(::std::string* mask) {
  if (mask != NULL) {
    
  } else {
    
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Routes.Item.mask)
}

// string gateway = 3;
inline void Routes_Item::clear_gateway() {
  gateway_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::gateway() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Routes.Item.gateway)
  return gateway_.GetNoArena();
}
inline void Routes_Item::set_gateway(const ::std::string& value) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Routes.Item.gateway)
}
#if LANG_CXX11
inline void Routes_Item::set_gateway(::std::string&& value) {
  
  gateway_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Routes.Item.gateway)
}
#endif
inline void Routes_Item::set_gateway(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Routes.Item.gateway)
}
inline void Routes_Item::set_gateway(const char* value, size_t size) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Routes.Item.gateway)
}
inline ::std::string* Routes_Item::mutable_gateway() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Routes.Item.gateway)
  return gateway_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_gateway() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Routes.Item.gateway)
  
  return gateway_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_gateway(::std::string* gateway) {
  if (gateway != NULL) {
    
  } else {
    
  }
  gateway_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gateway);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Routes.Item.gateway)
}

// uint32 metric = 4;
inline void Routes_Item::clear_metric() {
  metric_ = 0u;
}
inline ::google::protobuf::uint32 Routes_Item::metric() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Routes.Item.metric)
  return metric_;
}
inline void Routes_Item::set_metric(::google::protobuf::uint32 value) {
  
  metric_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Routes.Item.metric)
}

// -------------------------------------------------------------------

// Routes

// repeated .aspia.system_info.Routes.Item item = 1;
inline int Routes::item_size() const {
  return item_.size();
}
inline void Routes::clear_item() {
  item_.Clear();
}
inline const ::aspia::system_info::Routes_Item& Routes::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Routes.item)
  return item_.Get(index);
}
inline ::aspia::system_info::Routes_Item* Routes::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Routes.item)
  return item_.Mutable(index);
}
inline ::aspia::system_info::Routes_Item* Routes::add_item() {
  // @@protoc_insertion_point(field_add:aspia.system_info.Routes.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Routes_Item >*
Routes::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.Routes.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Routes_Item >&
Routes::item() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.Routes.item)
  return item_;
}

// -------------------------------------------------------------------

// Users_Item

// string name = 1;
inline void Users_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Users.Item.name)
  return name_.GetNoArena();
}
inline void Users_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Users.Item.name)
}
#if LANG_CXX11
inline void Users_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Users.Item.name)
}
#endif
inline void Users_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Users.Item.name)
}
inline void Users_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Users.Item.name)
}
inline ::std::string* Users_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Users.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Users.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Users.Item.name)
}

// string full_name = 2;
inline void Users_Item::clear_full_name() {
  full_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::full_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Users.Item.full_name)
  return full_name_.GetNoArena();
}
inline void Users_Item::set_full_name(const ::std::string& value) {
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Users.Item.full_name)
}
#if LANG_CXX11
inline void Users_Item::set_full_name(::std::string&& value) {
  
  full_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Users.Item.full_name)
}
#endif
inline void Users_Item::set_full_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Users.Item.full_name)
}
inline void Users_Item::set_full_name(const char* value, size_t size) {
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Users.Item.full_name)
}
inline ::std::string* Users_Item::mutable_full_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Users.Item.full_name)
  return full_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_full_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Users.Item.full_name)
  
  return full_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_full_name(::std::string* full_name) {
  if (full_name != NULL) {
    
  } else {
    
  }
  full_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), full_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Users.Item.full_name)
}

// string comment = 3;
inline void Users_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Users.Item.comment)
  return comment_.GetNoArena();
}
inline void Users_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Users.Item.comment)
}
#if LANG_CXX11
inline void Users_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Users.Item.comment)
}
#endif
inline void Users_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Users.Item.comment)
}
inline void Users_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Users.Item.comment)
}
inline ::std::string* Users_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Users.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Users.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Users.Item.comment)
}

// bool is_disabled = 4;
inline void Users_Item::clear_is_disabled() {
  is_disabled_ = false;
}
inline bool Users_Item::is_disabled() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Users.Item.is_disabled)
  return is_disabled_;
}
inline void Users_Item::set_is_disabled(bool value) {
  
  is_disabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Users.Item.is_disabled)
}

// bool is_password_cant_change = 5;
inline void Users_Item::clear_is_password_cant_change() {
  is_password_cant_change_ = false;
}
inline bool Users_Item::is_password_cant_change() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Users.Item.is_password_cant_change)
  return is_password_cant_change_;
}
inline void Users_Item::set_is_password_cant_change(bool value) {
  
  is_password_cant_change_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Users.Item.is_password_cant_change)
}

// bool is_password_expired = 6;
inline void Users_Item::clear_is_password_expired() {
  is_password_expired_ = false;
}
inline bool Users_Item::is_password_expired() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Users.Item.is_password_expired)
  return is_password_expired_;
}
inline void Users_Item::set_is_password_expired(bool value) {
  
  is_password_expired_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Users.Item.is_password_expired)
}

// bool is_dont_expire_password = 7;
inline void Users_Item::clear_is_dont_expire_password() {
  is_dont_expire_password_ = false;
}
inline bool Users_Item::is_dont_expire_password() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Users.Item.is_dont_expire_password)
  return is_dont_expire_password_;
}
inline void Users_Item::set_is_dont_expire_password(bool value) {
  
  is_dont_expire_password_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Users.Item.is_dont_expire_password)
}

// bool is_lockout = 8;
inline void Users_Item::clear_is_lockout() {
  is_lockout_ = false;
}
inline bool Users_Item::is_lockout() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Users.Item.is_lockout)
  return is_lockout_;
}
inline void Users_Item::set_is_lockout(bool value) {
  
  is_lockout_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Users.Item.is_lockout)
}

// uint32 number_logons = 9;
inline void Users_Item::clear_number_logons() {
  number_logons_ = 0u;
}
inline ::google::protobuf::uint32 Users_Item::number_logons() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Users.Item.number_logons)
  return number_logons_;
}
inline void Users_Item::set_number_logons(::google::protobuf::uint32 value) {
  
  number_logons_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Users.Item.number_logons)
}

// uint32 bad_password_count = 10;
inline void Users_Item::clear_bad_password_count() {
  bad_password_count_ = 0u;
}
inline ::google::protobuf::uint32 Users_Item::bad_password_count() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Users.Item.bad_password_count)
  return bad_password_count_;
}
inline void Users_Item::set_bad_password_count(::google::protobuf::uint32 value) {
  
  bad_password_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Users.Item.bad_password_count)
}

// int64 last_logon_time = 11;
inline void Users_Item::clear_last_logon_time() {
  last_logon_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Users_Item::last_logon_time() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Users.Item.last_logon_time)
  return last_logon_time_;
}
inline void Users_Item::set_last_logon_time(::google::protobuf::int64 value) {
  
  last_logon_time_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Users.Item.last_logon_time)
}

// -------------------------------------------------------------------

// Users

// repeated .aspia.system_info.Users.Item item = 1;
inline int Users::item_size() const {
  return item_.size();
}
inline void Users::clear_item() {
  item_.Clear();
}
inline const ::aspia::system_info::Users_Item& Users::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Users.item)
  return item_.Get(index);
}
inline ::aspia::system_info::Users_Item* Users::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Users.item)
  return item_.Mutable(index);
}
inline ::aspia::system_info::Users_Item* Users::add_item() {
  // @@protoc_insertion_point(field_add:aspia.system_info.Users.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Users_Item >*
Users::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.Users.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Users_Item >&
Users::item() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.Users.item)
  return item_;
}

// -------------------------------------------------------------------

// UserGroups_Item

// string name = 1;
inline void UserGroups_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserGroups_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.UserGroups.Item.name)
  return name_.GetNoArena();
}
inline void UserGroups_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.UserGroups.Item.name)
}
#if LANG_CXX11
inline void UserGroups_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.UserGroups.Item.name)
}
#endif
inline void UserGroups_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.UserGroups.Item.name)
}
inline void UserGroups_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.UserGroups.Item.name)
}
inline ::std::string* UserGroups_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.UserGroups.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserGroups_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.UserGroups.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserGroups_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.UserGroups.Item.name)
}

// string comment = 2;
inline void UserGroups_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserGroups_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.UserGroups.Item.comment)
  return comment_.GetNoArena();
}
inline void UserGroups_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.UserGroups.Item.comment)
}
#if LANG_CXX11
inline void UserGroups_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.UserGroups.Item.comment)
}
#endif
inline void UserGroups_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.UserGroups.Item.comment)
}
inline void UserGroups_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.UserGroups.Item.comment)
}
inline ::std::string* UserGroups_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.UserGroups.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserGroups_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.system_info.UserGroups.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserGroups_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.UserGroups.Item.comment)
}

// -------------------------------------------------------------------

// UserGroups

// repeated .aspia.system_info.UserGroups.Item item = 1;
inline int UserGroups::item_size() const {
  return item_.size();
}
inline void UserGroups::clear_item() {
  item_.Clear();
}
inline const ::aspia::system_info::UserGroups_Item& UserGroups::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.UserGroups.item)
  return item_.Get(index);
}
inline ::aspia::system_info::UserGroups_Item* UserGroups::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.UserGroups.item)
  return item_.Mutable(index);
}
inline ::aspia::system_info::UserGroups_Item* UserGroups::add_item() {
  // @@protoc_insertion_point(field_add:aspia.system_info.UserGroups.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::UserGroups_Item >*
UserGroups::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.UserGroups.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::UserGroups_Item >&
UserGroups::item() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.UserGroups.item)
  return item_;
}

// -------------------------------------------------------------------

// Sessions_Item

// string user_name = 1;
inline void Sessions_Item::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::user_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Sessions.Item.user_name)
  return user_name_.GetNoArena();
}
inline void Sessions_Item::set_user_name(const ::std::string& value) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Sessions.Item.user_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_user_name(::std::string&& value) {
  
  user_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Sessions.Item.user_name)
}
#endif
inline void Sessions_Item::set_user_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Sessions.Item.user_name)
}
inline void Sessions_Item::set_user_name(const char* value, size_t size) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Sessions.Item.user_name)
}
inline ::std::string* Sessions_Item::mutable_user_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Sessions.Item.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_user_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Sessions.Item.user_name)
  
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    
  } else {
    
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Sessions.Item.user_name)
}

// string domain_name = 2;
inline void Sessions_Item::clear_domain_name() {
  domain_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::domain_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Sessions.Item.domain_name)
  return domain_name_.GetNoArena();
}
inline void Sessions_Item::set_domain_name(const ::std::string& value) {
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Sessions.Item.domain_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_domain_name(::std::string&& value) {
  
  domain_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Sessions.Item.domain_name)
}
#endif
inline void Sessions_Item::set_domain_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Sessions.Item.domain_name)
}
inline void Sessions_Item::set_domain_name(const char* value, size_t size) {
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Sessions.Item.domain_name)
}
inline ::std::string* Sessions_Item::mutable_domain_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Sessions.Item.domain_name)
  return domain_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_domain_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Sessions.Item.domain_name)
  
  return domain_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_domain_name(::std::string* domain_name) {
  if (domain_name != NULL) {
    
  } else {
    
  }
  domain_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Sessions.Item.domain_name)
}

// uint32 session_id = 3;
inline void Sessions_Item::clear_session_id() {
  session_id_ = 0u;
}
inline ::google::protobuf::uint32 Sessions_Item::session_id() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Sessions.Item.session_id)
  return session_id_;
}
inline void Sessions_Item::set_session_id(::google::protobuf::uint32 value) {
  
  session_id_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.Sessions.Item.session_id)
}

// string connect_state = 4;
inline void Sessions_Item::clear_connect_state() {
  connect_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::connect_state() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Sessions.Item.connect_state)
  return connect_state_.GetNoArena();
}
inline void Sessions_Item::set_connect_state(const ::std::string& value) {
  
  connect_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Sessions.Item.connect_state)
}
#if LANG_CXX11
inline void Sessions_Item::set_connect_state(::std::string&& value) {
  
  connect_state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Sessions.Item.connect_state)
}
#endif
inline void Sessions_Item::set_connect_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  connect_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Sessions.Item.connect_state)
}
inline void Sessions_Item::set_connect_state(const char* value, size_t size) {
  
  connect_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Sessions.Item.connect_state)
}
inline ::std::string* Sessions_Item::mutable_connect_state() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Sessions.Item.connect_state)
  return connect_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_connect_state() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Sessions.Item.connect_state)
  
  return connect_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_connect_state(::std::string* connect_state) {
  if (connect_state != NULL) {
    
  } else {
    
  }
  connect_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connect_state);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Sessions.Item.connect_state)
}

// string client_name = 5;
inline void Sessions_Item::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::client_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Sessions.Item.client_name)
  return client_name_.GetNoArena();
}
inline void Sessions_Item::set_client_name(const ::std::string& value) {
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Sessions.Item.client_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_client_name(::std::string&& value) {
  
  client_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Sessions.Item.client_name)
}
#endif
inline void Sessions_Item::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Sessions.Item.client_name)
}
inline void Sessions_Item::set_client_name(const char* value, size_t size) {
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Sessions.Item.client_name)
}
inline ::std::string* Sessions_Item::mutable_client_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Sessions.Item.client_name)
  return client_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_client_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Sessions.Item.client_name)
  
  return client_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_client_name(::std::string* client_name) {
  if (client_name != NULL) {
    
  } else {
    
  }
  client_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Sessions.Item.client_name)
}

// string winstation_name = 6;
inline void Sessions_Item::clear_winstation_name() {
  winstation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::winstation_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Sessions.Item.winstation_name)
  return winstation_name_.GetNoArena();
}
inline void Sessions_Item::set_winstation_name(const ::std::string& value) {
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.Sessions.Item.winstation_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_winstation_name(::std::string&& value) {
  
  winstation_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.Sessions.Item.winstation_name)
}
#endif
inline void Sessions_Item::set_winstation_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.Sessions.Item.winstation_name)
}
inline void Sessions_Item::set_winstation_name(const char* value, size_t size) {
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.Sessions.Item.winstation_name)
}
inline ::std::string* Sessions_Item::mutable_winstation_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Sessions.Item.winstation_name)
  return winstation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_winstation_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.Sessions.Item.winstation_name)
  
  return winstation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_winstation_name(::std::string* winstation_name) {
  if (winstation_name != NULL) {
    
  } else {
    
  }
  winstation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), winstation_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.Sessions.Item.winstation_name)
}

// -------------------------------------------------------------------

// Sessions

// repeated .aspia.system_info.Sessions.Item item = 1;
inline int Sessions::item_size() const {
  return item_.size();
}
inline void Sessions::clear_item() {
  item_.Clear();
}
inline const ::aspia::system_info::Sessions_Item& Sessions::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.Sessions.item)
  return item_.Get(index);
}
inline ::aspia::system_info::Sessions_Item* Sessions::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.Sessions.item)
  return item_.Mutable(index);
}
inline ::aspia::system_info::Sessions_Item* Sessions::add_item() {
  // @@protoc_insertion_point(field_add:aspia.system_info.Sessions.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Sessions_Item >*
Sessions::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.Sessions.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::Sessions_Item >&
Sessions::item() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.Sessions.item)
  return item_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace system_info
}  // namespace aspia

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aspia::system_info::DmiBaseboard_Item_BoardType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::DmiChassis_Item_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::DmiChassis_Item_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::DmiChassis_Item_SecurityStatus> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::Monitors_Item_InputSignalType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::Printers_Item_Orientation> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::Services_Item_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::Services_Item_StartupType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::SharedResources_Item_Type> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED

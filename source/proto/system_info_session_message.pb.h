// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system_info_session_message.proto

#ifndef PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED
#define PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace protobuf_system_5finfo_5fsession_5fmessage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[61];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsDmiBios_FeatureImpl();
void InitDefaultsDmiBios_Feature();
void InitDefaultsDmiBiosImpl();
void InitDefaultsDmiBios();
void InitDefaultsDmiSystemImpl();
void InitDefaultsDmiSystem();
void InitDefaultsDmiBaseboard_Item_FeatureImpl();
void InitDefaultsDmiBaseboard_Item_Feature();
void InitDefaultsDmiBaseboard_ItemImpl();
void InitDefaultsDmiBaseboard_Item();
void InitDefaultsDmiBaseboardImpl();
void InitDefaultsDmiBaseboard();
void InitDefaultsDmiChassis_ItemImpl();
void InitDefaultsDmiChassis_Item();
void InitDefaultsDmiChassisImpl();
void InitDefaultsDmiChassis();
void InitDefaultsDmiCaches_Item_SRAMTypeImpl();
void InitDefaultsDmiCaches_Item_SRAMType();
void InitDefaultsDmiCaches_ItemImpl();
void InitDefaultsDmiCaches_Item();
void InitDefaultsDmiCachesImpl();
void InitDefaultsDmiCaches();
void InitDefaultsDmiProcessors_Item_FeatureImpl();
void InitDefaultsDmiProcessors_Item_Feature();
void InitDefaultsDmiProcessors_ItemImpl();
void InitDefaultsDmiProcessors_Item();
void InitDefaultsDmiProcessorsImpl();
void InitDefaultsDmiProcessors();
void InitDefaultsDmiMemoryDevices_ItemImpl();
void InitDefaultsDmiMemoryDevices_Item();
void InitDefaultsDmiMemoryDevicesImpl();
void InitDefaultsDmiMemoryDevices();
void InitDefaultsDmiSystemSlots_ItemImpl();
void InitDefaultsDmiSystemSlots_Item();
void InitDefaultsDmiSystemSlotsImpl();
void InitDefaultsDmiSystemSlots();
void InitDefaultsDmiPortConnectors_ItemImpl();
void InitDefaultsDmiPortConnectors_Item();
void InitDefaultsDmiPortConnectorsImpl();
void InitDefaultsDmiPortConnectors();
void InitDefaultsDmiOnBoardDevices_ItemImpl();
void InitDefaultsDmiOnBoardDevices_Item();
void InitDefaultsDmiOnBoardDevicesImpl();
void InitDefaultsDmiOnBoardDevices();
void InitDefaultsDmiBuildinPointing_ItemImpl();
void InitDefaultsDmiBuildinPointing_Item();
void InitDefaultsDmiBuildinPointingImpl();
void InitDefaultsDmiBuildinPointing();
void InitDefaultsDmiPortableBattery_ItemImpl();
void InitDefaultsDmiPortableBattery_Item();
void InitDefaultsDmiPortableBatteryImpl();
void InitDefaultsDmiPortableBattery();
void InitDefaultsAtaDrives_Item_FeatureImpl();
void InitDefaultsAtaDrives_Item_Feature();
void InitDefaultsAtaDrives_ItemImpl();
void InitDefaultsAtaDrives_Item();
void InitDefaultsAtaDrivesImpl();
void InitDefaultsAtaDrives();
void InitDefaultsVideoAdapters_ItemImpl();
void InitDefaultsVideoAdapters_Item();
void InitDefaultsVideoAdaptersImpl();
void InitDefaultsVideoAdapters();
void InitDefaultsMonitors_Item_TimingImpl();
void InitDefaultsMonitors_Item_Timing();
void InitDefaultsMonitors_ItemImpl();
void InitDefaultsMonitors_Item();
void InitDefaultsMonitorsImpl();
void InitDefaultsMonitors();
void InitDefaultsPowerOptions_BatteryImpl();
void InitDefaultsPowerOptions_Battery();
void InitDefaultsPowerOptionsImpl();
void InitDefaultsPowerOptions();
void InitDefaultsPrinters_ItemImpl();
void InitDefaultsPrinters_Item();
void InitDefaultsPrintersImpl();
void InitDefaultsPrinters();
void InitDefaultsWindowsDevices_ItemImpl();
void InitDefaultsWindowsDevices_Item();
void InitDefaultsWindowsDevicesImpl();
void InitDefaultsWindowsDevices();
void InitDefaultsPrograms_ItemImpl();
void InitDefaultsPrograms_Item();
void InitDefaultsProgramsImpl();
void InitDefaultsPrograms();
void InitDefaultsServices_ItemImpl();
void InitDefaultsServices_Item();
void InitDefaultsServicesImpl();
void InitDefaultsServices();
void InitDefaultsProcesses_ItemImpl();
void InitDefaultsProcesses_Item();
void InitDefaultsProcessesImpl();
void InitDefaultsProcesses();
void InitDefaultsNetworkCards_Item_IpAddressImpl();
void InitDefaultsNetworkCards_Item_IpAddress();
void InitDefaultsNetworkCards_ItemImpl();
void InitDefaultsNetworkCards_Item();
void InitDefaultsNetworkCardsImpl();
void InitDefaultsNetworkCards();
void InitDefaultsOpenConnections_ItemImpl();
void InitDefaultsOpenConnections_Item();
void InitDefaultsOpenConnectionsImpl();
void InitDefaultsOpenConnections();
void InitDefaultsSharedResources_ItemImpl();
void InitDefaultsSharedResources_Item();
void InitDefaultsSharedResourcesImpl();
void InitDefaultsSharedResources();
void InitDefaultsRoutes_ItemImpl();
void InitDefaultsRoutes_Item();
void InitDefaultsRoutesImpl();
void InitDefaultsRoutes();
void InitDefaultsUsers_ItemImpl();
void InitDefaultsUsers_Item();
void InitDefaultsUsersImpl();
void InitDefaultsUsers();
void InitDefaultsUserGroups_ItemImpl();
void InitDefaultsUserGroups_Item();
void InitDefaultsUserGroupsImpl();
void InitDefaultsUserGroups();
void InitDefaultsSessions_ItemImpl();
void InitDefaultsSessions_Item();
void InitDefaultsSessionsImpl();
void InitDefaultsSessions();
inline void InitDefaults() {
  InitDefaultsDmiBios_Feature();
  InitDefaultsDmiBios();
  InitDefaultsDmiSystem();
  InitDefaultsDmiBaseboard_Item_Feature();
  InitDefaultsDmiBaseboard_Item();
  InitDefaultsDmiBaseboard();
  InitDefaultsDmiChassis_Item();
  InitDefaultsDmiChassis();
  InitDefaultsDmiCaches_Item_SRAMType();
  InitDefaultsDmiCaches_Item();
  InitDefaultsDmiCaches();
  InitDefaultsDmiProcessors_Item_Feature();
  InitDefaultsDmiProcessors_Item();
  InitDefaultsDmiProcessors();
  InitDefaultsDmiMemoryDevices_Item();
  InitDefaultsDmiMemoryDevices();
  InitDefaultsDmiSystemSlots_Item();
  InitDefaultsDmiSystemSlots();
  InitDefaultsDmiPortConnectors_Item();
  InitDefaultsDmiPortConnectors();
  InitDefaultsDmiOnBoardDevices_Item();
  InitDefaultsDmiOnBoardDevices();
  InitDefaultsDmiBuildinPointing_Item();
  InitDefaultsDmiBuildinPointing();
  InitDefaultsDmiPortableBattery_Item();
  InitDefaultsDmiPortableBattery();
  InitDefaultsAtaDrives_Item_Feature();
  InitDefaultsAtaDrives_Item();
  InitDefaultsAtaDrives();
  InitDefaultsVideoAdapters_Item();
  InitDefaultsVideoAdapters();
  InitDefaultsMonitors_Item_Timing();
  InitDefaultsMonitors_Item();
  InitDefaultsMonitors();
  InitDefaultsPowerOptions_Battery();
  InitDefaultsPowerOptions();
  InitDefaultsPrinters_Item();
  InitDefaultsPrinters();
  InitDefaultsWindowsDevices_Item();
  InitDefaultsWindowsDevices();
  InitDefaultsPrograms_Item();
  InitDefaultsPrograms();
  InitDefaultsServices_Item();
  InitDefaultsServices();
  InitDefaultsProcesses_Item();
  InitDefaultsProcesses();
  InitDefaultsNetworkCards_Item_IpAddress();
  InitDefaultsNetworkCards_Item();
  InitDefaultsNetworkCards();
  InitDefaultsOpenConnections_Item();
  InitDefaultsOpenConnections();
  InitDefaultsSharedResources_Item();
  InitDefaultsSharedResources();
  InitDefaultsRoutes_Item();
  InitDefaultsRoutes();
  InitDefaultsUsers_Item();
  InitDefaultsUsers();
  InitDefaultsUserGroups_Item();
  InitDefaultsUserGroups();
  InitDefaultsSessions_Item();
  InitDefaultsSessions();
}
}  // namespace protobuf_system_5finfo_5fsession_5fmessage_2eproto
namespace aspia {
namespace proto {
class AtaDrives;
class AtaDrivesDefaultTypeInternal;
extern AtaDrivesDefaultTypeInternal _AtaDrives_default_instance_;
class AtaDrives_Item;
class AtaDrives_ItemDefaultTypeInternal;
extern AtaDrives_ItemDefaultTypeInternal _AtaDrives_Item_default_instance_;
class AtaDrives_Item_Feature;
class AtaDrives_Item_FeatureDefaultTypeInternal;
extern AtaDrives_Item_FeatureDefaultTypeInternal _AtaDrives_Item_Feature_default_instance_;
class DmiBaseboard;
class DmiBaseboardDefaultTypeInternal;
extern DmiBaseboardDefaultTypeInternal _DmiBaseboard_default_instance_;
class DmiBaseboard_Item;
class DmiBaseboard_ItemDefaultTypeInternal;
extern DmiBaseboard_ItemDefaultTypeInternal _DmiBaseboard_Item_default_instance_;
class DmiBaseboard_Item_Feature;
class DmiBaseboard_Item_FeatureDefaultTypeInternal;
extern DmiBaseboard_Item_FeatureDefaultTypeInternal _DmiBaseboard_Item_Feature_default_instance_;
class DmiBios;
class DmiBiosDefaultTypeInternal;
extern DmiBiosDefaultTypeInternal _DmiBios_default_instance_;
class DmiBios_Feature;
class DmiBios_FeatureDefaultTypeInternal;
extern DmiBios_FeatureDefaultTypeInternal _DmiBios_Feature_default_instance_;
class DmiBuildinPointing;
class DmiBuildinPointingDefaultTypeInternal;
extern DmiBuildinPointingDefaultTypeInternal _DmiBuildinPointing_default_instance_;
class DmiBuildinPointing_Item;
class DmiBuildinPointing_ItemDefaultTypeInternal;
extern DmiBuildinPointing_ItemDefaultTypeInternal _DmiBuildinPointing_Item_default_instance_;
class DmiCaches;
class DmiCachesDefaultTypeInternal;
extern DmiCachesDefaultTypeInternal _DmiCaches_default_instance_;
class DmiCaches_Item;
class DmiCaches_ItemDefaultTypeInternal;
extern DmiCaches_ItemDefaultTypeInternal _DmiCaches_Item_default_instance_;
class DmiCaches_Item_SRAMType;
class DmiCaches_Item_SRAMTypeDefaultTypeInternal;
extern DmiCaches_Item_SRAMTypeDefaultTypeInternal _DmiCaches_Item_SRAMType_default_instance_;
class DmiChassis;
class DmiChassisDefaultTypeInternal;
extern DmiChassisDefaultTypeInternal _DmiChassis_default_instance_;
class DmiChassis_Item;
class DmiChassis_ItemDefaultTypeInternal;
extern DmiChassis_ItemDefaultTypeInternal _DmiChassis_Item_default_instance_;
class DmiMemoryDevices;
class DmiMemoryDevicesDefaultTypeInternal;
extern DmiMemoryDevicesDefaultTypeInternal _DmiMemoryDevices_default_instance_;
class DmiMemoryDevices_Item;
class DmiMemoryDevices_ItemDefaultTypeInternal;
extern DmiMemoryDevices_ItemDefaultTypeInternal _DmiMemoryDevices_Item_default_instance_;
class DmiOnBoardDevices;
class DmiOnBoardDevicesDefaultTypeInternal;
extern DmiOnBoardDevicesDefaultTypeInternal _DmiOnBoardDevices_default_instance_;
class DmiOnBoardDevices_Item;
class DmiOnBoardDevices_ItemDefaultTypeInternal;
extern DmiOnBoardDevices_ItemDefaultTypeInternal _DmiOnBoardDevices_Item_default_instance_;
class DmiPortConnectors;
class DmiPortConnectorsDefaultTypeInternal;
extern DmiPortConnectorsDefaultTypeInternal _DmiPortConnectors_default_instance_;
class DmiPortConnectors_Item;
class DmiPortConnectors_ItemDefaultTypeInternal;
extern DmiPortConnectors_ItemDefaultTypeInternal _DmiPortConnectors_Item_default_instance_;
class DmiPortableBattery;
class DmiPortableBatteryDefaultTypeInternal;
extern DmiPortableBatteryDefaultTypeInternal _DmiPortableBattery_default_instance_;
class DmiPortableBattery_Item;
class DmiPortableBattery_ItemDefaultTypeInternal;
extern DmiPortableBattery_ItemDefaultTypeInternal _DmiPortableBattery_Item_default_instance_;
class DmiProcessors;
class DmiProcessorsDefaultTypeInternal;
extern DmiProcessorsDefaultTypeInternal _DmiProcessors_default_instance_;
class DmiProcessors_Item;
class DmiProcessors_ItemDefaultTypeInternal;
extern DmiProcessors_ItemDefaultTypeInternal _DmiProcessors_Item_default_instance_;
class DmiProcessors_Item_Feature;
class DmiProcessors_Item_FeatureDefaultTypeInternal;
extern DmiProcessors_Item_FeatureDefaultTypeInternal _DmiProcessors_Item_Feature_default_instance_;
class DmiSystem;
class DmiSystemDefaultTypeInternal;
extern DmiSystemDefaultTypeInternal _DmiSystem_default_instance_;
class DmiSystemSlots;
class DmiSystemSlotsDefaultTypeInternal;
extern DmiSystemSlotsDefaultTypeInternal _DmiSystemSlots_default_instance_;
class DmiSystemSlots_Item;
class DmiSystemSlots_ItemDefaultTypeInternal;
extern DmiSystemSlots_ItemDefaultTypeInternal _DmiSystemSlots_Item_default_instance_;
class Monitors;
class MonitorsDefaultTypeInternal;
extern MonitorsDefaultTypeInternal _Monitors_default_instance_;
class Monitors_Item;
class Monitors_ItemDefaultTypeInternal;
extern Monitors_ItemDefaultTypeInternal _Monitors_Item_default_instance_;
class Monitors_Item_Timing;
class Monitors_Item_TimingDefaultTypeInternal;
extern Monitors_Item_TimingDefaultTypeInternal _Monitors_Item_Timing_default_instance_;
class NetworkCards;
class NetworkCardsDefaultTypeInternal;
extern NetworkCardsDefaultTypeInternal _NetworkCards_default_instance_;
class NetworkCards_Item;
class NetworkCards_ItemDefaultTypeInternal;
extern NetworkCards_ItemDefaultTypeInternal _NetworkCards_Item_default_instance_;
class NetworkCards_Item_IpAddress;
class NetworkCards_Item_IpAddressDefaultTypeInternal;
extern NetworkCards_Item_IpAddressDefaultTypeInternal _NetworkCards_Item_IpAddress_default_instance_;
class OpenConnections;
class OpenConnectionsDefaultTypeInternal;
extern OpenConnectionsDefaultTypeInternal _OpenConnections_default_instance_;
class OpenConnections_Item;
class OpenConnections_ItemDefaultTypeInternal;
extern OpenConnections_ItemDefaultTypeInternal _OpenConnections_Item_default_instance_;
class PowerOptions;
class PowerOptionsDefaultTypeInternal;
extern PowerOptionsDefaultTypeInternal _PowerOptions_default_instance_;
class PowerOptions_Battery;
class PowerOptions_BatteryDefaultTypeInternal;
extern PowerOptions_BatteryDefaultTypeInternal _PowerOptions_Battery_default_instance_;
class Printers;
class PrintersDefaultTypeInternal;
extern PrintersDefaultTypeInternal _Printers_default_instance_;
class Printers_Item;
class Printers_ItemDefaultTypeInternal;
extern Printers_ItemDefaultTypeInternal _Printers_Item_default_instance_;
class Processes;
class ProcessesDefaultTypeInternal;
extern ProcessesDefaultTypeInternal _Processes_default_instance_;
class Processes_Item;
class Processes_ItemDefaultTypeInternal;
extern Processes_ItemDefaultTypeInternal _Processes_Item_default_instance_;
class Programs;
class ProgramsDefaultTypeInternal;
extern ProgramsDefaultTypeInternal _Programs_default_instance_;
class Programs_Item;
class Programs_ItemDefaultTypeInternal;
extern Programs_ItemDefaultTypeInternal _Programs_Item_default_instance_;
class Routes;
class RoutesDefaultTypeInternal;
extern RoutesDefaultTypeInternal _Routes_default_instance_;
class Routes_Item;
class Routes_ItemDefaultTypeInternal;
extern Routes_ItemDefaultTypeInternal _Routes_Item_default_instance_;
class Services;
class ServicesDefaultTypeInternal;
extern ServicesDefaultTypeInternal _Services_default_instance_;
class Services_Item;
class Services_ItemDefaultTypeInternal;
extern Services_ItemDefaultTypeInternal _Services_Item_default_instance_;
class Sessions;
class SessionsDefaultTypeInternal;
extern SessionsDefaultTypeInternal _Sessions_default_instance_;
class Sessions_Item;
class Sessions_ItemDefaultTypeInternal;
extern Sessions_ItemDefaultTypeInternal _Sessions_Item_default_instance_;
class SharedResources;
class SharedResourcesDefaultTypeInternal;
extern SharedResourcesDefaultTypeInternal _SharedResources_default_instance_;
class SharedResources_Item;
class SharedResources_ItemDefaultTypeInternal;
extern SharedResources_ItemDefaultTypeInternal _SharedResources_Item_default_instance_;
class UserGroups;
class UserGroupsDefaultTypeInternal;
extern UserGroupsDefaultTypeInternal _UserGroups_default_instance_;
class UserGroups_Item;
class UserGroups_ItemDefaultTypeInternal;
extern UserGroups_ItemDefaultTypeInternal _UserGroups_Item_default_instance_;
class Users;
class UsersDefaultTypeInternal;
extern UsersDefaultTypeInternal _Users_default_instance_;
class Users_Item;
class Users_ItemDefaultTypeInternal;
extern Users_ItemDefaultTypeInternal _Users_Item_default_instance_;
class VideoAdapters;
class VideoAdaptersDefaultTypeInternal;
extern VideoAdaptersDefaultTypeInternal _VideoAdapters_default_instance_;
class VideoAdapters_Item;
class VideoAdapters_ItemDefaultTypeInternal;
extern VideoAdapters_ItemDefaultTypeInternal _VideoAdapters_Item_default_instance_;
class WindowsDevices;
class WindowsDevicesDefaultTypeInternal;
extern WindowsDevicesDefaultTypeInternal _WindowsDevices_default_instance_;
class WindowsDevices_Item;
class WindowsDevices_ItemDefaultTypeInternal;
extern WindowsDevices_ItemDefaultTypeInternal _WindowsDevices_Item_default_instance_;
}  // namespace proto
}  // namespace aspia
namespace aspia {
namespace proto {

enum PowerOptions_Battery_State {
  PowerOptions_Battery_State_STATE_UNKNOWN = 0,
  PowerOptions_Battery_State_STATE_CHARGING = 1,
  PowerOptions_Battery_State_STATE_CRITICAL = 2,
  PowerOptions_Battery_State_STATE_DISCHARGING = 4,
  PowerOptions_Battery_State_STATE_POWER_ONLINE = 8,
  PowerOptions_Battery_State_PowerOptions_Battery_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PowerOptions_Battery_State_PowerOptions_Battery_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PowerOptions_Battery_State_IsValid(int value);
const PowerOptions_Battery_State PowerOptions_Battery_State_State_MIN = PowerOptions_Battery_State_STATE_UNKNOWN;
const PowerOptions_Battery_State PowerOptions_Battery_State_State_MAX = PowerOptions_Battery_State_STATE_POWER_ONLINE;
const int PowerOptions_Battery_State_State_ARRAYSIZE = PowerOptions_Battery_State_State_MAX + 1;

enum PowerOptions_PowerSource {
  PowerOptions_PowerSource_POWER_SOURCE_UNKNOWN = 0,
  PowerOptions_PowerSource_POWER_SOURCE_DC_BATTERY = 1,
  PowerOptions_PowerSource_POWER_SOURCE_AC_LINE = 2,
  PowerOptions_PowerSource_PowerOptions_PowerSource_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PowerOptions_PowerSource_PowerOptions_PowerSource_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PowerOptions_PowerSource_IsValid(int value);
const PowerOptions_PowerSource PowerOptions_PowerSource_PowerSource_MIN = PowerOptions_PowerSource_POWER_SOURCE_UNKNOWN;
const PowerOptions_PowerSource PowerOptions_PowerSource_PowerSource_MAX = PowerOptions_PowerSource_POWER_SOURCE_AC_LINE;
const int PowerOptions_PowerSource_PowerSource_ARRAYSIZE = PowerOptions_PowerSource_PowerSource_MAX + 1;

enum PowerOptions_BatteryStatus {
  PowerOptions_BatteryStatus_BATTERY_STATUS_UNKNOWN = 0,
  PowerOptions_BatteryStatus_BATTERY_STATUS_HIGH = 1,
  PowerOptions_BatteryStatus_BATTERY_STATUS_LOW = 2,
  PowerOptions_BatteryStatus_BATTERY_STATUS_CRITICAL = 3,
  PowerOptions_BatteryStatus_BATTERY_STATUS_CHARGING = 4,
  PowerOptions_BatteryStatus_BATTERY_STATUS_NO_BATTERY = 5,
  PowerOptions_BatteryStatus_PowerOptions_BatteryStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PowerOptions_BatteryStatus_PowerOptions_BatteryStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PowerOptions_BatteryStatus_IsValid(int value);
const PowerOptions_BatteryStatus PowerOptions_BatteryStatus_BatteryStatus_MIN = PowerOptions_BatteryStatus_BATTERY_STATUS_UNKNOWN;
const PowerOptions_BatteryStatus PowerOptions_BatteryStatus_BatteryStatus_MAX = PowerOptions_BatteryStatus_BATTERY_STATUS_NO_BATTERY;
const int PowerOptions_BatteryStatus_BatteryStatus_ARRAYSIZE = PowerOptions_BatteryStatus_BatteryStatus_MAX + 1;

enum Printers_Item_Orientation {
  Printers_Item_Orientation_ORIENTATION_UNKNOWN = 0,
  Printers_Item_Orientation_ORIENTATION_PORTRAIT = 1,
  Printers_Item_Orientation_ORIENTATION_LANDSCAPE = 2,
  Printers_Item_Orientation_Printers_Item_Orientation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Printers_Item_Orientation_Printers_Item_Orientation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Printers_Item_Orientation_IsValid(int value);
const Printers_Item_Orientation Printers_Item_Orientation_Orientation_MIN = Printers_Item_Orientation_ORIENTATION_UNKNOWN;
const Printers_Item_Orientation Printers_Item_Orientation_Orientation_MAX = Printers_Item_Orientation_ORIENTATION_LANDSCAPE;
const int Printers_Item_Orientation_Orientation_ARRAYSIZE = Printers_Item_Orientation_Orientation_MAX + 1;

enum Services_Item_Status {
  Services_Item_Status_STATUS_UNKNOWN = 0,
  Services_Item_Status_STATUS_CONTINUE_PENDING = 1,
  Services_Item_Status_STATUS_PAUSE_PENDING = 2,
  Services_Item_Status_STATUS_PAUSED = 3,
  Services_Item_Status_STATUS_RUNNING = 4,
  Services_Item_Status_STATUS_START_PENDING = 5,
  Services_Item_Status_STATUS_STOP_PENDING = 6,
  Services_Item_Status_STATUS_STOPPED = 7,
  Services_Item_Status_Services_Item_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Services_Item_Status_Services_Item_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Services_Item_Status_IsValid(int value);
const Services_Item_Status Services_Item_Status_Status_MIN = Services_Item_Status_STATUS_UNKNOWN;
const Services_Item_Status Services_Item_Status_Status_MAX = Services_Item_Status_STATUS_STOPPED;
const int Services_Item_Status_Status_ARRAYSIZE = Services_Item_Status_Status_MAX + 1;

enum Services_Item_StartupType {
  Services_Item_StartupType_STARTUP_TYPE_UNKNOWN = 0,
  Services_Item_StartupType_STARTUP_TYPE_AUTO_START = 1,
  Services_Item_StartupType_STARTUP_TYPE_DEMAND_START = 2,
  Services_Item_StartupType_STARTUP_TYPE_DISABLED = 3,
  Services_Item_StartupType_STARTUP_TYPE_BOOT_START = 4,
  Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START = 5,
  Services_Item_StartupType_Services_Item_StartupType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Services_Item_StartupType_Services_Item_StartupType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Services_Item_StartupType_IsValid(int value);
const Services_Item_StartupType Services_Item_StartupType_StartupType_MIN = Services_Item_StartupType_STARTUP_TYPE_UNKNOWN;
const Services_Item_StartupType Services_Item_StartupType_StartupType_MAX = Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START;
const int Services_Item_StartupType_StartupType_ARRAYSIZE = Services_Item_StartupType_StartupType_MAX + 1;

enum OpenConnections_Item_Protocol {
  OpenConnections_Item_Protocol_PROTOCOL_UNKNOWN = 0,
  OpenConnections_Item_Protocol_PROTOCOL_TCP = 1,
  OpenConnections_Item_Protocol_PROTOCOL_UDP = 2,
  OpenConnections_Item_Protocol_OpenConnections_Item_Protocol_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OpenConnections_Item_Protocol_OpenConnections_Item_Protocol_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OpenConnections_Item_Protocol_IsValid(int value);
const OpenConnections_Item_Protocol OpenConnections_Item_Protocol_Protocol_MIN = OpenConnections_Item_Protocol_PROTOCOL_UNKNOWN;
const OpenConnections_Item_Protocol OpenConnections_Item_Protocol_Protocol_MAX = OpenConnections_Item_Protocol_PROTOCOL_UDP;
const int OpenConnections_Item_Protocol_Protocol_ARRAYSIZE = OpenConnections_Item_Protocol_Protocol_MAX + 1;

enum SharedResources_Item_Type {
  SharedResources_Item_Type_TYPE_UNKNOWN = 0,
  SharedResources_Item_Type_TYPE_DISK = 1,
  SharedResources_Item_Type_TYPE_PRINTER = 2,
  SharedResources_Item_Type_TYPE_DEVICE = 3,
  SharedResources_Item_Type_TYPE_IPC = 4,
  SharedResources_Item_Type_TYPE_SPECIAL = 5,
  SharedResources_Item_Type_TYPE_TEMPORARY = 6,
  SharedResources_Item_Type_SharedResources_Item_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SharedResources_Item_Type_SharedResources_Item_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SharedResources_Item_Type_IsValid(int value);
const SharedResources_Item_Type SharedResources_Item_Type_Type_MIN = SharedResources_Item_Type_TYPE_UNKNOWN;
const SharedResources_Item_Type SharedResources_Item_Type_Type_MAX = SharedResources_Item_Type_TYPE_TEMPORARY;
const int SharedResources_Item_Type_Type_ARRAYSIZE = SharedResources_Item_Type_Type_MAX + 1;

// ===================================================================

class DmiBios_Feature : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBios.Feature) */ {
 public:
  DmiBios_Feature();
  virtual ~DmiBios_Feature();

  DmiBios_Feature(const DmiBios_Feature& from);

  inline DmiBios_Feature& operator=(const DmiBios_Feature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBios_Feature(DmiBios_Feature&& from) noexcept
    : DmiBios_Feature() {
    *this = ::std::move(from);
  }

  inline DmiBios_Feature& operator=(DmiBios_Feature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBios_Feature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBios_Feature* internal_default_instance() {
    return reinterpret_cast<const DmiBios_Feature*>(
               &_DmiBios_Feature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DmiBios_Feature* other);
  friend void swap(DmiBios_Feature& a, DmiBios_Feature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBios_Feature* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBios_Feature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBios_Feature& from);
  void MergeFrom(const DmiBios_Feature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBios_Feature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool supported = 2;
  void clear_supported();
  static const int kSupportedFieldNumber = 2;
  bool supported() const;
  void set_supported(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBios.Feature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool supported_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBios_FeatureImpl();
};
// -------------------------------------------------------------------

class DmiBios : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBios) */ {
 public:
  DmiBios();
  virtual ~DmiBios();

  DmiBios(const DmiBios& from);

  inline DmiBios& operator=(const DmiBios& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBios(DmiBios&& from) noexcept
    : DmiBios() {
    *this = ::std::move(from);
  }

  inline DmiBios& operator=(DmiBios&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBios& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBios* internal_default_instance() {
    return reinterpret_cast<const DmiBios*>(
               &_DmiBios_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DmiBios* other);
  friend void swap(DmiBios& a, DmiBios& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBios* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBios* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBios& from);
  void MergeFrom(const DmiBios& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBios* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiBios_Feature Feature;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiBios.Feature feature = 9;
  int feature_size() const;
  void clear_feature();
  static const int kFeatureFieldNumber = 9;
  const ::aspia::proto::DmiBios_Feature& feature(int index) const;
  ::aspia::proto::DmiBios_Feature* mutable_feature(int index);
  ::aspia::proto::DmiBios_Feature* add_feature();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBios_Feature >*
      mutable_feature();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBios_Feature >&
      feature() const;

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string date = 3;
  void clear_date();
  static const int kDateFieldNumber = 3;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // string bios_revision = 5;
  void clear_bios_revision();
  static const int kBiosRevisionFieldNumber = 5;
  const ::std::string& bios_revision() const;
  void set_bios_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_bios_revision(::std::string&& value);
  #endif
  void set_bios_revision(const char* value);
  void set_bios_revision(const char* value, size_t size);
  ::std::string* mutable_bios_revision();
  ::std::string* release_bios_revision();
  void set_allocated_bios_revision(::std::string* bios_revision);

  // string firmware_revision = 6;
  void clear_firmware_revision();
  static const int kFirmwareRevisionFieldNumber = 6;
  const ::std::string& firmware_revision() const;
  void set_firmware_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_firmware_revision(::std::string&& value);
  #endif
  void set_firmware_revision(const char* value);
  void set_firmware_revision(const char* value, size_t size);
  ::std::string* mutable_firmware_revision();
  ::std::string* release_firmware_revision();
  void set_allocated_firmware_revision(::std::string* firmware_revision);

  // string address = 7;
  void clear_address();
  static const int kAddressFieldNumber = 7;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // uint64 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // int32 runtime_size = 8;
  void clear_runtime_size();
  static const int kRuntimeSizeFieldNumber = 8;
  ::google::protobuf::int32 runtime_size() const;
  void set_runtime_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBios)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBios_Feature > feature_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr bios_revision_;
  ::google::protobuf::internal::ArenaStringPtr firmware_revision_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 runtime_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBiosImpl();
};
// -------------------------------------------------------------------

class DmiSystem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiSystem) */ {
 public:
  DmiSystem();
  virtual ~DmiSystem();

  DmiSystem(const DmiSystem& from);

  inline DmiSystem& operator=(const DmiSystem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiSystem(DmiSystem&& from) noexcept
    : DmiSystem() {
    *this = ::std::move(from);
  }

  inline DmiSystem& operator=(DmiSystem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiSystem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiSystem* internal_default_instance() {
    return reinterpret_cast<const DmiSystem*>(
               &_DmiSystem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DmiSystem* other);
  friend void swap(DmiSystem& a, DmiSystem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiSystem* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiSystem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiSystem& from);
  void MergeFrom(const DmiSystem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiSystem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string product_name = 2;
  void clear_product_name();
  static const int kProductNameFieldNumber = 2;
  const ::std::string& product_name() const;
  void set_product_name(const ::std::string& value);
  #if LANG_CXX11
  void set_product_name(::std::string&& value);
  #endif
  void set_product_name(const char* value);
  void set_product_name(const char* value, size_t size);
  ::std::string* mutable_product_name();
  ::std::string* release_product_name();
  void set_allocated_product_name(::std::string* product_name);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string uuid = 5;
  void clear_uuid();
  static const int kUuidFieldNumber = 5;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // string wakeup_type = 6;
  void clear_wakeup_type();
  static const int kWakeupTypeFieldNumber = 6;
  const ::std::string& wakeup_type() const;
  void set_wakeup_type(const ::std::string& value);
  #if LANG_CXX11
  void set_wakeup_type(::std::string&& value);
  #endif
  void set_wakeup_type(const char* value);
  void set_wakeup_type(const char* value, size_t size);
  ::std::string* mutable_wakeup_type();
  ::std::string* release_wakeup_type();
  void set_allocated_wakeup_type(::std::string* wakeup_type);

  // string sku_number = 7;
  void clear_sku_number();
  static const int kSkuNumberFieldNumber = 7;
  const ::std::string& sku_number() const;
  void set_sku_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sku_number(::std::string&& value);
  #endif
  void set_sku_number(const char* value);
  void set_sku_number(const char* value, size_t size);
  ::std::string* mutable_sku_number();
  ::std::string* release_sku_number();
  void set_allocated_sku_number(::std::string* sku_number);

  // string family = 8;
  void clear_family();
  static const int kFamilyFieldNumber = 8;
  const ::std::string& family() const;
  void set_family(const ::std::string& value);
  #if LANG_CXX11
  void set_family(::std::string&& value);
  #endif
  void set_family(const char* value);
  void set_family(const char* value, size_t size);
  ::std::string* mutable_family();
  ::std::string* release_family();
  void set_allocated_family(::std::string* family);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiSystem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr product_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr wakeup_type_;
  ::google::protobuf::internal::ArenaStringPtr sku_number_;
  ::google::protobuf::internal::ArenaStringPtr family_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiSystemImpl();
};
// -------------------------------------------------------------------

class DmiBaseboard_Item_Feature : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBaseboard.Item.Feature) */ {
 public:
  DmiBaseboard_Item_Feature();
  virtual ~DmiBaseboard_Item_Feature();

  DmiBaseboard_Item_Feature(const DmiBaseboard_Item_Feature& from);

  inline DmiBaseboard_Item_Feature& operator=(const DmiBaseboard_Item_Feature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBaseboard_Item_Feature(DmiBaseboard_Item_Feature&& from) noexcept
    : DmiBaseboard_Item_Feature() {
    *this = ::std::move(from);
  }

  inline DmiBaseboard_Item_Feature& operator=(DmiBaseboard_Item_Feature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBaseboard_Item_Feature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBaseboard_Item_Feature* internal_default_instance() {
    return reinterpret_cast<const DmiBaseboard_Item_Feature*>(
               &_DmiBaseboard_Item_Feature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DmiBaseboard_Item_Feature* other);
  friend void swap(DmiBaseboard_Item_Feature& a, DmiBaseboard_Item_Feature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBaseboard_Item_Feature* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBaseboard_Item_Feature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBaseboard_Item_Feature& from);
  void MergeFrom(const DmiBaseboard_Item_Feature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBaseboard_Item_Feature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool supported = 2;
  void clear_supported();
  static const int kSupportedFieldNumber = 2;
  bool supported() const;
  void set_supported(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBaseboard.Item.Feature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool supported_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBaseboard_Item_FeatureImpl();
};
// -------------------------------------------------------------------

class DmiBaseboard_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBaseboard.Item) */ {
 public:
  DmiBaseboard_Item();
  virtual ~DmiBaseboard_Item();

  DmiBaseboard_Item(const DmiBaseboard_Item& from);

  inline DmiBaseboard_Item& operator=(const DmiBaseboard_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBaseboard_Item(DmiBaseboard_Item&& from) noexcept
    : DmiBaseboard_Item() {
    *this = ::std::move(from);
  }

  inline DmiBaseboard_Item& operator=(DmiBaseboard_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBaseboard_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBaseboard_Item* internal_default_instance() {
    return reinterpret_cast<const DmiBaseboard_Item*>(
               &_DmiBaseboard_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DmiBaseboard_Item* other);
  friend void swap(DmiBaseboard_Item& a, DmiBaseboard_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBaseboard_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBaseboard_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBaseboard_Item& from);
  void MergeFrom(const DmiBaseboard_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBaseboard_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiBaseboard_Item_Feature Feature;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiBaseboard.Item.Feature feature = 6;
  int feature_size() const;
  void clear_feature();
  static const int kFeatureFieldNumber = 6;
  const ::aspia::proto::DmiBaseboard_Item_Feature& feature(int index) const;
  ::aspia::proto::DmiBaseboard_Item_Feature* mutable_feature(int index);
  ::aspia::proto::DmiBaseboard_Item_Feature* add_feature();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item_Feature >*
      mutable_feature();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item_Feature >&
      feature() const;

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string product_name = 2;
  void clear_product_name();
  static const int kProductNameFieldNumber = 2;
  const ::std::string& product_name() const;
  void set_product_name(const ::std::string& value);
  #if LANG_CXX11
  void set_product_name(::std::string&& value);
  #endif
  void set_product_name(const char* value);
  void set_product_name(const char* value, size_t size);
  ::std::string* mutable_product_name();
  ::std::string* release_product_name();
  void set_allocated_product_name(::std::string* product_name);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 5;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 5;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // string location_in_chassis = 7;
  void clear_location_in_chassis();
  static const int kLocationInChassisFieldNumber = 7;
  const ::std::string& location_in_chassis() const;
  void set_location_in_chassis(const ::std::string& value);
  #if LANG_CXX11
  void set_location_in_chassis(::std::string&& value);
  #endif
  void set_location_in_chassis(const char* value);
  void set_location_in_chassis(const char* value, size_t size);
  ::std::string* mutable_location_in_chassis();
  ::std::string* release_location_in_chassis();
  void set_allocated_location_in_chassis(::std::string* location_in_chassis);

  // string type = 8;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBaseboard.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item_Feature > feature_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr product_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  ::google::protobuf::internal::ArenaStringPtr location_in_chassis_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBaseboard_ItemImpl();
};
// -------------------------------------------------------------------

class DmiBaseboard : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBaseboard) */ {
 public:
  DmiBaseboard();
  virtual ~DmiBaseboard();

  DmiBaseboard(const DmiBaseboard& from);

  inline DmiBaseboard& operator=(const DmiBaseboard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBaseboard(DmiBaseboard&& from) noexcept
    : DmiBaseboard() {
    *this = ::std::move(from);
  }

  inline DmiBaseboard& operator=(DmiBaseboard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBaseboard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBaseboard* internal_default_instance() {
    return reinterpret_cast<const DmiBaseboard*>(
               &_DmiBaseboard_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(DmiBaseboard* other);
  friend void swap(DmiBaseboard& a, DmiBaseboard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBaseboard* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBaseboard* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBaseboard& from);
  void MergeFrom(const DmiBaseboard& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBaseboard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiBaseboard_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiBaseboard.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiBaseboard_Item& item(int index) const;
  ::aspia::proto::DmiBaseboard_Item* mutable_item(int index);
  ::aspia::proto::DmiBaseboard_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBaseboard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBaseboardImpl();
};
// -------------------------------------------------------------------

class DmiChassis_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiChassis.Item) */ {
 public:
  DmiChassis_Item();
  virtual ~DmiChassis_Item();

  DmiChassis_Item(const DmiChassis_Item& from);

  inline DmiChassis_Item& operator=(const DmiChassis_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiChassis_Item(DmiChassis_Item&& from) noexcept
    : DmiChassis_Item() {
    *this = ::std::move(from);
  }

  inline DmiChassis_Item& operator=(DmiChassis_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiChassis_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiChassis_Item* internal_default_instance() {
    return reinterpret_cast<const DmiChassis_Item*>(
               &_DmiChassis_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(DmiChassis_Item* other);
  friend void swap(DmiChassis_Item& a, DmiChassis_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiChassis_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiChassis_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiChassis_Item& from);
  void MergeFrom(const DmiChassis_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiChassis_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 3;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 3;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 4;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 4;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // string type = 5;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string os_load_status = 6;
  void clear_os_load_status();
  static const int kOsLoadStatusFieldNumber = 6;
  const ::std::string& os_load_status() const;
  void set_os_load_status(const ::std::string& value);
  #if LANG_CXX11
  void set_os_load_status(::std::string&& value);
  #endif
  void set_os_load_status(const char* value);
  void set_os_load_status(const char* value, size_t size);
  ::std::string* mutable_os_load_status();
  ::std::string* release_os_load_status();
  void set_allocated_os_load_status(::std::string* os_load_status);

  // string power_source_status = 7;
  void clear_power_source_status();
  static const int kPowerSourceStatusFieldNumber = 7;
  const ::std::string& power_source_status() const;
  void set_power_source_status(const ::std::string& value);
  #if LANG_CXX11
  void set_power_source_status(::std::string&& value);
  #endif
  void set_power_source_status(const char* value);
  void set_power_source_status(const char* value, size_t size);
  ::std::string* mutable_power_source_status();
  ::std::string* release_power_source_status();
  void set_allocated_power_source_status(::std::string* power_source_status);

  // string temparature_status = 8;
  void clear_temparature_status();
  static const int kTemparatureStatusFieldNumber = 8;
  const ::std::string& temparature_status() const;
  void set_temparature_status(const ::std::string& value);
  #if LANG_CXX11
  void set_temparature_status(::std::string&& value);
  #endif
  void set_temparature_status(const char* value);
  void set_temparature_status(const char* value, size_t size);
  ::std::string* mutable_temparature_status();
  ::std::string* release_temparature_status();
  void set_allocated_temparature_status(::std::string* temparature_status);

  // string security_status = 9;
  void clear_security_status();
  static const int kSecurityStatusFieldNumber = 9;
  const ::std::string& security_status() const;
  void set_security_status(const ::std::string& value);
  #if LANG_CXX11
  void set_security_status(::std::string&& value);
  #endif
  void set_security_status(const char* value);
  void set_security_status(const char* value, size_t size);
  ::std::string* mutable_security_status();
  ::std::string* release_security_status();
  void set_allocated_security_status(::std::string* security_status);

  // int32 height = 10;
  void clear_height();
  static const int kHeightFieldNumber = 10;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // int32 number_of_power_cords = 11;
  void clear_number_of_power_cords();
  static const int kNumberOfPowerCordsFieldNumber = 11;
  ::google::protobuf::int32 number_of_power_cords() const;
  void set_number_of_power_cords(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiChassis.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr os_load_status_;
  ::google::protobuf::internal::ArenaStringPtr power_source_status_;
  ::google::protobuf::internal::ArenaStringPtr temparature_status_;
  ::google::protobuf::internal::ArenaStringPtr security_status_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 number_of_power_cords_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiChassis_ItemImpl();
};
// -------------------------------------------------------------------

class DmiChassis : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiChassis) */ {
 public:
  DmiChassis();
  virtual ~DmiChassis();

  DmiChassis(const DmiChassis& from);

  inline DmiChassis& operator=(const DmiChassis& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiChassis(DmiChassis&& from) noexcept
    : DmiChassis() {
    *this = ::std::move(from);
  }

  inline DmiChassis& operator=(DmiChassis&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiChassis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiChassis* internal_default_instance() {
    return reinterpret_cast<const DmiChassis*>(
               &_DmiChassis_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(DmiChassis* other);
  friend void swap(DmiChassis& a, DmiChassis& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiChassis* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiChassis* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiChassis& from);
  void MergeFrom(const DmiChassis& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiChassis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiChassis_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiChassis.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiChassis_Item& item(int index) const;
  ::aspia::proto::DmiChassis_Item* mutable_item(int index);
  ::aspia::proto::DmiChassis_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiChassis)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiChassisImpl();
};
// -------------------------------------------------------------------

class DmiCaches_Item_SRAMType : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiCaches.Item.SRAMType) */ {
 public:
  DmiCaches_Item_SRAMType();
  virtual ~DmiCaches_Item_SRAMType();

  DmiCaches_Item_SRAMType(const DmiCaches_Item_SRAMType& from);

  inline DmiCaches_Item_SRAMType& operator=(const DmiCaches_Item_SRAMType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiCaches_Item_SRAMType(DmiCaches_Item_SRAMType&& from) noexcept
    : DmiCaches_Item_SRAMType() {
    *this = ::std::move(from);
  }

  inline DmiCaches_Item_SRAMType& operator=(DmiCaches_Item_SRAMType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiCaches_Item_SRAMType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiCaches_Item_SRAMType* internal_default_instance() {
    return reinterpret_cast<const DmiCaches_Item_SRAMType*>(
               &_DmiCaches_Item_SRAMType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(DmiCaches_Item_SRAMType* other);
  friend void swap(DmiCaches_Item_SRAMType& a, DmiCaches_Item_SRAMType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiCaches_Item_SRAMType* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiCaches_Item_SRAMType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiCaches_Item_SRAMType& from);
  void MergeFrom(const DmiCaches_Item_SRAMType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiCaches_Item_SRAMType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool supported = 2;
  void clear_supported();
  static const int kSupportedFieldNumber = 2;
  bool supported() const;
  void set_supported(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiCaches.Item.SRAMType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool supported_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiCaches_Item_SRAMTypeImpl();
};
// -------------------------------------------------------------------

class DmiCaches_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiCaches.Item) */ {
 public:
  DmiCaches_Item();
  virtual ~DmiCaches_Item();

  DmiCaches_Item(const DmiCaches_Item& from);

  inline DmiCaches_Item& operator=(const DmiCaches_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiCaches_Item(DmiCaches_Item&& from) noexcept
    : DmiCaches_Item() {
    *this = ::std::move(from);
  }

  inline DmiCaches_Item& operator=(DmiCaches_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiCaches_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiCaches_Item* internal_default_instance() {
    return reinterpret_cast<const DmiCaches_Item*>(
               &_DmiCaches_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(DmiCaches_Item* other);
  friend void swap(DmiCaches_Item& a, DmiCaches_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiCaches_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiCaches_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiCaches_Item& from);
  void MergeFrom(const DmiCaches_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiCaches_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiCaches_Item_SRAMType SRAMType;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiCaches.Item.SRAMType supported_sram_type = 8;
  int supported_sram_type_size() const;
  void clear_supported_sram_type();
  static const int kSupportedSramTypeFieldNumber = 8;
  const ::aspia::proto::DmiCaches_Item_SRAMType& supported_sram_type(int index) const;
  ::aspia::proto::DmiCaches_Item_SRAMType* mutable_supported_sram_type(int index);
  ::aspia::proto::DmiCaches_Item_SRAMType* add_supported_sram_type();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item_SRAMType >*
      mutable_supported_sram_type();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item_SRAMType >&
      supported_sram_type() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string location = 2;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // string mode = 4;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  const ::std::string& mode() const;
  void set_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_mode(::std::string&& value);
  #endif
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  ::std::string* mutable_mode();
  ::std::string* release_mode();
  void set_allocated_mode(::std::string* mode);

  // string current_sram_type = 9;
  void clear_current_sram_type();
  static const int kCurrentSramTypeFieldNumber = 9;
  const ::std::string& current_sram_type() const;
  void set_current_sram_type(const ::std::string& value);
  #if LANG_CXX11
  void set_current_sram_type(::std::string&& value);
  #endif
  void set_current_sram_type(const char* value);
  void set_current_sram_type(const char* value, size_t size);
  ::std::string* mutable_current_sram_type();
  ::std::string* release_current_sram_type();
  void set_allocated_current_sram_type(::std::string* current_sram_type);

  // string error_correction_type = 11;
  void clear_error_correction_type();
  static const int kErrorCorrectionTypeFieldNumber = 11;
  const ::std::string& error_correction_type() const;
  void set_error_correction_type(const ::std::string& value);
  #if LANG_CXX11
  void set_error_correction_type(::std::string&& value);
  #endif
  void set_error_correction_type(const char* value);
  void set_error_correction_type(const char* value, size_t size);
  ::std::string* mutable_error_correction_type();
  ::std::string* release_error_correction_type();
  void set_allocated_error_correction_type(::std::string* error_correction_type);

  // string type = 12;
  void clear_type();
  static const int kTypeFieldNumber = 12;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string associativity = 13;
  void clear_associativity();
  static const int kAssociativityFieldNumber = 13;
  const ::std::string& associativity() const;
  void set_associativity(const ::std::string& value);
  #if LANG_CXX11
  void set_associativity(::std::string&& value);
  #endif
  void set_associativity(const char* value);
  void set_associativity(const char* value, size_t size);
  ::std::string* mutable_associativity();
  ::std::string* release_associativity();
  void set_allocated_associativity(::std::string* associativity);

  // bool enabled = 3;
  void clear_enabled();
  static const int kEnabledFieldNumber = 3;
  bool enabled() const;
  void set_enabled(bool value);

  // int32 level = 5;
  void clear_level();
  static const int kLevelFieldNumber = 5;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // int32 maximum_size = 6;
  void clear_maximum_size();
  static const int kMaximumSizeFieldNumber = 6;
  ::google::protobuf::int32 maximum_size() const;
  void set_maximum_size(::google::protobuf::int32 value);

  // int32 current_size = 7;
  void clear_current_size();
  static const int kCurrentSizeFieldNumber = 7;
  ::google::protobuf::int32 current_size() const;
  void set_current_size(::google::protobuf::int32 value);

  // int32 speed = 10;
  void clear_speed();
  static const int kSpeedFieldNumber = 10;
  ::google::protobuf::int32 speed() const;
  void set_speed(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiCaches.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item_SRAMType > supported_sram_type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr mode_;
  ::google::protobuf::internal::ArenaStringPtr current_sram_type_;
  ::google::protobuf::internal::ArenaStringPtr error_correction_type_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr associativity_;
  bool enabled_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 maximum_size_;
  ::google::protobuf::int32 current_size_;
  ::google::protobuf::int32 speed_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiCaches_ItemImpl();
};
// -------------------------------------------------------------------

class DmiCaches : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiCaches) */ {
 public:
  DmiCaches();
  virtual ~DmiCaches();

  DmiCaches(const DmiCaches& from);

  inline DmiCaches& operator=(const DmiCaches& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiCaches(DmiCaches&& from) noexcept
    : DmiCaches() {
    *this = ::std::move(from);
  }

  inline DmiCaches& operator=(DmiCaches&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiCaches& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiCaches* internal_default_instance() {
    return reinterpret_cast<const DmiCaches*>(
               &_DmiCaches_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(DmiCaches* other);
  friend void swap(DmiCaches& a, DmiCaches& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiCaches* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiCaches* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiCaches& from);
  void MergeFrom(const DmiCaches& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiCaches* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiCaches_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiCaches.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiCaches_Item& item(int index) const;
  ::aspia::proto::DmiCaches_Item* mutable_item(int index);
  ::aspia::proto::DmiCaches_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiCaches)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiCachesImpl();
};
// -------------------------------------------------------------------

class DmiProcessors_Item_Feature : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiProcessors.Item.Feature) */ {
 public:
  DmiProcessors_Item_Feature();
  virtual ~DmiProcessors_Item_Feature();

  DmiProcessors_Item_Feature(const DmiProcessors_Item_Feature& from);

  inline DmiProcessors_Item_Feature& operator=(const DmiProcessors_Item_Feature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiProcessors_Item_Feature(DmiProcessors_Item_Feature&& from) noexcept
    : DmiProcessors_Item_Feature() {
    *this = ::std::move(from);
  }

  inline DmiProcessors_Item_Feature& operator=(DmiProcessors_Item_Feature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiProcessors_Item_Feature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiProcessors_Item_Feature* internal_default_instance() {
    return reinterpret_cast<const DmiProcessors_Item_Feature*>(
               &_DmiProcessors_Item_Feature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(DmiProcessors_Item_Feature* other);
  friend void swap(DmiProcessors_Item_Feature& a, DmiProcessors_Item_Feature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiProcessors_Item_Feature* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiProcessors_Item_Feature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiProcessors_Item_Feature& from);
  void MergeFrom(const DmiProcessors_Item_Feature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiProcessors_Item_Feature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool supported = 2;
  void clear_supported();
  static const int kSupportedFieldNumber = 2;
  bool supported() const;
  void set_supported(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiProcessors.Item.Feature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool supported_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiProcessors_Item_FeatureImpl();
};
// -------------------------------------------------------------------

class DmiProcessors_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiProcessors.Item) */ {
 public:
  DmiProcessors_Item();
  virtual ~DmiProcessors_Item();

  DmiProcessors_Item(const DmiProcessors_Item& from);

  inline DmiProcessors_Item& operator=(const DmiProcessors_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiProcessors_Item(DmiProcessors_Item&& from) noexcept
    : DmiProcessors_Item() {
    *this = ::std::move(from);
  }

  inline DmiProcessors_Item& operator=(DmiProcessors_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiProcessors_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiProcessors_Item* internal_default_instance() {
    return reinterpret_cast<const DmiProcessors_Item*>(
               &_DmiProcessors_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DmiProcessors_Item* other);
  friend void swap(DmiProcessors_Item& a, DmiProcessors_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiProcessors_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiProcessors_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiProcessors_Item& from);
  void MergeFrom(const DmiProcessors_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiProcessors_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiProcessors_Item_Feature Feature;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiProcessors.Item.Feature feature = 18;
  int feature_size() const;
  void clear_feature();
  static const int kFeatureFieldNumber = 18;
  const ::aspia::proto::DmiProcessors_Item_Feature& feature(int index) const;
  ::aspia::proto::DmiProcessors_Item_Feature* mutable_feature(int index);
  ::aspia::proto::DmiProcessors_Item_Feature* add_feature();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item_Feature >*
      mutable_feature();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item_Feature >&
      feature() const;

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string family = 3;
  void clear_family();
  static const int kFamilyFieldNumber = 3;
  const ::std::string& family() const;
  void set_family(const ::std::string& value);
  #if LANG_CXX11
  void set_family(::std::string&& value);
  #endif
  void set_family(const char* value);
  void set_family(const char* value, size_t size);
  ::std::string* mutable_family();
  ::std::string* release_family();
  void set_allocated_family(::std::string* family);

  // string type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string status = 5;
  void clear_status();
  static const int kStatusFieldNumber = 5;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // string socket = 6;
  void clear_socket();
  static const int kSocketFieldNumber = 6;
  const ::std::string& socket() const;
  void set_socket(const ::std::string& value);
  #if LANG_CXX11
  void set_socket(::std::string&& value);
  #endif
  void set_socket(const char* value);
  void set_socket(const char* value, size_t size);
  ::std::string* mutable_socket();
  ::std::string* release_socket();
  void set_allocated_socket(::std::string* socket);

  // string upgrade = 7;
  void clear_upgrade();
  static const int kUpgradeFieldNumber = 7;
  const ::std::string& upgrade() const;
  void set_upgrade(const ::std::string& value);
  #if LANG_CXX11
  void set_upgrade(::std::string&& value);
  #endif
  void set_upgrade(const char* value);
  void set_upgrade(const char* value, size_t size);
  ::std::string* mutable_upgrade();
  ::std::string* release_upgrade();
  void set_allocated_upgrade(::std::string* upgrade);

  // string serial_number = 12;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 12;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 13;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 13;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // string part_number = 14;
  void clear_part_number();
  static const int kPartNumberFieldNumber = 14;
  const ::std::string& part_number() const;
  void set_part_number(const ::std::string& value);
  #if LANG_CXX11
  void set_part_number(::std::string&& value);
  #endif
  void set_part_number(const char* value);
  void set_part_number(const char* value, size_t size);
  ::std::string* mutable_part_number();
  ::std::string* release_part_number();
  void set_allocated_part_number(::std::string* part_number);

  // int32 external_clock = 8;
  void clear_external_clock();
  static const int kExternalClockFieldNumber = 8;
  ::google::protobuf::int32 external_clock() const;
  void set_external_clock(::google::protobuf::int32 value);

  // int32 current_speed = 9;
  void clear_current_speed();
  static const int kCurrentSpeedFieldNumber = 9;
  ::google::protobuf::int32 current_speed() const;
  void set_current_speed(::google::protobuf::int32 value);

  // double voltage = 11;
  void clear_voltage();
  static const int kVoltageFieldNumber = 11;
  double voltage() const;
  void set_voltage(double value);

  // int32 maximum_speed = 10;
  void clear_maximum_speed();
  static const int kMaximumSpeedFieldNumber = 10;
  ::google::protobuf::int32 maximum_speed() const;
  void set_maximum_speed(::google::protobuf::int32 value);

  // int32 core_count = 15;
  void clear_core_count();
  static const int kCoreCountFieldNumber = 15;
  ::google::protobuf::int32 core_count() const;
  void set_core_count(::google::protobuf::int32 value);

  // int32 core_enabled = 16;
  void clear_core_enabled();
  static const int kCoreEnabledFieldNumber = 16;
  ::google::protobuf::int32 core_enabled() const;
  void set_core_enabled(::google::protobuf::int32 value);

  // int32 thread_count = 17;
  void clear_thread_count();
  static const int kThreadCountFieldNumber = 17;
  ::google::protobuf::int32 thread_count() const;
  void set_thread_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiProcessors.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item_Feature > feature_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr family_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::internal::ArenaStringPtr socket_;
  ::google::protobuf::internal::ArenaStringPtr upgrade_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  ::google::protobuf::internal::ArenaStringPtr part_number_;
  ::google::protobuf::int32 external_clock_;
  ::google::protobuf::int32 current_speed_;
  double voltage_;
  ::google::protobuf::int32 maximum_speed_;
  ::google::protobuf::int32 core_count_;
  ::google::protobuf::int32 core_enabled_;
  ::google::protobuf::int32 thread_count_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiProcessors_ItemImpl();
};
// -------------------------------------------------------------------

class DmiProcessors : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiProcessors) */ {
 public:
  DmiProcessors();
  virtual ~DmiProcessors();

  DmiProcessors(const DmiProcessors& from);

  inline DmiProcessors& operator=(const DmiProcessors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiProcessors(DmiProcessors&& from) noexcept
    : DmiProcessors() {
    *this = ::std::move(from);
  }

  inline DmiProcessors& operator=(DmiProcessors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiProcessors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiProcessors* internal_default_instance() {
    return reinterpret_cast<const DmiProcessors*>(
               &_DmiProcessors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(DmiProcessors* other);
  friend void swap(DmiProcessors& a, DmiProcessors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiProcessors* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiProcessors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiProcessors& from);
  void MergeFrom(const DmiProcessors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiProcessors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiProcessors_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiProcessors.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiProcessors_Item& item(int index) const;
  ::aspia::proto::DmiProcessors_Item* mutable_item(int index);
  ::aspia::proto::DmiProcessors_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiProcessors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiProcessorsImpl();
};
// -------------------------------------------------------------------

class DmiMemoryDevices_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiMemoryDevices.Item) */ {
 public:
  DmiMemoryDevices_Item();
  virtual ~DmiMemoryDevices_Item();

  DmiMemoryDevices_Item(const DmiMemoryDevices_Item& from);

  inline DmiMemoryDevices_Item& operator=(const DmiMemoryDevices_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiMemoryDevices_Item(DmiMemoryDevices_Item&& from) noexcept
    : DmiMemoryDevices_Item() {
    *this = ::std::move(from);
  }

  inline DmiMemoryDevices_Item& operator=(DmiMemoryDevices_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiMemoryDevices_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiMemoryDevices_Item* internal_default_instance() {
    return reinterpret_cast<const DmiMemoryDevices_Item*>(
               &_DmiMemoryDevices_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(DmiMemoryDevices_Item* other);
  friend void swap(DmiMemoryDevices_Item& a, DmiMemoryDevices_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiMemoryDevices_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiMemoryDevices_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiMemoryDevices_Item& from);
  void MergeFrom(const DmiMemoryDevices_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiMemoryDevices_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device_locator = 1;
  void clear_device_locator();
  static const int kDeviceLocatorFieldNumber = 1;
  const ::std::string& device_locator() const;
  void set_device_locator(const ::std::string& value);
  #if LANG_CXX11
  void set_device_locator(::std::string&& value);
  #endif
  void set_device_locator(const char* value);
  void set_device_locator(const char* value, size_t size);
  ::std::string* mutable_device_locator();
  ::std::string* release_device_locator();
  void set_allocated_device_locator(::std::string* device_locator);

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string form_factor = 5;
  void clear_form_factor();
  static const int kFormFactorFieldNumber = 5;
  const ::std::string& form_factor() const;
  void set_form_factor(const ::std::string& value);
  #if LANG_CXX11
  void set_form_factor(::std::string&& value);
  #endif
  void set_form_factor(const char* value);
  void set_form_factor(const char* value, size_t size);
  ::std::string* mutable_form_factor();
  ::std::string* release_form_factor();
  void set_allocated_form_factor(::std::string* form_factor);

  // string serial_number = 6;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 6;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string part_number = 7;
  void clear_part_number();
  static const int kPartNumberFieldNumber = 7;
  const ::std::string& part_number() const;
  void set_part_number(const ::std::string& value);
  #if LANG_CXX11
  void set_part_number(::std::string&& value);
  #endif
  void set_part_number(const char* value);
  void set_part_number(const char* value, size_t size);
  ::std::string* mutable_part_number();
  ::std::string* release_part_number();
  void set_allocated_part_number(::std::string* part_number);

  // string manufactorer = 8;
  void clear_manufactorer();
  static const int kManufactorerFieldNumber = 8;
  const ::std::string& manufactorer() const;
  void set_manufactorer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufactorer(::std::string&& value);
  #endif
  void set_manufactorer(const char* value);
  void set_manufactorer(const char* value, size_t size);
  ::std::string* mutable_manufactorer();
  ::std::string* release_manufactorer();
  void set_allocated_manufactorer(::std::string* manufactorer);

  // string bank = 9;
  void clear_bank();
  static const int kBankFieldNumber = 9;
  const ::std::string& bank() const;
  void set_bank(const ::std::string& value);
  #if LANG_CXX11
  void set_bank(::std::string&& value);
  #endif
  void set_bank(const char* value);
  void set_bank(const char* value, size_t size);
  ::std::string* mutable_bank();
  ::std::string* release_bank();
  void set_allocated_bank(::std::string* bank);

  // int32 size = 2;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // int32 speed = 4;
  void clear_speed();
  static const int kSpeedFieldNumber = 4;
  ::google::protobuf::int32 speed() const;
  void set_speed(::google::protobuf::int32 value);

  // int32 total_width = 10;
  void clear_total_width();
  static const int kTotalWidthFieldNumber = 10;
  ::google::protobuf::int32 total_width() const;
  void set_total_width(::google::protobuf::int32 value);

  // int32 data_width = 11;
  void clear_data_width();
  static const int kDataWidthFieldNumber = 11;
  ::google::protobuf::int32 data_width() const;
  void set_data_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiMemoryDevices.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_locator_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr form_factor_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr part_number_;
  ::google::protobuf::internal::ArenaStringPtr manufactorer_;
  ::google::protobuf::internal::ArenaStringPtr bank_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 total_width_;
  ::google::protobuf::int32 data_width_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiMemoryDevices_ItemImpl();
};
// -------------------------------------------------------------------

class DmiMemoryDevices : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiMemoryDevices) */ {
 public:
  DmiMemoryDevices();
  virtual ~DmiMemoryDevices();

  DmiMemoryDevices(const DmiMemoryDevices& from);

  inline DmiMemoryDevices& operator=(const DmiMemoryDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiMemoryDevices(DmiMemoryDevices&& from) noexcept
    : DmiMemoryDevices() {
    *this = ::std::move(from);
  }

  inline DmiMemoryDevices& operator=(DmiMemoryDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiMemoryDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiMemoryDevices* internal_default_instance() {
    return reinterpret_cast<const DmiMemoryDevices*>(
               &_DmiMemoryDevices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(DmiMemoryDevices* other);
  friend void swap(DmiMemoryDevices& a, DmiMemoryDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiMemoryDevices* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiMemoryDevices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiMemoryDevices& from);
  void MergeFrom(const DmiMemoryDevices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiMemoryDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiMemoryDevices_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiMemoryDevices.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiMemoryDevices_Item& item(int index) const;
  ::aspia::proto::DmiMemoryDevices_Item* mutable_item(int index);
  ::aspia::proto::DmiMemoryDevices_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiMemoryDevices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiMemoryDevicesImpl();
};
// -------------------------------------------------------------------

class DmiSystemSlots_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiSystemSlots.Item) */ {
 public:
  DmiSystemSlots_Item();
  virtual ~DmiSystemSlots_Item();

  DmiSystemSlots_Item(const DmiSystemSlots_Item& from);

  inline DmiSystemSlots_Item& operator=(const DmiSystemSlots_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiSystemSlots_Item(DmiSystemSlots_Item&& from) noexcept
    : DmiSystemSlots_Item() {
    *this = ::std::move(from);
  }

  inline DmiSystemSlots_Item& operator=(DmiSystemSlots_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiSystemSlots_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiSystemSlots_Item* internal_default_instance() {
    return reinterpret_cast<const DmiSystemSlots_Item*>(
               &_DmiSystemSlots_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(DmiSystemSlots_Item* other);
  friend void swap(DmiSystemSlots_Item& a, DmiSystemSlots_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiSystemSlots_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiSystemSlots_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiSystemSlots_Item& from);
  void MergeFrom(const DmiSystemSlots_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiSystemSlots_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string slot_designation = 1;
  void clear_slot_designation();
  static const int kSlotDesignationFieldNumber = 1;
  const ::std::string& slot_designation() const;
  void set_slot_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_slot_designation(::std::string&& value);
  #endif
  void set_slot_designation(const char* value);
  void set_slot_designation(const char* value, size_t size);
  ::std::string* mutable_slot_designation();
  ::std::string* release_slot_designation();
  void set_allocated_slot_designation(::std::string* slot_designation);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string usage = 3;
  void clear_usage();
  static const int kUsageFieldNumber = 3;
  const ::std::string& usage() const;
  void set_usage(const ::std::string& value);
  #if LANG_CXX11
  void set_usage(::std::string&& value);
  #endif
  void set_usage(const char* value);
  void set_usage(const char* value, size_t size);
  ::std::string* mutable_usage();
  ::std::string* release_usage();
  void set_allocated_usage(::std::string* usage);

  // string bus_width = 4;
  void clear_bus_width();
  static const int kBusWidthFieldNumber = 4;
  const ::std::string& bus_width() const;
  void set_bus_width(const ::std::string& value);
  #if LANG_CXX11
  void set_bus_width(::std::string&& value);
  #endif
  void set_bus_width(const char* value);
  void set_bus_width(const char* value, size_t size);
  ::std::string* mutable_bus_width();
  ::std::string* release_bus_width();
  void set_allocated_bus_width(::std::string* bus_width);

  // string length = 5;
  void clear_length();
  static const int kLengthFieldNumber = 5;
  const ::std::string& length() const;
  void set_length(const ::std::string& value);
  #if LANG_CXX11
  void set_length(::std::string&& value);
  #endif
  void set_length(const char* value);
  void set_length(const char* value, size_t size);
  ::std::string* mutable_length();
  ::std::string* release_length();
  void set_allocated_length(::std::string* length);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiSystemSlots.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr slot_designation_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr usage_;
  ::google::protobuf::internal::ArenaStringPtr bus_width_;
  ::google::protobuf::internal::ArenaStringPtr length_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiSystemSlots_ItemImpl();
};
// -------------------------------------------------------------------

class DmiSystemSlots : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiSystemSlots) */ {
 public:
  DmiSystemSlots();
  virtual ~DmiSystemSlots();

  DmiSystemSlots(const DmiSystemSlots& from);

  inline DmiSystemSlots& operator=(const DmiSystemSlots& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiSystemSlots(DmiSystemSlots&& from) noexcept
    : DmiSystemSlots() {
    *this = ::std::move(from);
  }

  inline DmiSystemSlots& operator=(DmiSystemSlots&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiSystemSlots& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiSystemSlots* internal_default_instance() {
    return reinterpret_cast<const DmiSystemSlots*>(
               &_DmiSystemSlots_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(DmiSystemSlots* other);
  friend void swap(DmiSystemSlots& a, DmiSystemSlots& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiSystemSlots* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiSystemSlots* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiSystemSlots& from);
  void MergeFrom(const DmiSystemSlots& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiSystemSlots* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiSystemSlots_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiSystemSlots.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiSystemSlots_Item& item(int index) const;
  ::aspia::proto::DmiSystemSlots_Item* mutable_item(int index);
  ::aspia::proto::DmiSystemSlots_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiSystemSlots)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiSystemSlotsImpl();
};
// -------------------------------------------------------------------

class DmiPortConnectors_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortConnectors.Item) */ {
 public:
  DmiPortConnectors_Item();
  virtual ~DmiPortConnectors_Item();

  DmiPortConnectors_Item(const DmiPortConnectors_Item& from);

  inline DmiPortConnectors_Item& operator=(const DmiPortConnectors_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortConnectors_Item(DmiPortConnectors_Item&& from) noexcept
    : DmiPortConnectors_Item() {
    *this = ::std::move(from);
  }

  inline DmiPortConnectors_Item& operator=(DmiPortConnectors_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortConnectors_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortConnectors_Item* internal_default_instance() {
    return reinterpret_cast<const DmiPortConnectors_Item*>(
               &_DmiPortConnectors_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(DmiPortConnectors_Item* other);
  friend void swap(DmiPortConnectors_Item& a, DmiPortConnectors_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortConnectors_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortConnectors_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortConnectors_Item& from);
  void MergeFrom(const DmiPortConnectors_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortConnectors_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string internal_designation = 1;
  void clear_internal_designation();
  static const int kInternalDesignationFieldNumber = 1;
  const ::std::string& internal_designation() const;
  void set_internal_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_internal_designation(::std::string&& value);
  #endif
  void set_internal_designation(const char* value);
  void set_internal_designation(const char* value, size_t size);
  ::std::string* mutable_internal_designation();
  ::std::string* release_internal_designation();
  void set_allocated_internal_designation(::std::string* internal_designation);

  // string external_designation = 2;
  void clear_external_designation();
  static const int kExternalDesignationFieldNumber = 2;
  const ::std::string& external_designation() const;
  void set_external_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_external_designation(::std::string&& value);
  #endif
  void set_external_designation(const char* value);
  void set_external_designation(const char* value, size_t size);
  ::std::string* mutable_external_designation();
  ::std::string* release_external_designation();
  void set_allocated_external_designation(::std::string* external_designation);

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string internal_connector_type = 4;
  void clear_internal_connector_type();
  static const int kInternalConnectorTypeFieldNumber = 4;
  const ::std::string& internal_connector_type() const;
  void set_internal_connector_type(const ::std::string& value);
  #if LANG_CXX11
  void set_internal_connector_type(::std::string&& value);
  #endif
  void set_internal_connector_type(const char* value);
  void set_internal_connector_type(const char* value, size_t size);
  ::std::string* mutable_internal_connector_type();
  ::std::string* release_internal_connector_type();
  void set_allocated_internal_connector_type(::std::string* internal_connector_type);

  // string external_connector_type = 5;
  void clear_external_connector_type();
  static const int kExternalConnectorTypeFieldNumber = 5;
  const ::std::string& external_connector_type() const;
  void set_external_connector_type(const ::std::string& value);
  #if LANG_CXX11
  void set_external_connector_type(::std::string&& value);
  #endif
  void set_external_connector_type(const char* value);
  void set_external_connector_type(const char* value, size_t size);
  ::std::string* mutable_external_connector_type();
  ::std::string* release_external_connector_type();
  void set_allocated_external_connector_type(::std::string* external_connector_type);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortConnectors.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr internal_designation_;
  ::google::protobuf::internal::ArenaStringPtr external_designation_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr internal_connector_type_;
  ::google::protobuf::internal::ArenaStringPtr external_connector_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortConnectors_ItemImpl();
};
// -------------------------------------------------------------------

class DmiPortConnectors : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortConnectors) */ {
 public:
  DmiPortConnectors();
  virtual ~DmiPortConnectors();

  DmiPortConnectors(const DmiPortConnectors& from);

  inline DmiPortConnectors& operator=(const DmiPortConnectors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortConnectors(DmiPortConnectors&& from) noexcept
    : DmiPortConnectors() {
    *this = ::std::move(from);
  }

  inline DmiPortConnectors& operator=(DmiPortConnectors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortConnectors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortConnectors* internal_default_instance() {
    return reinterpret_cast<const DmiPortConnectors*>(
               &_DmiPortConnectors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(DmiPortConnectors* other);
  friend void swap(DmiPortConnectors& a, DmiPortConnectors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortConnectors* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortConnectors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortConnectors& from);
  void MergeFrom(const DmiPortConnectors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortConnectors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiPortConnectors_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiPortConnectors.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiPortConnectors_Item& item(int index) const;
  ::aspia::proto::DmiPortConnectors_Item* mutable_item(int index);
  ::aspia::proto::DmiPortConnectors_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortConnectors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortConnectorsImpl();
};
// -------------------------------------------------------------------

class DmiOnBoardDevices_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiOnBoardDevices.Item) */ {
 public:
  DmiOnBoardDevices_Item();
  virtual ~DmiOnBoardDevices_Item();

  DmiOnBoardDevices_Item(const DmiOnBoardDevices_Item& from);

  inline DmiOnBoardDevices_Item& operator=(const DmiOnBoardDevices_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiOnBoardDevices_Item(DmiOnBoardDevices_Item&& from) noexcept
    : DmiOnBoardDevices_Item() {
    *this = ::std::move(from);
  }

  inline DmiOnBoardDevices_Item& operator=(DmiOnBoardDevices_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiOnBoardDevices_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiOnBoardDevices_Item* internal_default_instance() {
    return reinterpret_cast<const DmiOnBoardDevices_Item*>(
               &_DmiOnBoardDevices_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(DmiOnBoardDevices_Item* other);
  friend void swap(DmiOnBoardDevices_Item& a, DmiOnBoardDevices_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiOnBoardDevices_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiOnBoardDevices_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiOnBoardDevices_Item& from);
  void MergeFrom(const DmiOnBoardDevices_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiOnBoardDevices_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string description = 1;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // bool enabled = 3;
  void clear_enabled();
  static const int kEnabledFieldNumber = 3;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiOnBoardDevices.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  bool enabled_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiOnBoardDevices_ItemImpl();
};
// -------------------------------------------------------------------

class DmiOnBoardDevices : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiOnBoardDevices) */ {
 public:
  DmiOnBoardDevices();
  virtual ~DmiOnBoardDevices();

  DmiOnBoardDevices(const DmiOnBoardDevices& from);

  inline DmiOnBoardDevices& operator=(const DmiOnBoardDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiOnBoardDevices(DmiOnBoardDevices&& from) noexcept
    : DmiOnBoardDevices() {
    *this = ::std::move(from);
  }

  inline DmiOnBoardDevices& operator=(DmiOnBoardDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiOnBoardDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiOnBoardDevices* internal_default_instance() {
    return reinterpret_cast<const DmiOnBoardDevices*>(
               &_DmiOnBoardDevices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(DmiOnBoardDevices* other);
  friend void swap(DmiOnBoardDevices& a, DmiOnBoardDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiOnBoardDevices* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiOnBoardDevices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiOnBoardDevices& from);
  void MergeFrom(const DmiOnBoardDevices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiOnBoardDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiOnBoardDevices_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiOnBoardDevices.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiOnBoardDevices_Item& item(int index) const;
  ::aspia::proto::DmiOnBoardDevices_Item* mutable_item(int index);
  ::aspia::proto::DmiOnBoardDevices_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiOnBoardDevices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiOnBoardDevicesImpl();
};
// -------------------------------------------------------------------

class DmiBuildinPointing_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBuildinPointing.Item) */ {
 public:
  DmiBuildinPointing_Item();
  virtual ~DmiBuildinPointing_Item();

  DmiBuildinPointing_Item(const DmiBuildinPointing_Item& from);

  inline DmiBuildinPointing_Item& operator=(const DmiBuildinPointing_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBuildinPointing_Item(DmiBuildinPointing_Item&& from) noexcept
    : DmiBuildinPointing_Item() {
    *this = ::std::move(from);
  }

  inline DmiBuildinPointing_Item& operator=(DmiBuildinPointing_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBuildinPointing_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBuildinPointing_Item* internal_default_instance() {
    return reinterpret_cast<const DmiBuildinPointing_Item*>(
               &_DmiBuildinPointing_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(DmiBuildinPointing_Item* other);
  friend void swap(DmiBuildinPointing_Item& a, DmiBuildinPointing_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBuildinPointing_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBuildinPointing_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBuildinPointing_Item& from);
  void MergeFrom(const DmiBuildinPointing_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBuildinPointing_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device_type = 1;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 1;
  const ::std::string& device_type() const;
  void set_device_type(const ::std::string& value);
  #if LANG_CXX11
  void set_device_type(::std::string&& value);
  #endif
  void set_device_type(const char* value);
  void set_device_type(const char* value, size_t size);
  ::std::string* mutable_device_type();
  ::std::string* release_device_type();
  void set_allocated_device_type(::std::string* device_type);

  // string device_interface = 2;
  void clear_device_interface();
  static const int kDeviceInterfaceFieldNumber = 2;
  const ::std::string& device_interface() const;
  void set_device_interface(const ::std::string& value);
  #if LANG_CXX11
  void set_device_interface(::std::string&& value);
  #endif
  void set_device_interface(const char* value);
  void set_device_interface(const char* value, size_t size);
  ::std::string* mutable_device_interface();
  ::std::string* release_device_interface();
  void set_allocated_device_interface(::std::string* device_interface);

  // int32 button_count = 3;
  void clear_button_count();
  static const int kButtonCountFieldNumber = 3;
  ::google::protobuf::int32 button_count() const;
  void set_button_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBuildinPointing.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_type_;
  ::google::protobuf::internal::ArenaStringPtr device_interface_;
  ::google::protobuf::int32 button_count_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBuildinPointing_ItemImpl();
};
// -------------------------------------------------------------------

class DmiBuildinPointing : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBuildinPointing) */ {
 public:
  DmiBuildinPointing();
  virtual ~DmiBuildinPointing();

  DmiBuildinPointing(const DmiBuildinPointing& from);

  inline DmiBuildinPointing& operator=(const DmiBuildinPointing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBuildinPointing(DmiBuildinPointing&& from) noexcept
    : DmiBuildinPointing() {
    *this = ::std::move(from);
  }

  inline DmiBuildinPointing& operator=(DmiBuildinPointing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBuildinPointing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBuildinPointing* internal_default_instance() {
    return reinterpret_cast<const DmiBuildinPointing*>(
               &_DmiBuildinPointing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(DmiBuildinPointing* other);
  friend void swap(DmiBuildinPointing& a, DmiBuildinPointing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBuildinPointing* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBuildinPointing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBuildinPointing& from);
  void MergeFrom(const DmiBuildinPointing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBuildinPointing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiBuildinPointing_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiBuildinPointing.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiBuildinPointing_Item& item(int index) const;
  ::aspia::proto::DmiBuildinPointing_Item* mutable_item(int index);
  ::aspia::proto::DmiBuildinPointing_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBuildinPointing_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBuildinPointing_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBuildinPointing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBuildinPointing_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBuildinPointingImpl();
};
// -------------------------------------------------------------------

class DmiPortableBattery_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortableBattery.Item) */ {
 public:
  DmiPortableBattery_Item();
  virtual ~DmiPortableBattery_Item();

  DmiPortableBattery_Item(const DmiPortableBattery_Item& from);

  inline DmiPortableBattery_Item& operator=(const DmiPortableBattery_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortableBattery_Item(DmiPortableBattery_Item&& from) noexcept
    : DmiPortableBattery_Item() {
    *this = ::std::move(from);
  }

  inline DmiPortableBattery_Item& operator=(DmiPortableBattery_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortableBattery_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortableBattery_Item* internal_default_instance() {
    return reinterpret_cast<const DmiPortableBattery_Item*>(
               &_DmiPortableBattery_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(DmiPortableBattery_Item* other);
  friend void swap(DmiPortableBattery_Item& a, DmiPortableBattery_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortableBattery_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortableBattery_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortableBattery_Item& from);
  void MergeFrom(const DmiPortableBattery_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortableBattery_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string location = 1;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // string manufacturer = 2;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 2;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string manufacture_date = 3;
  void clear_manufacture_date();
  static const int kManufactureDateFieldNumber = 3;
  const ::std::string& manufacture_date() const;
  void set_manufacture_date(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacture_date(::std::string&& value);
  #endif
  void set_manufacture_date(const char* value);
  void set_manufacture_date(const char* value, size_t size);
  ::std::string* mutable_manufacture_date();
  ::std::string* release_manufacture_date();
  void set_allocated_manufacture_date(::std::string* manufacture_date);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string device_name = 5;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 5;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  #if LANG_CXX11
  void set_device_name(::std::string&& value);
  #endif
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // string chemistry = 6;
  void clear_chemistry();
  static const int kChemistryFieldNumber = 6;
  const ::std::string& chemistry() const;
  void set_chemistry(const ::std::string& value);
  #if LANG_CXX11
  void set_chemistry(::std::string&& value);
  #endif
  void set_chemistry(const char* value);
  void set_chemistry(const char* value, size_t size);
  ::std::string* mutable_chemistry();
  ::std::string* release_chemistry();
  void set_allocated_chemistry(::std::string* chemistry);

  // string sbds_version_number = 9;
  void clear_sbds_version_number();
  static const int kSbdsVersionNumberFieldNumber = 9;
  const ::std::string& sbds_version_number() const;
  void set_sbds_version_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_version_number(::std::string&& value);
  #endif
  void set_sbds_version_number(const char* value);
  void set_sbds_version_number(const char* value, size_t size);
  ::std::string* mutable_sbds_version_number();
  ::std::string* release_sbds_version_number();
  void set_allocated_sbds_version_number(::std::string* sbds_version_number);

  // string sbds_serial_number = 11;
  void clear_sbds_serial_number();
  static const int kSbdsSerialNumberFieldNumber = 11;
  const ::std::string& sbds_serial_number() const;
  void set_sbds_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_serial_number(::std::string&& value);
  #endif
  void set_sbds_serial_number(const char* value);
  void set_sbds_serial_number(const char* value, size_t size);
  ::std::string* mutable_sbds_serial_number();
  ::std::string* release_sbds_serial_number();
  void set_allocated_sbds_serial_number(::std::string* sbds_serial_number);

  // string sbds_manufacture_date = 12;
  void clear_sbds_manufacture_date();
  static const int kSbdsManufactureDateFieldNumber = 12;
  const ::std::string& sbds_manufacture_date() const;
  void set_sbds_manufacture_date(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_manufacture_date(::std::string&& value);
  #endif
  void set_sbds_manufacture_date(const char* value);
  void set_sbds_manufacture_date(const char* value, size_t size);
  ::std::string* mutable_sbds_manufacture_date();
  ::std::string* release_sbds_manufacture_date();
  void set_allocated_sbds_manufacture_date(::std::string* sbds_manufacture_date);

  // string sbds_device_chemistry = 13;
  void clear_sbds_device_chemistry();
  static const int kSbdsDeviceChemistryFieldNumber = 13;
  const ::std::string& sbds_device_chemistry() const;
  void set_sbds_device_chemistry(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_device_chemistry(::std::string&& value);
  #endif
  void set_sbds_device_chemistry(const char* value);
  void set_sbds_device_chemistry(const char* value, size_t size);
  ::std::string* mutable_sbds_device_chemistry();
  ::std::string* release_sbds_device_chemistry();
  void set_allocated_sbds_device_chemistry(::std::string* sbds_device_chemistry);

  // int32 design_capacity = 7;
  void clear_design_capacity();
  static const int kDesignCapacityFieldNumber = 7;
  ::google::protobuf::int32 design_capacity() const;
  void set_design_capacity(::google::protobuf::int32 value);

  // int32 design_voltage = 8;
  void clear_design_voltage();
  static const int kDesignVoltageFieldNumber = 8;
  ::google::protobuf::int32 design_voltage() const;
  void set_design_voltage(::google::protobuf::int32 value);

  // int32 max_error_in_battery_data = 10;
  void clear_max_error_in_battery_data();
  static const int kMaxErrorInBatteryDataFieldNumber = 10;
  ::google::protobuf::int32 max_error_in_battery_data() const;
  void set_max_error_in_battery_data(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortableBattery.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr manufacture_date_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  ::google::protobuf::internal::ArenaStringPtr chemistry_;
  ::google::protobuf::internal::ArenaStringPtr sbds_version_number_;
  ::google::protobuf::internal::ArenaStringPtr sbds_serial_number_;
  ::google::protobuf::internal::ArenaStringPtr sbds_manufacture_date_;
  ::google::protobuf::internal::ArenaStringPtr sbds_device_chemistry_;
  ::google::protobuf::int32 design_capacity_;
  ::google::protobuf::int32 design_voltage_;
  ::google::protobuf::int32 max_error_in_battery_data_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortableBattery_ItemImpl();
};
// -------------------------------------------------------------------

class DmiPortableBattery : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortableBattery) */ {
 public:
  DmiPortableBattery();
  virtual ~DmiPortableBattery();

  DmiPortableBattery(const DmiPortableBattery& from);

  inline DmiPortableBattery& operator=(const DmiPortableBattery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortableBattery(DmiPortableBattery&& from) noexcept
    : DmiPortableBattery() {
    *this = ::std::move(from);
  }

  inline DmiPortableBattery& operator=(DmiPortableBattery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortableBattery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortableBattery* internal_default_instance() {
    return reinterpret_cast<const DmiPortableBattery*>(
               &_DmiPortableBattery_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(DmiPortableBattery* other);
  friend void swap(DmiPortableBattery& a, DmiPortableBattery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortableBattery* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortableBattery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortableBattery& from);
  void MergeFrom(const DmiPortableBattery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortableBattery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiPortableBattery_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiPortableBattery.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiPortableBattery_Item& item(int index) const;
  ::aspia::proto::DmiPortableBattery_Item* mutable_item(int index);
  ::aspia::proto::DmiPortableBattery_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortableBattery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortableBatteryImpl();
};
// -------------------------------------------------------------------

class AtaDrives_Item_Feature : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.AtaDrives.Item.Feature) */ {
 public:
  AtaDrives_Item_Feature();
  virtual ~AtaDrives_Item_Feature();

  AtaDrives_Item_Feature(const AtaDrives_Item_Feature& from);

  inline AtaDrives_Item_Feature& operator=(const AtaDrives_Item_Feature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AtaDrives_Item_Feature(AtaDrives_Item_Feature&& from) noexcept
    : AtaDrives_Item_Feature() {
    *this = ::std::move(from);
  }

  inline AtaDrives_Item_Feature& operator=(AtaDrives_Item_Feature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AtaDrives_Item_Feature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AtaDrives_Item_Feature* internal_default_instance() {
    return reinterpret_cast<const AtaDrives_Item_Feature*>(
               &_AtaDrives_Item_Feature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(AtaDrives_Item_Feature* other);
  friend void swap(AtaDrives_Item_Feature& a, AtaDrives_Item_Feature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AtaDrives_Item_Feature* New() const PROTOBUF_FINAL { return New(NULL); }

  AtaDrives_Item_Feature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AtaDrives_Item_Feature& from);
  void MergeFrom(const AtaDrives_Item_Feature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AtaDrives_Item_Feature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool enabled = 2;
  void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.AtaDrives.Item.Feature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool enabled_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsAtaDrives_Item_FeatureImpl();
};
// -------------------------------------------------------------------

class AtaDrives_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.AtaDrives.Item) */ {
 public:
  AtaDrives_Item();
  virtual ~AtaDrives_Item();

  AtaDrives_Item(const AtaDrives_Item& from);

  inline AtaDrives_Item& operator=(const AtaDrives_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AtaDrives_Item(AtaDrives_Item&& from) noexcept
    : AtaDrives_Item() {
    *this = ::std::move(from);
  }

  inline AtaDrives_Item& operator=(AtaDrives_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AtaDrives_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AtaDrives_Item* internal_default_instance() {
    return reinterpret_cast<const AtaDrives_Item*>(
               &_AtaDrives_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(AtaDrives_Item* other);
  friend void swap(AtaDrives_Item& a, AtaDrives_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AtaDrives_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  AtaDrives_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AtaDrives_Item& from);
  void MergeFrom(const AtaDrives_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AtaDrives_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AtaDrives_Item_Feature Feature;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.AtaDrives.Item.Feature feature = 17;
  int feature_size() const;
  void clear_feature();
  static const int kFeatureFieldNumber = 17;
  const ::aspia::proto::AtaDrives_Item_Feature& feature(int index) const;
  ::aspia::proto::AtaDrives_Item_Feature* mutable_feature(int index);
  ::aspia::proto::AtaDrives_Item_Feature* add_feature();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item_Feature >*
      mutable_feature();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item_Feature >&
      feature() const;

  // string model_number = 1;
  void clear_model_number();
  static const int kModelNumberFieldNumber = 1;
  const ::std::string& model_number() const;
  void set_model_number(const ::std::string& value);
  #if LANG_CXX11
  void set_model_number(::std::string&& value);
  #endif
  void set_model_number(const char* value);
  void set_model_number(const char* value, size_t size);
  ::std::string* mutable_model_number();
  ::std::string* release_model_number();
  void set_allocated_model_number(::std::string* model_number);

  // string serial_number = 2;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string firmware_revision = 3;
  void clear_firmware_revision();
  static const int kFirmwareRevisionFieldNumber = 3;
  const ::std::string& firmware_revision() const;
  void set_firmware_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_firmware_revision(::std::string&& value);
  #endif
  void set_firmware_revision(const char* value);
  void set_firmware_revision(const char* value, size_t size);
  ::std::string* mutable_firmware_revision();
  ::std::string* release_firmware_revision();
  void set_allocated_firmware_revision(::std::string* firmware_revision);

  // string bus_type = 4;
  void clear_bus_type();
  static const int kBusTypeFieldNumber = 4;
  const ::std::string& bus_type() const;
  void set_bus_type(const ::std::string& value);
  #if LANG_CXX11
  void set_bus_type(::std::string&& value);
  #endif
  void set_bus_type(const char* value);
  void set_bus_type(const char* value, size_t size);
  ::std::string* mutable_bus_type();
  ::std::string* release_bus_type();
  void set_allocated_bus_type(::std::string* bus_type);

  // string transfer_mode = 5;
  void clear_transfer_mode();
  static const int kTransferModeFieldNumber = 5;
  const ::std::string& transfer_mode() const;
  void set_transfer_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_transfer_mode(::std::string&& value);
  #endif
  void set_transfer_mode(const char* value);
  void set_transfer_mode(const char* value, size_t size);
  ::std::string* mutable_transfer_mode();
  ::std::string* release_transfer_mode();
  void set_allocated_transfer_mode(::std::string* transfer_mode);

  // uint64 drive_size = 7;
  void clear_drive_size();
  static const int kDriveSizeFieldNumber = 7;
  ::google::protobuf::uint64 drive_size() const;
  void set_drive_size(::google::protobuf::uint64 value);

  // uint32 rotation_rate = 6;
  void clear_rotation_rate();
  static const int kRotationRateFieldNumber = 6;
  ::google::protobuf::uint32 rotation_rate() const;
  void set_rotation_rate(::google::protobuf::uint32 value);

  // uint32 buffer_size = 8;
  void clear_buffer_size();
  static const int kBufferSizeFieldNumber = 8;
  ::google::protobuf::uint32 buffer_size() const;
  void set_buffer_size(::google::protobuf::uint32 value);

  // uint32 multisectors = 9;
  void clear_multisectors();
  static const int kMultisectorsFieldNumber = 9;
  ::google::protobuf::uint32 multisectors() const;
  void set_multisectors(::google::protobuf::uint32 value);

  // uint32 ecc_size = 10;
  void clear_ecc_size();
  static const int kEccSizeFieldNumber = 10;
  ::google::protobuf::uint32 ecc_size() const;
  void set_ecc_size(::google::protobuf::uint32 value);

  // uint64 cylinders_number = 12;
  void clear_cylinders_number();
  static const int kCylindersNumberFieldNumber = 12;
  ::google::protobuf::uint64 cylinders_number() const;
  void set_cylinders_number(::google::protobuf::uint64 value);

  // bool is_removable = 11;
  void clear_is_removable();
  static const int kIsRemovableFieldNumber = 11;
  bool is_removable() const;
  void set_is_removable(bool value);

  // uint32 tracks_per_cylinder = 13;
  void clear_tracks_per_cylinder();
  static const int kTracksPerCylinderFieldNumber = 13;
  ::google::protobuf::uint32 tracks_per_cylinder() const;
  void set_tracks_per_cylinder(::google::protobuf::uint32 value);

  // uint32 sectors_per_track = 14;
  void clear_sectors_per_track();
  static const int kSectorsPerTrackFieldNumber = 14;
  ::google::protobuf::uint32 sectors_per_track() const;
  void set_sectors_per_track(::google::protobuf::uint32 value);

  // uint32 bytes_per_sector = 15;
  void clear_bytes_per_sector();
  static const int kBytesPerSectorFieldNumber = 15;
  ::google::protobuf::uint32 bytes_per_sector() const;
  void set_bytes_per_sector(::google::protobuf::uint32 value);

  // uint32 heads_number = 16;
  void clear_heads_number();
  static const int kHeadsNumberFieldNumber = 16;
  ::google::protobuf::uint32 heads_number() const;
  void set_heads_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.AtaDrives.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item_Feature > feature_;
  ::google::protobuf::internal::ArenaStringPtr model_number_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr firmware_revision_;
  ::google::protobuf::internal::ArenaStringPtr bus_type_;
  ::google::protobuf::internal::ArenaStringPtr transfer_mode_;
  ::google::protobuf::uint64 drive_size_;
  ::google::protobuf::uint32 rotation_rate_;
  ::google::protobuf::uint32 buffer_size_;
  ::google::protobuf::uint32 multisectors_;
  ::google::protobuf::uint32 ecc_size_;
  ::google::protobuf::uint64 cylinders_number_;
  bool is_removable_;
  ::google::protobuf::uint32 tracks_per_cylinder_;
  ::google::protobuf::uint32 sectors_per_track_;
  ::google::protobuf::uint32 bytes_per_sector_;
  ::google::protobuf::uint32 heads_number_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsAtaDrives_ItemImpl();
};
// -------------------------------------------------------------------

class AtaDrives : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.AtaDrives) */ {
 public:
  AtaDrives();
  virtual ~AtaDrives();

  AtaDrives(const AtaDrives& from);

  inline AtaDrives& operator=(const AtaDrives& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AtaDrives(AtaDrives&& from) noexcept
    : AtaDrives() {
    *this = ::std::move(from);
  }

  inline AtaDrives& operator=(AtaDrives&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AtaDrives& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AtaDrives* internal_default_instance() {
    return reinterpret_cast<const AtaDrives*>(
               &_AtaDrives_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(AtaDrives* other);
  friend void swap(AtaDrives& a, AtaDrives& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AtaDrives* New() const PROTOBUF_FINAL { return New(NULL); }

  AtaDrives* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AtaDrives& from);
  void MergeFrom(const AtaDrives& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AtaDrives* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AtaDrives_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.AtaDrives.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::AtaDrives_Item& item(int index) const;
  ::aspia::proto::AtaDrives_Item* mutable_item(int index);
  ::aspia::proto::AtaDrives_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.AtaDrives)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsAtaDrivesImpl();
};
// -------------------------------------------------------------------

class VideoAdapters_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.VideoAdapters.Item) */ {
 public:
  VideoAdapters_Item();
  virtual ~VideoAdapters_Item();

  VideoAdapters_Item(const VideoAdapters_Item& from);

  inline VideoAdapters_Item& operator=(const VideoAdapters_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VideoAdapters_Item(VideoAdapters_Item&& from) noexcept
    : VideoAdapters_Item() {
    *this = ::std::move(from);
  }

  inline VideoAdapters_Item& operator=(VideoAdapters_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const VideoAdapters_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoAdapters_Item* internal_default_instance() {
    return reinterpret_cast<const VideoAdapters_Item*>(
               &_VideoAdapters_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(VideoAdapters_Item* other);
  friend void swap(VideoAdapters_Item& a, VideoAdapters_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VideoAdapters_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  VideoAdapters_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VideoAdapters_Item& from);
  void MergeFrom(const VideoAdapters_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoAdapters_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string description = 1;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string adapter_string = 2;
  void clear_adapter_string();
  static const int kAdapterStringFieldNumber = 2;
  const ::std::string& adapter_string() const;
  void set_adapter_string(const ::std::string& value);
  #if LANG_CXX11
  void set_adapter_string(::std::string&& value);
  #endif
  void set_adapter_string(const char* value);
  void set_adapter_string(const char* value, size_t size);
  ::std::string* mutable_adapter_string();
  ::std::string* release_adapter_string();
  void set_allocated_adapter_string(::std::string* adapter_string);

  // string bios_string = 3;
  void clear_bios_string();
  static const int kBiosStringFieldNumber = 3;
  const ::std::string& bios_string() const;
  void set_bios_string(const ::std::string& value);
  #if LANG_CXX11
  void set_bios_string(::std::string&& value);
  #endif
  void set_bios_string(const char* value);
  void set_bios_string(const char* value, size_t size);
  ::std::string* mutable_bios_string();
  ::std::string* release_bios_string();
  void set_allocated_bios_string(::std::string* bios_string);

  // string chip_type = 4;
  void clear_chip_type();
  static const int kChipTypeFieldNumber = 4;
  const ::std::string& chip_type() const;
  void set_chip_type(const ::std::string& value);
  #if LANG_CXX11
  void set_chip_type(::std::string&& value);
  #endif
  void set_chip_type(const char* value);
  void set_chip_type(const char* value, size_t size);
  ::std::string* mutable_chip_type();
  ::std::string* release_chip_type();
  void set_allocated_chip_type(::std::string* chip_type);

  // string dac_type = 5;
  void clear_dac_type();
  static const int kDacTypeFieldNumber = 5;
  const ::std::string& dac_type() const;
  void set_dac_type(const ::std::string& value);
  #if LANG_CXX11
  void set_dac_type(::std::string&& value);
  #endif
  void set_dac_type(const char* value);
  void set_dac_type(const char* value, size_t size);
  ::std::string* mutable_dac_type();
  ::std::string* release_dac_type();
  void set_allocated_dac_type(::std::string* dac_type);

  // string driver_date = 6;
  void clear_driver_date();
  static const int kDriverDateFieldNumber = 6;
  const ::std::string& driver_date() const;
  void set_driver_date(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_date(::std::string&& value);
  #endif
  void set_driver_date(const char* value);
  void set_driver_date(const char* value, size_t size);
  ::std::string* mutable_driver_date();
  ::std::string* release_driver_date();
  void set_allocated_driver_date(::std::string* driver_date);

  // string driver_version = 7;
  void clear_driver_version();
  static const int kDriverVersionFieldNumber = 7;
  const ::std::string& driver_version() const;
  void set_driver_version(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_version(::std::string&& value);
  #endif
  void set_driver_version(const char* value);
  void set_driver_version(const char* value, size_t size);
  ::std::string* mutable_driver_version();
  ::std::string* release_driver_version();
  void set_allocated_driver_version(::std::string* driver_version);

  // string driver_provider = 8;
  void clear_driver_provider();
  static const int kDriverProviderFieldNumber = 8;
  const ::std::string& driver_provider() const;
  void set_driver_provider(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_provider(::std::string&& value);
  #endif
  void set_driver_provider(const char* value);
  void set_driver_provider(const char* value, size_t size);
  ::std::string* mutable_driver_provider();
  ::std::string* release_driver_provider();
  void set_allocated_driver_provider(::std::string* driver_provider);

  // uint64 memory_size = 9;
  void clear_memory_size();
  static const int kMemorySizeFieldNumber = 9;
  ::google::protobuf::uint64 memory_size() const;
  void set_memory_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.VideoAdapters.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr adapter_string_;
  ::google::protobuf::internal::ArenaStringPtr bios_string_;
  ::google::protobuf::internal::ArenaStringPtr chip_type_;
  ::google::protobuf::internal::ArenaStringPtr dac_type_;
  ::google::protobuf::internal::ArenaStringPtr driver_date_;
  ::google::protobuf::internal::ArenaStringPtr driver_version_;
  ::google::protobuf::internal::ArenaStringPtr driver_provider_;
  ::google::protobuf::uint64 memory_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsVideoAdapters_ItemImpl();
};
// -------------------------------------------------------------------

class VideoAdapters : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.VideoAdapters) */ {
 public:
  VideoAdapters();
  virtual ~VideoAdapters();

  VideoAdapters(const VideoAdapters& from);

  inline VideoAdapters& operator=(const VideoAdapters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VideoAdapters(VideoAdapters&& from) noexcept
    : VideoAdapters() {
    *this = ::std::move(from);
  }

  inline VideoAdapters& operator=(VideoAdapters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const VideoAdapters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoAdapters* internal_default_instance() {
    return reinterpret_cast<const VideoAdapters*>(
               &_VideoAdapters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(VideoAdapters* other);
  friend void swap(VideoAdapters& a, VideoAdapters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VideoAdapters* New() const PROTOBUF_FINAL { return New(NULL); }

  VideoAdapters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VideoAdapters& from);
  void MergeFrom(const VideoAdapters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoAdapters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef VideoAdapters_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.VideoAdapters.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::VideoAdapters_Item& item(int index) const;
  ::aspia::proto::VideoAdapters_Item* mutable_item(int index);
  ::aspia::proto::VideoAdapters_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::VideoAdapters_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::VideoAdapters_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.VideoAdapters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::VideoAdapters_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsVideoAdaptersImpl();
};
// -------------------------------------------------------------------

class Monitors_Item_Timing : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Monitors.Item.Timing) */ {
 public:
  Monitors_Item_Timing();
  virtual ~Monitors_Item_Timing();

  Monitors_Item_Timing(const Monitors_Item_Timing& from);

  inline Monitors_Item_Timing& operator=(const Monitors_Item_Timing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Monitors_Item_Timing(Monitors_Item_Timing&& from) noexcept
    : Monitors_Item_Timing() {
    *this = ::std::move(from);
  }

  inline Monitors_Item_Timing& operator=(Monitors_Item_Timing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Monitors_Item_Timing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Monitors_Item_Timing* internal_default_instance() {
    return reinterpret_cast<const Monitors_Item_Timing*>(
               &_Monitors_Item_Timing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(Monitors_Item_Timing* other);
  friend void swap(Monitors_Item_Timing& a, Monitors_Item_Timing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Monitors_Item_Timing* New() const PROTOBUF_FINAL { return New(NULL); }

  Monitors_Item_Timing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Monitors_Item_Timing& from);
  void MergeFrom(const Monitors_Item_Timing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Monitors_Item_Timing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // int32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // int32 frequency = 3;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 3;
  ::google::protobuf::int32 frequency() const;
  void set_frequency(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Monitors.Item.Timing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 frequency_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsMonitors_Item_TimingImpl();
};
// -------------------------------------------------------------------

class Monitors_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Monitors.Item) */ {
 public:
  Monitors_Item();
  virtual ~Monitors_Item();

  Monitors_Item(const Monitors_Item& from);

  inline Monitors_Item& operator=(const Monitors_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Monitors_Item(Monitors_Item&& from) noexcept
    : Monitors_Item() {
    *this = ::std::move(from);
  }

  inline Monitors_Item& operator=(Monitors_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Monitors_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Monitors_Item* internal_default_instance() {
    return reinterpret_cast<const Monitors_Item*>(
               &_Monitors_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(Monitors_Item* other);
  friend void swap(Monitors_Item& a, Monitors_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Monitors_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Monitors_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Monitors_Item& from);
  void MergeFrom(const Monitors_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Monitors_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Monitors_Item_Timing Timing;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Monitors.Item.Timing timings = 28;
  int timings_size() const;
  void clear_timings();
  static const int kTimingsFieldNumber = 28;
  const ::aspia::proto::Monitors_Item_Timing& timings(int index) const;
  ::aspia::proto::Monitors_Item_Timing* mutable_timings(int index);
  ::aspia::proto::Monitors_Item_Timing* add_timings();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item_Timing >*
      mutable_timings();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item_Timing >&
      timings() const;

  // string system_name = 1;
  void clear_system_name();
  static const int kSystemNameFieldNumber = 1;
  const ::std::string& system_name() const;
  void set_system_name(const ::std::string& value);
  #if LANG_CXX11
  void set_system_name(::std::string&& value);
  #endif
  void set_system_name(const char* value);
  void set_system_name(const char* value, size_t size);
  ::std::string* mutable_system_name();
  ::std::string* release_system_name();
  void set_allocated_system_name(::std::string* system_name);

  // string monitor_name = 2;
  void clear_monitor_name();
  static const int kMonitorNameFieldNumber = 2;
  const ::std::string& monitor_name() const;
  void set_monitor_name(const ::std::string& value);
  #if LANG_CXX11
  void set_monitor_name(::std::string&& value);
  #endif
  void set_monitor_name(const char* value);
  void set_monitor_name(const char* value, size_t size);
  ::std::string* mutable_monitor_name();
  ::std::string* release_monitor_name();
  void set_allocated_monitor_name(::std::string* monitor_name);

  // string manufacturer_name = 3;
  void clear_manufacturer_name();
  static const int kManufacturerNameFieldNumber = 3;
  const ::std::string& manufacturer_name() const;
  void set_manufacturer_name(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer_name(::std::string&& value);
  #endif
  void set_manufacturer_name(const char* value);
  void set_manufacturer_name(const char* value, size_t size);
  ::std::string* mutable_manufacturer_name();
  ::std::string* release_manufacturer_name();
  void set_allocated_manufacturer_name(::std::string* manufacturer_name);

  // string monitor_id = 4;
  void clear_monitor_id();
  static const int kMonitorIdFieldNumber = 4;
  const ::std::string& monitor_id() const;
  void set_monitor_id(const ::std::string& value);
  #if LANG_CXX11
  void set_monitor_id(::std::string&& value);
  #endif
  void set_monitor_id(const char* value);
  void set_monitor_id(const char* value, size_t size);
  ::std::string* mutable_monitor_id();
  ::std::string* release_monitor_id();
  void set_allocated_monitor_id(::std::string* monitor_id);

  // string serial_number = 5;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 5;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string input_signal_type = 21;
  void clear_input_signal_type();
  static const int kInputSignalTypeFieldNumber = 21;
  const ::std::string& input_signal_type() const;
  void set_input_signal_type(const ::std::string& value);
  #if LANG_CXX11
  void set_input_signal_type(::std::string&& value);
  #endif
  void set_input_signal_type(const char* value);
  void set_input_signal_type(const char* value, size_t size);
  ::std::string* mutable_input_signal_type();
  ::std::string* release_input_signal_type();
  void set_allocated_input_signal_type(::std::string* input_signal_type);

  // int32 edid_version = 6;
  void clear_edid_version();
  static const int kEdidVersionFieldNumber = 6;
  ::google::protobuf::int32 edid_version() const;
  void set_edid_version(::google::protobuf::int32 value);

  // int32 edid_revision = 7;
  void clear_edid_revision();
  static const int kEdidRevisionFieldNumber = 7;
  ::google::protobuf::int32 edid_revision() const;
  void set_edid_revision(::google::protobuf::int32 value);

  // int32 week_of_manufacture = 8;
  void clear_week_of_manufacture();
  static const int kWeekOfManufactureFieldNumber = 8;
  ::google::protobuf::int32 week_of_manufacture() const;
  void set_week_of_manufacture(::google::protobuf::int32 value);

  // int32 year_of_manufacture = 9;
  void clear_year_of_manufacture();
  static const int kYearOfManufactureFieldNumber = 9;
  ::google::protobuf::int32 year_of_manufacture() const;
  void set_year_of_manufacture(::google::protobuf::int32 value);

  // int32 max_horizontal_image_size = 10;
  void clear_max_horizontal_image_size();
  static const int kMaxHorizontalImageSizeFieldNumber = 10;
  ::google::protobuf::int32 max_horizontal_image_size() const;
  void set_max_horizontal_image_size(::google::protobuf::int32 value);

  // int32 max_vertical_image_size = 11;
  void clear_max_vertical_image_size();
  static const int kMaxVerticalImageSizeFieldNumber = 11;
  ::google::protobuf::int32 max_vertical_image_size() const;
  void set_max_vertical_image_size(::google::protobuf::int32 value);

  // int32 horizontal_resolution = 12;
  void clear_horizontal_resolution();
  static const int kHorizontalResolutionFieldNumber = 12;
  ::google::protobuf::int32 horizontal_resolution() const;
  void set_horizontal_resolution(::google::protobuf::int32 value);

  // int32 vertical_resoulution = 13;
  void clear_vertical_resoulution();
  static const int kVerticalResoulutionFieldNumber = 13;
  ::google::protobuf::int32 vertical_resoulution() const;
  void set_vertical_resoulution(::google::protobuf::int32 value);

  // double gamma = 14;
  void clear_gamma();
  static const int kGammaFieldNumber = 14;
  double gamma() const;
  void set_gamma(double value);

  // int32 min_horizontal_rate = 15;
  void clear_min_horizontal_rate();
  static const int kMinHorizontalRateFieldNumber = 15;
  ::google::protobuf::int32 min_horizontal_rate() const;
  void set_min_horizontal_rate(::google::protobuf::int32 value);

  // int32 max_horizontal_rate = 16;
  void clear_max_horizontal_rate();
  static const int kMaxHorizontalRateFieldNumber = 16;
  ::google::protobuf::int32 max_horizontal_rate() const;
  void set_max_horizontal_rate(::google::protobuf::int32 value);

  // int32 min_vertical_rate = 17;
  void clear_min_vertical_rate();
  static const int kMinVerticalRateFieldNumber = 17;
  ::google::protobuf::int32 min_vertical_rate() const;
  void set_min_vertical_rate(::google::protobuf::int32 value);

  // int32 max_vertical_rate = 18;
  void clear_max_vertical_rate();
  static const int kMaxVerticalRateFieldNumber = 18;
  ::google::protobuf::int32 max_vertical_rate() const;
  void set_max_vertical_rate(::google::protobuf::int32 value);

  // double pixel_clock = 19;
  void clear_pixel_clock();
  static const int kPixelClockFieldNumber = 19;
  double pixel_clock() const;
  void set_pixel_clock(double value);

  // int32 max_pixel_clock = 20;
  void clear_max_pixel_clock();
  static const int kMaxPixelClockFieldNumber = 20;
  ::google::protobuf::int32 max_pixel_clock() const;
  void set_max_pixel_clock(::google::protobuf::int32 value);

  // bool default_gtf_supported = 22;
  void clear_default_gtf_supported();
  static const int kDefaultGtfSupportedFieldNumber = 22;
  bool default_gtf_supported() const;
  void set_default_gtf_supported(bool value);

  // bool suspend_supported = 23;
  void clear_suspend_supported();
  static const int kSuspendSupportedFieldNumber = 23;
  bool suspend_supported() const;
  void set_suspend_supported(bool value);

  // bool standby_supported = 24;
  void clear_standby_supported();
  static const int kStandbySupportedFieldNumber = 24;
  bool standby_supported() const;
  void set_standby_supported(bool value);

  // bool active_off_supported = 25;
  void clear_active_off_supported();
  static const int kActiveOffSupportedFieldNumber = 25;
  bool active_off_supported() const;
  void set_active_off_supported(bool value);

  // bool preferred_timing_mode_supported = 26;
  void clear_preferred_timing_mode_supported();
  static const int kPreferredTimingModeSupportedFieldNumber = 26;
  bool preferred_timing_mode_supported() const;
  void set_preferred_timing_mode_supported(bool value);

  // bool srgb_supported = 27;
  void clear_srgb_supported();
  static const int kSrgbSupportedFieldNumber = 27;
  bool srgb_supported() const;
  void set_srgb_supported(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Monitors.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item_Timing > timings_;
  ::google::protobuf::internal::ArenaStringPtr system_name_;
  ::google::protobuf::internal::ArenaStringPtr monitor_name_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_name_;
  ::google::protobuf::internal::ArenaStringPtr monitor_id_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr input_signal_type_;
  ::google::protobuf::int32 edid_version_;
  ::google::protobuf::int32 edid_revision_;
  ::google::protobuf::int32 week_of_manufacture_;
  ::google::protobuf::int32 year_of_manufacture_;
  ::google::protobuf::int32 max_horizontal_image_size_;
  ::google::protobuf::int32 max_vertical_image_size_;
  ::google::protobuf::int32 horizontal_resolution_;
  ::google::protobuf::int32 vertical_resoulution_;
  double gamma_;
  ::google::protobuf::int32 min_horizontal_rate_;
  ::google::protobuf::int32 max_horizontal_rate_;
  ::google::protobuf::int32 min_vertical_rate_;
  ::google::protobuf::int32 max_vertical_rate_;
  double pixel_clock_;
  ::google::protobuf::int32 max_pixel_clock_;
  bool default_gtf_supported_;
  bool suspend_supported_;
  bool standby_supported_;
  bool active_off_supported_;
  bool preferred_timing_mode_supported_;
  bool srgb_supported_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsMonitors_ItemImpl();
};
// -------------------------------------------------------------------

class Monitors : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Monitors) */ {
 public:
  Monitors();
  virtual ~Monitors();

  Monitors(const Monitors& from);

  inline Monitors& operator=(const Monitors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Monitors(Monitors&& from) noexcept
    : Monitors() {
    *this = ::std::move(from);
  }

  inline Monitors& operator=(Monitors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Monitors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Monitors* internal_default_instance() {
    return reinterpret_cast<const Monitors*>(
               &_Monitors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(Monitors* other);
  friend void swap(Monitors& a, Monitors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Monitors* New() const PROTOBUF_FINAL { return New(NULL); }

  Monitors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Monitors& from);
  void MergeFrom(const Monitors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Monitors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Monitors_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Monitors.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Monitors_Item& item(int index) const;
  ::aspia::proto::Monitors_Item* mutable_item(int index);
  ::aspia::proto::Monitors_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Monitors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsMonitorsImpl();
};
// -------------------------------------------------------------------

class PowerOptions_Battery : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.PowerOptions.Battery) */ {
 public:
  PowerOptions_Battery();
  virtual ~PowerOptions_Battery();

  PowerOptions_Battery(const PowerOptions_Battery& from);

  inline PowerOptions_Battery& operator=(const PowerOptions_Battery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PowerOptions_Battery(PowerOptions_Battery&& from) noexcept
    : PowerOptions_Battery() {
    *this = ::std::move(from);
  }

  inline PowerOptions_Battery& operator=(PowerOptions_Battery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PowerOptions_Battery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PowerOptions_Battery* internal_default_instance() {
    return reinterpret_cast<const PowerOptions_Battery*>(
               &_PowerOptions_Battery_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(PowerOptions_Battery* other);
  friend void swap(PowerOptions_Battery& a, PowerOptions_Battery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PowerOptions_Battery* New() const PROTOBUF_FINAL { return New(NULL); }

  PowerOptions_Battery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PowerOptions_Battery& from);
  void MergeFrom(const PowerOptions_Battery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PowerOptions_Battery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PowerOptions_Battery_State State;
  static const State STATE_UNKNOWN =
    PowerOptions_Battery_State_STATE_UNKNOWN;
  static const State STATE_CHARGING =
    PowerOptions_Battery_State_STATE_CHARGING;
  static const State STATE_CRITICAL =
    PowerOptions_Battery_State_STATE_CRITICAL;
  static const State STATE_DISCHARGING =
    PowerOptions_Battery_State_STATE_DISCHARGING;
  static const State STATE_POWER_ONLINE =
    PowerOptions_Battery_State_STATE_POWER_ONLINE;
  static inline bool State_IsValid(int value) {
    return PowerOptions_Battery_State_IsValid(value);
  }
  static const State State_MIN =
    PowerOptions_Battery_State_State_MIN;
  static const State State_MAX =
    PowerOptions_Battery_State_State_MAX;
  static const int State_ARRAYSIZE =
    PowerOptions_Battery_State_State_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string device_name = 1;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 1;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  #if LANG_CXX11
  void set_device_name(::std::string&& value);
  #endif
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // string manufacturer = 2;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 2;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string manufacture_date = 3;
  void clear_manufacture_date();
  static const int kManufactureDateFieldNumber = 3;
  const ::std::string& manufacture_date() const;
  void set_manufacture_date(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacture_date(::std::string&& value);
  #endif
  void set_manufacture_date(const char* value);
  void set_manufacture_date(const char* value, size_t size);
  ::std::string* mutable_manufacture_date();
  ::std::string* release_manufacture_date();
  void set_allocated_manufacture_date(::std::string* manufacture_date);

  // string unique_id = 4;
  void clear_unique_id();
  static const int kUniqueIdFieldNumber = 4;
  const ::std::string& unique_id() const;
  void set_unique_id(const ::std::string& value);
  #if LANG_CXX11
  void set_unique_id(::std::string&& value);
  #endif
  void set_unique_id(const char* value);
  void set_unique_id(const char* value, size_t size);
  ::std::string* mutable_unique_id();
  ::std::string* release_unique_id();
  void set_allocated_unique_id(::std::string* unique_id);

  // string serial_number = 5;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 5;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string temperature = 6;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 6;
  const ::std::string& temperature() const;
  void set_temperature(const ::std::string& value);
  #if LANG_CXX11
  void set_temperature(::std::string&& value);
  #endif
  void set_temperature(const char* value);
  void set_temperature(const char* value, size_t size);
  ::std::string* mutable_temperature();
  ::std::string* release_temperature();
  void set_allocated_temperature(::std::string* temperature);

  // string type = 8;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // int32 design_capacity = 7;
  void clear_design_capacity();
  static const int kDesignCapacityFieldNumber = 7;
  ::google::protobuf::int32 design_capacity() const;
  void set_design_capacity(::google::protobuf::int32 value);

  // int32 full_charged_capacity = 9;
  void clear_full_charged_capacity();
  static const int kFullChargedCapacityFieldNumber = 9;
  ::google::protobuf::int32 full_charged_capacity() const;
  void set_full_charged_capacity(::google::protobuf::int32 value);

  // int32 depreciation = 10;
  void clear_depreciation();
  static const int kDepreciationFieldNumber = 10;
  ::google::protobuf::int32 depreciation() const;
  void set_depreciation(::google::protobuf::int32 value);

  // int32 current_capacity = 11;
  void clear_current_capacity();
  static const int kCurrentCapacityFieldNumber = 11;
  ::google::protobuf::int32 current_capacity() const;
  void set_current_capacity(::google::protobuf::int32 value);

  // int32 voltage = 12;
  void clear_voltage();
  static const int kVoltageFieldNumber = 12;
  ::google::protobuf::int32 voltage() const;
  void set_voltage(::google::protobuf::int32 value);

  // uint32 state = 13;
  void clear_state();
  static const int kStateFieldNumber = 13;
  ::google::protobuf::uint32 state() const;
  void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.PowerOptions.Battery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr manufacture_date_;
  ::google::protobuf::internal::ArenaStringPtr unique_id_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr temperature_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::int32 design_capacity_;
  ::google::protobuf::int32 full_charged_capacity_;
  ::google::protobuf::int32 depreciation_;
  ::google::protobuf::int32 current_capacity_;
  ::google::protobuf::int32 voltage_;
  ::google::protobuf::uint32 state_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsPowerOptions_BatteryImpl();
};
// -------------------------------------------------------------------

class PowerOptions : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.PowerOptions) */ {
 public:
  PowerOptions();
  virtual ~PowerOptions();

  PowerOptions(const PowerOptions& from);

  inline PowerOptions& operator=(const PowerOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PowerOptions(PowerOptions&& from) noexcept
    : PowerOptions() {
    *this = ::std::move(from);
  }

  inline PowerOptions& operator=(PowerOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PowerOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PowerOptions* internal_default_instance() {
    return reinterpret_cast<const PowerOptions*>(
               &_PowerOptions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(PowerOptions* other);
  friend void swap(PowerOptions& a, PowerOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PowerOptions* New() const PROTOBUF_FINAL { return New(NULL); }

  PowerOptions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PowerOptions& from);
  void MergeFrom(const PowerOptions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PowerOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PowerOptions_Battery Battery;

  typedef PowerOptions_PowerSource PowerSource;
  static const PowerSource POWER_SOURCE_UNKNOWN =
    PowerOptions_PowerSource_POWER_SOURCE_UNKNOWN;
  static const PowerSource POWER_SOURCE_DC_BATTERY =
    PowerOptions_PowerSource_POWER_SOURCE_DC_BATTERY;
  static const PowerSource POWER_SOURCE_AC_LINE =
    PowerOptions_PowerSource_POWER_SOURCE_AC_LINE;
  static inline bool PowerSource_IsValid(int value) {
    return PowerOptions_PowerSource_IsValid(value);
  }
  static const PowerSource PowerSource_MIN =
    PowerOptions_PowerSource_PowerSource_MIN;
  static const PowerSource PowerSource_MAX =
    PowerOptions_PowerSource_PowerSource_MAX;
  static const int PowerSource_ARRAYSIZE =
    PowerOptions_PowerSource_PowerSource_ARRAYSIZE;

  typedef PowerOptions_BatteryStatus BatteryStatus;
  static const BatteryStatus BATTERY_STATUS_UNKNOWN =
    PowerOptions_BatteryStatus_BATTERY_STATUS_UNKNOWN;
  static const BatteryStatus BATTERY_STATUS_HIGH =
    PowerOptions_BatteryStatus_BATTERY_STATUS_HIGH;
  static const BatteryStatus BATTERY_STATUS_LOW =
    PowerOptions_BatteryStatus_BATTERY_STATUS_LOW;
  static const BatteryStatus BATTERY_STATUS_CRITICAL =
    PowerOptions_BatteryStatus_BATTERY_STATUS_CRITICAL;
  static const BatteryStatus BATTERY_STATUS_CHARGING =
    PowerOptions_BatteryStatus_BATTERY_STATUS_CHARGING;
  static const BatteryStatus BATTERY_STATUS_NO_BATTERY =
    PowerOptions_BatteryStatus_BATTERY_STATUS_NO_BATTERY;
  static inline bool BatteryStatus_IsValid(int value) {
    return PowerOptions_BatteryStatus_IsValid(value);
  }
  static const BatteryStatus BatteryStatus_MIN =
    PowerOptions_BatteryStatus_BatteryStatus_MIN;
  static const BatteryStatus BatteryStatus_MAX =
    PowerOptions_BatteryStatus_BatteryStatus_MAX;
  static const int BatteryStatus_ARRAYSIZE =
    PowerOptions_BatteryStatus_BatteryStatus_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.PowerOptions.Battery battery = 6;
  int battery_size() const;
  void clear_battery();
  static const int kBatteryFieldNumber = 6;
  const ::aspia::proto::PowerOptions_Battery& battery(int index) const;
  ::aspia::proto::PowerOptions_Battery* mutable_battery(int index);
  ::aspia::proto::PowerOptions_Battery* add_battery();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::PowerOptions_Battery >*
      mutable_battery();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::PowerOptions_Battery >&
      battery() const;

  // .aspia.proto.PowerOptions.PowerSource power_source = 1;
  void clear_power_source();
  static const int kPowerSourceFieldNumber = 1;
  ::aspia::proto::PowerOptions_PowerSource power_source() const;
  void set_power_source(::aspia::proto::PowerOptions_PowerSource value);

  // .aspia.proto.PowerOptions.BatteryStatus battery_status = 2;
  void clear_battery_status();
  static const int kBatteryStatusFieldNumber = 2;
  ::aspia::proto::PowerOptions_BatteryStatus battery_status() const;
  void set_battery_status(::aspia::proto::PowerOptions_BatteryStatus value);

  // int64 full_battery_life_time = 3;
  void clear_full_battery_life_time();
  static const int kFullBatteryLifeTimeFieldNumber = 3;
  ::google::protobuf::int64 full_battery_life_time() const;
  void set_full_battery_life_time(::google::protobuf::int64 value);

  // int64 remaining_battery_life_time = 4;
  void clear_remaining_battery_life_time();
  static const int kRemainingBatteryLifeTimeFieldNumber = 4;
  ::google::protobuf::int64 remaining_battery_life_time() const;
  void set_remaining_battery_life_time(::google::protobuf::int64 value);

  // int32 battery_life_percent = 5;
  void clear_battery_life_percent();
  static const int kBatteryLifePercentFieldNumber = 5;
  ::google::protobuf::int32 battery_life_percent() const;
  void set_battery_life_percent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.PowerOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::PowerOptions_Battery > battery_;
  int power_source_;
  int battery_status_;
  ::google::protobuf::int64 full_battery_life_time_;
  ::google::protobuf::int64 remaining_battery_life_time_;
  ::google::protobuf::int32 battery_life_percent_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsPowerOptionsImpl();
};
// -------------------------------------------------------------------

class Printers_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Printers.Item) */ {
 public:
  Printers_Item();
  virtual ~Printers_Item();

  Printers_Item(const Printers_Item& from);

  inline Printers_Item& operator=(const Printers_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Printers_Item(Printers_Item&& from) noexcept
    : Printers_Item() {
    *this = ::std::move(from);
  }

  inline Printers_Item& operator=(Printers_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Printers_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Printers_Item* internal_default_instance() {
    return reinterpret_cast<const Printers_Item*>(
               &_Printers_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(Printers_Item* other);
  friend void swap(Printers_Item& a, Printers_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Printers_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Printers_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Printers_Item& from);
  void MergeFrom(const Printers_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Printers_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Printers_Item_Orientation Orientation;
  static const Orientation ORIENTATION_UNKNOWN =
    Printers_Item_Orientation_ORIENTATION_UNKNOWN;
  static const Orientation ORIENTATION_PORTRAIT =
    Printers_Item_Orientation_ORIENTATION_PORTRAIT;
  static const Orientation ORIENTATION_LANDSCAPE =
    Printers_Item_Orientation_ORIENTATION_LANDSCAPE;
  static inline bool Orientation_IsValid(int value) {
    return Printers_Item_Orientation_IsValid(value);
  }
  static const Orientation Orientation_MIN =
    Printers_Item_Orientation_Orientation_MIN;
  static const Orientation Orientation_MAX =
    Printers_Item_Orientation_Orientation_MAX;
  static const int Orientation_ARRAYSIZE =
    Printers_Item_Orientation_Orientation_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string share_name = 4;
  void clear_share_name();
  static const int kShareNameFieldNumber = 4;
  const ::std::string& share_name() const;
  void set_share_name(const ::std::string& value);
  #if LANG_CXX11
  void set_share_name(::std::string&& value);
  #endif
  void set_share_name(const char* value);
  void set_share_name(const char* value, size_t size);
  ::std::string* mutable_share_name();
  ::std::string* release_share_name();
  void set_allocated_share_name(::std::string* share_name);

  // string port_name = 5;
  void clear_port_name();
  static const int kPortNameFieldNumber = 5;
  const ::std::string& port_name() const;
  void set_port_name(const ::std::string& value);
  #if LANG_CXX11
  void set_port_name(::std::string&& value);
  #endif
  void set_port_name(const char* value);
  void set_port_name(const char* value, size_t size);
  ::std::string* mutable_port_name();
  ::std::string* release_port_name();
  void set_allocated_port_name(::std::string* port_name);

  // string driver_name = 6;
  void clear_driver_name();
  static const int kDriverNameFieldNumber = 6;
  const ::std::string& driver_name() const;
  void set_driver_name(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_name(::std::string&& value);
  #endif
  void set_driver_name(const char* value);
  void set_driver_name(const char* value, size_t size);
  ::std::string* mutable_driver_name();
  ::std::string* release_driver_name();
  void set_allocated_driver_name(::std::string* driver_name);

  // string device_name = 7;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 7;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  #if LANG_CXX11
  void set_device_name(::std::string&& value);
  #endif
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // string print_processor = 8;
  void clear_print_processor();
  static const int kPrintProcessorFieldNumber = 8;
  const ::std::string& print_processor() const;
  void set_print_processor(const ::std::string& value);
  #if LANG_CXX11
  void set_print_processor(::std::string&& value);
  #endif
  void set_print_processor(const char* value);
  void set_print_processor(const char* value, size_t size);
  ::std::string* mutable_print_processor();
  ::std::string* release_print_processor();
  void set_allocated_print_processor(::std::string* print_processor);

  // string data_type = 9;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 9;
  const ::std::string& data_type() const;
  void set_data_type(const ::std::string& value);
  #if LANG_CXX11
  void set_data_type(::std::string&& value);
  #endif
  void set_data_type(const char* value);
  void set_data_type(const char* value, size_t size);
  ::std::string* mutable_data_type();
  ::std::string* release_data_type();
  void set_allocated_data_type(::std::string* data_type);

  // string server_name = 10;
  void clear_server_name();
  static const int kServerNameFieldNumber = 10;
  const ::std::string& server_name() const;
  void set_server_name(const ::std::string& value);
  #if LANG_CXX11
  void set_server_name(::std::string&& value);
  #endif
  void set_server_name(const char* value);
  void set_server_name(const char* value, size_t size);
  ::std::string* mutable_server_name();
  ::std::string* release_server_name();
  void set_allocated_server_name(::std::string* server_name);

  // string location = 11;
  void clear_location();
  static const int kLocationFieldNumber = 11;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // string comment = 12;
  void clear_comment();
  static const int kCommentFieldNumber = 12;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // bool is_default = 2;
  void clear_is_default();
  static const int kIsDefaultFieldNumber = 2;
  bool is_default() const;
  void set_is_default(bool value);

  // bool is_shared = 3;
  void clear_is_shared();
  static const int kIsSharedFieldNumber = 3;
  bool is_shared() const;
  void set_is_shared(bool value);

  // int32 jobs_count = 13;
  void clear_jobs_count();
  static const int kJobsCountFieldNumber = 13;
  ::google::protobuf::int32 jobs_count() const;
  void set_jobs_count(::google::protobuf::int32 value);

  // int32 paper_width = 14;
  void clear_paper_width();
  static const int kPaperWidthFieldNumber = 14;
  ::google::protobuf::int32 paper_width() const;
  void set_paper_width(::google::protobuf::int32 value);

  // int32 paper_length = 15;
  void clear_paper_length();
  static const int kPaperLengthFieldNumber = 15;
  ::google::protobuf::int32 paper_length() const;
  void set_paper_length(::google::protobuf::int32 value);

  // int32 print_quality = 16;
  void clear_print_quality();
  static const int kPrintQualityFieldNumber = 16;
  ::google::protobuf::int32 print_quality() const;
  void set_print_quality(::google::protobuf::int32 value);

  // .aspia.proto.Printers.Item.Orientation orientation = 17;
  void clear_orientation();
  static const int kOrientationFieldNumber = 17;
  ::aspia::proto::Printers_Item_Orientation orientation() const;
  void set_orientation(::aspia::proto::Printers_Item_Orientation value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Printers.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr share_name_;
  ::google::protobuf::internal::ArenaStringPtr port_name_;
  ::google::protobuf::internal::ArenaStringPtr driver_name_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  ::google::protobuf::internal::ArenaStringPtr print_processor_;
  ::google::protobuf::internal::ArenaStringPtr data_type_;
  ::google::protobuf::internal::ArenaStringPtr server_name_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  bool is_default_;
  bool is_shared_;
  ::google::protobuf::int32 jobs_count_;
  ::google::protobuf::int32 paper_width_;
  ::google::protobuf::int32 paper_length_;
  ::google::protobuf::int32 print_quality_;
  int orientation_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsPrinters_ItemImpl();
};
// -------------------------------------------------------------------

class Printers : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Printers) */ {
 public:
  Printers();
  virtual ~Printers();

  Printers(const Printers& from);

  inline Printers& operator=(const Printers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Printers(Printers&& from) noexcept
    : Printers() {
    *this = ::std::move(from);
  }

  inline Printers& operator=(Printers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Printers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Printers* internal_default_instance() {
    return reinterpret_cast<const Printers*>(
               &_Printers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(Printers* other);
  friend void swap(Printers& a, Printers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Printers* New() const PROTOBUF_FINAL { return New(NULL); }

  Printers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Printers& from);
  void MergeFrom(const Printers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Printers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Printers_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Printers.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Printers_Item& item(int index) const;
  ::aspia::proto::Printers_Item* mutable_item(int index);
  ::aspia::proto::Printers_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Printers_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Printers_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Printers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Printers_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsPrintersImpl();
};
// -------------------------------------------------------------------

class WindowsDevices_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.WindowsDevices.Item) */ {
 public:
  WindowsDevices_Item();
  virtual ~WindowsDevices_Item();

  WindowsDevices_Item(const WindowsDevices_Item& from);

  inline WindowsDevices_Item& operator=(const WindowsDevices_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WindowsDevices_Item(WindowsDevices_Item&& from) noexcept
    : WindowsDevices_Item() {
    *this = ::std::move(from);
  }

  inline WindowsDevices_Item& operator=(WindowsDevices_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const WindowsDevices_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WindowsDevices_Item* internal_default_instance() {
    return reinterpret_cast<const WindowsDevices_Item*>(
               &_WindowsDevices_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(WindowsDevices_Item* other);
  friend void swap(WindowsDevices_Item& a, WindowsDevices_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WindowsDevices_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  WindowsDevices_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const WindowsDevices_Item& from);
  void MergeFrom(const WindowsDevices_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WindowsDevices_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string friendly_name = 1;
  void clear_friendly_name();
  static const int kFriendlyNameFieldNumber = 1;
  const ::std::string& friendly_name() const;
  void set_friendly_name(const ::std::string& value);
  #if LANG_CXX11
  void set_friendly_name(::std::string&& value);
  #endif
  void set_friendly_name(const char* value);
  void set_friendly_name(const char* value, size_t size);
  ::std::string* mutable_friendly_name();
  ::std::string* release_friendly_name();
  void set_allocated_friendly_name(::std::string* friendly_name);

  // string description = 2;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string driver_version = 3;
  void clear_driver_version();
  static const int kDriverVersionFieldNumber = 3;
  const ::std::string& driver_version() const;
  void set_driver_version(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_version(::std::string&& value);
  #endif
  void set_driver_version(const char* value);
  void set_driver_version(const char* value, size_t size);
  ::std::string* mutable_driver_version();
  ::std::string* release_driver_version();
  void set_allocated_driver_version(::std::string* driver_version);

  // string driver_date = 4;
  void clear_driver_date();
  static const int kDriverDateFieldNumber = 4;
  const ::std::string& driver_date() const;
  void set_driver_date(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_date(::std::string&& value);
  #endif
  void set_driver_date(const char* value);
  void set_driver_date(const char* value, size_t size);
  ::std::string* mutable_driver_date();
  ::std::string* release_driver_date();
  void set_allocated_driver_date(::std::string* driver_date);

  // string driver_vendor = 5;
  void clear_driver_vendor();
  static const int kDriverVendorFieldNumber = 5;
  const ::std::string& driver_vendor() const;
  void set_driver_vendor(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_vendor(::std::string&& value);
  #endif
  void set_driver_vendor(const char* value);
  void set_driver_vendor(const char* value, size_t size);
  ::std::string* mutable_driver_vendor();
  ::std::string* release_driver_vendor();
  void set_allocated_driver_vendor(::std::string* driver_vendor);

  // string device_id = 6;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 6;
  const ::std::string& device_id() const;
  void set_device_id(const ::std::string& value);
  #if LANG_CXX11
  void set_device_id(::std::string&& value);
  #endif
  void set_device_id(const char* value);
  void set_device_id(const char* value, size_t size);
  ::std::string* mutable_device_id();
  ::std::string* release_device_id();
  void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:aspia.proto.WindowsDevices.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr friendly_name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr driver_version_;
  ::google::protobuf::internal::ArenaStringPtr driver_date_;
  ::google::protobuf::internal::ArenaStringPtr driver_vendor_;
  ::google::protobuf::internal::ArenaStringPtr device_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsWindowsDevices_ItemImpl();
};
// -------------------------------------------------------------------

class WindowsDevices : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.WindowsDevices) */ {
 public:
  WindowsDevices();
  virtual ~WindowsDevices();

  WindowsDevices(const WindowsDevices& from);

  inline WindowsDevices& operator=(const WindowsDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WindowsDevices(WindowsDevices&& from) noexcept
    : WindowsDevices() {
    *this = ::std::move(from);
  }

  inline WindowsDevices& operator=(WindowsDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const WindowsDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WindowsDevices* internal_default_instance() {
    return reinterpret_cast<const WindowsDevices*>(
               &_WindowsDevices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(WindowsDevices* other);
  friend void swap(WindowsDevices& a, WindowsDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WindowsDevices* New() const PROTOBUF_FINAL { return New(NULL); }

  WindowsDevices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const WindowsDevices& from);
  void MergeFrom(const WindowsDevices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WindowsDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef WindowsDevices_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.WindowsDevices.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::WindowsDevices_Item& item(int index) const;
  ::aspia::proto::WindowsDevices_Item* mutable_item(int index);
  ::aspia::proto::WindowsDevices_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::WindowsDevices_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::WindowsDevices_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.WindowsDevices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::WindowsDevices_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsWindowsDevicesImpl();
};
// -------------------------------------------------------------------

class Programs_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Programs.Item) */ {
 public:
  Programs_Item();
  virtual ~Programs_Item();

  Programs_Item(const Programs_Item& from);

  inline Programs_Item& operator=(const Programs_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Programs_Item(Programs_Item&& from) noexcept
    : Programs_Item() {
    *this = ::std::move(from);
  }

  inline Programs_Item& operator=(Programs_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Programs_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Programs_Item* internal_default_instance() {
    return reinterpret_cast<const Programs_Item*>(
               &_Programs_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(Programs_Item* other);
  friend void swap(Programs_Item& a, Programs_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Programs_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Programs_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Programs_Item& from);
  void MergeFrom(const Programs_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Programs_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string publisher = 3;
  void clear_publisher();
  static const int kPublisherFieldNumber = 3;
  const ::std::string& publisher() const;
  void set_publisher(const ::std::string& value);
  #if LANG_CXX11
  void set_publisher(::std::string&& value);
  #endif
  void set_publisher(const char* value);
  void set_publisher(const char* value, size_t size);
  ::std::string* mutable_publisher();
  ::std::string* release_publisher();
  void set_allocated_publisher(::std::string* publisher);

  // string install_date = 4;
  void clear_install_date();
  static const int kInstallDateFieldNumber = 4;
  const ::std::string& install_date() const;
  void set_install_date(const ::std::string& value);
  #if LANG_CXX11
  void set_install_date(::std::string&& value);
  #endif
  void set_install_date(const char* value);
  void set_install_date(const char* value, size_t size);
  ::std::string* mutable_install_date();
  ::std::string* release_install_date();
  void set_allocated_install_date(::std::string* install_date);

  // string install_location = 5;
  void clear_install_location();
  static const int kInstallLocationFieldNumber = 5;
  const ::std::string& install_location() const;
  void set_install_location(const ::std::string& value);
  #if LANG_CXX11
  void set_install_location(::std::string&& value);
  #endif
  void set_install_location(const char* value);
  void set_install_location(const char* value, size_t size);
  ::std::string* mutable_install_location();
  ::std::string* release_install_location();
  void set_allocated_install_location(::std::string* install_location);

  // @@protoc_insertion_point(class_scope:aspia.proto.Programs.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr publisher_;
  ::google::protobuf::internal::ArenaStringPtr install_date_;
  ::google::protobuf::internal::ArenaStringPtr install_location_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsPrograms_ItemImpl();
};
// -------------------------------------------------------------------

class Programs : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Programs) */ {
 public:
  Programs();
  virtual ~Programs();

  Programs(const Programs& from);

  inline Programs& operator=(const Programs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Programs(Programs&& from) noexcept
    : Programs() {
    *this = ::std::move(from);
  }

  inline Programs& operator=(Programs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Programs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Programs* internal_default_instance() {
    return reinterpret_cast<const Programs*>(
               &_Programs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(Programs* other);
  friend void swap(Programs& a, Programs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Programs* New() const PROTOBUF_FINAL { return New(NULL); }

  Programs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Programs& from);
  void MergeFrom(const Programs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Programs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Programs_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Programs.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Programs_Item& item(int index) const;
  ::aspia::proto::Programs_Item* mutable_item(int index);
  ::aspia::proto::Programs_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Programs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsProgramsImpl();
};
// -------------------------------------------------------------------

class Services_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Services.Item) */ {
 public:
  Services_Item();
  virtual ~Services_Item();

  Services_Item(const Services_Item& from);

  inline Services_Item& operator=(const Services_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Services_Item(Services_Item&& from) noexcept
    : Services_Item() {
    *this = ::std::move(from);
  }

  inline Services_Item& operator=(Services_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Services_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Services_Item* internal_default_instance() {
    return reinterpret_cast<const Services_Item*>(
               &_Services_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(Services_Item* other);
  friend void swap(Services_Item& a, Services_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Services_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Services_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Services_Item& from);
  void MergeFrom(const Services_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Services_Item_Status Status;
  static const Status STATUS_UNKNOWN =
    Services_Item_Status_STATUS_UNKNOWN;
  static const Status STATUS_CONTINUE_PENDING =
    Services_Item_Status_STATUS_CONTINUE_PENDING;
  static const Status STATUS_PAUSE_PENDING =
    Services_Item_Status_STATUS_PAUSE_PENDING;
  static const Status STATUS_PAUSED =
    Services_Item_Status_STATUS_PAUSED;
  static const Status STATUS_RUNNING =
    Services_Item_Status_STATUS_RUNNING;
  static const Status STATUS_START_PENDING =
    Services_Item_Status_STATUS_START_PENDING;
  static const Status STATUS_STOP_PENDING =
    Services_Item_Status_STATUS_STOP_PENDING;
  static const Status STATUS_STOPPED =
    Services_Item_Status_STATUS_STOPPED;
  static inline bool Status_IsValid(int value) {
    return Services_Item_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Services_Item_Status_Status_MIN;
  static const Status Status_MAX =
    Services_Item_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Services_Item_Status_Status_ARRAYSIZE;

  typedef Services_Item_StartupType StartupType;
  static const StartupType STARTUP_TYPE_UNKNOWN =
    Services_Item_StartupType_STARTUP_TYPE_UNKNOWN;
  static const StartupType STARTUP_TYPE_AUTO_START =
    Services_Item_StartupType_STARTUP_TYPE_AUTO_START;
  static const StartupType STARTUP_TYPE_DEMAND_START =
    Services_Item_StartupType_STARTUP_TYPE_DEMAND_START;
  static const StartupType STARTUP_TYPE_DISABLED =
    Services_Item_StartupType_STARTUP_TYPE_DISABLED;
  static const StartupType STARTUP_TYPE_BOOT_START =
    Services_Item_StartupType_STARTUP_TYPE_BOOT_START;
  static const StartupType STARTUP_TYPE_SYSTEM_START =
    Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START;
  static inline bool StartupType_IsValid(int value) {
    return Services_Item_StartupType_IsValid(value);
  }
  static const StartupType StartupType_MIN =
    Services_Item_StartupType_StartupType_MIN;
  static const StartupType StartupType_MAX =
    Services_Item_StartupType_StartupType_MAX;
  static const int StartupType_ARRAYSIZE =
    Services_Item_StartupType_StartupType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string display_name = 2;
  void clear_display_name();
  static const int kDisplayNameFieldNumber = 2;
  const ::std::string& display_name() const;
  void set_display_name(const ::std::string& value);
  #if LANG_CXX11
  void set_display_name(::std::string&& value);
  #endif
  void set_display_name(const char* value);
  void set_display_name(const char* value, size_t size);
  ::std::string* mutable_display_name();
  ::std::string* release_display_name();
  void set_allocated_display_name(::std::string* display_name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string binary_path = 6;
  void clear_binary_path();
  static const int kBinaryPathFieldNumber = 6;
  const ::std::string& binary_path() const;
  void set_binary_path(const ::std::string& value);
  #if LANG_CXX11
  void set_binary_path(::std::string&& value);
  #endif
  void set_binary_path(const char* value);
  void set_binary_path(const char* value, size_t size);
  ::std::string* mutable_binary_path();
  ::std::string* release_binary_path();
  void set_allocated_binary_path(::std::string* binary_path);

  // string start_name = 7;
  void clear_start_name();
  static const int kStartNameFieldNumber = 7;
  const ::std::string& start_name() const;
  void set_start_name(const ::std::string& value);
  #if LANG_CXX11
  void set_start_name(::std::string&& value);
  #endif
  void set_start_name(const char* value);
  void set_start_name(const char* value, size_t size);
  ::std::string* mutable_start_name();
  ::std::string* release_start_name();
  void set_allocated_start_name(::std::string* start_name);

  // .aspia.proto.Services.Item.Status status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::aspia::proto::Services_Item_Status status() const;
  void set_status(::aspia::proto::Services_Item_Status value);

  // .aspia.proto.Services.Item.StartupType startup_type = 5;
  void clear_startup_type();
  static const int kStartupTypeFieldNumber = 5;
  ::aspia::proto::Services_Item_StartupType startup_type() const;
  void set_startup_type(::aspia::proto::Services_Item_StartupType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Services.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr display_name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr binary_path_;
  ::google::protobuf::internal::ArenaStringPtr start_name_;
  int status_;
  int startup_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsServices_ItemImpl();
};
// -------------------------------------------------------------------

class Services : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Services) */ {
 public:
  Services();
  virtual ~Services();

  Services(const Services& from);

  inline Services& operator=(const Services& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Services(Services&& from) noexcept
    : Services() {
    *this = ::std::move(from);
  }

  inline Services& operator=(Services&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Services& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Services* internal_default_instance() {
    return reinterpret_cast<const Services*>(
               &_Services_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(Services* other);
  friend void swap(Services& a, Services& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Services* New() const PROTOBUF_FINAL { return New(NULL); }

  Services* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Services& from);
  void MergeFrom(const Services& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Services_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Services.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Services_Item& item(int index) const;
  ::aspia::proto::Services_Item* mutable_item(int index);
  ::aspia::proto::Services_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Services)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsServicesImpl();
};
// -------------------------------------------------------------------

class Processes_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Processes.Item) */ {
 public:
  Processes_Item();
  virtual ~Processes_Item();

  Processes_Item(const Processes_Item& from);

  inline Processes_Item& operator=(const Processes_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Processes_Item(Processes_Item&& from) noexcept
    : Processes_Item() {
    *this = ::std::move(from);
  }

  inline Processes_Item& operator=(Processes_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Processes_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Processes_Item* internal_default_instance() {
    return reinterpret_cast<const Processes_Item*>(
               &_Processes_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(Processes_Item* other);
  friend void swap(Processes_Item& a, Processes_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Processes_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Processes_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Processes_Item& from);
  void MergeFrom(const Processes_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Processes_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string process_name = 1;
  void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  const ::std::string& process_name() const;
  void set_process_name(const ::std::string& value);
  #if LANG_CXX11
  void set_process_name(::std::string&& value);
  #endif
  void set_process_name(const char* value);
  void set_process_name(const char* value, size_t size);
  ::std::string* mutable_process_name();
  ::std::string* release_process_name();
  void set_allocated_process_name(::std::string* process_name);

  // string file_path = 2;
  void clear_file_path();
  static const int kFilePathFieldNumber = 2;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  #if LANG_CXX11
  void set_file_path(::std::string&& value);
  #endif
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // string description = 5;
  void clear_description();
  static const int kDescriptionFieldNumber = 5;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // uint64 used_memory = 3;
  void clear_used_memory();
  static const int kUsedMemoryFieldNumber = 3;
  ::google::protobuf::uint64 used_memory() const;
  void set_used_memory(::google::protobuf::uint64 value);

  // uint64 used_swap = 4;
  void clear_used_swap();
  static const int kUsedSwapFieldNumber = 4;
  ::google::protobuf::uint64 used_swap() const;
  void set_used_swap(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Processes.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr process_name_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::uint64 used_memory_;
  ::google::protobuf::uint64 used_swap_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsProcesses_ItemImpl();
};
// -------------------------------------------------------------------

class Processes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Processes) */ {
 public:
  Processes();
  virtual ~Processes();

  Processes(const Processes& from);

  inline Processes& operator=(const Processes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Processes(Processes&& from) noexcept
    : Processes() {
    *this = ::std::move(from);
  }

  inline Processes& operator=(Processes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Processes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Processes* internal_default_instance() {
    return reinterpret_cast<const Processes*>(
               &_Processes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(Processes* other);
  friend void swap(Processes& a, Processes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Processes* New() const PROTOBUF_FINAL { return New(NULL); }

  Processes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Processes& from);
  void MergeFrom(const Processes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Processes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Processes_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Processes.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Processes_Item& item(int index) const;
  ::aspia::proto::Processes_Item* mutable_item(int index);
  ::aspia::proto::Processes_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Processes_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Processes_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Processes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Processes_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsProcessesImpl();
};
// -------------------------------------------------------------------

class NetworkCards_Item_IpAddress : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.NetworkCards.Item.IpAddress) */ {
 public:
  NetworkCards_Item_IpAddress();
  virtual ~NetworkCards_Item_IpAddress();

  NetworkCards_Item_IpAddress(const NetworkCards_Item_IpAddress& from);

  inline NetworkCards_Item_IpAddress& operator=(const NetworkCards_Item_IpAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards_Item_IpAddress(NetworkCards_Item_IpAddress&& from) noexcept
    : NetworkCards_Item_IpAddress() {
    *this = ::std::move(from);
  }

  inline NetworkCards_Item_IpAddress& operator=(NetworkCards_Item_IpAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards_Item_IpAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkCards_Item_IpAddress* internal_default_instance() {
    return reinterpret_cast<const NetworkCards_Item_IpAddress*>(
               &_NetworkCards_Item_IpAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(NetworkCards_Item_IpAddress* other);
  friend void swap(NetworkCards_Item_IpAddress& a, NetworkCards_Item_IpAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards_Item_IpAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards_Item_IpAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards_Item_IpAddress& from);
  void MergeFrom(const NetworkCards_Item_IpAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards_Item_IpAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // string mask = 2;
  void clear_mask();
  static const int kMaskFieldNumber = 2;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // @@protoc_insertion_point(class_scope:aspia.proto.NetworkCards.Item.IpAddress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsNetworkCards_Item_IpAddressImpl();
};
// -------------------------------------------------------------------

class NetworkCards_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.NetworkCards.Item) */ {
 public:
  NetworkCards_Item();
  virtual ~NetworkCards_Item();

  NetworkCards_Item(const NetworkCards_Item& from);

  inline NetworkCards_Item& operator=(const NetworkCards_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards_Item(NetworkCards_Item&& from) noexcept
    : NetworkCards_Item() {
    *this = ::std::move(from);
  }

  inline NetworkCards_Item& operator=(NetworkCards_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkCards_Item* internal_default_instance() {
    return reinterpret_cast<const NetworkCards_Item*>(
               &_NetworkCards_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(NetworkCards_Item* other);
  friend void swap(NetworkCards_Item& a, NetworkCards_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards_Item& from);
  void MergeFrom(const NetworkCards_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NetworkCards_Item_IpAddress IpAddress;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.NetworkCards.Item.IpAddress ip_address = 11;
  int ip_address_size() const;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 11;
  const ::aspia::proto::NetworkCards_Item_IpAddress& ip_address(int index) const;
  ::aspia::proto::NetworkCards_Item_IpAddress* mutable_ip_address(int index);
  ::aspia::proto::NetworkCards_Item_IpAddress* add_ip_address();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >*
      mutable_ip_address();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >&
      ip_address() const;

  // repeated string gateway_address = 12;
  int gateway_address_size() const;
  void clear_gateway_address();
  static const int kGatewayAddressFieldNumber = 12;
  const ::std::string& gateway_address(int index) const;
  ::std::string* mutable_gateway_address(int index);
  void set_gateway_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_gateway_address(int index, ::std::string&& value);
  #endif
  void set_gateway_address(int index, const char* value);
  void set_gateway_address(int index, const char* value, size_t size);
  ::std::string* add_gateway_address();
  void add_gateway_address(const ::std::string& value);
  #if LANG_CXX11
  void add_gateway_address(::std::string&& value);
  #endif
  void add_gateway_address(const char* value);
  void add_gateway_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& gateway_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_gateway_address();

  // repeated string dhcp_server_address = 13;
  int dhcp_server_address_size() const;
  void clear_dhcp_server_address();
  static const int kDhcpServerAddressFieldNumber = 13;
  const ::std::string& dhcp_server_address(int index) const;
  ::std::string* mutable_dhcp_server_address(int index);
  void set_dhcp_server_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dhcp_server_address(int index, ::std::string&& value);
  #endif
  void set_dhcp_server_address(int index, const char* value);
  void set_dhcp_server_address(int index, const char* value, size_t size);
  ::std::string* add_dhcp_server_address();
  void add_dhcp_server_address(const ::std::string& value);
  #if LANG_CXX11
  void add_dhcp_server_address(::std::string&& value);
  #endif
  void add_dhcp_server_address(const char* value);
  void add_dhcp_server_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dhcp_server_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dhcp_server_address();

  // repeated string dns_server_address = 14;
  int dns_server_address_size() const;
  void clear_dns_server_address();
  static const int kDnsServerAddressFieldNumber = 14;
  const ::std::string& dns_server_address(int index) const;
  ::std::string* mutable_dns_server_address(int index);
  void set_dns_server_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dns_server_address(int index, ::std::string&& value);
  #endif
  void set_dns_server_address(int index, const char* value);
  void set_dns_server_address(int index, const char* value, size_t size);
  ::std::string* add_dns_server_address();
  void add_dns_server_address(const ::std::string& value);
  #if LANG_CXX11
  void add_dns_server_address(::std::string&& value);
  #endif
  void add_dns_server_address(const char* value);
  void add_dns_server_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dns_server_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dns_server_address();

  // string adapter_name = 1;
  void clear_adapter_name();
  static const int kAdapterNameFieldNumber = 1;
  const ::std::string& adapter_name() const;
  void set_adapter_name(const ::std::string& value);
  #if LANG_CXX11
  void set_adapter_name(::std::string&& value);
  #endif
  void set_adapter_name(const char* value);
  void set_adapter_name(const char* value, size_t size);
  ::std::string* mutable_adapter_name();
  ::std::string* release_adapter_name();
  void set_allocated_adapter_name(::std::string* adapter_name);

  // string connection_name = 2;
  void clear_connection_name();
  static const int kConnectionNameFieldNumber = 2;
  const ::std::string& connection_name() const;
  void set_connection_name(const ::std::string& value);
  #if LANG_CXX11
  void set_connection_name(::std::string&& value);
  #endif
  void set_connection_name(const char* value);
  void set_connection_name(const char* value, size_t size);
  ::std::string* mutable_connection_name();
  ::std::string* release_connection_name();
  void set_allocated_connection_name(::std::string* connection_name);

  // string interface_type = 3;
  void clear_interface_type();
  static const int kInterfaceTypeFieldNumber = 3;
  const ::std::string& interface_type() const;
  void set_interface_type(const ::std::string& value);
  #if LANG_CXX11
  void set_interface_type(::std::string&& value);
  #endif
  void set_interface_type(const char* value);
  void set_interface_type(const char* value, size_t size);
  ::std::string* mutable_interface_type();
  ::std::string* release_interface_type();
  void set_allocated_interface_type(::std::string* interface_type);

  // string mac_address = 6;
  void clear_mac_address();
  static const int kMacAddressFieldNumber = 6;
  const ::std::string& mac_address() const;
  void set_mac_address(const ::std::string& value);
  #if LANG_CXX11
  void set_mac_address(::std::string&& value);
  #endif
  void set_mac_address(const char* value);
  void set_mac_address(const char* value, size_t size);
  ::std::string* mutable_mac_address();
  ::std::string* release_mac_address();
  void set_allocated_mac_address(::std::string* mac_address);

  // string primary_wins_server = 8;
  void clear_primary_wins_server();
  static const int kPrimaryWinsServerFieldNumber = 8;
  const ::std::string& primary_wins_server() const;
  void set_primary_wins_server(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_wins_server(::std::string&& value);
  #endif
  void set_primary_wins_server(const char* value);
  void set_primary_wins_server(const char* value, size_t size);
  ::std::string* mutable_primary_wins_server();
  ::std::string* release_primary_wins_server();
  void set_allocated_primary_wins_server(::std::string* primary_wins_server);

  // string secondary_wins_server = 9;
  void clear_secondary_wins_server();
  static const int kSecondaryWinsServerFieldNumber = 9;
  const ::std::string& secondary_wins_server() const;
  void set_secondary_wins_server(const ::std::string& value);
  #if LANG_CXX11
  void set_secondary_wins_server(::std::string&& value);
  #endif
  void set_secondary_wins_server(const char* value);
  void set_secondary_wins_server(const char* value, size_t size);
  ::std::string* mutable_secondary_wins_server();
  ::std::string* release_secondary_wins_server();
  void set_allocated_secondary_wins_server(::std::string* secondary_wins_server);

  // uint32 mtu = 4;
  void clear_mtu();
  static const int kMtuFieldNumber = 4;
  ::google::protobuf::uint32 mtu() const;
  void set_mtu(::google::protobuf::uint32 value);

  // uint32 speed = 5;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  ::google::protobuf::uint32 speed() const;
  void set_speed(::google::protobuf::uint32 value);

  // bool is_wins_enabled = 7;
  void clear_is_wins_enabled();
  static const int kIsWinsEnabledFieldNumber = 7;
  bool is_wins_enabled() const;
  void set_is_wins_enabled(bool value);

  // bool is_dhcp_enabled = 10;
  void clear_is_dhcp_enabled();
  static const int kIsDhcpEnabledFieldNumber = 10;
  bool is_dhcp_enabled() const;
  void set_is_dhcp_enabled(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.NetworkCards.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress > ip_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> gateway_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dhcp_server_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dns_server_address_;
  ::google::protobuf::internal::ArenaStringPtr adapter_name_;
  ::google::protobuf::internal::ArenaStringPtr connection_name_;
  ::google::protobuf::internal::ArenaStringPtr interface_type_;
  ::google::protobuf::internal::ArenaStringPtr mac_address_;
  ::google::protobuf::internal::ArenaStringPtr primary_wins_server_;
  ::google::protobuf::internal::ArenaStringPtr secondary_wins_server_;
  ::google::protobuf::uint32 mtu_;
  ::google::protobuf::uint32 speed_;
  bool is_wins_enabled_;
  bool is_dhcp_enabled_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsNetworkCards_ItemImpl();
};
// -------------------------------------------------------------------

class NetworkCards : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.NetworkCards) */ {
 public:
  NetworkCards();
  virtual ~NetworkCards();

  NetworkCards(const NetworkCards& from);

  inline NetworkCards& operator=(const NetworkCards& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards(NetworkCards&& from) noexcept
    : NetworkCards() {
    *this = ::std::move(from);
  }

  inline NetworkCards& operator=(NetworkCards&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkCards* internal_default_instance() {
    return reinterpret_cast<const NetworkCards*>(
               &_NetworkCards_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(NetworkCards* other);
  friend void swap(NetworkCards& a, NetworkCards& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards& from);
  void MergeFrom(const NetworkCards& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NetworkCards_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.NetworkCards.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::NetworkCards_Item& item(int index) const;
  ::aspia::proto::NetworkCards_Item* mutable_item(int index);
  ::aspia::proto::NetworkCards_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.NetworkCards)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsNetworkCardsImpl();
};
// -------------------------------------------------------------------

class OpenConnections_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.OpenConnections.Item) */ {
 public:
  OpenConnections_Item();
  virtual ~OpenConnections_Item();

  OpenConnections_Item(const OpenConnections_Item& from);

  inline OpenConnections_Item& operator=(const OpenConnections_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenConnections_Item(OpenConnections_Item&& from) noexcept
    : OpenConnections_Item() {
    *this = ::std::move(from);
  }

  inline OpenConnections_Item& operator=(OpenConnections_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OpenConnections_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenConnections_Item* internal_default_instance() {
    return reinterpret_cast<const OpenConnections_Item*>(
               &_OpenConnections_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(OpenConnections_Item* other);
  friend void swap(OpenConnections_Item& a, OpenConnections_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenConnections_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  OpenConnections_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpenConnections_Item& from);
  void MergeFrom(const OpenConnections_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenConnections_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef OpenConnections_Item_Protocol Protocol;
  static const Protocol PROTOCOL_UNKNOWN =
    OpenConnections_Item_Protocol_PROTOCOL_UNKNOWN;
  static const Protocol PROTOCOL_TCP =
    OpenConnections_Item_Protocol_PROTOCOL_TCP;
  static const Protocol PROTOCOL_UDP =
    OpenConnections_Item_Protocol_PROTOCOL_UDP;
  static inline bool Protocol_IsValid(int value) {
    return OpenConnections_Item_Protocol_IsValid(value);
  }
  static const Protocol Protocol_MIN =
    OpenConnections_Item_Protocol_Protocol_MIN;
  static const Protocol Protocol_MAX =
    OpenConnections_Item_Protocol_Protocol_MAX;
  static const int Protocol_ARRAYSIZE =
    OpenConnections_Item_Protocol_Protocol_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string process_name = 1;
  void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  const ::std::string& process_name() const;
  void set_process_name(const ::std::string& value);
  #if LANG_CXX11
  void set_process_name(::std::string&& value);
  #endif
  void set_process_name(const char* value);
  void set_process_name(const char* value, size_t size);
  ::std::string* mutable_process_name();
  ::std::string* release_process_name();
  void set_allocated_process_name(::std::string* process_name);

  // string local_address = 3;
  void clear_local_address();
  static const int kLocalAddressFieldNumber = 3;
  const ::std::string& local_address() const;
  void set_local_address(const ::std::string& value);
  #if LANG_CXX11
  void set_local_address(::std::string&& value);
  #endif
  void set_local_address(const char* value);
  void set_local_address(const char* value, size_t size);
  ::std::string* mutable_local_address();
  ::std::string* release_local_address();
  void set_allocated_local_address(::std::string* local_address);

  // string remote_address = 4;
  void clear_remote_address();
  static const int kRemoteAddressFieldNumber = 4;
  const ::std::string& remote_address() const;
  void set_remote_address(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_address(::std::string&& value);
  #endif
  void set_remote_address(const char* value);
  void set_remote_address(const char* value, size_t size);
  ::std::string* mutable_remote_address();
  ::std::string* release_remote_address();
  void set_allocated_remote_address(::std::string* remote_address);

  // string state = 7;
  void clear_state();
  static const int kStateFieldNumber = 7;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  #if LANG_CXX11
  void set_state(::std::string&& value);
  #endif
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // .aspia.proto.OpenConnections.Item.Protocol protocol = 2;
  void clear_protocol();
  static const int kProtocolFieldNumber = 2;
  ::aspia::proto::OpenConnections_Item_Protocol protocol() const;
  void set_protocol(::aspia::proto::OpenConnections_Item_Protocol value);

  // uint32 local_port = 5;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 5;
  ::google::protobuf::uint32 local_port() const;
  void set_local_port(::google::protobuf::uint32 value);

  // uint32 remote_port = 6;
  void clear_remote_port();
  static const int kRemotePortFieldNumber = 6;
  ::google::protobuf::uint32 remote_port() const;
  void set_remote_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.OpenConnections.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr process_name_;
  ::google::protobuf::internal::ArenaStringPtr local_address_;
  ::google::protobuf::internal::ArenaStringPtr remote_address_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  int protocol_;
  ::google::protobuf::uint32 local_port_;
  ::google::protobuf::uint32 remote_port_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsOpenConnections_ItemImpl();
};
// -------------------------------------------------------------------

class OpenConnections : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.OpenConnections) */ {
 public:
  OpenConnections();
  virtual ~OpenConnections();

  OpenConnections(const OpenConnections& from);

  inline OpenConnections& operator=(const OpenConnections& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenConnections(OpenConnections&& from) noexcept
    : OpenConnections() {
    *this = ::std::move(from);
  }

  inline OpenConnections& operator=(OpenConnections&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OpenConnections& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenConnections* internal_default_instance() {
    return reinterpret_cast<const OpenConnections*>(
               &_OpenConnections_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(OpenConnections* other);
  friend void swap(OpenConnections& a, OpenConnections& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenConnections* New() const PROTOBUF_FINAL { return New(NULL); }

  OpenConnections* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpenConnections& from);
  void MergeFrom(const OpenConnections& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenConnections* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef OpenConnections_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.OpenConnections.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::OpenConnections_Item& item(int index) const;
  ::aspia::proto::OpenConnections_Item* mutable_item(int index);
  ::aspia::proto::OpenConnections_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.OpenConnections)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsOpenConnectionsImpl();
};
// -------------------------------------------------------------------

class SharedResources_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.SharedResources.Item) */ {
 public:
  SharedResources_Item();
  virtual ~SharedResources_Item();

  SharedResources_Item(const SharedResources_Item& from);

  inline SharedResources_Item& operator=(const SharedResources_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SharedResources_Item(SharedResources_Item&& from) noexcept
    : SharedResources_Item() {
    *this = ::std::move(from);
  }

  inline SharedResources_Item& operator=(SharedResources_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SharedResources_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SharedResources_Item* internal_default_instance() {
    return reinterpret_cast<const SharedResources_Item*>(
               &_SharedResources_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(SharedResources_Item* other);
  friend void swap(SharedResources_Item& a, SharedResources_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SharedResources_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  SharedResources_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SharedResources_Item& from);
  void MergeFrom(const SharedResources_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedResources_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SharedResources_Item_Type Type;
  static const Type TYPE_UNKNOWN =
    SharedResources_Item_Type_TYPE_UNKNOWN;
  static const Type TYPE_DISK =
    SharedResources_Item_Type_TYPE_DISK;
  static const Type TYPE_PRINTER =
    SharedResources_Item_Type_TYPE_PRINTER;
  static const Type TYPE_DEVICE =
    SharedResources_Item_Type_TYPE_DEVICE;
  static const Type TYPE_IPC =
    SharedResources_Item_Type_TYPE_IPC;
  static const Type TYPE_SPECIAL =
    SharedResources_Item_Type_TYPE_SPECIAL;
  static const Type TYPE_TEMPORARY =
    SharedResources_Item_Type_TYPE_TEMPORARY;
  static inline bool Type_IsValid(int value) {
    return SharedResources_Item_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SharedResources_Item_Type_Type_MIN;
  static const Type Type_MAX =
    SharedResources_Item_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SharedResources_Item_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string local_path = 4;
  void clear_local_path();
  static const int kLocalPathFieldNumber = 4;
  const ::std::string& local_path() const;
  void set_local_path(const ::std::string& value);
  #if LANG_CXX11
  void set_local_path(::std::string&& value);
  #endif
  void set_local_path(const char* value);
  void set_local_path(const char* value, size_t size);
  ::std::string* mutable_local_path();
  ::std::string* release_local_path();
  void set_allocated_local_path(::std::string* local_path);

  // .aspia.proto.SharedResources.Item.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::aspia::proto::SharedResources_Item_Type type() const;
  void set_type(::aspia::proto::SharedResources_Item_Type value);

  // uint32 current_uses = 5;
  void clear_current_uses();
  static const int kCurrentUsesFieldNumber = 5;
  ::google::protobuf::uint32 current_uses() const;
  void set_current_uses(::google::protobuf::uint32 value);

  // uint32 maximum_uses = 6;
  void clear_maximum_uses();
  static const int kMaximumUsesFieldNumber = 6;
  ::google::protobuf::uint32 maximum_uses() const;
  void set_maximum_uses(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.SharedResources.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr local_path_;
  int type_;
  ::google::protobuf::uint32 current_uses_;
  ::google::protobuf::uint32 maximum_uses_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSharedResources_ItemImpl();
};
// -------------------------------------------------------------------

class SharedResources : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.SharedResources) */ {
 public:
  SharedResources();
  virtual ~SharedResources();

  SharedResources(const SharedResources& from);

  inline SharedResources& operator=(const SharedResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SharedResources(SharedResources&& from) noexcept
    : SharedResources() {
    *this = ::std::move(from);
  }

  inline SharedResources& operator=(SharedResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SharedResources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SharedResources* internal_default_instance() {
    return reinterpret_cast<const SharedResources*>(
               &_SharedResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(SharedResources* other);
  friend void swap(SharedResources& a, SharedResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SharedResources* New() const PROTOBUF_FINAL { return New(NULL); }

  SharedResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SharedResources& from);
  void MergeFrom(const SharedResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SharedResources_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.SharedResources.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::SharedResources_Item& item(int index) const;
  ::aspia::proto::SharedResources_Item* mutable_item(int index);
  ::aspia::proto::SharedResources_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.SharedResources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSharedResourcesImpl();
};
// -------------------------------------------------------------------

class Routes_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Routes.Item) */ {
 public:
  Routes_Item();
  virtual ~Routes_Item();

  Routes_Item(const Routes_Item& from);

  inline Routes_Item& operator=(const Routes_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Routes_Item(Routes_Item&& from) noexcept
    : Routes_Item() {
    *this = ::std::move(from);
  }

  inline Routes_Item& operator=(Routes_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Routes_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Routes_Item* internal_default_instance() {
    return reinterpret_cast<const Routes_Item*>(
               &_Routes_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(Routes_Item* other);
  friend void swap(Routes_Item& a, Routes_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Routes_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Routes_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Routes_Item& from);
  void MergeFrom(const Routes_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Routes_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string destonation = 1;
  void clear_destonation();
  static const int kDestonationFieldNumber = 1;
  const ::std::string& destonation() const;
  void set_destonation(const ::std::string& value);
  #if LANG_CXX11
  void set_destonation(::std::string&& value);
  #endif
  void set_destonation(const char* value);
  void set_destonation(const char* value, size_t size);
  ::std::string* mutable_destonation();
  ::std::string* release_destonation();
  void set_allocated_destonation(::std::string* destonation);

  // string mask = 2;
  void clear_mask();
  static const int kMaskFieldNumber = 2;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // string gateway = 3;
  void clear_gateway();
  static const int kGatewayFieldNumber = 3;
  const ::std::string& gateway() const;
  void set_gateway(const ::std::string& value);
  #if LANG_CXX11
  void set_gateway(::std::string&& value);
  #endif
  void set_gateway(const char* value);
  void set_gateway(const char* value, size_t size);
  ::std::string* mutable_gateway();
  ::std::string* release_gateway();
  void set_allocated_gateway(::std::string* gateway);

  // uint32 metric = 4;
  void clear_metric();
  static const int kMetricFieldNumber = 4;
  ::google::protobuf::uint32 metric() const;
  void set_metric(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Routes.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr destonation_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  ::google::protobuf::internal::ArenaStringPtr gateway_;
  ::google::protobuf::uint32 metric_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsRoutes_ItemImpl();
};
// -------------------------------------------------------------------

class Routes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Routes) */ {
 public:
  Routes();
  virtual ~Routes();

  Routes(const Routes& from);

  inline Routes& operator=(const Routes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Routes(Routes&& from) noexcept
    : Routes() {
    *this = ::std::move(from);
  }

  inline Routes& operator=(Routes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Routes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Routes* internal_default_instance() {
    return reinterpret_cast<const Routes*>(
               &_Routes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(Routes* other);
  friend void swap(Routes& a, Routes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Routes* New() const PROTOBUF_FINAL { return New(NULL); }

  Routes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Routes& from);
  void MergeFrom(const Routes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Routes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Routes_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Routes.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Routes_Item& item(int index) const;
  ::aspia::proto::Routes_Item* mutable_item(int index);
  ::aspia::proto::Routes_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Routes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsRoutesImpl();
};
// -------------------------------------------------------------------

class Users_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Users.Item) */ {
 public:
  Users_Item();
  virtual ~Users_Item();

  Users_Item(const Users_Item& from);

  inline Users_Item& operator=(const Users_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Users_Item(Users_Item&& from) noexcept
    : Users_Item() {
    *this = ::std::move(from);
  }

  inline Users_Item& operator=(Users_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Users_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Users_Item* internal_default_instance() {
    return reinterpret_cast<const Users_Item*>(
               &_Users_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(Users_Item* other);
  friend void swap(Users_Item& a, Users_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Users_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Users_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Users_Item& from);
  void MergeFrom(const Users_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Users_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string full_name = 2;
  void clear_full_name();
  static const int kFullNameFieldNumber = 2;
  const ::std::string& full_name() const;
  void set_full_name(const ::std::string& value);
  #if LANG_CXX11
  void set_full_name(::std::string&& value);
  #endif
  void set_full_name(const char* value);
  void set_full_name(const char* value, size_t size);
  ::std::string* mutable_full_name();
  ::std::string* release_full_name();
  void set_allocated_full_name(::std::string* full_name);

  // string comment = 3;
  void clear_comment();
  static const int kCommentFieldNumber = 3;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // bool is_disabled = 4;
  void clear_is_disabled();
  static const int kIsDisabledFieldNumber = 4;
  bool is_disabled() const;
  void set_is_disabled(bool value);

  // bool is_password_cant_change = 5;
  void clear_is_password_cant_change();
  static const int kIsPasswordCantChangeFieldNumber = 5;
  bool is_password_cant_change() const;
  void set_is_password_cant_change(bool value);

  // bool is_password_expired = 6;
  void clear_is_password_expired();
  static const int kIsPasswordExpiredFieldNumber = 6;
  bool is_password_expired() const;
  void set_is_password_expired(bool value);

  // bool is_dont_expire_password = 7;
  void clear_is_dont_expire_password();
  static const int kIsDontExpirePasswordFieldNumber = 7;
  bool is_dont_expire_password() const;
  void set_is_dont_expire_password(bool value);

  // bool is_lockout = 8;
  void clear_is_lockout();
  static const int kIsLockoutFieldNumber = 8;
  bool is_lockout() const;
  void set_is_lockout(bool value);

  // uint32 number_logons = 9;
  void clear_number_logons();
  static const int kNumberLogonsFieldNumber = 9;
  ::google::protobuf::uint32 number_logons() const;
  void set_number_logons(::google::protobuf::uint32 value);

  // uint32 bad_password_count = 10;
  void clear_bad_password_count();
  static const int kBadPasswordCountFieldNumber = 10;
  ::google::protobuf::uint32 bad_password_count() const;
  void set_bad_password_count(::google::protobuf::uint32 value);

  // int64 last_logon_time = 11;
  void clear_last_logon_time();
  static const int kLastLogonTimeFieldNumber = 11;
  ::google::protobuf::int64 last_logon_time() const;
  void set_last_logon_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Users.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr full_name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  bool is_disabled_;
  bool is_password_cant_change_;
  bool is_password_expired_;
  bool is_dont_expire_password_;
  bool is_lockout_;
  ::google::protobuf::uint32 number_logons_;
  ::google::protobuf::uint32 bad_password_count_;
  ::google::protobuf::int64 last_logon_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUsers_ItemImpl();
};
// -------------------------------------------------------------------

class Users : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Users) */ {
 public:
  Users();
  virtual ~Users();

  Users(const Users& from);

  inline Users& operator=(const Users& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Users(Users&& from) noexcept
    : Users() {
    *this = ::std::move(from);
  }

  inline Users& operator=(Users&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Users& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Users* internal_default_instance() {
    return reinterpret_cast<const Users*>(
               &_Users_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(Users* other);
  friend void swap(Users& a, Users& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Users* New() const PROTOBUF_FINAL { return New(NULL); }

  Users* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Users& from);
  void MergeFrom(const Users& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Users* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Users_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Users.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Users_Item& item(int index) const;
  ::aspia::proto::Users_Item* mutable_item(int index);
  ::aspia::proto::Users_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Users)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUsersImpl();
};
// -------------------------------------------------------------------

class UserGroups_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.UserGroups.Item) */ {
 public:
  UserGroups_Item();
  virtual ~UserGroups_Item();

  UserGroups_Item(const UserGroups_Item& from);

  inline UserGroups_Item& operator=(const UserGroups_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserGroups_Item(UserGroups_Item&& from) noexcept
    : UserGroups_Item() {
    *this = ::std::move(from);
  }

  inline UserGroups_Item& operator=(UserGroups_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const UserGroups_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserGroups_Item* internal_default_instance() {
    return reinterpret_cast<const UserGroups_Item*>(
               &_UserGroups_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(UserGroups_Item* other);
  friend void swap(UserGroups_Item& a, UserGroups_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserGroups_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  UserGroups_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserGroups_Item& from);
  void MergeFrom(const UserGroups_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserGroups_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string comment = 2;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:aspia.proto.UserGroups.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUserGroups_ItemImpl();
};
// -------------------------------------------------------------------

class UserGroups : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.UserGroups) */ {
 public:
  UserGroups();
  virtual ~UserGroups();

  UserGroups(const UserGroups& from);

  inline UserGroups& operator=(const UserGroups& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserGroups(UserGroups&& from) noexcept
    : UserGroups() {
    *this = ::std::move(from);
  }

  inline UserGroups& operator=(UserGroups&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const UserGroups& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserGroups* internal_default_instance() {
    return reinterpret_cast<const UserGroups*>(
               &_UserGroups_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(UserGroups* other);
  friend void swap(UserGroups& a, UserGroups& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserGroups* New() const PROTOBUF_FINAL { return New(NULL); }

  UserGroups* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserGroups& from);
  void MergeFrom(const UserGroups& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserGroups* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef UserGroups_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.UserGroups.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::UserGroups_Item& item(int index) const;
  ::aspia::proto::UserGroups_Item* mutable_item(int index);
  ::aspia::proto::UserGroups_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.UserGroups)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUserGroupsImpl();
};
// -------------------------------------------------------------------

class Sessions_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Sessions.Item) */ {
 public:
  Sessions_Item();
  virtual ~Sessions_Item();

  Sessions_Item(const Sessions_Item& from);

  inline Sessions_Item& operator=(const Sessions_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sessions_Item(Sessions_Item&& from) noexcept
    : Sessions_Item() {
    *this = ::std::move(from);
  }

  inline Sessions_Item& operator=(Sessions_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Sessions_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sessions_Item* internal_default_instance() {
    return reinterpret_cast<const Sessions_Item*>(
               &_Sessions_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(Sessions_Item* other);
  friend void swap(Sessions_Item& a, Sessions_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sessions_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Sessions_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Sessions_Item& from);
  void MergeFrom(const Sessions_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sessions_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_name = 1;
  void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& user_name() const;
  void set_user_name(const ::std::string& value);
  #if LANG_CXX11
  void set_user_name(::std::string&& value);
  #endif
  void set_user_name(const char* value);
  void set_user_name(const char* value, size_t size);
  ::std::string* mutable_user_name();
  ::std::string* release_user_name();
  void set_allocated_user_name(::std::string* user_name);

  // string domain_name = 2;
  void clear_domain_name();
  static const int kDomainNameFieldNumber = 2;
  const ::std::string& domain_name() const;
  void set_domain_name(const ::std::string& value);
  #if LANG_CXX11
  void set_domain_name(::std::string&& value);
  #endif
  void set_domain_name(const char* value);
  void set_domain_name(const char* value, size_t size);
  ::std::string* mutable_domain_name();
  ::std::string* release_domain_name();
  void set_allocated_domain_name(::std::string* domain_name);

  // string connect_state = 4;
  void clear_connect_state();
  static const int kConnectStateFieldNumber = 4;
  const ::std::string& connect_state() const;
  void set_connect_state(const ::std::string& value);
  #if LANG_CXX11
  void set_connect_state(::std::string&& value);
  #endif
  void set_connect_state(const char* value);
  void set_connect_state(const char* value, size_t size);
  ::std::string* mutable_connect_state();
  ::std::string* release_connect_state();
  void set_allocated_connect_state(::std::string* connect_state);

  // string client_name = 5;
  void clear_client_name();
  static const int kClientNameFieldNumber = 5;
  const ::std::string& client_name() const;
  void set_client_name(const ::std::string& value);
  #if LANG_CXX11
  void set_client_name(::std::string&& value);
  #endif
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  ::std::string* mutable_client_name();
  ::std::string* release_client_name();
  void set_allocated_client_name(::std::string* client_name);

  // string winstation_name = 6;
  void clear_winstation_name();
  static const int kWinstationNameFieldNumber = 6;
  const ::std::string& winstation_name() const;
  void set_winstation_name(const ::std::string& value);
  #if LANG_CXX11
  void set_winstation_name(::std::string&& value);
  #endif
  void set_winstation_name(const char* value);
  void set_winstation_name(const char* value, size_t size);
  ::std::string* mutable_winstation_name();
  ::std::string* release_winstation_name();
  void set_allocated_winstation_name(::std::string* winstation_name);

  // uint32 session_id = 3;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  ::google::protobuf::uint32 session_id() const;
  void set_session_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Sessions.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  ::google::protobuf::internal::ArenaStringPtr domain_name_;
  ::google::protobuf::internal::ArenaStringPtr connect_state_;
  ::google::protobuf::internal::ArenaStringPtr client_name_;
  ::google::protobuf::internal::ArenaStringPtr winstation_name_;
  ::google::protobuf::uint32 session_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSessions_ItemImpl();
};
// -------------------------------------------------------------------

class Sessions : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Sessions) */ {
 public:
  Sessions();
  virtual ~Sessions();

  Sessions(const Sessions& from);

  inline Sessions& operator=(const Sessions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sessions(Sessions&& from) noexcept
    : Sessions() {
    *this = ::std::move(from);
  }

  inline Sessions& operator=(Sessions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Sessions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sessions* internal_default_instance() {
    return reinterpret_cast<const Sessions*>(
               &_Sessions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(Sessions* other);
  friend void swap(Sessions& a, Sessions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sessions* New() const PROTOBUF_FINAL { return New(NULL); }

  Sessions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Sessions& from);
  void MergeFrom(const Sessions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sessions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Sessions_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Sessions.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Sessions_Item& item(int index) const;
  ::aspia::proto::Sessions_Item* mutable_item(int index);
  ::aspia::proto::Sessions_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Sessions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSessionsImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DmiBios_Feature

// string name = 1;
inline void DmiBios_Feature::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios_Feature::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Feature.name)
  return name_.GetNoArena();
}
inline void DmiBios_Feature::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Feature.name)
}
#if LANG_CXX11
inline void DmiBios_Feature::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.Feature.name)
}
#endif
inline void DmiBios_Feature::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.Feature.name)
}
inline void DmiBios_Feature::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.Feature.name)
}
inline ::std::string* DmiBios_Feature::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.Feature.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios_Feature::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.Feature.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios_Feature::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.Feature.name)
}

// bool supported = 2;
inline void DmiBios_Feature::clear_supported() {
  supported_ = false;
}
inline bool DmiBios_Feature::supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.Feature.supported)
  return supported_;
}
inline void DmiBios_Feature::set_supported(bool value) {
  
  supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.Feature.supported)
}

// -------------------------------------------------------------------

// DmiBios

// string manufacturer = 1;
inline void DmiBios::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiBios::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.manufacturer)
}
#if LANG_CXX11
inline void DmiBios::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.manufacturer)
}
#endif
inline void DmiBios::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.manufacturer)
}
inline void DmiBios::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.manufacturer)
}
inline ::std::string* DmiBios::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.manufacturer)
}

// string version = 2;
inline void DmiBios::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.version)
  return version_.GetNoArena();
}
inline void DmiBios::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.version)
}
#if LANG_CXX11
inline void DmiBios::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.version)
}
#endif
inline void DmiBios::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.version)
}
inline void DmiBios::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.version)
}
inline ::std::string* DmiBios::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.version)
}

// string date = 3;
inline void DmiBios::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.date)
  return date_.GetNoArena();
}
inline void DmiBios::set_date(const ::std::string& value) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.date)
}
#if LANG_CXX11
inline void DmiBios::set_date(::std::string&& value) {
  
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.date)
}
#endif
inline void DmiBios::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.date)
}
inline void DmiBios::set_date(const char* value, size_t size) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.date)
}
inline ::std::string* DmiBios::mutable_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.date)
  
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    
  } else {
    
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.date)
}

// uint64 size = 4;
inline void DmiBios::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DmiBios::size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.size)
  return size_;
}
inline void DmiBios::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.size)
}

// string bios_revision = 5;
inline void DmiBios::clear_bios_revision() {
  bios_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::bios_revision() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.bios_revision)
  return bios_revision_.GetNoArena();
}
inline void DmiBios::set_bios_revision(const ::std::string& value) {
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.bios_revision)
}
#if LANG_CXX11
inline void DmiBios::set_bios_revision(::std::string&& value) {
  
  bios_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.bios_revision)
}
#endif
inline void DmiBios::set_bios_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.bios_revision)
}
inline void DmiBios::set_bios_revision(const char* value, size_t size) {
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.bios_revision)
}
inline ::std::string* DmiBios::mutable_bios_revision() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.bios_revision)
  return bios_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_bios_revision() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.bios_revision)
  
  return bios_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_bios_revision(::std::string* bios_revision) {
  if (bios_revision != NULL) {
    
  } else {
    
  }
  bios_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bios_revision);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.bios_revision)
}

// string firmware_revision = 6;
inline void DmiBios::clear_firmware_revision() {
  firmware_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::firmware_revision() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.firmware_revision)
  return firmware_revision_.GetNoArena();
}
inline void DmiBios::set_firmware_revision(const ::std::string& value) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.firmware_revision)
}
#if LANG_CXX11
inline void DmiBios::set_firmware_revision(::std::string&& value) {
  
  firmware_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.firmware_revision)
}
#endif
inline void DmiBios::set_firmware_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.firmware_revision)
}
inline void DmiBios::set_firmware_revision(const char* value, size_t size) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.firmware_revision)
}
inline ::std::string* DmiBios::mutable_firmware_revision() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.firmware_revision)
  return firmware_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_firmware_revision() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.firmware_revision)
  
  return firmware_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_firmware_revision(::std::string* firmware_revision) {
  if (firmware_revision != NULL) {
    
  } else {
    
  }
  firmware_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_revision);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.firmware_revision)
}

// string address = 7;
inline void DmiBios::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.address)
  return address_.GetNoArena();
}
inline void DmiBios::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.address)
}
#if LANG_CXX11
inline void DmiBios::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.address)
}
#endif
inline void DmiBios::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.address)
}
inline void DmiBios::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.address)
}
inline ::std::string* DmiBios::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.address)
}

// int32 runtime_size = 8;
inline void DmiBios::clear_runtime_size() {
  runtime_size_ = 0;
}
inline ::google::protobuf::int32 DmiBios::runtime_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.runtime_size)
  return runtime_size_;
}
inline void DmiBios::set_runtime_size(::google::protobuf::int32 value) {
  
  runtime_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.runtime_size)
}

// repeated .aspia.proto.DmiBios.Feature feature = 9;
inline int DmiBios::feature_size() const {
  return feature_.size();
}
inline void DmiBios::clear_feature() {
  feature_.Clear();
}
inline const ::aspia::proto::DmiBios_Feature& DmiBios::feature(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.feature)
  return feature_.Get(index);
}
inline ::aspia::proto::DmiBios_Feature* DmiBios::mutable_feature(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.feature)
  return feature_.Mutable(index);
}
inline ::aspia::proto::DmiBios_Feature* DmiBios::add_feature() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiBios.feature)
  return feature_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBios_Feature >*
DmiBios::mutable_feature() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiBios.feature)
  return &feature_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBios_Feature >&
DmiBios::feature() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiBios.feature)
  return feature_;
}

// -------------------------------------------------------------------

// DmiSystem

// string manufacturer = 1;
inline void DmiSystem::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiSystem::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.manufacturer)
}
#if LANG_CXX11
inline void DmiSystem::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.manufacturer)
}
#endif
inline void DmiSystem::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.manufacturer)
}
inline void DmiSystem::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.manufacturer)
}
inline ::std::string* DmiSystem::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.manufacturer)
}

// string product_name = 2;
inline void DmiSystem::clear_product_name() {
  product_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::product_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.product_name)
  return product_name_.GetNoArena();
}
inline void DmiSystem::set_product_name(const ::std::string& value) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.product_name)
}
#if LANG_CXX11
inline void DmiSystem::set_product_name(::std::string&& value) {
  
  product_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.product_name)
}
#endif
inline void DmiSystem::set_product_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.product_name)
}
inline void DmiSystem::set_product_name(const char* value, size_t size) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.product_name)
}
inline ::std::string* DmiSystem::mutable_product_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.product_name)
  return product_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_product_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.product_name)
  
  return product_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_product_name(::std::string* product_name) {
  if (product_name != NULL) {
    
  } else {
    
  }
  product_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.product_name)
}

// string version = 3;
inline void DmiSystem::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.version)
  return version_.GetNoArena();
}
inline void DmiSystem::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.version)
}
#if LANG_CXX11
inline void DmiSystem::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.version)
}
#endif
inline void DmiSystem::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.version)
}
inline void DmiSystem::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.version)
}
inline ::std::string* DmiSystem::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.version)
}

// string serial_number = 4;
inline void DmiSystem::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiSystem::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.serial_number)
}
#if LANG_CXX11
inline void DmiSystem::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.serial_number)
}
#endif
inline void DmiSystem::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.serial_number)
}
inline void DmiSystem::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.serial_number)
}
inline ::std::string* DmiSystem::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.serial_number)
}

// string uuid = 5;
inline void DmiSystem::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::uuid() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.uuid)
  return uuid_.GetNoArena();
}
inline void DmiSystem::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.uuid)
}
#if LANG_CXX11
inline void DmiSystem::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.uuid)
}
#endif
inline void DmiSystem::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.uuid)
}
inline void DmiSystem::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.uuid)
}
inline ::std::string* DmiSystem::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_uuid() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.uuid)
}

// string wakeup_type = 6;
inline void DmiSystem::clear_wakeup_type() {
  wakeup_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::wakeup_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.wakeup_type)
  return wakeup_type_.GetNoArena();
}
inline void DmiSystem::set_wakeup_type(const ::std::string& value) {
  
  wakeup_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.wakeup_type)
}
#if LANG_CXX11
inline void DmiSystem::set_wakeup_type(::std::string&& value) {
  
  wakeup_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.wakeup_type)
}
#endif
inline void DmiSystem::set_wakeup_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  wakeup_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.wakeup_type)
}
inline void DmiSystem::set_wakeup_type(const char* value, size_t size) {
  
  wakeup_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.wakeup_type)
}
inline ::std::string* DmiSystem::mutable_wakeup_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.wakeup_type)
  return wakeup_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_wakeup_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.wakeup_type)
  
  return wakeup_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_wakeup_type(::std::string* wakeup_type) {
  if (wakeup_type != NULL) {
    
  } else {
    
  }
  wakeup_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wakeup_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.wakeup_type)
}

// string sku_number = 7;
inline void DmiSystem::clear_sku_number() {
  sku_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::sku_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.sku_number)
  return sku_number_.GetNoArena();
}
inline void DmiSystem::set_sku_number(const ::std::string& value) {
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.sku_number)
}
#if LANG_CXX11
inline void DmiSystem::set_sku_number(::std::string&& value) {
  
  sku_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.sku_number)
}
#endif
inline void DmiSystem::set_sku_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.sku_number)
}
inline void DmiSystem::set_sku_number(const char* value, size_t size) {
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.sku_number)
}
inline ::std::string* DmiSystem::mutable_sku_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.sku_number)
  return sku_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_sku_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.sku_number)
  
  return sku_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_sku_number(::std::string* sku_number) {
  if (sku_number != NULL) {
    
  } else {
    
  }
  sku_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sku_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.sku_number)
}

// string family = 8;
inline void DmiSystem::clear_family() {
  family_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::family() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.family)
  return family_.GetNoArena();
}
inline void DmiSystem::set_family(const ::std::string& value) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.family)
}
#if LANG_CXX11
inline void DmiSystem::set_family(::std::string&& value) {
  
  family_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.family)
}
#endif
inline void DmiSystem::set_family(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.family)
}
inline void DmiSystem::set_family(const char* value, size_t size) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.family)
}
inline ::std::string* DmiSystem::mutable_family() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.family)
  return family_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_family() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.family)
  
  return family_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_family(::std::string* family) {
  if (family != NULL) {
    
  } else {
    
  }
  family_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.family)
}

// -------------------------------------------------------------------

// DmiBaseboard_Item_Feature

// string name = 1;
inline void DmiBaseboard_Item_Feature::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item_Feature::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.Feature.name)
  return name_.GetNoArena();
}
inline void DmiBaseboard_Item_Feature::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.Feature.name)
}
#if LANG_CXX11
inline void DmiBaseboard_Item_Feature::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.Feature.name)
}
#endif
inline void DmiBaseboard_Item_Feature::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.Feature.name)
}
inline void DmiBaseboard_Item_Feature::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.Feature.name)
}
inline ::std::string* DmiBaseboard_Item_Feature::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.Feature.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item_Feature::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.Feature.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item_Feature::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.Feature.name)
}

// bool supported = 2;
inline void DmiBaseboard_Item_Feature::clear_supported() {
  supported_ = false;
}
inline bool DmiBaseboard_Item_Feature::supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.Feature.supported)
  return supported_;
}
inline void DmiBaseboard_Item_Feature::set_supported(bool value) {
  
  supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.Feature.supported)
}

// -------------------------------------------------------------------

// DmiBaseboard_Item

// string manufacturer = 1;
inline void DmiBaseboard_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiBaseboard_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.manufacturer)
}
#endif
inline void DmiBaseboard_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.manufacturer)
}
inline void DmiBaseboard_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.manufacturer)
}
inline ::std::string* DmiBaseboard_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.manufacturer)
}

// string product_name = 2;
inline void DmiBaseboard_Item::clear_product_name() {
  product_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::product_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.product_name)
  return product_name_.GetNoArena();
}
inline void DmiBaseboard_Item::set_product_name(const ::std::string& value) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.product_name)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_product_name(::std::string&& value) {
  
  product_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.product_name)
}
#endif
inline void DmiBaseboard_Item::set_product_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.product_name)
}
inline void DmiBaseboard_Item::set_product_name(const char* value, size_t size) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.product_name)
}
inline ::std::string* DmiBaseboard_Item::mutable_product_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.product_name)
  return product_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_product_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.product_name)
  
  return product_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_product_name(::std::string* product_name) {
  if (product_name != NULL) {
    
  } else {
    
  }
  product_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.product_name)
}

// string version = 3;
inline void DmiBaseboard_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.version)
  return version_.GetNoArena();
}
inline void DmiBaseboard_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.version)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.version)
}
#endif
inline void DmiBaseboard_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.version)
}
inline void DmiBaseboard_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.version)
}
inline ::std::string* DmiBaseboard_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.version)
}

// string serial_number = 4;
inline void DmiBaseboard_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiBaseboard_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.serial_number)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.serial_number)
}
#endif
inline void DmiBaseboard_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.serial_number)
}
inline void DmiBaseboard_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.serial_number)
}
inline ::std::string* DmiBaseboard_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.serial_number)
}

// string asset_tag = 5;
inline void DmiBaseboard_Item::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void DmiBaseboard_Item::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.asset_tag)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.asset_tag)
}
#endif
inline void DmiBaseboard_Item::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.asset_tag)
}
inline void DmiBaseboard_Item::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.asset_tag)
}
inline ::std::string* DmiBaseboard_Item::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.asset_tag)
}

// repeated .aspia.proto.DmiBaseboard.Item.Feature feature = 6;
inline int DmiBaseboard_Item::feature_size() const {
  return feature_.size();
}
inline void DmiBaseboard_Item::clear_feature() {
  feature_.Clear();
}
inline const ::aspia::proto::DmiBaseboard_Item_Feature& DmiBaseboard_Item::feature(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.feature)
  return feature_.Get(index);
}
inline ::aspia::proto::DmiBaseboard_Item_Feature* DmiBaseboard_Item::mutable_feature(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.feature)
  return feature_.Mutable(index);
}
inline ::aspia::proto::DmiBaseboard_Item_Feature* DmiBaseboard_Item::add_feature() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiBaseboard.Item.feature)
  return feature_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item_Feature >*
DmiBaseboard_Item::mutable_feature() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiBaseboard.Item.feature)
  return &feature_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item_Feature >&
DmiBaseboard_Item::feature() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiBaseboard.Item.feature)
  return feature_;
}

// string location_in_chassis = 7;
inline void DmiBaseboard_Item::clear_location_in_chassis() {
  location_in_chassis_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::location_in_chassis() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.location_in_chassis)
  return location_in_chassis_.GetNoArena();
}
inline void DmiBaseboard_Item::set_location_in_chassis(const ::std::string& value) {
  
  location_in_chassis_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_location_in_chassis(::std::string&& value) {
  
  location_in_chassis_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}
#endif
inline void DmiBaseboard_Item::set_location_in_chassis(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_in_chassis_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}
inline void DmiBaseboard_Item::set_location_in_chassis(const char* value, size_t size) {
  
  location_in_chassis_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}
inline ::std::string* DmiBaseboard_Item::mutable_location_in_chassis() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.location_in_chassis)
  return location_in_chassis_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_location_in_chassis() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.location_in_chassis)
  
  return location_in_chassis_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_location_in_chassis(::std::string* location_in_chassis) {
  if (location_in_chassis != NULL) {
    
  } else {
    
  }
  location_in_chassis_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location_in_chassis);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}

// string type = 8;
inline void DmiBaseboard_Item::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.type)
  return type_.GetNoArena();
}
inline void DmiBaseboard_Item::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.type)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.type)
}
#endif
inline void DmiBaseboard_Item::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.type)
}
inline void DmiBaseboard_Item::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.type)
}
inline ::std::string* DmiBaseboard_Item::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.type)
}

// -------------------------------------------------------------------

// DmiBaseboard

// repeated .aspia.proto.DmiBaseboard.Item item = 1;
inline int DmiBaseboard::item_size() const {
  return item_.size();
}
inline void DmiBaseboard::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiBaseboard_Item& DmiBaseboard::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiBaseboard_Item* DmiBaseboard::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiBaseboard_Item* DmiBaseboard::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiBaseboard.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item >*
DmiBaseboard::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiBaseboard.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item >&
DmiBaseboard::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiBaseboard.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiChassis_Item

// string manufacturer = 1;
inline void DmiChassis_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiChassis_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.manufacturer)
}
#endif
inline void DmiChassis_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.manufacturer)
}
inline void DmiChassis_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.manufacturer)
}
inline ::std::string* DmiChassis_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.manufacturer)
}

// string version = 2;
inline void DmiChassis_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.version)
  return version_.GetNoArena();
}
inline void DmiChassis_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.version)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.version)
}
#endif
inline void DmiChassis_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.version)
}
inline void DmiChassis_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.version)
}
inline ::std::string* DmiChassis_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.version)
}

// string serial_number = 3;
inline void DmiChassis_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiChassis_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.serial_number)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.serial_number)
}
#endif
inline void DmiChassis_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.serial_number)
}
inline void DmiChassis_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.serial_number)
}
inline ::std::string* DmiChassis_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.serial_number)
}

// string asset_tag = 4;
inline void DmiChassis_Item::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void DmiChassis_Item::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.asset_tag)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.asset_tag)
}
#endif
inline void DmiChassis_Item::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.asset_tag)
}
inline void DmiChassis_Item::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.asset_tag)
}
inline ::std::string* DmiChassis_Item::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.asset_tag)
}

// string type = 5;
inline void DmiChassis_Item::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.type)
  return type_.GetNoArena();
}
inline void DmiChassis_Item::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.type)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.type)
}
#endif
inline void DmiChassis_Item::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.type)
}
inline void DmiChassis_Item::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.type)
}
inline ::std::string* DmiChassis_Item::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.type)
}

// string os_load_status = 6;
inline void DmiChassis_Item::clear_os_load_status() {
  os_load_status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::os_load_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.os_load_status)
  return os_load_status_.GetNoArena();
}
inline void DmiChassis_Item::set_os_load_status(const ::std::string& value) {
  
  os_load_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.os_load_status)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_os_load_status(::std::string&& value) {
  
  os_load_status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.os_load_status)
}
#endif
inline void DmiChassis_Item::set_os_load_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  os_load_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.os_load_status)
}
inline void DmiChassis_Item::set_os_load_status(const char* value, size_t size) {
  
  os_load_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.os_load_status)
}
inline ::std::string* DmiChassis_Item::mutable_os_load_status() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.os_load_status)
  return os_load_status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_os_load_status() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.os_load_status)
  
  return os_load_status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_os_load_status(::std::string* os_load_status) {
  if (os_load_status != NULL) {
    
  } else {
    
  }
  os_load_status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_load_status);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.os_load_status)
}

// string power_source_status = 7;
inline void DmiChassis_Item::clear_power_source_status() {
  power_source_status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::power_source_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.power_source_status)
  return power_source_status_.GetNoArena();
}
inline void DmiChassis_Item::set_power_source_status(const ::std::string& value) {
  
  power_source_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.power_source_status)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_power_source_status(::std::string&& value) {
  
  power_source_status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.power_source_status)
}
#endif
inline void DmiChassis_Item::set_power_source_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  power_source_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.power_source_status)
}
inline void DmiChassis_Item::set_power_source_status(const char* value, size_t size) {
  
  power_source_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.power_source_status)
}
inline ::std::string* DmiChassis_Item::mutable_power_source_status() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.power_source_status)
  return power_source_status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_power_source_status() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.power_source_status)
  
  return power_source_status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_power_source_status(::std::string* power_source_status) {
  if (power_source_status != NULL) {
    
  } else {
    
  }
  power_source_status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), power_source_status);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.power_source_status)
}

// string temparature_status = 8;
inline void DmiChassis_Item::clear_temparature_status() {
  temparature_status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::temparature_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.temparature_status)
  return temparature_status_.GetNoArena();
}
inline void DmiChassis_Item::set_temparature_status(const ::std::string& value) {
  
  temparature_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.temparature_status)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_temparature_status(::std::string&& value) {
  
  temparature_status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.temparature_status)
}
#endif
inline void DmiChassis_Item::set_temparature_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  temparature_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.temparature_status)
}
inline void DmiChassis_Item::set_temparature_status(const char* value, size_t size) {
  
  temparature_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.temparature_status)
}
inline ::std::string* DmiChassis_Item::mutable_temparature_status() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.temparature_status)
  return temparature_status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_temparature_status() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.temparature_status)
  
  return temparature_status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_temparature_status(::std::string* temparature_status) {
  if (temparature_status != NULL) {
    
  } else {
    
  }
  temparature_status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), temparature_status);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.temparature_status)
}

// string security_status = 9;
inline void DmiChassis_Item::clear_security_status() {
  security_status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::security_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.security_status)
  return security_status_.GetNoArena();
}
inline void DmiChassis_Item::set_security_status(const ::std::string& value) {
  
  security_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.security_status)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_security_status(::std::string&& value) {
  
  security_status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.security_status)
}
#endif
inline void DmiChassis_Item::set_security_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  security_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.security_status)
}
inline void DmiChassis_Item::set_security_status(const char* value, size_t size) {
  
  security_status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.security_status)
}
inline ::std::string* DmiChassis_Item::mutable_security_status() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.security_status)
  return security_status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_security_status() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.security_status)
  
  return security_status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_security_status(::std::string* security_status) {
  if (security_status != NULL) {
    
  } else {
    
  }
  security_status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), security_status);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.security_status)
}

// int32 height = 10;
inline void DmiChassis_Item::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 DmiChassis_Item::height() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.height)
  return height_;
}
inline void DmiChassis_Item::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.height)
}

// int32 number_of_power_cords = 11;
inline void DmiChassis_Item::clear_number_of_power_cords() {
  number_of_power_cords_ = 0;
}
inline ::google::protobuf::int32 DmiChassis_Item::number_of_power_cords() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.number_of_power_cords)
  return number_of_power_cords_;
}
inline void DmiChassis_Item::set_number_of_power_cords(::google::protobuf::int32 value) {
  
  number_of_power_cords_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.number_of_power_cords)
}

// -------------------------------------------------------------------

// DmiChassis

// repeated .aspia.proto.DmiChassis.Item item = 1;
inline int DmiChassis::item_size() const {
  return item_.size();
}
inline void DmiChassis::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiChassis_Item& DmiChassis::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiChassis_Item* DmiChassis::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiChassis_Item* DmiChassis::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiChassis.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item >*
DmiChassis::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiChassis.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item >&
DmiChassis::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiChassis.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiCaches_Item_SRAMType

// string name = 1;
inline void DmiCaches_Item_SRAMType::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiCaches_Item_SRAMType::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.SRAMType.name)
  return name_.GetNoArena();
}
inline void DmiCaches_Item_SRAMType::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.SRAMType.name)
}
#if LANG_CXX11
inline void DmiCaches_Item_SRAMType::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiCaches.Item.SRAMType.name)
}
#endif
inline void DmiCaches_Item_SRAMType::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiCaches.Item.SRAMType.name)
}
inline void DmiCaches_Item_SRAMType::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiCaches.Item.SRAMType.name)
}
inline ::std::string* DmiCaches_Item_SRAMType::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.Item.SRAMType.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiCaches_Item_SRAMType::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiCaches.Item.SRAMType.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiCaches_Item_SRAMType::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiCaches.Item.SRAMType.name)
}

// bool supported = 2;
inline void DmiCaches_Item_SRAMType::clear_supported() {
  supported_ = false;
}
inline bool DmiCaches_Item_SRAMType::supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.SRAMType.supported)
  return supported_;
}
inline void DmiCaches_Item_SRAMType::set_supported(bool value) {
  
  supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.SRAMType.supported)
}

// -------------------------------------------------------------------

// DmiCaches_Item

// string name = 1;
inline void DmiCaches_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiCaches_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.name)
  return name_.GetNoArena();
}
inline void DmiCaches_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.name)
}
#if LANG_CXX11
inline void DmiCaches_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiCaches.Item.name)
}
#endif
inline void DmiCaches_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiCaches.Item.name)
}
inline void DmiCaches_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiCaches.Item.name)
}
inline ::std::string* DmiCaches_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiCaches_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiCaches.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiCaches_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiCaches.Item.name)
}

// string location = 2;
inline void DmiCaches_Item::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiCaches_Item::location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.location)
  return location_.GetNoArena();
}
inline void DmiCaches_Item::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.location)
}
#if LANG_CXX11
inline void DmiCaches_Item::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiCaches.Item.location)
}
#endif
inline void DmiCaches_Item::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiCaches.Item.location)
}
inline void DmiCaches_Item::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiCaches.Item.location)
}
inline ::std::string* DmiCaches_Item::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.Item.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiCaches_Item::release_location() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiCaches.Item.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiCaches_Item::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiCaches.Item.location)
}

// bool enabled = 3;
inline void DmiCaches_Item::clear_enabled() {
  enabled_ = false;
}
inline bool DmiCaches_Item::enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.enabled)
  return enabled_;
}
inline void DmiCaches_Item::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.enabled)
}

// string mode = 4;
inline void DmiCaches_Item::clear_mode() {
  mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiCaches_Item::mode() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.mode)
  return mode_.GetNoArena();
}
inline void DmiCaches_Item::set_mode(const ::std::string& value) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.mode)
}
#if LANG_CXX11
inline void DmiCaches_Item::set_mode(::std::string&& value) {
  
  mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiCaches.Item.mode)
}
#endif
inline void DmiCaches_Item::set_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiCaches.Item.mode)
}
inline void DmiCaches_Item::set_mode(const char* value, size_t size) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiCaches.Item.mode)
}
inline ::std::string* DmiCaches_Item::mutable_mode() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.Item.mode)
  return mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiCaches_Item::release_mode() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiCaches.Item.mode)
  
  return mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiCaches_Item::set_allocated_mode(::std::string* mode) {
  if (mode != NULL) {
    
  } else {
    
  }
  mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiCaches.Item.mode)
}

// int32 level = 5;
inline void DmiCaches_Item::clear_level() {
  level_ = 0;
}
inline ::google::protobuf::int32 DmiCaches_Item::level() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.level)
  return level_;
}
inline void DmiCaches_Item::set_level(::google::protobuf::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.level)
}

// int32 maximum_size = 6;
inline void DmiCaches_Item::clear_maximum_size() {
  maximum_size_ = 0;
}
inline ::google::protobuf::int32 DmiCaches_Item::maximum_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.maximum_size)
  return maximum_size_;
}
inline void DmiCaches_Item::set_maximum_size(::google::protobuf::int32 value) {
  
  maximum_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.maximum_size)
}

// int32 current_size = 7;
inline void DmiCaches_Item::clear_current_size() {
  current_size_ = 0;
}
inline ::google::protobuf::int32 DmiCaches_Item::current_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.current_size)
  return current_size_;
}
inline void DmiCaches_Item::set_current_size(::google::protobuf::int32 value) {
  
  current_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.current_size)
}

// repeated .aspia.proto.DmiCaches.Item.SRAMType supported_sram_type = 8;
inline int DmiCaches_Item::supported_sram_type_size() const {
  return supported_sram_type_.size();
}
inline void DmiCaches_Item::clear_supported_sram_type() {
  supported_sram_type_.Clear();
}
inline const ::aspia::proto::DmiCaches_Item_SRAMType& DmiCaches_Item::supported_sram_type(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.supported_sram_type)
  return supported_sram_type_.Get(index);
}
inline ::aspia::proto::DmiCaches_Item_SRAMType* DmiCaches_Item::mutable_supported_sram_type(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.Item.supported_sram_type)
  return supported_sram_type_.Mutable(index);
}
inline ::aspia::proto::DmiCaches_Item_SRAMType* DmiCaches_Item::add_supported_sram_type() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiCaches.Item.supported_sram_type)
  return supported_sram_type_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item_SRAMType >*
DmiCaches_Item::mutable_supported_sram_type() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiCaches.Item.supported_sram_type)
  return &supported_sram_type_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item_SRAMType >&
DmiCaches_Item::supported_sram_type() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiCaches.Item.supported_sram_type)
  return supported_sram_type_;
}

// string current_sram_type = 9;
inline void DmiCaches_Item::clear_current_sram_type() {
  current_sram_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiCaches_Item::current_sram_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.current_sram_type)
  return current_sram_type_.GetNoArena();
}
inline void DmiCaches_Item::set_current_sram_type(const ::std::string& value) {
  
  current_sram_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.current_sram_type)
}
#if LANG_CXX11
inline void DmiCaches_Item::set_current_sram_type(::std::string&& value) {
  
  current_sram_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiCaches.Item.current_sram_type)
}
#endif
inline void DmiCaches_Item::set_current_sram_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  current_sram_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiCaches.Item.current_sram_type)
}
inline void DmiCaches_Item::set_current_sram_type(const char* value, size_t size) {
  
  current_sram_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiCaches.Item.current_sram_type)
}
inline ::std::string* DmiCaches_Item::mutable_current_sram_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.Item.current_sram_type)
  return current_sram_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiCaches_Item::release_current_sram_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiCaches.Item.current_sram_type)
  
  return current_sram_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiCaches_Item::set_allocated_current_sram_type(::std::string* current_sram_type) {
  if (current_sram_type != NULL) {
    
  } else {
    
  }
  current_sram_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_sram_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiCaches.Item.current_sram_type)
}

// int32 speed = 10;
inline void DmiCaches_Item::clear_speed() {
  speed_ = 0;
}
inline ::google::protobuf::int32 DmiCaches_Item::speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.speed)
  return speed_;
}
inline void DmiCaches_Item::set_speed(::google::protobuf::int32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.speed)
}

// string error_correction_type = 11;
inline void DmiCaches_Item::clear_error_correction_type() {
  error_correction_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiCaches_Item::error_correction_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.error_correction_type)
  return error_correction_type_.GetNoArena();
}
inline void DmiCaches_Item::set_error_correction_type(const ::std::string& value) {
  
  error_correction_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.error_correction_type)
}
#if LANG_CXX11
inline void DmiCaches_Item::set_error_correction_type(::std::string&& value) {
  
  error_correction_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiCaches.Item.error_correction_type)
}
#endif
inline void DmiCaches_Item::set_error_correction_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_correction_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiCaches.Item.error_correction_type)
}
inline void DmiCaches_Item::set_error_correction_type(const char* value, size_t size) {
  
  error_correction_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiCaches.Item.error_correction_type)
}
inline ::std::string* DmiCaches_Item::mutable_error_correction_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.Item.error_correction_type)
  return error_correction_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiCaches_Item::release_error_correction_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiCaches.Item.error_correction_type)
  
  return error_correction_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiCaches_Item::set_allocated_error_correction_type(::std::string* error_correction_type) {
  if (error_correction_type != NULL) {
    
  } else {
    
  }
  error_correction_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_correction_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiCaches.Item.error_correction_type)
}

// string type = 12;
inline void DmiCaches_Item::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiCaches_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.type)
  return type_.GetNoArena();
}
inline void DmiCaches_Item::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.type)
}
#if LANG_CXX11
inline void DmiCaches_Item::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiCaches.Item.type)
}
#endif
inline void DmiCaches_Item::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiCaches.Item.type)
}
inline void DmiCaches_Item::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiCaches.Item.type)
}
inline ::std::string* DmiCaches_Item::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.Item.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiCaches_Item::release_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiCaches.Item.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiCaches_Item::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiCaches.Item.type)
}

// string associativity = 13;
inline void DmiCaches_Item::clear_associativity() {
  associativity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiCaches_Item::associativity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.associativity)
  return associativity_.GetNoArena();
}
inline void DmiCaches_Item::set_associativity(const ::std::string& value) {
  
  associativity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.associativity)
}
#if LANG_CXX11
inline void DmiCaches_Item::set_associativity(::std::string&& value) {
  
  associativity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiCaches.Item.associativity)
}
#endif
inline void DmiCaches_Item::set_associativity(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  associativity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiCaches.Item.associativity)
}
inline void DmiCaches_Item::set_associativity(const char* value, size_t size) {
  
  associativity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiCaches.Item.associativity)
}
inline ::std::string* DmiCaches_Item::mutable_associativity() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.Item.associativity)
  return associativity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiCaches_Item::release_associativity() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiCaches.Item.associativity)
  
  return associativity_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiCaches_Item::set_allocated_associativity(::std::string* associativity) {
  if (associativity != NULL) {
    
  } else {
    
  }
  associativity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), associativity);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiCaches.Item.associativity)
}

// -------------------------------------------------------------------

// DmiCaches

// repeated .aspia.proto.DmiCaches.Item item = 1;
inline int DmiCaches::item_size() const {
  return item_.size();
}
inline void DmiCaches::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiCaches_Item& DmiCaches::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiCaches_Item* DmiCaches::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiCaches_Item* DmiCaches::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiCaches.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item >*
DmiCaches::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiCaches.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item >&
DmiCaches::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiCaches.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiProcessors_Item_Feature

// string name = 1;
inline void DmiProcessors_Item_Feature::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item_Feature::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.Feature.name)
  return name_.GetNoArena();
}
inline void DmiProcessors_Item_Feature::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.Feature.name)
}
#if LANG_CXX11
inline void DmiProcessors_Item_Feature::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.Feature.name)
}
#endif
inline void DmiProcessors_Item_Feature::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.Feature.name)
}
inline void DmiProcessors_Item_Feature::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.Feature.name)
}
inline ::std::string* DmiProcessors_Item_Feature::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.Feature.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item_Feature::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.Feature.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item_Feature::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.Feature.name)
}

// bool supported = 2;
inline void DmiProcessors_Item_Feature::clear_supported() {
  supported_ = false;
}
inline bool DmiProcessors_Item_Feature::supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.Feature.supported)
  return supported_;
}
inline void DmiProcessors_Item_Feature::set_supported(bool value) {
  
  supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.Feature.supported)
}

// -------------------------------------------------------------------

// DmiProcessors_Item

// string manufacturer = 1;
inline void DmiProcessors_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiProcessors_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.manufacturer)
}
#endif
inline void DmiProcessors_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.manufacturer)
}
inline void DmiProcessors_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.manufacturer)
}
inline ::std::string* DmiProcessors_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.manufacturer)
}

// string version = 2;
inline void DmiProcessors_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.version)
  return version_.GetNoArena();
}
inline void DmiProcessors_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.version)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.version)
}
#endif
inline void DmiProcessors_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.version)
}
inline void DmiProcessors_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.version)
}
inline ::std::string* DmiProcessors_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.version)
}

// string family = 3;
inline void DmiProcessors_Item::clear_family() {
  family_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::family() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.family)
  return family_.GetNoArena();
}
inline void DmiProcessors_Item::set_family(const ::std::string& value) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.family)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_family(::std::string&& value) {
  
  family_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.family)
}
#endif
inline void DmiProcessors_Item::set_family(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.family)
}
inline void DmiProcessors_Item::set_family(const char* value, size_t size) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.family)
}
inline ::std::string* DmiProcessors_Item::mutable_family() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.family)
  return family_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_family() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.family)
  
  return family_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_family(::std::string* family) {
  if (family != NULL) {
    
  } else {
    
  }
  family_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.family)
}

// string type = 4;
inline void DmiProcessors_Item::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.type)
  return type_.GetNoArena();
}
inline void DmiProcessors_Item::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.type)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.type)
}
#endif
inline void DmiProcessors_Item::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.type)
}
inline void DmiProcessors_Item::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.type)
}
inline ::std::string* DmiProcessors_Item::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.type)
}

// string status = 5;
inline void DmiProcessors_Item::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.status)
  return status_.GetNoArena();
}
inline void DmiProcessors_Item::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.status)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.status)
}
#endif
inline void DmiProcessors_Item::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.status)
}
inline void DmiProcessors_Item::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.status)
}
inline ::std::string* DmiProcessors_Item::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_status() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.status)
}

// string socket = 6;
inline void DmiProcessors_Item::clear_socket() {
  socket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::socket() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.socket)
  return socket_.GetNoArena();
}
inline void DmiProcessors_Item::set_socket(const ::std::string& value) {
  
  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.socket)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_socket(::std::string&& value) {
  
  socket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.socket)
}
#endif
inline void DmiProcessors_Item::set_socket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.socket)
}
inline void DmiProcessors_Item::set_socket(const char* value, size_t size) {
  
  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.socket)
}
inline ::std::string* DmiProcessors_Item::mutable_socket() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.socket)
  return socket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_socket() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.socket)
  
  return socket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_socket(::std::string* socket) {
  if (socket != NULL) {
    
  } else {
    
  }
  socket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), socket);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.socket)
}

// string upgrade = 7;
inline void DmiProcessors_Item::clear_upgrade() {
  upgrade_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::upgrade() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.upgrade)
  return upgrade_.GetNoArena();
}
inline void DmiProcessors_Item::set_upgrade(const ::std::string& value) {
  
  upgrade_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.upgrade)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_upgrade(::std::string&& value) {
  
  upgrade_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.upgrade)
}
#endif
inline void DmiProcessors_Item::set_upgrade(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  upgrade_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.upgrade)
}
inline void DmiProcessors_Item::set_upgrade(const char* value, size_t size) {
  
  upgrade_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.upgrade)
}
inline ::std::string* DmiProcessors_Item::mutable_upgrade() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.upgrade)
  return upgrade_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_upgrade() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.upgrade)
  
  return upgrade_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_upgrade(::std::string* upgrade) {
  if (upgrade != NULL) {
    
  } else {
    
  }
  upgrade_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), upgrade);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.upgrade)
}

// int32 external_clock = 8;
inline void DmiProcessors_Item::clear_external_clock() {
  external_clock_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::external_clock() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.external_clock)
  return external_clock_;
}
inline void DmiProcessors_Item::set_external_clock(::google::protobuf::int32 value) {
  
  external_clock_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.external_clock)
}

// int32 current_speed = 9;
inline void DmiProcessors_Item::clear_current_speed() {
  current_speed_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::current_speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.current_speed)
  return current_speed_;
}
inline void DmiProcessors_Item::set_current_speed(::google::protobuf::int32 value) {
  
  current_speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.current_speed)
}

// int32 maximum_speed = 10;
inline void DmiProcessors_Item::clear_maximum_speed() {
  maximum_speed_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::maximum_speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.maximum_speed)
  return maximum_speed_;
}
inline void DmiProcessors_Item::set_maximum_speed(::google::protobuf::int32 value) {
  
  maximum_speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.maximum_speed)
}

// double voltage = 11;
inline void DmiProcessors_Item::clear_voltage() {
  voltage_ = 0;
}
inline double DmiProcessors_Item::voltage() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.voltage)
  return voltage_;
}
inline void DmiProcessors_Item::set_voltage(double value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.voltage)
}

// string serial_number = 12;
inline void DmiProcessors_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiProcessors_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.serial_number)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.serial_number)
}
#endif
inline void DmiProcessors_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.serial_number)
}
inline void DmiProcessors_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.serial_number)
}
inline ::std::string* DmiProcessors_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.serial_number)
}

// string asset_tag = 13;
inline void DmiProcessors_Item::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void DmiProcessors_Item::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.asset_tag)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.asset_tag)
}
#endif
inline void DmiProcessors_Item::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.asset_tag)
}
inline void DmiProcessors_Item::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.asset_tag)
}
inline ::std::string* DmiProcessors_Item::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.asset_tag)
}

// string part_number = 14;
inline void DmiProcessors_Item::clear_part_number() {
  part_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::part_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.part_number)
  return part_number_.GetNoArena();
}
inline void DmiProcessors_Item::set_part_number(const ::std::string& value) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.part_number)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_part_number(::std::string&& value) {
  
  part_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.part_number)
}
#endif
inline void DmiProcessors_Item::set_part_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.part_number)
}
inline void DmiProcessors_Item::set_part_number(const char* value, size_t size) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.part_number)
}
inline ::std::string* DmiProcessors_Item::mutable_part_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.part_number)
  return part_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_part_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.part_number)
  
  return part_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_part_number(::std::string* part_number) {
  if (part_number != NULL) {
    
  } else {
    
  }
  part_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), part_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.part_number)
}

// int32 core_count = 15;
inline void DmiProcessors_Item::clear_core_count() {
  core_count_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::core_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.core_count)
  return core_count_;
}
inline void DmiProcessors_Item::set_core_count(::google::protobuf::int32 value) {
  
  core_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.core_count)
}

// int32 core_enabled = 16;
inline void DmiProcessors_Item::clear_core_enabled() {
  core_enabled_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::core_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.core_enabled)
  return core_enabled_;
}
inline void DmiProcessors_Item::set_core_enabled(::google::protobuf::int32 value) {
  
  core_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.core_enabled)
}

// int32 thread_count = 17;
inline void DmiProcessors_Item::clear_thread_count() {
  thread_count_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::thread_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.thread_count)
  return thread_count_;
}
inline void DmiProcessors_Item::set_thread_count(::google::protobuf::int32 value) {
  
  thread_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.thread_count)
}

// repeated .aspia.proto.DmiProcessors.Item.Feature feature = 18;
inline int DmiProcessors_Item::feature_size() const {
  return feature_.size();
}
inline void DmiProcessors_Item::clear_feature() {
  feature_.Clear();
}
inline const ::aspia::proto::DmiProcessors_Item_Feature& DmiProcessors_Item::feature(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.feature)
  return feature_.Get(index);
}
inline ::aspia::proto::DmiProcessors_Item_Feature* DmiProcessors_Item::mutable_feature(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.feature)
  return feature_.Mutable(index);
}
inline ::aspia::proto::DmiProcessors_Item_Feature* DmiProcessors_Item::add_feature() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiProcessors.Item.feature)
  return feature_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item_Feature >*
DmiProcessors_Item::mutable_feature() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiProcessors.Item.feature)
  return &feature_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item_Feature >&
DmiProcessors_Item::feature() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiProcessors.Item.feature)
  return feature_;
}

// -------------------------------------------------------------------

// DmiProcessors

// repeated .aspia.proto.DmiProcessors.Item item = 1;
inline int DmiProcessors::item_size() const {
  return item_.size();
}
inline void DmiProcessors::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiProcessors_Item& DmiProcessors::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiProcessors_Item* DmiProcessors::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiProcessors_Item* DmiProcessors::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiProcessors.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item >*
DmiProcessors::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiProcessors.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item >&
DmiProcessors::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiProcessors.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiMemoryDevices_Item

// string device_locator = 1;
inline void DmiMemoryDevices_Item::clear_device_locator() {
  device_locator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::device_locator() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.device_locator)
  return device_locator_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_device_locator(const ::std::string& value) {
  
  device_locator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.device_locator)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_device_locator(::std::string&& value) {
  
  device_locator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.device_locator)
}
#endif
inline void DmiMemoryDevices_Item::set_device_locator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_locator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.device_locator)
}
inline void DmiMemoryDevices_Item::set_device_locator(const char* value, size_t size) {
  
  device_locator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.device_locator)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_device_locator() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.device_locator)
  return device_locator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_device_locator() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.device_locator)
  
  return device_locator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_device_locator(::std::string* device_locator) {
  if (device_locator != NULL) {
    
  } else {
    
  }
  device_locator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_locator);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.device_locator)
}

// int32 size = 2;
inline void DmiMemoryDevices_Item::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 DmiMemoryDevices_Item::size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.size)
  return size_;
}
inline void DmiMemoryDevices_Item::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.size)
}

// string type = 3;
inline void DmiMemoryDevices_Item::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.type)
  return type_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.type)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.type)
}
#endif
inline void DmiMemoryDevices_Item::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.type)
}
inline void DmiMemoryDevices_Item::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.type)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.type)
}

// int32 speed = 4;
inline void DmiMemoryDevices_Item::clear_speed() {
  speed_ = 0;
}
inline ::google::protobuf::int32 DmiMemoryDevices_Item::speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.speed)
  return speed_;
}
inline void DmiMemoryDevices_Item::set_speed(::google::protobuf::int32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.speed)
}

// string form_factor = 5;
inline void DmiMemoryDevices_Item::clear_form_factor() {
  form_factor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::form_factor() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.form_factor)
  return form_factor_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_form_factor(const ::std::string& value) {
  
  form_factor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.form_factor)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_form_factor(::std::string&& value) {
  
  form_factor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.form_factor)
}
#endif
inline void DmiMemoryDevices_Item::set_form_factor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  form_factor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.form_factor)
}
inline void DmiMemoryDevices_Item::set_form_factor(const char* value, size_t size) {
  
  form_factor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.form_factor)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_form_factor() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.form_factor)
  return form_factor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_form_factor() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.form_factor)
  
  return form_factor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_form_factor(::std::string* form_factor) {
  if (form_factor != NULL) {
    
  } else {
    
  }
  form_factor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), form_factor);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.form_factor)
}

// string serial_number = 6;
inline void DmiMemoryDevices_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.serial_number)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.serial_number)
}
#endif
inline void DmiMemoryDevices_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.serial_number)
}
inline void DmiMemoryDevices_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.serial_number)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.serial_number)
}

// string part_number = 7;
inline void DmiMemoryDevices_Item::clear_part_number() {
  part_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::part_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.part_number)
  return part_number_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_part_number(const ::std::string& value) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.part_number)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_part_number(::std::string&& value) {
  
  part_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.part_number)
}
#endif
inline void DmiMemoryDevices_Item::set_part_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.part_number)
}
inline void DmiMemoryDevices_Item::set_part_number(const char* value, size_t size) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.part_number)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_part_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.part_number)
  return part_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_part_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.part_number)
  
  return part_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_part_number(::std::string* part_number) {
  if (part_number != NULL) {
    
  } else {
    
  }
  part_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), part_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.part_number)
}

// string manufactorer = 8;
inline void DmiMemoryDevices_Item::clear_manufactorer() {
  manufactorer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::manufactorer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.manufactorer)
  return manufactorer_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_manufactorer(const ::std::string& value) {
  
  manufactorer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_manufactorer(::std::string&& value) {
  
  manufactorer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}
#endif
inline void DmiMemoryDevices_Item::set_manufactorer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufactorer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}
inline void DmiMemoryDevices_Item::set_manufactorer(const char* value, size_t size) {
  
  manufactorer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_manufactorer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.manufactorer)
  return manufactorer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_manufactorer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.manufactorer)
  
  return manufactorer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_manufactorer(::std::string* manufactorer) {
  if (manufactorer != NULL) {
    
  } else {
    
  }
  manufactorer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufactorer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}

// string bank = 9;
inline void DmiMemoryDevices_Item::clear_bank() {
  bank_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::bank() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.bank)
  return bank_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_bank(const ::std::string& value) {
  
  bank_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.bank)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_bank(::std::string&& value) {
  
  bank_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.bank)
}
#endif
inline void DmiMemoryDevices_Item::set_bank(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bank_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.bank)
}
inline void DmiMemoryDevices_Item::set_bank(const char* value, size_t size) {
  
  bank_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.bank)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_bank() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.bank)
  return bank_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_bank() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.bank)
  
  return bank_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_bank(::std::string* bank) {
  if (bank != NULL) {
    
  } else {
    
  }
  bank_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bank);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.bank)
}

// int32 total_width = 10;
inline void DmiMemoryDevices_Item::clear_total_width() {
  total_width_ = 0;
}
inline ::google::protobuf::int32 DmiMemoryDevices_Item::total_width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.total_width)
  return total_width_;
}
inline void DmiMemoryDevices_Item::set_total_width(::google::protobuf::int32 value) {
  
  total_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.total_width)
}

// int32 data_width = 11;
inline void DmiMemoryDevices_Item::clear_data_width() {
  data_width_ = 0;
}
inline ::google::protobuf::int32 DmiMemoryDevices_Item::data_width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.data_width)
  return data_width_;
}
inline void DmiMemoryDevices_Item::set_data_width(::google::protobuf::int32 value) {
  
  data_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.data_width)
}

// -------------------------------------------------------------------

// DmiMemoryDevices

// repeated .aspia.proto.DmiMemoryDevices.Item item = 1;
inline int DmiMemoryDevices::item_size() const {
  return item_.size();
}
inline void DmiMemoryDevices::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiMemoryDevices_Item& DmiMemoryDevices::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiMemoryDevices_Item* DmiMemoryDevices::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiMemoryDevices_Item* DmiMemoryDevices::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiMemoryDevices.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item >*
DmiMemoryDevices::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiMemoryDevices.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item >&
DmiMemoryDevices::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiMemoryDevices.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiSystemSlots_Item

// string slot_designation = 1;
inline void DmiSystemSlots_Item::clear_slot_designation() {
  slot_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystemSlots_Item::slot_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.slot_designation)
  return slot_designation_.GetNoArena();
}
inline void DmiSystemSlots_Item::set_slot_designation(const ::std::string& value) {
  
  slot_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.slot_designation)
}
#if LANG_CXX11
inline void DmiSystemSlots_Item::set_slot_designation(::std::string&& value) {
  
  slot_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystemSlots.Item.slot_designation)
}
#endif
inline void DmiSystemSlots_Item::set_slot_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  slot_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystemSlots.Item.slot_designation)
}
inline void DmiSystemSlots_Item::set_slot_designation(const char* value, size_t size) {
  
  slot_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystemSlots.Item.slot_designation)
}
inline ::std::string* DmiSystemSlots_Item::mutable_slot_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystemSlots.Item.slot_designation)
  return slot_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystemSlots_Item::release_slot_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystemSlots.Item.slot_designation)
  
  return slot_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystemSlots_Item::set_allocated_slot_designation(::std::string* slot_designation) {
  if (slot_designation != NULL) {
    
  } else {
    
  }
  slot_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), slot_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystemSlots.Item.slot_designation)
}

// string type = 2;
inline void DmiSystemSlots_Item::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystemSlots_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.type)
  return type_.GetNoArena();
}
inline void DmiSystemSlots_Item::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.type)
}
#if LANG_CXX11
inline void DmiSystemSlots_Item::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystemSlots.Item.type)
}
#endif
inline void DmiSystemSlots_Item::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystemSlots.Item.type)
}
inline void DmiSystemSlots_Item::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystemSlots.Item.type)
}
inline ::std::string* DmiSystemSlots_Item::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystemSlots.Item.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystemSlots_Item::release_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystemSlots.Item.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystemSlots_Item::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystemSlots.Item.type)
}

// string usage = 3;
inline void DmiSystemSlots_Item::clear_usage() {
  usage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystemSlots_Item::usage() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.usage)
  return usage_.GetNoArena();
}
inline void DmiSystemSlots_Item::set_usage(const ::std::string& value) {
  
  usage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.usage)
}
#if LANG_CXX11
inline void DmiSystemSlots_Item::set_usage(::std::string&& value) {
  
  usage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystemSlots.Item.usage)
}
#endif
inline void DmiSystemSlots_Item::set_usage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  usage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystemSlots.Item.usage)
}
inline void DmiSystemSlots_Item::set_usage(const char* value, size_t size) {
  
  usage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystemSlots.Item.usage)
}
inline ::std::string* DmiSystemSlots_Item::mutable_usage() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystemSlots.Item.usage)
  return usage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystemSlots_Item::release_usage() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystemSlots.Item.usage)
  
  return usage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystemSlots_Item::set_allocated_usage(::std::string* usage) {
  if (usage != NULL) {
    
  } else {
    
  }
  usage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), usage);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystemSlots.Item.usage)
}

// string bus_width = 4;
inline void DmiSystemSlots_Item::clear_bus_width() {
  bus_width_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystemSlots_Item::bus_width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.bus_width)
  return bus_width_.GetNoArena();
}
inline void DmiSystemSlots_Item::set_bus_width(const ::std::string& value) {
  
  bus_width_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.bus_width)
}
#if LANG_CXX11
inline void DmiSystemSlots_Item::set_bus_width(::std::string&& value) {
  
  bus_width_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystemSlots.Item.bus_width)
}
#endif
inline void DmiSystemSlots_Item::set_bus_width(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bus_width_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystemSlots.Item.bus_width)
}
inline void DmiSystemSlots_Item::set_bus_width(const char* value, size_t size) {
  
  bus_width_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystemSlots.Item.bus_width)
}
inline ::std::string* DmiSystemSlots_Item::mutable_bus_width() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystemSlots.Item.bus_width)
  return bus_width_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystemSlots_Item::release_bus_width() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystemSlots.Item.bus_width)
  
  return bus_width_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystemSlots_Item::set_allocated_bus_width(::std::string* bus_width) {
  if (bus_width != NULL) {
    
  } else {
    
  }
  bus_width_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bus_width);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystemSlots.Item.bus_width)
}

// string length = 5;
inline void DmiSystemSlots_Item::clear_length() {
  length_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystemSlots_Item::length() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.length)
  return length_.GetNoArena();
}
inline void DmiSystemSlots_Item::set_length(const ::std::string& value) {
  
  length_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.length)
}
#if LANG_CXX11
inline void DmiSystemSlots_Item::set_length(::std::string&& value) {
  
  length_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystemSlots.Item.length)
}
#endif
inline void DmiSystemSlots_Item::set_length(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  length_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystemSlots.Item.length)
}
inline void DmiSystemSlots_Item::set_length(const char* value, size_t size) {
  
  length_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystemSlots.Item.length)
}
inline ::std::string* DmiSystemSlots_Item::mutable_length() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystemSlots.Item.length)
  return length_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystemSlots_Item::release_length() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystemSlots.Item.length)
  
  return length_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystemSlots_Item::set_allocated_length(::std::string* length) {
  if (length != NULL) {
    
  } else {
    
  }
  length_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), length);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystemSlots.Item.length)
}

// -------------------------------------------------------------------

// DmiSystemSlots

// repeated .aspia.proto.DmiSystemSlots.Item item = 1;
inline int DmiSystemSlots::item_size() const {
  return item_.size();
}
inline void DmiSystemSlots::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiSystemSlots_Item& DmiSystemSlots::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiSystemSlots_Item* DmiSystemSlots::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystemSlots.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiSystemSlots_Item* DmiSystemSlots::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiSystemSlots.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item >*
DmiSystemSlots::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiSystemSlots.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item >&
DmiSystemSlots::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiSystemSlots.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiPortConnectors_Item

// string internal_designation = 1;
inline void DmiPortConnectors_Item::clear_internal_designation() {
  internal_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnectors_Item::internal_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.internal_designation)
  return internal_designation_.GetNoArena();
}
inline void DmiPortConnectors_Item::set_internal_designation(const ::std::string& value) {
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
#if LANG_CXX11
inline void DmiPortConnectors_Item::set_internal_designation(::std::string&& value) {
  
  internal_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
#endif
inline void DmiPortConnectors_Item::set_internal_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
inline void DmiPortConnectors_Item::set_internal_designation(const char* value, size_t size) {
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
inline ::std::string* DmiPortConnectors_Item::mutable_internal_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.Item.internal_designation)
  return internal_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnectors_Item::release_internal_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnectors.Item.internal_designation)
  
  return internal_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnectors_Item::set_allocated_internal_designation(::std::string* internal_designation) {
  if (internal_designation != NULL) {
    
  } else {
    
  }
  internal_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), internal_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnectors.Item.internal_designation)
}

// string external_designation = 2;
inline void DmiPortConnectors_Item::clear_external_designation() {
  external_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnectors_Item::external_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.external_designation)
  return external_designation_.GetNoArena();
}
inline void DmiPortConnectors_Item::set_external_designation(const ::std::string& value) {
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.external_designation)
}
#if LANG_CXX11
inline void DmiPortConnectors_Item::set_external_designation(::std::string&& value) {
  
  external_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnectors.Item.external_designation)
}
#endif
inline void DmiPortConnectors_Item::set_external_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnectors.Item.external_designation)
}
inline void DmiPortConnectors_Item::set_external_designation(const char* value, size_t size) {
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnectors.Item.external_designation)
}
inline ::std::string* DmiPortConnectors_Item::mutable_external_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.Item.external_designation)
  return external_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnectors_Item::release_external_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnectors.Item.external_designation)
  
  return external_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnectors_Item::set_allocated_external_designation(::std::string* external_designation) {
  if (external_designation != NULL) {
    
  } else {
    
  }
  external_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), external_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnectors.Item.external_designation)
}

// string type = 3;
inline void DmiPortConnectors_Item::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnectors_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.type)
  return type_.GetNoArena();
}
inline void DmiPortConnectors_Item::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.type)
}
#if LANG_CXX11
inline void DmiPortConnectors_Item::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnectors.Item.type)
}
#endif
inline void DmiPortConnectors_Item::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnectors.Item.type)
}
inline void DmiPortConnectors_Item::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnectors.Item.type)
}
inline ::std::string* DmiPortConnectors_Item::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.Item.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnectors_Item::release_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnectors.Item.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnectors_Item::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnectors.Item.type)
}

// string internal_connector_type = 4;
inline void DmiPortConnectors_Item::clear_internal_connector_type() {
  internal_connector_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnectors_Item::internal_connector_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
  return internal_connector_type_.GetNoArena();
}
inline void DmiPortConnectors_Item::set_internal_connector_type(const ::std::string& value) {
  
  internal_connector_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
}
#if LANG_CXX11
inline void DmiPortConnectors_Item::set_internal_connector_type(::std::string&& value) {
  
  internal_connector_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
}
#endif
inline void DmiPortConnectors_Item::set_internal_connector_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  internal_connector_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
}
inline void DmiPortConnectors_Item::set_internal_connector_type(const char* value, size_t size) {
  
  internal_connector_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
}
inline ::std::string* DmiPortConnectors_Item::mutable_internal_connector_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
  return internal_connector_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnectors_Item::release_internal_connector_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
  
  return internal_connector_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnectors_Item::set_allocated_internal_connector_type(::std::string* internal_connector_type) {
  if (internal_connector_type != NULL) {
    
  } else {
    
  }
  internal_connector_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), internal_connector_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
}

// string external_connector_type = 5;
inline void DmiPortConnectors_Item::clear_external_connector_type() {
  external_connector_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnectors_Item::external_connector_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.external_connector_type)
  return external_connector_type_.GetNoArena();
}
inline void DmiPortConnectors_Item::set_external_connector_type(const ::std::string& value) {
  
  external_connector_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.external_connector_type)
}
#if LANG_CXX11
inline void DmiPortConnectors_Item::set_external_connector_type(::std::string&& value) {
  
  external_connector_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnectors.Item.external_connector_type)
}
#endif
inline void DmiPortConnectors_Item::set_external_connector_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  external_connector_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnectors.Item.external_connector_type)
}
inline void DmiPortConnectors_Item::set_external_connector_type(const char* value, size_t size) {
  
  external_connector_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnectors.Item.external_connector_type)
}
inline ::std::string* DmiPortConnectors_Item::mutable_external_connector_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.Item.external_connector_type)
  return external_connector_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnectors_Item::release_external_connector_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnectors.Item.external_connector_type)
  
  return external_connector_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnectors_Item::set_allocated_external_connector_type(::std::string* external_connector_type) {
  if (external_connector_type != NULL) {
    
  } else {
    
  }
  external_connector_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), external_connector_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnectors.Item.external_connector_type)
}

// -------------------------------------------------------------------

// DmiPortConnectors

// repeated .aspia.proto.DmiPortConnectors.Item item = 1;
inline int DmiPortConnectors::item_size() const {
  return item_.size();
}
inline void DmiPortConnectors::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiPortConnectors_Item& DmiPortConnectors::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiPortConnectors_Item* DmiPortConnectors::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiPortConnectors_Item* DmiPortConnectors::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiPortConnectors.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >*
DmiPortConnectors::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiPortConnectors.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >&
DmiPortConnectors::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiPortConnectors.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiOnBoardDevices_Item

// string description = 1;
inline void DmiOnBoardDevices_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiOnBoardDevices_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.Item.description)
  return description_.GetNoArena();
}
inline void DmiOnBoardDevices_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiOnBoardDevices.Item.description)
}
#if LANG_CXX11
inline void DmiOnBoardDevices_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiOnBoardDevices.Item.description)
}
#endif
inline void DmiOnBoardDevices_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiOnBoardDevices.Item.description)
}
inline void DmiOnBoardDevices_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiOnBoardDevices.Item.description)
}
inline ::std::string* DmiOnBoardDevices_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiOnBoardDevices.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiOnBoardDevices_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiOnBoardDevices.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiOnBoardDevices_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiOnBoardDevices.Item.description)
}

// string type = 2;
inline void DmiOnBoardDevices_Item::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiOnBoardDevices_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.Item.type)
  return type_.GetNoArena();
}
inline void DmiOnBoardDevices_Item::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiOnBoardDevices.Item.type)
}
#if LANG_CXX11
inline void DmiOnBoardDevices_Item::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiOnBoardDevices.Item.type)
}
#endif
inline void DmiOnBoardDevices_Item::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiOnBoardDevices.Item.type)
}
inline void DmiOnBoardDevices_Item::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiOnBoardDevices.Item.type)
}
inline ::std::string* DmiOnBoardDevices_Item::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiOnBoardDevices.Item.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiOnBoardDevices_Item::release_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiOnBoardDevices.Item.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiOnBoardDevices_Item::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiOnBoardDevices.Item.type)
}

// bool enabled = 3;
inline void DmiOnBoardDevices_Item::clear_enabled() {
  enabled_ = false;
}
inline bool DmiOnBoardDevices_Item::enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.Item.enabled)
  return enabled_;
}
inline void DmiOnBoardDevices_Item::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiOnBoardDevices.Item.enabled)
}

// -------------------------------------------------------------------

// DmiOnBoardDevices

// repeated .aspia.proto.DmiOnBoardDevices.Item item = 1;
inline int DmiOnBoardDevices::item_size() const {
  return item_.size();
}
inline void DmiOnBoardDevices::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiOnBoardDevices_Item& DmiOnBoardDevices::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiOnBoardDevices_Item* DmiOnBoardDevices::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiOnBoardDevices.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiOnBoardDevices_Item* DmiOnBoardDevices::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiOnBoardDevices.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >*
DmiOnBoardDevices::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiOnBoardDevices.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >&
DmiOnBoardDevices::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiOnBoardDevices.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiBuildinPointing_Item

// string device_type = 1;
inline void DmiBuildinPointing_Item::clear_device_type() {
  device_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBuildinPointing_Item::device_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBuildinPointing.Item.device_type)
  return device_type_.GetNoArena();
}
inline void DmiBuildinPointing_Item::set_device_type(const ::std::string& value) {
  
  device_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBuildinPointing.Item.device_type)
}
#if LANG_CXX11
inline void DmiBuildinPointing_Item::set_device_type(::std::string&& value) {
  
  device_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBuildinPointing.Item.device_type)
}
#endif
inline void DmiBuildinPointing_Item::set_device_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBuildinPointing.Item.device_type)
}
inline void DmiBuildinPointing_Item::set_device_type(const char* value, size_t size) {
  
  device_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBuildinPointing.Item.device_type)
}
inline ::std::string* DmiBuildinPointing_Item::mutable_device_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBuildinPointing.Item.device_type)
  return device_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBuildinPointing_Item::release_device_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBuildinPointing.Item.device_type)
  
  return device_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBuildinPointing_Item::set_allocated_device_type(::std::string* device_type) {
  if (device_type != NULL) {
    
  } else {
    
  }
  device_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBuildinPointing.Item.device_type)
}

// string device_interface = 2;
inline void DmiBuildinPointing_Item::clear_device_interface() {
  device_interface_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBuildinPointing_Item::device_interface() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBuildinPointing.Item.device_interface)
  return device_interface_.GetNoArena();
}
inline void DmiBuildinPointing_Item::set_device_interface(const ::std::string& value) {
  
  device_interface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBuildinPointing.Item.device_interface)
}
#if LANG_CXX11
inline void DmiBuildinPointing_Item::set_device_interface(::std::string&& value) {
  
  device_interface_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBuildinPointing.Item.device_interface)
}
#endif
inline void DmiBuildinPointing_Item::set_device_interface(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_interface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBuildinPointing.Item.device_interface)
}
inline void DmiBuildinPointing_Item::set_device_interface(const char* value, size_t size) {
  
  device_interface_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBuildinPointing.Item.device_interface)
}
inline ::std::string* DmiBuildinPointing_Item::mutable_device_interface() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBuildinPointing.Item.device_interface)
  return device_interface_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBuildinPointing_Item::release_device_interface() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBuildinPointing.Item.device_interface)
  
  return device_interface_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBuildinPointing_Item::set_allocated_device_interface(::std::string* device_interface) {
  if (device_interface != NULL) {
    
  } else {
    
  }
  device_interface_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_interface);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBuildinPointing.Item.device_interface)
}

// int32 button_count = 3;
inline void DmiBuildinPointing_Item::clear_button_count() {
  button_count_ = 0;
}
inline ::google::protobuf::int32 DmiBuildinPointing_Item::button_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBuildinPointing.Item.button_count)
  return button_count_;
}
inline void DmiBuildinPointing_Item::set_button_count(::google::protobuf::int32 value) {
  
  button_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBuildinPointing.Item.button_count)
}

// -------------------------------------------------------------------

// DmiBuildinPointing

// repeated .aspia.proto.DmiBuildinPointing.Item item = 1;
inline int DmiBuildinPointing::item_size() const {
  return item_.size();
}
inline void DmiBuildinPointing::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiBuildinPointing_Item& DmiBuildinPointing::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBuildinPointing.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiBuildinPointing_Item* DmiBuildinPointing::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBuildinPointing.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiBuildinPointing_Item* DmiBuildinPointing::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiBuildinPointing.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBuildinPointing_Item >*
DmiBuildinPointing::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiBuildinPointing.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBuildinPointing_Item >&
DmiBuildinPointing::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiBuildinPointing.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiPortableBattery_Item

// string location = 1;
inline void DmiPortableBattery_Item::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.location)
  return location_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.location)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.location)
}
#endif
inline void DmiPortableBattery_Item::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.location)
}
inline void DmiPortableBattery_Item::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.location)
}
inline ::std::string* DmiPortableBattery_Item::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_location() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.location)
}

// string manufacturer = 2;
inline void DmiPortableBattery_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
#endif
inline void DmiPortableBattery_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
inline void DmiPortableBattery_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
inline ::std::string* DmiPortableBattery_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.manufacturer)
}

// string manufacture_date = 3;
inline void DmiPortableBattery_Item::clear_manufacture_date() {
  manufacture_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::manufacture_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.manufacture_date)
  return manufacture_date_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_manufacture_date(const ::std::string& value) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_manufacture_date(::std::string&& value) {
  
  manufacture_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
#endif
inline void DmiPortableBattery_Item::set_manufacture_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
inline void DmiPortableBattery_Item::set_manufacture_date(const char* value, size_t size) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
inline ::std::string* DmiPortableBattery_Item::mutable_manufacture_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.manufacture_date)
  return manufacture_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_manufacture_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.manufacture_date)
  
  return manufacture_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_manufacture_date(::std::string* manufacture_date) {
  if (manufacture_date != NULL) {
    
  } else {
    
  }
  manufacture_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacture_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}

// string serial_number = 4;
inline void DmiPortableBattery_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.serial_number)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.serial_number)
}
#endif
inline void DmiPortableBattery_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.serial_number)
}
inline void DmiPortableBattery_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.serial_number)
}
inline ::std::string* DmiPortableBattery_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.serial_number)
}

// string device_name = 5;
inline void DmiPortableBattery_Item::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::device_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.device_name)
  return device_name_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_device_name(const ::std::string& value) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.device_name)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_device_name(::std::string&& value) {
  
  device_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.device_name)
}
#endif
inline void DmiPortableBattery_Item::set_device_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.device_name)
}
inline void DmiPortableBattery_Item::set_device_name(const char* value, size_t size) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.device_name)
}
inline ::std::string* DmiPortableBattery_Item::mutable_device_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_device_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.device_name)
  
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    
  } else {
    
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.device_name)
}

// string chemistry = 6;
inline void DmiPortableBattery_Item::clear_chemistry() {
  chemistry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::chemistry() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.chemistry)
  return chemistry_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_chemistry(const ::std::string& value) {
  
  chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.chemistry)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_chemistry(::std::string&& value) {
  
  chemistry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.chemistry)
}
#endif
inline void DmiPortableBattery_Item::set_chemistry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.chemistry)
}
inline void DmiPortableBattery_Item::set_chemistry(const char* value, size_t size) {
  
  chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.chemistry)
}
inline ::std::string* DmiPortableBattery_Item::mutable_chemistry() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.chemistry)
  return chemistry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_chemistry() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.chemistry)
  
  return chemistry_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_chemistry(::std::string* chemistry) {
  if (chemistry != NULL) {
    
  } else {
    
  }
  chemistry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chemistry);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.chemistry)
}

// int32 design_capacity = 7;
inline void DmiPortableBattery_Item::clear_design_capacity() {
  design_capacity_ = 0;
}
inline ::google::protobuf::int32 DmiPortableBattery_Item::design_capacity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.design_capacity)
  return design_capacity_;
}
inline void DmiPortableBattery_Item::set_design_capacity(::google::protobuf::int32 value) {
  
  design_capacity_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.design_capacity)
}

// int32 design_voltage = 8;
inline void DmiPortableBattery_Item::clear_design_voltage() {
  design_voltage_ = 0;
}
inline ::google::protobuf::int32 DmiPortableBattery_Item::design_voltage() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.design_voltage)
  return design_voltage_;
}
inline void DmiPortableBattery_Item::set_design_voltage(::google::protobuf::int32 value) {
  
  design_voltage_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.design_voltage)
}

// string sbds_version_number = 9;
inline void DmiPortableBattery_Item::clear_sbds_version_number() {
  sbds_version_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_version_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
  return sbds_version_number_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_version_number(const ::std::string& value) {
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_version_number(::std::string&& value) {
  
  sbds_version_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_version_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
inline void DmiPortableBattery_Item::set_sbds_version_number(const char* value, size_t size) {
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_version_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
  return sbds_version_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_version_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
  
  return sbds_version_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_version_number(::std::string* sbds_version_number) {
  if (sbds_version_number != NULL) {
    
  } else {
    
  }
  sbds_version_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_version_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}

// int32 max_error_in_battery_data = 10;
inline void DmiPortableBattery_Item::clear_max_error_in_battery_data() {
  max_error_in_battery_data_ = 0;
}
inline ::google::protobuf::int32 DmiPortableBattery_Item::max_error_in_battery_data() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.max_error_in_battery_data)
  return max_error_in_battery_data_;
}
inline void DmiPortableBattery_Item::set_max_error_in_battery_data(::google::protobuf::int32 value) {
  
  max_error_in_battery_data_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.max_error_in_battery_data)
}

// string sbds_serial_number = 11;
inline void DmiPortableBattery_Item::clear_sbds_serial_number() {
  sbds_serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
  return sbds_serial_number_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_serial_number(const ::std::string& value) {
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_serial_number(::std::string&& value) {
  
  sbds_serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
inline void DmiPortableBattery_Item::set_sbds_serial_number(const char* value, size_t size) {
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
  return sbds_serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
  
  return sbds_serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_serial_number(::std::string* sbds_serial_number) {
  if (sbds_serial_number != NULL) {
    
  } else {
    
  }
  sbds_serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}

// string sbds_manufacture_date = 12;
inline void DmiPortableBattery_Item::clear_sbds_manufacture_date() {
  sbds_manufacture_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_manufacture_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
  return sbds_manufacture_date_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(const ::std::string& value) {
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(::std::string&& value) {
  
  sbds_manufacture_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(const char* value, size_t size) {
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_manufacture_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
  return sbds_manufacture_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_manufacture_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
  
  return sbds_manufacture_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_manufacture_date(::std::string* sbds_manufacture_date) {
  if (sbds_manufacture_date != NULL) {
    
  } else {
    
  }
  sbds_manufacture_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_manufacture_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}

// string sbds_device_chemistry = 13;
inline void DmiPortableBattery_Item::clear_sbds_device_chemistry() {
  sbds_device_chemistry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_device_chemistry() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
  return sbds_device_chemistry_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(const ::std::string& value) {
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(::std::string&& value) {
  
  sbds_device_chemistry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(const char* value, size_t size) {
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_device_chemistry() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
  return sbds_device_chemistry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_device_chemistry() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
  
  return sbds_device_chemistry_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_device_chemistry(::std::string* sbds_device_chemistry) {
  if (sbds_device_chemistry != NULL) {
    
  } else {
    
  }
  sbds_device_chemistry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_device_chemistry);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}

// -------------------------------------------------------------------

// DmiPortableBattery

// repeated .aspia.proto.DmiPortableBattery.Item item = 1;
inline int DmiPortableBattery::item_size() const {
  return item_.size();
}
inline void DmiPortableBattery::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiPortableBattery_Item& DmiPortableBattery::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiPortableBattery_Item* DmiPortableBattery::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiPortableBattery_Item* DmiPortableBattery::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiPortableBattery.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >*
DmiPortableBattery::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiPortableBattery.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >&
DmiPortableBattery::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiPortableBattery.item)
  return item_;
}

// -------------------------------------------------------------------

// AtaDrives_Item_Feature

// string name = 1;
inline void AtaDrives_Item_Feature::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AtaDrives_Item_Feature::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.Feature.name)
  return name_.GetNoArena();
}
inline void AtaDrives_Item_Feature::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.Feature.name)
}
#if LANG_CXX11
inline void AtaDrives_Item_Feature::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.AtaDrives.Item.Feature.name)
}
#endif
inline void AtaDrives_Item_Feature::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.AtaDrives.Item.Feature.name)
}
inline void AtaDrives_Item_Feature::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.AtaDrives.Item.Feature.name)
}
inline ::std::string* AtaDrives_Item_Feature::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.AtaDrives.Item.Feature.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AtaDrives_Item_Feature::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.AtaDrives.Item.Feature.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AtaDrives_Item_Feature::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.AtaDrives.Item.Feature.name)
}

// bool enabled = 2;
inline void AtaDrives_Item_Feature::clear_enabled() {
  enabled_ = false;
}
inline bool AtaDrives_Item_Feature::enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.Feature.enabled)
  return enabled_;
}
inline void AtaDrives_Item_Feature::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.Feature.enabled)
}

// -------------------------------------------------------------------

// AtaDrives_Item

// string model_number = 1;
inline void AtaDrives_Item::clear_model_number() {
  model_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AtaDrives_Item::model_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.model_number)
  return model_number_.GetNoArena();
}
inline void AtaDrives_Item::set_model_number(const ::std::string& value) {
  
  model_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.model_number)
}
#if LANG_CXX11
inline void AtaDrives_Item::set_model_number(::std::string&& value) {
  
  model_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.AtaDrives.Item.model_number)
}
#endif
inline void AtaDrives_Item::set_model_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  model_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.AtaDrives.Item.model_number)
}
inline void AtaDrives_Item::set_model_number(const char* value, size_t size) {
  
  model_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.AtaDrives.Item.model_number)
}
inline ::std::string* AtaDrives_Item::mutable_model_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.AtaDrives.Item.model_number)
  return model_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AtaDrives_Item::release_model_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.AtaDrives.Item.model_number)
  
  return model_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AtaDrives_Item::set_allocated_model_number(::std::string* model_number) {
  if (model_number != NULL) {
    
  } else {
    
  }
  model_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.AtaDrives.Item.model_number)
}

// string serial_number = 2;
inline void AtaDrives_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AtaDrives_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void AtaDrives_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.serial_number)
}
#if LANG_CXX11
inline void AtaDrives_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.AtaDrives.Item.serial_number)
}
#endif
inline void AtaDrives_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.AtaDrives.Item.serial_number)
}
inline void AtaDrives_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.AtaDrives.Item.serial_number)
}
inline ::std::string* AtaDrives_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.AtaDrives.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AtaDrives_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.AtaDrives.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AtaDrives_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.AtaDrives.Item.serial_number)
}

// string firmware_revision = 3;
inline void AtaDrives_Item::clear_firmware_revision() {
  firmware_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AtaDrives_Item::firmware_revision() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.firmware_revision)
  return firmware_revision_.GetNoArena();
}
inline void AtaDrives_Item::set_firmware_revision(const ::std::string& value) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.firmware_revision)
}
#if LANG_CXX11
inline void AtaDrives_Item::set_firmware_revision(::std::string&& value) {
  
  firmware_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.AtaDrives.Item.firmware_revision)
}
#endif
inline void AtaDrives_Item::set_firmware_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.AtaDrives.Item.firmware_revision)
}
inline void AtaDrives_Item::set_firmware_revision(const char* value, size_t size) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.AtaDrives.Item.firmware_revision)
}
inline ::std::string* AtaDrives_Item::mutable_firmware_revision() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.AtaDrives.Item.firmware_revision)
  return firmware_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AtaDrives_Item::release_firmware_revision() {
  // @@protoc_insertion_point(field_release:aspia.proto.AtaDrives.Item.firmware_revision)
  
  return firmware_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AtaDrives_Item::set_allocated_firmware_revision(::std::string* firmware_revision) {
  if (firmware_revision != NULL) {
    
  } else {
    
  }
  firmware_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_revision);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.AtaDrives.Item.firmware_revision)
}

// string bus_type = 4;
inline void AtaDrives_Item::clear_bus_type() {
  bus_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AtaDrives_Item::bus_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.bus_type)
  return bus_type_.GetNoArena();
}
inline void AtaDrives_Item::set_bus_type(const ::std::string& value) {
  
  bus_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.bus_type)
}
#if LANG_CXX11
inline void AtaDrives_Item::set_bus_type(::std::string&& value) {
  
  bus_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.AtaDrives.Item.bus_type)
}
#endif
inline void AtaDrives_Item::set_bus_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bus_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.AtaDrives.Item.bus_type)
}
inline void AtaDrives_Item::set_bus_type(const char* value, size_t size) {
  
  bus_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.AtaDrives.Item.bus_type)
}
inline ::std::string* AtaDrives_Item::mutable_bus_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.AtaDrives.Item.bus_type)
  return bus_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AtaDrives_Item::release_bus_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.AtaDrives.Item.bus_type)
  
  return bus_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AtaDrives_Item::set_allocated_bus_type(::std::string* bus_type) {
  if (bus_type != NULL) {
    
  } else {
    
  }
  bus_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bus_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.AtaDrives.Item.bus_type)
}

// string transfer_mode = 5;
inline void AtaDrives_Item::clear_transfer_mode() {
  transfer_mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AtaDrives_Item::transfer_mode() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.transfer_mode)
  return transfer_mode_.GetNoArena();
}
inline void AtaDrives_Item::set_transfer_mode(const ::std::string& value) {
  
  transfer_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.transfer_mode)
}
#if LANG_CXX11
inline void AtaDrives_Item::set_transfer_mode(::std::string&& value) {
  
  transfer_mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.AtaDrives.Item.transfer_mode)
}
#endif
inline void AtaDrives_Item::set_transfer_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  transfer_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.AtaDrives.Item.transfer_mode)
}
inline void AtaDrives_Item::set_transfer_mode(const char* value, size_t size) {
  
  transfer_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.AtaDrives.Item.transfer_mode)
}
inline ::std::string* AtaDrives_Item::mutable_transfer_mode() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.AtaDrives.Item.transfer_mode)
  return transfer_mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AtaDrives_Item::release_transfer_mode() {
  // @@protoc_insertion_point(field_release:aspia.proto.AtaDrives.Item.transfer_mode)
  
  return transfer_mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AtaDrives_Item::set_allocated_transfer_mode(::std::string* transfer_mode) {
  if (transfer_mode != NULL) {
    
  } else {
    
  }
  transfer_mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transfer_mode);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.AtaDrives.Item.transfer_mode)
}

// uint32 rotation_rate = 6;
inline void AtaDrives_Item::clear_rotation_rate() {
  rotation_rate_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::rotation_rate() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.rotation_rate)
  return rotation_rate_;
}
inline void AtaDrives_Item::set_rotation_rate(::google::protobuf::uint32 value) {
  
  rotation_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.rotation_rate)
}

// uint64 drive_size = 7;
inline void AtaDrives_Item::clear_drive_size() {
  drive_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AtaDrives_Item::drive_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.drive_size)
  return drive_size_;
}
inline void AtaDrives_Item::set_drive_size(::google::protobuf::uint64 value) {
  
  drive_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.drive_size)
}

// uint32 buffer_size = 8;
inline void AtaDrives_Item::clear_buffer_size() {
  buffer_size_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::buffer_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.buffer_size)
  return buffer_size_;
}
inline void AtaDrives_Item::set_buffer_size(::google::protobuf::uint32 value) {
  
  buffer_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.buffer_size)
}

// uint32 multisectors = 9;
inline void AtaDrives_Item::clear_multisectors() {
  multisectors_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::multisectors() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.multisectors)
  return multisectors_;
}
inline void AtaDrives_Item::set_multisectors(::google::protobuf::uint32 value) {
  
  multisectors_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.multisectors)
}

// uint32 ecc_size = 10;
inline void AtaDrives_Item::clear_ecc_size() {
  ecc_size_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::ecc_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.ecc_size)
  return ecc_size_;
}
inline void AtaDrives_Item::set_ecc_size(::google::protobuf::uint32 value) {
  
  ecc_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.ecc_size)
}

// bool is_removable = 11;
inline void AtaDrives_Item::clear_is_removable() {
  is_removable_ = false;
}
inline bool AtaDrives_Item::is_removable() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.is_removable)
  return is_removable_;
}
inline void AtaDrives_Item::set_is_removable(bool value) {
  
  is_removable_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.is_removable)
}

// uint64 cylinders_number = 12;
inline void AtaDrives_Item::clear_cylinders_number() {
  cylinders_number_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AtaDrives_Item::cylinders_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.cylinders_number)
  return cylinders_number_;
}
inline void AtaDrives_Item::set_cylinders_number(::google::protobuf::uint64 value) {
  
  cylinders_number_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.cylinders_number)
}

// uint32 tracks_per_cylinder = 13;
inline void AtaDrives_Item::clear_tracks_per_cylinder() {
  tracks_per_cylinder_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::tracks_per_cylinder() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.tracks_per_cylinder)
  return tracks_per_cylinder_;
}
inline void AtaDrives_Item::set_tracks_per_cylinder(::google::protobuf::uint32 value) {
  
  tracks_per_cylinder_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.tracks_per_cylinder)
}

// uint32 sectors_per_track = 14;
inline void AtaDrives_Item::clear_sectors_per_track() {
  sectors_per_track_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::sectors_per_track() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.sectors_per_track)
  return sectors_per_track_;
}
inline void AtaDrives_Item::set_sectors_per_track(::google::protobuf::uint32 value) {
  
  sectors_per_track_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.sectors_per_track)
}

// uint32 bytes_per_sector = 15;
inline void AtaDrives_Item::clear_bytes_per_sector() {
  bytes_per_sector_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::bytes_per_sector() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.bytes_per_sector)
  return bytes_per_sector_;
}
inline void AtaDrives_Item::set_bytes_per_sector(::google::protobuf::uint32 value) {
  
  bytes_per_sector_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.bytes_per_sector)
}

// uint32 heads_number = 16;
inline void AtaDrives_Item::clear_heads_number() {
  heads_number_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::heads_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.heads_number)
  return heads_number_;
}
inline void AtaDrives_Item::set_heads_number(::google::protobuf::uint32 value) {
  
  heads_number_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.heads_number)
}

// repeated .aspia.proto.AtaDrives.Item.Feature feature = 17;
inline int AtaDrives_Item::feature_size() const {
  return feature_.size();
}
inline void AtaDrives_Item::clear_feature() {
  feature_.Clear();
}
inline const ::aspia::proto::AtaDrives_Item_Feature& AtaDrives_Item::feature(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.feature)
  return feature_.Get(index);
}
inline ::aspia::proto::AtaDrives_Item_Feature* AtaDrives_Item::mutable_feature(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.AtaDrives.Item.feature)
  return feature_.Mutable(index);
}
inline ::aspia::proto::AtaDrives_Item_Feature* AtaDrives_Item::add_feature() {
  // @@protoc_insertion_point(field_add:aspia.proto.AtaDrives.Item.feature)
  return feature_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item_Feature >*
AtaDrives_Item::mutable_feature() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.AtaDrives.Item.feature)
  return &feature_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item_Feature >&
AtaDrives_Item::feature() const {
  // @@protoc_insertion_point(field_list:aspia.proto.AtaDrives.Item.feature)
  return feature_;
}

// -------------------------------------------------------------------

// AtaDrives

// repeated .aspia.proto.AtaDrives.Item item = 1;
inline int AtaDrives::item_size() const {
  return item_.size();
}
inline void AtaDrives::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::AtaDrives_Item& AtaDrives::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.item)
  return item_.Get(index);
}
inline ::aspia::proto::AtaDrives_Item* AtaDrives::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.AtaDrives.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::AtaDrives_Item* AtaDrives::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.AtaDrives.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item >*
AtaDrives::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.AtaDrives.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item >&
AtaDrives::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.AtaDrives.item)
  return item_;
}

// -------------------------------------------------------------------

// VideoAdapters_Item

// string description = 1;
inline void VideoAdapters_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.description)
  return description_.GetNoArena();
}
inline void VideoAdapters_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.description)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.description)
}
#endif
inline void VideoAdapters_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.description)
}
inline void VideoAdapters_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.description)
}
inline ::std::string* VideoAdapters_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.description)
}

// string adapter_string = 2;
inline void VideoAdapters_Item::clear_adapter_string() {
  adapter_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::adapter_string() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.adapter_string)
  return adapter_string_.GetNoArena();
}
inline void VideoAdapters_Item::set_adapter_string(const ::std::string& value) {
  
  adapter_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.adapter_string)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_adapter_string(::std::string&& value) {
  
  adapter_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.adapter_string)
}
#endif
inline void VideoAdapters_Item::set_adapter_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  adapter_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.adapter_string)
}
inline void VideoAdapters_Item::set_adapter_string(const char* value, size_t size) {
  
  adapter_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.adapter_string)
}
inline ::std::string* VideoAdapters_Item::mutable_adapter_string() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.adapter_string)
  return adapter_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_adapter_string() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.adapter_string)
  
  return adapter_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_adapter_string(::std::string* adapter_string) {
  if (adapter_string != NULL) {
    
  } else {
    
  }
  adapter_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adapter_string);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.adapter_string)
}

// string bios_string = 3;
inline void VideoAdapters_Item::clear_bios_string() {
  bios_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::bios_string() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.bios_string)
  return bios_string_.GetNoArena();
}
inline void VideoAdapters_Item::set_bios_string(const ::std::string& value) {
  
  bios_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.bios_string)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_bios_string(::std::string&& value) {
  
  bios_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.bios_string)
}
#endif
inline void VideoAdapters_Item::set_bios_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bios_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.bios_string)
}
inline void VideoAdapters_Item::set_bios_string(const char* value, size_t size) {
  
  bios_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.bios_string)
}
inline ::std::string* VideoAdapters_Item::mutable_bios_string() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.bios_string)
  return bios_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_bios_string() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.bios_string)
  
  return bios_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_bios_string(::std::string* bios_string) {
  if (bios_string != NULL) {
    
  } else {
    
  }
  bios_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bios_string);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.bios_string)
}

// string chip_type = 4;
inline void VideoAdapters_Item::clear_chip_type() {
  chip_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::chip_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.chip_type)
  return chip_type_.GetNoArena();
}
inline void VideoAdapters_Item::set_chip_type(const ::std::string& value) {
  
  chip_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.chip_type)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_chip_type(::std::string&& value) {
  
  chip_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.chip_type)
}
#endif
inline void VideoAdapters_Item::set_chip_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chip_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.chip_type)
}
inline void VideoAdapters_Item::set_chip_type(const char* value, size_t size) {
  
  chip_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.chip_type)
}
inline ::std::string* VideoAdapters_Item::mutable_chip_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.chip_type)
  return chip_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_chip_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.chip_type)
  
  return chip_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_chip_type(::std::string* chip_type) {
  if (chip_type != NULL) {
    
  } else {
    
  }
  chip_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chip_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.chip_type)
}

// string dac_type = 5;
inline void VideoAdapters_Item::clear_dac_type() {
  dac_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::dac_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.dac_type)
  return dac_type_.GetNoArena();
}
inline void VideoAdapters_Item::set_dac_type(const ::std::string& value) {
  
  dac_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.dac_type)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_dac_type(::std::string&& value) {
  
  dac_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.dac_type)
}
#endif
inline void VideoAdapters_Item::set_dac_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dac_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.dac_type)
}
inline void VideoAdapters_Item::set_dac_type(const char* value, size_t size) {
  
  dac_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.dac_type)
}
inline ::std::string* VideoAdapters_Item::mutable_dac_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.dac_type)
  return dac_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_dac_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.dac_type)
  
  return dac_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_dac_type(::std::string* dac_type) {
  if (dac_type != NULL) {
    
  } else {
    
  }
  dac_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dac_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.dac_type)
}

// string driver_date = 6;
inline void VideoAdapters_Item::clear_driver_date() {
  driver_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::driver_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.driver_date)
  return driver_date_.GetNoArena();
}
inline void VideoAdapters_Item::set_driver_date(const ::std::string& value) {
  
  driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.driver_date)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_driver_date(::std::string&& value) {
  
  driver_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.driver_date)
}
#endif
inline void VideoAdapters_Item::set_driver_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.driver_date)
}
inline void VideoAdapters_Item::set_driver_date(const char* value, size_t size) {
  
  driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.driver_date)
}
inline ::std::string* VideoAdapters_Item::mutable_driver_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.driver_date)
  return driver_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_driver_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.driver_date)
  
  return driver_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_driver_date(::std::string* driver_date) {
  if (driver_date != NULL) {
    
  } else {
    
  }
  driver_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.driver_date)
}

// string driver_version = 7;
inline void VideoAdapters_Item::clear_driver_version() {
  driver_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::driver_version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.driver_version)
  return driver_version_.GetNoArena();
}
inline void VideoAdapters_Item::set_driver_version(const ::std::string& value) {
  
  driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.driver_version)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_driver_version(::std::string&& value) {
  
  driver_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.driver_version)
}
#endif
inline void VideoAdapters_Item::set_driver_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.driver_version)
}
inline void VideoAdapters_Item::set_driver_version(const char* value, size_t size) {
  
  driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.driver_version)
}
inline ::std::string* VideoAdapters_Item::mutable_driver_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.driver_version)
  return driver_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_driver_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.driver_version)
  
  return driver_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_driver_version(::std::string* driver_version) {
  if (driver_version != NULL) {
    
  } else {
    
  }
  driver_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.driver_version)
}

// string driver_provider = 8;
inline void VideoAdapters_Item::clear_driver_provider() {
  driver_provider_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::driver_provider() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.driver_provider)
  return driver_provider_.GetNoArena();
}
inline void VideoAdapters_Item::set_driver_provider(const ::std::string& value) {
  
  driver_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.driver_provider)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_driver_provider(::std::string&& value) {
  
  driver_provider_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.driver_provider)
}
#endif
inline void VideoAdapters_Item::set_driver_provider(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.driver_provider)
}
inline void VideoAdapters_Item::set_driver_provider(const char* value, size_t size) {
  
  driver_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.driver_provider)
}
inline ::std::string* VideoAdapters_Item::mutable_driver_provider() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.driver_provider)
  return driver_provider_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_driver_provider() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.driver_provider)
  
  return driver_provider_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_driver_provider(::std::string* driver_provider) {
  if (driver_provider != NULL) {
    
  } else {
    
  }
  driver_provider_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_provider);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.driver_provider)
}

// uint64 memory_size = 9;
inline void VideoAdapters_Item::clear_memory_size() {
  memory_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 VideoAdapters_Item::memory_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.memory_size)
  return memory_size_;
}
inline void VideoAdapters_Item::set_memory_size(::google::protobuf::uint64 value) {
  
  memory_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.memory_size)
}

// -------------------------------------------------------------------

// VideoAdapters

// repeated .aspia.proto.VideoAdapters.Item item = 1;
inline int VideoAdapters::item_size() const {
  return item_.size();
}
inline void VideoAdapters::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::VideoAdapters_Item& VideoAdapters::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.item)
  return item_.Get(index);
}
inline ::aspia::proto::VideoAdapters_Item* VideoAdapters::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::VideoAdapters_Item* VideoAdapters::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.VideoAdapters.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::VideoAdapters_Item >*
VideoAdapters::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.VideoAdapters.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::VideoAdapters_Item >&
VideoAdapters::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.VideoAdapters.item)
  return item_;
}

// -------------------------------------------------------------------

// Monitors_Item_Timing

// int32 width = 1;
inline void Monitors_Item_Timing::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item_Timing::width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.Timing.width)
  return width_;
}
inline void Monitors_Item_Timing::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.Timing.width)
}

// int32 height = 2;
inline void Monitors_Item_Timing::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item_Timing::height() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.Timing.height)
  return height_;
}
inline void Monitors_Item_Timing::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.Timing.height)
}

// int32 frequency = 3;
inline void Monitors_Item_Timing::clear_frequency() {
  frequency_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item_Timing::frequency() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.Timing.frequency)
  return frequency_;
}
inline void Monitors_Item_Timing::set_frequency(::google::protobuf::int32 value) {
  
  frequency_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.Timing.frequency)
}

// -------------------------------------------------------------------

// Monitors_Item

// string system_name = 1;
inline void Monitors_Item::clear_system_name() {
  system_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::system_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.system_name)
  return system_name_.GetNoArena();
}
inline void Monitors_Item::set_system_name(const ::std::string& value) {
  
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.system_name)
}
#if LANG_CXX11
inline void Monitors_Item::set_system_name(::std::string&& value) {
  
  system_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Monitors.Item.system_name)
}
#endif
inline void Monitors_Item::set_system_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Monitors.Item.system_name)
}
inline void Monitors_Item::set_system_name(const char* value, size_t size) {
  
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Monitors.Item.system_name)
}
inline ::std::string* Monitors_Item::mutable_system_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.system_name)
  return system_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_system_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Monitors.Item.system_name)
  
  return system_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_system_name(::std::string* system_name) {
  if (system_name != NULL) {
    
  } else {
    
  }
  system_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Monitors.Item.system_name)
}

// string monitor_name = 2;
inline void Monitors_Item::clear_monitor_name() {
  monitor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::monitor_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.monitor_name)
  return monitor_name_.GetNoArena();
}
inline void Monitors_Item::set_monitor_name(const ::std::string& value) {
  
  monitor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.monitor_name)
}
#if LANG_CXX11
inline void Monitors_Item::set_monitor_name(::std::string&& value) {
  
  monitor_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Monitors.Item.monitor_name)
}
#endif
inline void Monitors_Item::set_monitor_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  monitor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Monitors.Item.monitor_name)
}
inline void Monitors_Item::set_monitor_name(const char* value, size_t size) {
  
  monitor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Monitors.Item.monitor_name)
}
inline ::std::string* Monitors_Item::mutable_monitor_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.monitor_name)
  return monitor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_monitor_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Monitors.Item.monitor_name)
  
  return monitor_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_monitor_name(::std::string* monitor_name) {
  if (monitor_name != NULL) {
    
  } else {
    
  }
  monitor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), monitor_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Monitors.Item.monitor_name)
}

// string manufacturer_name = 3;
inline void Monitors_Item::clear_manufacturer_name() {
  manufacturer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::manufacturer_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.manufacturer_name)
  return manufacturer_name_.GetNoArena();
}
inline void Monitors_Item::set_manufacturer_name(const ::std::string& value) {
  
  manufacturer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.manufacturer_name)
}
#if LANG_CXX11
inline void Monitors_Item::set_manufacturer_name(::std::string&& value) {
  
  manufacturer_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Monitors.Item.manufacturer_name)
}
#endif
inline void Monitors_Item::set_manufacturer_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Monitors.Item.manufacturer_name)
}
inline void Monitors_Item::set_manufacturer_name(const char* value, size_t size) {
  
  manufacturer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Monitors.Item.manufacturer_name)
}
inline ::std::string* Monitors_Item::mutable_manufacturer_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.manufacturer_name)
  return manufacturer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_manufacturer_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Monitors.Item.manufacturer_name)
  
  return manufacturer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_manufacturer_name(::std::string* manufacturer_name) {
  if (manufacturer_name != NULL) {
    
  } else {
    
  }
  manufacturer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Monitors.Item.manufacturer_name)
}

// string monitor_id = 4;
inline void Monitors_Item::clear_monitor_id() {
  monitor_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::monitor_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.monitor_id)
  return monitor_id_.GetNoArena();
}
inline void Monitors_Item::set_monitor_id(const ::std::string& value) {
  
  monitor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.monitor_id)
}
#if LANG_CXX11
inline void Monitors_Item::set_monitor_id(::std::string&& value) {
  
  monitor_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Monitors.Item.monitor_id)
}
#endif
inline void Monitors_Item::set_monitor_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  monitor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Monitors.Item.monitor_id)
}
inline void Monitors_Item::set_monitor_id(const char* value, size_t size) {
  
  monitor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Monitors.Item.monitor_id)
}
inline ::std::string* Monitors_Item::mutable_monitor_id() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.monitor_id)
  return monitor_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_monitor_id() {
  // @@protoc_insertion_point(field_release:aspia.proto.Monitors.Item.monitor_id)
  
  return monitor_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_monitor_id(::std::string* monitor_id) {
  if (monitor_id != NULL) {
    
  } else {
    
  }
  monitor_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), monitor_id);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Monitors.Item.monitor_id)
}

// string serial_number = 5;
inline void Monitors_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void Monitors_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.serial_number)
}
#if LANG_CXX11
inline void Monitors_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Monitors.Item.serial_number)
}
#endif
inline void Monitors_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Monitors.Item.serial_number)
}
inline void Monitors_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Monitors.Item.serial_number)
}
inline ::std::string* Monitors_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.Monitors.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Monitors.Item.serial_number)
}

// int32 edid_version = 6;
inline void Monitors_Item::clear_edid_version() {
  edid_version_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::edid_version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.edid_version)
  return edid_version_;
}
inline void Monitors_Item::set_edid_version(::google::protobuf::int32 value) {
  
  edid_version_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.edid_version)
}

// int32 edid_revision = 7;
inline void Monitors_Item::clear_edid_revision() {
  edid_revision_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::edid_revision() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.edid_revision)
  return edid_revision_;
}
inline void Monitors_Item::set_edid_revision(::google::protobuf::int32 value) {
  
  edid_revision_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.edid_revision)
}

// int32 week_of_manufacture = 8;
inline void Monitors_Item::clear_week_of_manufacture() {
  week_of_manufacture_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::week_of_manufacture() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.week_of_manufacture)
  return week_of_manufacture_;
}
inline void Monitors_Item::set_week_of_manufacture(::google::protobuf::int32 value) {
  
  week_of_manufacture_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.week_of_manufacture)
}

// int32 year_of_manufacture = 9;
inline void Monitors_Item::clear_year_of_manufacture() {
  year_of_manufacture_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::year_of_manufacture() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.year_of_manufacture)
  return year_of_manufacture_;
}
inline void Monitors_Item::set_year_of_manufacture(::google::protobuf::int32 value) {
  
  year_of_manufacture_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.year_of_manufacture)
}

// int32 max_horizontal_image_size = 10;
inline void Monitors_Item::clear_max_horizontal_image_size() {
  max_horizontal_image_size_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_horizontal_image_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.max_horizontal_image_size)
  return max_horizontal_image_size_;
}
inline void Monitors_Item::set_max_horizontal_image_size(::google::protobuf::int32 value) {
  
  max_horizontal_image_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.max_horizontal_image_size)
}

// int32 max_vertical_image_size = 11;
inline void Monitors_Item::clear_max_vertical_image_size() {
  max_vertical_image_size_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_vertical_image_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.max_vertical_image_size)
  return max_vertical_image_size_;
}
inline void Monitors_Item::set_max_vertical_image_size(::google::protobuf::int32 value) {
  
  max_vertical_image_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.max_vertical_image_size)
}

// int32 horizontal_resolution = 12;
inline void Monitors_Item::clear_horizontal_resolution() {
  horizontal_resolution_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::horizontal_resolution() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.horizontal_resolution)
  return horizontal_resolution_;
}
inline void Monitors_Item::set_horizontal_resolution(::google::protobuf::int32 value) {
  
  horizontal_resolution_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.horizontal_resolution)
}

// int32 vertical_resoulution = 13;
inline void Monitors_Item::clear_vertical_resoulution() {
  vertical_resoulution_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::vertical_resoulution() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.vertical_resoulution)
  return vertical_resoulution_;
}
inline void Monitors_Item::set_vertical_resoulution(::google::protobuf::int32 value) {
  
  vertical_resoulution_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.vertical_resoulution)
}

// double gamma = 14;
inline void Monitors_Item::clear_gamma() {
  gamma_ = 0;
}
inline double Monitors_Item::gamma() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.gamma)
  return gamma_;
}
inline void Monitors_Item::set_gamma(double value) {
  
  gamma_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.gamma)
}

// int32 min_horizontal_rate = 15;
inline void Monitors_Item::clear_min_horizontal_rate() {
  min_horizontal_rate_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::min_horizontal_rate() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.min_horizontal_rate)
  return min_horizontal_rate_;
}
inline void Monitors_Item::set_min_horizontal_rate(::google::protobuf::int32 value) {
  
  min_horizontal_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.min_horizontal_rate)
}

// int32 max_horizontal_rate = 16;
inline void Monitors_Item::clear_max_horizontal_rate() {
  max_horizontal_rate_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_horizontal_rate() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.max_horizontal_rate)
  return max_horizontal_rate_;
}
inline void Monitors_Item::set_max_horizontal_rate(::google::protobuf::int32 value) {
  
  max_horizontal_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.max_horizontal_rate)
}

// int32 min_vertical_rate = 17;
inline void Monitors_Item::clear_min_vertical_rate() {
  min_vertical_rate_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::min_vertical_rate() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.min_vertical_rate)
  return min_vertical_rate_;
}
inline void Monitors_Item::set_min_vertical_rate(::google::protobuf::int32 value) {
  
  min_vertical_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.min_vertical_rate)
}

// int32 max_vertical_rate = 18;
inline void Monitors_Item::clear_max_vertical_rate() {
  max_vertical_rate_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_vertical_rate() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.max_vertical_rate)
  return max_vertical_rate_;
}
inline void Monitors_Item::set_max_vertical_rate(::google::protobuf::int32 value) {
  
  max_vertical_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.max_vertical_rate)
}

// double pixel_clock = 19;
inline void Monitors_Item::clear_pixel_clock() {
  pixel_clock_ = 0;
}
inline double Monitors_Item::pixel_clock() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.pixel_clock)
  return pixel_clock_;
}
inline void Monitors_Item::set_pixel_clock(double value) {
  
  pixel_clock_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.pixel_clock)
}

// int32 max_pixel_clock = 20;
inline void Monitors_Item::clear_max_pixel_clock() {
  max_pixel_clock_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_pixel_clock() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.max_pixel_clock)
  return max_pixel_clock_;
}
inline void Monitors_Item::set_max_pixel_clock(::google::protobuf::int32 value) {
  
  max_pixel_clock_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.max_pixel_clock)
}

// string input_signal_type = 21;
inline void Monitors_Item::clear_input_signal_type() {
  input_signal_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::input_signal_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.input_signal_type)
  return input_signal_type_.GetNoArena();
}
inline void Monitors_Item::set_input_signal_type(const ::std::string& value) {
  
  input_signal_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.input_signal_type)
}
#if LANG_CXX11
inline void Monitors_Item::set_input_signal_type(::std::string&& value) {
  
  input_signal_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Monitors.Item.input_signal_type)
}
#endif
inline void Monitors_Item::set_input_signal_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  input_signal_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Monitors.Item.input_signal_type)
}
inline void Monitors_Item::set_input_signal_type(const char* value, size_t size) {
  
  input_signal_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Monitors.Item.input_signal_type)
}
inline ::std::string* Monitors_Item::mutable_input_signal_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.input_signal_type)
  return input_signal_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_input_signal_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.Monitors.Item.input_signal_type)
  
  return input_signal_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_input_signal_type(::std::string* input_signal_type) {
  if (input_signal_type != NULL) {
    
  } else {
    
  }
  input_signal_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_signal_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Monitors.Item.input_signal_type)
}

// bool default_gtf_supported = 22;
inline void Monitors_Item::clear_default_gtf_supported() {
  default_gtf_supported_ = false;
}
inline bool Monitors_Item::default_gtf_supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.default_gtf_supported)
  return default_gtf_supported_;
}
inline void Monitors_Item::set_default_gtf_supported(bool value) {
  
  default_gtf_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.default_gtf_supported)
}

// bool suspend_supported = 23;
inline void Monitors_Item::clear_suspend_supported() {
  suspend_supported_ = false;
}
inline bool Monitors_Item::suspend_supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.suspend_supported)
  return suspend_supported_;
}
inline void Monitors_Item::set_suspend_supported(bool value) {
  
  suspend_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.suspend_supported)
}

// bool standby_supported = 24;
inline void Monitors_Item::clear_standby_supported() {
  standby_supported_ = false;
}
inline bool Monitors_Item::standby_supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.standby_supported)
  return standby_supported_;
}
inline void Monitors_Item::set_standby_supported(bool value) {
  
  standby_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.standby_supported)
}

// bool active_off_supported = 25;
inline void Monitors_Item::clear_active_off_supported() {
  active_off_supported_ = false;
}
inline bool Monitors_Item::active_off_supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.active_off_supported)
  return active_off_supported_;
}
inline void Monitors_Item::set_active_off_supported(bool value) {
  
  active_off_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.active_off_supported)
}

// bool preferred_timing_mode_supported = 26;
inline void Monitors_Item::clear_preferred_timing_mode_supported() {
  preferred_timing_mode_supported_ = false;
}
inline bool Monitors_Item::preferred_timing_mode_supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.preferred_timing_mode_supported)
  return preferred_timing_mode_supported_;
}
inline void Monitors_Item::set_preferred_timing_mode_supported(bool value) {
  
  preferred_timing_mode_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.preferred_timing_mode_supported)
}

// bool srgb_supported = 27;
inline void Monitors_Item::clear_srgb_supported() {
  srgb_supported_ = false;
}
inline bool Monitors_Item::srgb_supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.srgb_supported)
  return srgb_supported_;
}
inline void Monitors_Item::set_srgb_supported(bool value) {
  
  srgb_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.srgb_supported)
}

// repeated .aspia.proto.Monitors.Item.Timing timings = 28;
inline int Monitors_Item::timings_size() const {
  return timings_.size();
}
inline void Monitors_Item::clear_timings() {
  timings_.Clear();
}
inline const ::aspia::proto::Monitors_Item_Timing& Monitors_Item::timings(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.timings)
  return timings_.Get(index);
}
inline ::aspia::proto::Monitors_Item_Timing* Monitors_Item::mutable_timings(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.timings)
  return timings_.Mutable(index);
}
inline ::aspia::proto::Monitors_Item_Timing* Monitors_Item::add_timings() {
  // @@protoc_insertion_point(field_add:aspia.proto.Monitors.Item.timings)
  return timings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item_Timing >*
Monitors_Item::mutable_timings() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Monitors.Item.timings)
  return &timings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item_Timing >&
Monitors_Item::timings() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Monitors.Item.timings)
  return timings_;
}

// -------------------------------------------------------------------

// Monitors

// repeated .aspia.proto.Monitors.Item item = 1;
inline int Monitors::item_size() const {
  return item_.size();
}
inline void Monitors::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Monitors_Item& Monitors::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.item)
  return item_.Get(index);
}
inline ::aspia::proto::Monitors_Item* Monitors::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Monitors_Item* Monitors::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Monitors.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item >*
Monitors::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Monitors.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item >&
Monitors::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Monitors.item)
  return item_;
}

// -------------------------------------------------------------------

// PowerOptions_Battery

// string device_name = 1;
inline void PowerOptions_Battery::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::device_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.device_name)
  return device_name_.GetNoArena();
}
inline void PowerOptions_Battery::set_device_name(const ::std::string& value) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.device_name)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_device_name(::std::string&& value) {
  
  device_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.device_name)
}
#endif
inline void PowerOptions_Battery::set_device_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.device_name)
}
inline void PowerOptions_Battery::set_device_name(const char* value, size_t size) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.device_name)
}
inline ::std::string* PowerOptions_Battery::mutable_device_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_device_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.device_name)
  
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    
  } else {
    
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.device_name)
}

// string manufacturer = 2;
inline void PowerOptions_Battery::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void PowerOptions_Battery::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.manufacturer)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.manufacturer)
}
#endif
inline void PowerOptions_Battery::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.manufacturer)
}
inline void PowerOptions_Battery::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.manufacturer)
}
inline ::std::string* PowerOptions_Battery::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.manufacturer)
}

// string manufacture_date = 3;
inline void PowerOptions_Battery::clear_manufacture_date() {
  manufacture_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::manufacture_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.manufacture_date)
  return manufacture_date_.GetNoArena();
}
inline void PowerOptions_Battery::set_manufacture_date(const ::std::string& value) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.manufacture_date)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_manufacture_date(::std::string&& value) {
  
  manufacture_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.manufacture_date)
}
#endif
inline void PowerOptions_Battery::set_manufacture_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.manufacture_date)
}
inline void PowerOptions_Battery::set_manufacture_date(const char* value, size_t size) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.manufacture_date)
}
inline ::std::string* PowerOptions_Battery::mutable_manufacture_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.manufacture_date)
  return manufacture_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_manufacture_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.manufacture_date)
  
  return manufacture_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_manufacture_date(::std::string* manufacture_date) {
  if (manufacture_date != NULL) {
    
  } else {
    
  }
  manufacture_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacture_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.manufacture_date)
}

// string unique_id = 4;
inline void PowerOptions_Battery::clear_unique_id() {
  unique_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::unique_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.unique_id)
  return unique_id_.GetNoArena();
}
inline void PowerOptions_Battery::set_unique_id(const ::std::string& value) {
  
  unique_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.unique_id)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_unique_id(::std::string&& value) {
  
  unique_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.unique_id)
}
#endif
inline void PowerOptions_Battery::set_unique_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  unique_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.unique_id)
}
inline void PowerOptions_Battery::set_unique_id(const char* value, size_t size) {
  
  unique_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.unique_id)
}
inline ::std::string* PowerOptions_Battery::mutable_unique_id() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.unique_id)
  return unique_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_unique_id() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.unique_id)
  
  return unique_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_unique_id(::std::string* unique_id) {
  if (unique_id != NULL) {
    
  } else {
    
  }
  unique_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), unique_id);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.unique_id)
}

// string serial_number = 5;
inline void PowerOptions_Battery::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.serial_number)
  return serial_number_.GetNoArena();
}
inline void PowerOptions_Battery::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.serial_number)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.serial_number)
}
#endif
inline void PowerOptions_Battery::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.serial_number)
}
inline void PowerOptions_Battery::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.serial_number)
}
inline ::std::string* PowerOptions_Battery::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.serial_number)
}

// string temperature = 6;
inline void PowerOptions_Battery::clear_temperature() {
  temperature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::temperature() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.temperature)
  return temperature_.GetNoArena();
}
inline void PowerOptions_Battery::set_temperature(const ::std::string& value) {
  
  temperature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.temperature)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_temperature(::std::string&& value) {
  
  temperature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.temperature)
}
#endif
inline void PowerOptions_Battery::set_temperature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  temperature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.temperature)
}
inline void PowerOptions_Battery::set_temperature(const char* value, size_t size) {
  
  temperature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.temperature)
}
inline ::std::string* PowerOptions_Battery::mutable_temperature() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.temperature)
  return temperature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_temperature() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.temperature)
  
  return temperature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_temperature(::std::string* temperature) {
  if (temperature != NULL) {
    
  } else {
    
  }
  temperature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), temperature);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.temperature)
}

// int32 design_capacity = 7;
inline void PowerOptions_Battery::clear_design_capacity() {
  design_capacity_ = 0;
}
inline ::google::protobuf::int32 PowerOptions_Battery::design_capacity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.design_capacity)
  return design_capacity_;
}
inline void PowerOptions_Battery::set_design_capacity(::google::protobuf::int32 value) {
  
  design_capacity_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.design_capacity)
}

// string type = 8;
inline void PowerOptions_Battery::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.type)
  return type_.GetNoArena();
}
inline void PowerOptions_Battery::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.type)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.type)
}
#endif
inline void PowerOptions_Battery::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.type)
}
inline void PowerOptions_Battery::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.type)
}
inline ::std::string* PowerOptions_Battery::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.type)
}

// int32 full_charged_capacity = 9;
inline void PowerOptions_Battery::clear_full_charged_capacity() {
  full_charged_capacity_ = 0;
}
inline ::google::protobuf::int32 PowerOptions_Battery::full_charged_capacity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.full_charged_capacity)
  return full_charged_capacity_;
}
inline void PowerOptions_Battery::set_full_charged_capacity(::google::protobuf::int32 value) {
  
  full_charged_capacity_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.full_charged_capacity)
}

// int32 depreciation = 10;
inline void PowerOptions_Battery::clear_depreciation() {
  depreciation_ = 0;
}
inline ::google::protobuf::int32 PowerOptions_Battery::depreciation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.depreciation)
  return depreciation_;
}
inline void PowerOptions_Battery::set_depreciation(::google::protobuf::int32 value) {
  
  depreciation_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.depreciation)
}

// int32 current_capacity = 11;
inline void PowerOptions_Battery::clear_current_capacity() {
  current_capacity_ = 0;
}
inline ::google::protobuf::int32 PowerOptions_Battery::current_capacity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.current_capacity)
  return current_capacity_;
}
inline void PowerOptions_Battery::set_current_capacity(::google::protobuf::int32 value) {
  
  current_capacity_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.current_capacity)
}

// int32 voltage = 12;
inline void PowerOptions_Battery::clear_voltage() {
  voltage_ = 0;
}
inline ::google::protobuf::int32 PowerOptions_Battery::voltage() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.voltage)
  return voltage_;
}
inline void PowerOptions_Battery::set_voltage(::google::protobuf::int32 value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.voltage)
}

// uint32 state = 13;
inline void PowerOptions_Battery::clear_state() {
  state_ = 0u;
}
inline ::google::protobuf::uint32 PowerOptions_Battery::state() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.state)
  return state_;
}
inline void PowerOptions_Battery::set_state(::google::protobuf::uint32 value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.state)
}

// -------------------------------------------------------------------

// PowerOptions

// .aspia.proto.PowerOptions.PowerSource power_source = 1;
inline void PowerOptions::clear_power_source() {
  power_source_ = 0;
}
inline ::aspia::proto::PowerOptions_PowerSource PowerOptions::power_source() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.power_source)
  return static_cast< ::aspia::proto::PowerOptions_PowerSource >(power_source_);
}
inline void PowerOptions::set_power_source(::aspia::proto::PowerOptions_PowerSource value) {
  
  power_source_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.power_source)
}

// .aspia.proto.PowerOptions.BatteryStatus battery_status = 2;
inline void PowerOptions::clear_battery_status() {
  battery_status_ = 0;
}
inline ::aspia::proto::PowerOptions_BatteryStatus PowerOptions::battery_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.battery_status)
  return static_cast< ::aspia::proto::PowerOptions_BatteryStatus >(battery_status_);
}
inline void PowerOptions::set_battery_status(::aspia::proto::PowerOptions_BatteryStatus value) {
  
  battery_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.battery_status)
}

// int64 full_battery_life_time = 3;
inline void PowerOptions::clear_full_battery_life_time() {
  full_battery_life_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PowerOptions::full_battery_life_time() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.full_battery_life_time)
  return full_battery_life_time_;
}
inline void PowerOptions::set_full_battery_life_time(::google::protobuf::int64 value) {
  
  full_battery_life_time_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.full_battery_life_time)
}

// int64 remaining_battery_life_time = 4;
inline void PowerOptions::clear_remaining_battery_life_time() {
  remaining_battery_life_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PowerOptions::remaining_battery_life_time() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.remaining_battery_life_time)
  return remaining_battery_life_time_;
}
inline void PowerOptions::set_remaining_battery_life_time(::google::protobuf::int64 value) {
  
  remaining_battery_life_time_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.remaining_battery_life_time)
}

// int32 battery_life_percent = 5;
inline void PowerOptions::clear_battery_life_percent() {
  battery_life_percent_ = 0;
}
inline ::google::protobuf::int32 PowerOptions::battery_life_percent() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.battery_life_percent)
  return battery_life_percent_;
}
inline void PowerOptions::set_battery_life_percent(::google::protobuf::int32 value) {
  
  battery_life_percent_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.battery_life_percent)
}

// repeated .aspia.proto.PowerOptions.Battery battery = 6;
inline int PowerOptions::battery_size() const {
  return battery_.size();
}
inline void PowerOptions::clear_battery() {
  battery_.Clear();
}
inline const ::aspia::proto::PowerOptions_Battery& PowerOptions::battery(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.battery)
  return battery_.Get(index);
}
inline ::aspia::proto::PowerOptions_Battery* PowerOptions::mutable_battery(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.battery)
  return battery_.Mutable(index);
}
inline ::aspia::proto::PowerOptions_Battery* PowerOptions::add_battery() {
  // @@protoc_insertion_point(field_add:aspia.proto.PowerOptions.battery)
  return battery_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::PowerOptions_Battery >*
PowerOptions::mutable_battery() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.PowerOptions.battery)
  return &battery_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::PowerOptions_Battery >&
PowerOptions::battery() const {
  // @@protoc_insertion_point(field_list:aspia.proto.PowerOptions.battery)
  return battery_;
}

// -------------------------------------------------------------------

// Printers_Item

// string name = 1;
inline void Printers_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.name)
  return name_.GetNoArena();
}
inline void Printers_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.name)
}
#if LANG_CXX11
inline void Printers_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.name)
}
#endif
inline void Printers_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.name)
}
inline void Printers_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.name)
}
inline ::std::string* Printers_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.name)
}

// bool is_default = 2;
inline void Printers_Item::clear_is_default() {
  is_default_ = false;
}
inline bool Printers_Item::is_default() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.is_default)
  return is_default_;
}
inline void Printers_Item::set_is_default(bool value) {
  
  is_default_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.is_default)
}

// bool is_shared = 3;
inline void Printers_Item::clear_is_shared() {
  is_shared_ = false;
}
inline bool Printers_Item::is_shared() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.is_shared)
  return is_shared_;
}
inline void Printers_Item::set_is_shared(bool value) {
  
  is_shared_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.is_shared)
}

// string share_name = 4;
inline void Printers_Item::clear_share_name() {
  share_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::share_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.share_name)
  return share_name_.GetNoArena();
}
inline void Printers_Item::set_share_name(const ::std::string& value) {
  
  share_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.share_name)
}
#if LANG_CXX11
inline void Printers_Item::set_share_name(::std::string&& value) {
  
  share_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.share_name)
}
#endif
inline void Printers_Item::set_share_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  share_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.share_name)
}
inline void Printers_Item::set_share_name(const char* value, size_t size) {
  
  share_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.share_name)
}
inline ::std::string* Printers_Item::mutable_share_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.share_name)
  return share_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_share_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.share_name)
  
  return share_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_share_name(::std::string* share_name) {
  if (share_name != NULL) {
    
  } else {
    
  }
  share_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), share_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.share_name)
}

// string port_name = 5;
inline void Printers_Item::clear_port_name() {
  port_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::port_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.port_name)
  return port_name_.GetNoArena();
}
inline void Printers_Item::set_port_name(const ::std::string& value) {
  
  port_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.port_name)
}
#if LANG_CXX11
inline void Printers_Item::set_port_name(::std::string&& value) {
  
  port_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.port_name)
}
#endif
inline void Printers_Item::set_port_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.port_name)
}
inline void Printers_Item::set_port_name(const char* value, size_t size) {
  
  port_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.port_name)
}
inline ::std::string* Printers_Item::mutable_port_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.port_name)
  return port_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_port_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.port_name)
  
  return port_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_port_name(::std::string* port_name) {
  if (port_name != NULL) {
    
  } else {
    
  }
  port_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.port_name)
}

// string driver_name = 6;
inline void Printers_Item::clear_driver_name() {
  driver_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::driver_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.driver_name)
  return driver_name_.GetNoArena();
}
inline void Printers_Item::set_driver_name(const ::std::string& value) {
  
  driver_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.driver_name)
}
#if LANG_CXX11
inline void Printers_Item::set_driver_name(::std::string&& value) {
  
  driver_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.driver_name)
}
#endif
inline void Printers_Item::set_driver_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.driver_name)
}
inline void Printers_Item::set_driver_name(const char* value, size_t size) {
  
  driver_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.driver_name)
}
inline ::std::string* Printers_Item::mutable_driver_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.driver_name)
  return driver_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_driver_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.driver_name)
  
  return driver_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_driver_name(::std::string* driver_name) {
  if (driver_name != NULL) {
    
  } else {
    
  }
  driver_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.driver_name)
}

// string device_name = 7;
inline void Printers_Item::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::device_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.device_name)
  return device_name_.GetNoArena();
}
inline void Printers_Item::set_device_name(const ::std::string& value) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.device_name)
}
#if LANG_CXX11
inline void Printers_Item::set_device_name(::std::string&& value) {
  
  device_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.device_name)
}
#endif
inline void Printers_Item::set_device_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.device_name)
}
inline void Printers_Item::set_device_name(const char* value, size_t size) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.device_name)
}
inline ::std::string* Printers_Item::mutable_device_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_device_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.device_name)
  
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    
  } else {
    
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.device_name)
}

// string print_processor = 8;
inline void Printers_Item::clear_print_processor() {
  print_processor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::print_processor() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.print_processor)
  return print_processor_.GetNoArena();
}
inline void Printers_Item::set_print_processor(const ::std::string& value) {
  
  print_processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.print_processor)
}
#if LANG_CXX11
inline void Printers_Item::set_print_processor(::std::string&& value) {
  
  print_processor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.print_processor)
}
#endif
inline void Printers_Item::set_print_processor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  print_processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.print_processor)
}
inline void Printers_Item::set_print_processor(const char* value, size_t size) {
  
  print_processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.print_processor)
}
inline ::std::string* Printers_Item::mutable_print_processor() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.print_processor)
  return print_processor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_print_processor() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.print_processor)
  
  return print_processor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_print_processor(::std::string* print_processor) {
  if (print_processor != NULL) {
    
  } else {
    
  }
  print_processor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), print_processor);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.print_processor)
}

// string data_type = 9;
inline void Printers_Item::clear_data_type() {
  data_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::data_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.data_type)
  return data_type_.GetNoArena();
}
inline void Printers_Item::set_data_type(const ::std::string& value) {
  
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.data_type)
}
#if LANG_CXX11
inline void Printers_Item::set_data_type(::std::string&& value) {
  
  data_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.data_type)
}
#endif
inline void Printers_Item::set_data_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.data_type)
}
inline void Printers_Item::set_data_type(const char* value, size_t size) {
  
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.data_type)
}
inline ::std::string* Printers_Item::mutable_data_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.data_type)
  return data_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_data_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.data_type)
  
  return data_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_data_type(::std::string* data_type) {
  if (data_type != NULL) {
    
  } else {
    
  }
  data_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.data_type)
}

// string server_name = 10;
inline void Printers_Item::clear_server_name() {
  server_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::server_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.server_name)
  return server_name_.GetNoArena();
}
inline void Printers_Item::set_server_name(const ::std::string& value) {
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.server_name)
}
#if LANG_CXX11
inline void Printers_Item::set_server_name(::std::string&& value) {
  
  server_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.server_name)
}
#endif
inline void Printers_Item::set_server_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.server_name)
}
inline void Printers_Item::set_server_name(const char* value, size_t size) {
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.server_name)
}
inline ::std::string* Printers_Item::mutable_server_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.server_name)
  return server_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_server_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.server_name)
  
  return server_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_server_name(::std::string* server_name) {
  if (server_name != NULL) {
    
  } else {
    
  }
  server_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.server_name)
}

// string location = 11;
inline void Printers_Item::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.location)
  return location_.GetNoArena();
}
inline void Printers_Item::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.location)
}
#if LANG_CXX11
inline void Printers_Item::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.location)
}
#endif
inline void Printers_Item::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.location)
}
inline void Printers_Item::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.location)
}
inline ::std::string* Printers_Item::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_location() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.location)
}

// string comment = 12;
inline void Printers_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.comment)
  return comment_.GetNoArena();
}
inline void Printers_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.comment)
}
#if LANG_CXX11
inline void Printers_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.comment)
}
#endif
inline void Printers_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.comment)
}
inline void Printers_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.comment)
}
inline ::std::string* Printers_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.comment)
}

// int32 jobs_count = 13;
inline void Printers_Item::clear_jobs_count() {
  jobs_count_ = 0;
}
inline ::google::protobuf::int32 Printers_Item::jobs_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.jobs_count)
  return jobs_count_;
}
inline void Printers_Item::set_jobs_count(::google::protobuf::int32 value) {
  
  jobs_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.jobs_count)
}

// int32 paper_width = 14;
inline void Printers_Item::clear_paper_width() {
  paper_width_ = 0;
}
inline ::google::protobuf::int32 Printers_Item::paper_width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.paper_width)
  return paper_width_;
}
inline void Printers_Item::set_paper_width(::google::protobuf::int32 value) {
  
  paper_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.paper_width)
}

// int32 paper_length = 15;
inline void Printers_Item::clear_paper_length() {
  paper_length_ = 0;
}
inline ::google::protobuf::int32 Printers_Item::paper_length() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.paper_length)
  return paper_length_;
}
inline void Printers_Item::set_paper_length(::google::protobuf::int32 value) {
  
  paper_length_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.paper_length)
}

// int32 print_quality = 16;
inline void Printers_Item::clear_print_quality() {
  print_quality_ = 0;
}
inline ::google::protobuf::int32 Printers_Item::print_quality() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.print_quality)
  return print_quality_;
}
inline void Printers_Item::set_print_quality(::google::protobuf::int32 value) {
  
  print_quality_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.print_quality)
}

// .aspia.proto.Printers.Item.Orientation orientation = 17;
inline void Printers_Item::clear_orientation() {
  orientation_ = 0;
}
inline ::aspia::proto::Printers_Item_Orientation Printers_Item::orientation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.orientation)
  return static_cast< ::aspia::proto::Printers_Item_Orientation >(orientation_);
}
inline void Printers_Item::set_orientation(::aspia::proto::Printers_Item_Orientation value) {
  
  orientation_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.orientation)
}

// -------------------------------------------------------------------

// Printers

// repeated .aspia.proto.Printers.Item item = 1;
inline int Printers::item_size() const {
  return item_.size();
}
inline void Printers::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Printers_Item& Printers::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.item)
  return item_.Get(index);
}
inline ::aspia::proto::Printers_Item* Printers::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Printers_Item* Printers::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Printers.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Printers_Item >*
Printers::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Printers.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Printers_Item >&
Printers::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Printers.item)
  return item_;
}

// -------------------------------------------------------------------

// WindowsDevices_Item

// string friendly_name = 1;
inline void WindowsDevices_Item::clear_friendly_name() {
  friendly_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WindowsDevices_Item::friendly_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.Item.friendly_name)
  return friendly_name_.GetNoArena();
}
inline void WindowsDevices_Item::set_friendly_name(const ::std::string& value) {
  
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.WindowsDevices.Item.friendly_name)
}
#if LANG_CXX11
inline void WindowsDevices_Item::set_friendly_name(::std::string&& value) {
  
  friendly_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.WindowsDevices.Item.friendly_name)
}
#endif
inline void WindowsDevices_Item::set_friendly_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.WindowsDevices.Item.friendly_name)
}
inline void WindowsDevices_Item::set_friendly_name(const char* value, size_t size) {
  
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.WindowsDevices.Item.friendly_name)
}
inline ::std::string* WindowsDevices_Item::mutable_friendly_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.Item.friendly_name)
  return friendly_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WindowsDevices_Item::release_friendly_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.WindowsDevices.Item.friendly_name)
  
  return friendly_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WindowsDevices_Item::set_allocated_friendly_name(::std::string* friendly_name) {
  if (friendly_name != NULL) {
    
  } else {
    
  }
  friendly_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), friendly_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.WindowsDevices.Item.friendly_name)
}

// string description = 2;
inline void WindowsDevices_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WindowsDevices_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.Item.description)
  return description_.GetNoArena();
}
inline void WindowsDevices_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.WindowsDevices.Item.description)
}
#if LANG_CXX11
inline void WindowsDevices_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.WindowsDevices.Item.description)
}
#endif
inline void WindowsDevices_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.WindowsDevices.Item.description)
}
inline void WindowsDevices_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.WindowsDevices.Item.description)
}
inline ::std::string* WindowsDevices_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WindowsDevices_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.WindowsDevices.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WindowsDevices_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.WindowsDevices.Item.description)
}

// string driver_version = 3;
inline void WindowsDevices_Item::clear_driver_version() {
  driver_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WindowsDevices_Item::driver_version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.Item.driver_version)
  return driver_version_.GetNoArena();
}
inline void WindowsDevices_Item::set_driver_version(const ::std::string& value) {
  
  driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.WindowsDevices.Item.driver_version)
}
#if LANG_CXX11
inline void WindowsDevices_Item::set_driver_version(::std::string&& value) {
  
  driver_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.WindowsDevices.Item.driver_version)
}
#endif
inline void WindowsDevices_Item::set_driver_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.WindowsDevices.Item.driver_version)
}
inline void WindowsDevices_Item::set_driver_version(const char* value, size_t size) {
  
  driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.WindowsDevices.Item.driver_version)
}
inline ::std::string* WindowsDevices_Item::mutable_driver_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.Item.driver_version)
  return driver_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WindowsDevices_Item::release_driver_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.WindowsDevices.Item.driver_version)
  
  return driver_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WindowsDevices_Item::set_allocated_driver_version(::std::string* driver_version) {
  if (driver_version != NULL) {
    
  } else {
    
  }
  driver_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.WindowsDevices.Item.driver_version)
}

// string driver_date = 4;
inline void WindowsDevices_Item::clear_driver_date() {
  driver_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WindowsDevices_Item::driver_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.Item.driver_date)
  return driver_date_.GetNoArena();
}
inline void WindowsDevices_Item::set_driver_date(const ::std::string& value) {
  
  driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.WindowsDevices.Item.driver_date)
}
#if LANG_CXX11
inline void WindowsDevices_Item::set_driver_date(::std::string&& value) {
  
  driver_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.WindowsDevices.Item.driver_date)
}
#endif
inline void WindowsDevices_Item::set_driver_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.WindowsDevices.Item.driver_date)
}
inline void WindowsDevices_Item::set_driver_date(const char* value, size_t size) {
  
  driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.WindowsDevices.Item.driver_date)
}
inline ::std::string* WindowsDevices_Item::mutable_driver_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.Item.driver_date)
  return driver_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WindowsDevices_Item::release_driver_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.WindowsDevices.Item.driver_date)
  
  return driver_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WindowsDevices_Item::set_allocated_driver_date(::std::string* driver_date) {
  if (driver_date != NULL) {
    
  } else {
    
  }
  driver_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.WindowsDevices.Item.driver_date)
}

// string driver_vendor = 5;
inline void WindowsDevices_Item::clear_driver_vendor() {
  driver_vendor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WindowsDevices_Item::driver_vendor() const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.Item.driver_vendor)
  return driver_vendor_.GetNoArena();
}
inline void WindowsDevices_Item::set_driver_vendor(const ::std::string& value) {
  
  driver_vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.WindowsDevices.Item.driver_vendor)
}
#if LANG_CXX11
inline void WindowsDevices_Item::set_driver_vendor(::std::string&& value) {
  
  driver_vendor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.WindowsDevices.Item.driver_vendor)
}
#endif
inline void WindowsDevices_Item::set_driver_vendor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.WindowsDevices.Item.driver_vendor)
}
inline void WindowsDevices_Item::set_driver_vendor(const char* value, size_t size) {
  
  driver_vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.WindowsDevices.Item.driver_vendor)
}
inline ::std::string* WindowsDevices_Item::mutable_driver_vendor() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.Item.driver_vendor)
  return driver_vendor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WindowsDevices_Item::release_driver_vendor() {
  // @@protoc_insertion_point(field_release:aspia.proto.WindowsDevices.Item.driver_vendor)
  
  return driver_vendor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WindowsDevices_Item::set_allocated_driver_vendor(::std::string* driver_vendor) {
  if (driver_vendor != NULL) {
    
  } else {
    
  }
  driver_vendor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_vendor);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.WindowsDevices.Item.driver_vendor)
}

// string device_id = 6;
inline void WindowsDevices_Item::clear_device_id() {
  device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WindowsDevices_Item::device_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.Item.device_id)
  return device_id_.GetNoArena();
}
inline void WindowsDevices_Item::set_device_id(const ::std::string& value) {
  
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.WindowsDevices.Item.device_id)
}
#if LANG_CXX11
inline void WindowsDevices_Item::set_device_id(::std::string&& value) {
  
  device_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.WindowsDevices.Item.device_id)
}
#endif
inline void WindowsDevices_Item::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.WindowsDevices.Item.device_id)
}
inline void WindowsDevices_Item::set_device_id(const char* value, size_t size) {
  
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.WindowsDevices.Item.device_id)
}
inline ::std::string* WindowsDevices_Item::mutable_device_id() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.Item.device_id)
  return device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WindowsDevices_Item::release_device_id() {
  // @@protoc_insertion_point(field_release:aspia.proto.WindowsDevices.Item.device_id)
  
  return device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WindowsDevices_Item::set_allocated_device_id(::std::string* device_id) {
  if (device_id != NULL) {
    
  } else {
    
  }
  device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_id);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.WindowsDevices.Item.device_id)
}

// -------------------------------------------------------------------

// WindowsDevices

// repeated .aspia.proto.WindowsDevices.Item item = 1;
inline int WindowsDevices::item_size() const {
  return item_.size();
}
inline void WindowsDevices::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::WindowsDevices_Item& WindowsDevices::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.item)
  return item_.Get(index);
}
inline ::aspia::proto::WindowsDevices_Item* WindowsDevices::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::WindowsDevices_Item* WindowsDevices::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.WindowsDevices.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::WindowsDevices_Item >*
WindowsDevices::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.WindowsDevices.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::WindowsDevices_Item >&
WindowsDevices::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.WindowsDevices.item)
  return item_;
}

// -------------------------------------------------------------------

// Programs_Item

// string name = 1;
inline void Programs_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.name)
  return name_.GetNoArena();
}
inline void Programs_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.name)
}
#if LANG_CXX11
inline void Programs_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.name)
}
#endif
inline void Programs_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.name)
}
inline void Programs_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.name)
}
inline ::std::string* Programs_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.name)
}

// string version = 2;
inline void Programs_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.version)
  return version_.GetNoArena();
}
inline void Programs_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.version)
}
#if LANG_CXX11
inline void Programs_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.version)
}
#endif
inline void Programs_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.version)
}
inline void Programs_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.version)
}
inline ::std::string* Programs_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.version)
}

// string publisher = 3;
inline void Programs_Item::clear_publisher() {
  publisher_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::publisher() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.publisher)
  return publisher_.GetNoArena();
}
inline void Programs_Item::set_publisher(const ::std::string& value) {
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.publisher)
}
#if LANG_CXX11
inline void Programs_Item::set_publisher(::std::string&& value) {
  
  publisher_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.publisher)
}
#endif
inline void Programs_Item::set_publisher(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.publisher)
}
inline void Programs_Item::set_publisher(const char* value, size_t size) {
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.publisher)
}
inline ::std::string* Programs_Item::mutable_publisher() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.publisher)
  return publisher_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_publisher() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.publisher)
  
  return publisher_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_publisher(::std::string* publisher) {
  if (publisher != NULL) {
    
  } else {
    
  }
  publisher_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publisher);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.publisher)
}

// string install_date = 4;
inline void Programs_Item::clear_install_date() {
  install_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::install_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.install_date)
  return install_date_.GetNoArena();
}
inline void Programs_Item::set_install_date(const ::std::string& value) {
  
  install_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.install_date)
}
#if LANG_CXX11
inline void Programs_Item::set_install_date(::std::string&& value) {
  
  install_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.install_date)
}
#endif
inline void Programs_Item::set_install_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  install_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.install_date)
}
inline void Programs_Item::set_install_date(const char* value, size_t size) {
  
  install_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.install_date)
}
inline ::std::string* Programs_Item::mutable_install_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.install_date)
  return install_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_install_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.install_date)
  
  return install_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_install_date(::std::string* install_date) {
  if (install_date != NULL) {
    
  } else {
    
  }
  install_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), install_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.install_date)
}

// string install_location = 5;
inline void Programs_Item::clear_install_location() {
  install_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::install_location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.install_location)
  return install_location_.GetNoArena();
}
inline void Programs_Item::set_install_location(const ::std::string& value) {
  
  install_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.install_location)
}
#if LANG_CXX11
inline void Programs_Item::set_install_location(::std::string&& value) {
  
  install_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.install_location)
}
#endif
inline void Programs_Item::set_install_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  install_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.install_location)
}
inline void Programs_Item::set_install_location(const char* value, size_t size) {
  
  install_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.install_location)
}
inline ::std::string* Programs_Item::mutable_install_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.install_location)
  return install_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_install_location() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.install_location)
  
  return install_location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_install_location(::std::string* install_location) {
  if (install_location != NULL) {
    
  } else {
    
  }
  install_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), install_location);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.install_location)
}

// -------------------------------------------------------------------

// Programs

// repeated .aspia.proto.Programs.Item item = 1;
inline int Programs::item_size() const {
  return item_.size();
}
inline void Programs::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Programs_Item& Programs::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.item)
  return item_.Get(index);
}
inline ::aspia::proto::Programs_Item* Programs::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Programs_Item* Programs::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Programs.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >*
Programs::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Programs.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >&
Programs::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Programs.item)
  return item_;
}

// -------------------------------------------------------------------

// Services_Item

// string name = 1;
inline void Services_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.name)
  return name_.GetNoArena();
}
inline void Services_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.name)
}
#if LANG_CXX11
inline void Services_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.name)
}
#endif
inline void Services_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.name)
}
inline void Services_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.name)
}
inline ::std::string* Services_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.name)
}

// string display_name = 2;
inline void Services_Item::clear_display_name() {
  display_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::display_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.display_name)
  return display_name_.GetNoArena();
}
inline void Services_Item::set_display_name(const ::std::string& value) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.display_name)
}
#if LANG_CXX11
inline void Services_Item::set_display_name(::std::string&& value) {
  
  display_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.display_name)
}
#endif
inline void Services_Item::set_display_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.display_name)
}
inline void Services_Item::set_display_name(const char* value, size_t size) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.display_name)
}
inline ::std::string* Services_Item::mutable_display_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.display_name)
  return display_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_display_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.display_name)
  
  return display_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_display_name(::std::string* display_name) {
  if (display_name != NULL) {
    
  } else {
    
  }
  display_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.display_name)
}

// string description = 3;
inline void Services_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.description)
  return description_.GetNoArena();
}
inline void Services_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.description)
}
#if LANG_CXX11
inline void Services_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.description)
}
#endif
inline void Services_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.description)
}
inline void Services_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.description)
}
inline ::std::string* Services_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.description)
}

// .aspia.proto.Services.Item.Status status = 4;
inline void Services_Item::clear_status() {
  status_ = 0;
}
inline ::aspia::proto::Services_Item_Status Services_Item::status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.status)
  return static_cast< ::aspia::proto::Services_Item_Status >(status_);
}
inline void Services_Item::set_status(::aspia::proto::Services_Item_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.status)
}

// .aspia.proto.Services.Item.StartupType startup_type = 5;
inline void Services_Item::clear_startup_type() {
  startup_type_ = 0;
}
inline ::aspia::proto::Services_Item_StartupType Services_Item::startup_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.startup_type)
  return static_cast< ::aspia::proto::Services_Item_StartupType >(startup_type_);
}
inline void Services_Item::set_startup_type(::aspia::proto::Services_Item_StartupType value) {
  
  startup_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.startup_type)
}

// string binary_path = 6;
inline void Services_Item::clear_binary_path() {
  binary_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::binary_path() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.binary_path)
  return binary_path_.GetNoArena();
}
inline void Services_Item::set_binary_path(const ::std::string& value) {
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.binary_path)
}
#if LANG_CXX11
inline void Services_Item::set_binary_path(::std::string&& value) {
  
  binary_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.binary_path)
}
#endif
inline void Services_Item::set_binary_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.binary_path)
}
inline void Services_Item::set_binary_path(const char* value, size_t size) {
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.binary_path)
}
inline ::std::string* Services_Item::mutable_binary_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.binary_path)
  return binary_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_binary_path() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.binary_path)
  
  return binary_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_binary_path(::std::string* binary_path) {
  if (binary_path != NULL) {
    
  } else {
    
  }
  binary_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), binary_path);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.binary_path)
}

// string start_name = 7;
inline void Services_Item::clear_start_name() {
  start_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::start_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.start_name)
  return start_name_.GetNoArena();
}
inline void Services_Item::set_start_name(const ::std::string& value) {
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.start_name)
}
#if LANG_CXX11
inline void Services_Item::set_start_name(::std::string&& value) {
  
  start_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.start_name)
}
#endif
inline void Services_Item::set_start_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.start_name)
}
inline void Services_Item::set_start_name(const char* value, size_t size) {
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.start_name)
}
inline ::std::string* Services_Item::mutable_start_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.start_name)
  return start_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_start_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.start_name)
  
  return start_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_start_name(::std::string* start_name) {
  if (start_name != NULL) {
    
  } else {
    
  }
  start_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.start_name)
}

// -------------------------------------------------------------------

// Services

// repeated .aspia.proto.Services.Item item = 1;
inline int Services::item_size() const {
  return item_.size();
}
inline void Services::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Services_Item& Services::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.item)
  return item_.Get(index);
}
inline ::aspia::proto::Services_Item* Services::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Services_Item* Services::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Services.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >*
Services::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Services.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >&
Services::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Services.item)
  return item_;
}

// -------------------------------------------------------------------

// Processes_Item

// string process_name = 1;
inline void Processes_Item::clear_process_name() {
  process_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processes_Item::process_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Processes.Item.process_name)
  return process_name_.GetNoArena();
}
inline void Processes_Item::set_process_name(const ::std::string& value) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Processes.Item.process_name)
}
#if LANG_CXX11
inline void Processes_Item::set_process_name(::std::string&& value) {
  
  process_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Processes.Item.process_name)
}
#endif
inline void Processes_Item::set_process_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Processes.Item.process_name)
}
inline void Processes_Item::set_process_name(const char* value, size_t size) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Processes.Item.process_name)
}
inline ::std::string* Processes_Item::mutable_process_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Processes.Item.process_name)
  return process_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processes_Item::release_process_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Processes.Item.process_name)
  
  return process_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processes_Item::set_allocated_process_name(::std::string* process_name) {
  if (process_name != NULL) {
    
  } else {
    
  }
  process_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Processes.Item.process_name)
}

// string file_path = 2;
inline void Processes_Item::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processes_Item::file_path() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Processes.Item.file_path)
  return file_path_.GetNoArena();
}
inline void Processes_Item::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Processes.Item.file_path)
}
#if LANG_CXX11
inline void Processes_Item::set_file_path(::std::string&& value) {
  
  file_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Processes.Item.file_path)
}
#endif
inline void Processes_Item::set_file_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Processes.Item.file_path)
}
inline void Processes_Item::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Processes.Item.file_path)
}
inline ::std::string* Processes_Item::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Processes.Item.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processes_Item::release_file_path() {
  // @@protoc_insertion_point(field_release:aspia.proto.Processes.Item.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processes_Item::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Processes.Item.file_path)
}

// uint64 used_memory = 3;
inline void Processes_Item::clear_used_memory() {
  used_memory_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Processes_Item::used_memory() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Processes.Item.used_memory)
  return used_memory_;
}
inline void Processes_Item::set_used_memory(::google::protobuf::uint64 value) {
  
  used_memory_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Processes.Item.used_memory)
}

// uint64 used_swap = 4;
inline void Processes_Item::clear_used_swap() {
  used_swap_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Processes_Item::used_swap() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Processes.Item.used_swap)
  return used_swap_;
}
inline void Processes_Item::set_used_swap(::google::protobuf::uint64 value) {
  
  used_swap_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Processes.Item.used_swap)
}

// string description = 5;
inline void Processes_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processes_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Processes.Item.description)
  return description_.GetNoArena();
}
inline void Processes_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Processes.Item.description)
}
#if LANG_CXX11
inline void Processes_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Processes.Item.description)
}
#endif
inline void Processes_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Processes.Item.description)
}
inline void Processes_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Processes.Item.description)
}
inline ::std::string* Processes_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Processes.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processes_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.Processes.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processes_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Processes.Item.description)
}

// -------------------------------------------------------------------

// Processes

// repeated .aspia.proto.Processes.Item item = 1;
inline int Processes::item_size() const {
  return item_.size();
}
inline void Processes::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Processes_Item& Processes::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Processes.item)
  return item_.Get(index);
}
inline ::aspia::proto::Processes_Item* Processes::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Processes.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Processes_Item* Processes::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Processes.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Processes_Item >*
Processes::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Processes.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Processes_Item >&
Processes::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Processes.item)
  return item_;
}

// -------------------------------------------------------------------

// NetworkCards_Item_IpAddress

// string address = 1;
inline void NetworkCards_Item_IpAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item_IpAddress::address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.IpAddress.address)
  return address_.GetNoArena();
}
inline void NetworkCards_Item_IpAddress::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.IpAddress.address)
}
#if LANG_CXX11
inline void NetworkCards_Item_IpAddress::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.IpAddress.address)
}
#endif
inline void NetworkCards_Item_IpAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.IpAddress.address)
}
inline void NetworkCards_Item_IpAddress::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.IpAddress.address)
}
inline ::std::string* NetworkCards_Item_IpAddress::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.IpAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item_IpAddress::release_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.IpAddress.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item_IpAddress::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.IpAddress.address)
}

// string mask = 2;
inline void NetworkCards_Item_IpAddress::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item_IpAddress::mask() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.IpAddress.mask)
  return mask_.GetNoArena();
}
inline void NetworkCards_Item_IpAddress::set_mask(const ::std::string& value) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
#if LANG_CXX11
inline void NetworkCards_Item_IpAddress::set_mask(::std::string&& value) {
  
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
#endif
inline void NetworkCards_Item_IpAddress::set_mask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
inline void NetworkCards_Item_IpAddress::set_mask(const char* value, size_t size) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
inline ::std::string* NetworkCards_Item_IpAddress::mutable_mask() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.IpAddress.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item_IpAddress::release_mask() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.IpAddress.mask)
  
  return mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item_IpAddress::set_allocated_mask(::std::string* mask) {
  if (mask != NULL) {
    
  } else {
    
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.IpAddress.mask)
}

// -------------------------------------------------------------------

// NetworkCards_Item

// string adapter_name = 1;
inline void NetworkCards_Item::clear_adapter_name() {
  adapter_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::adapter_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.adapter_name)
  return adapter_name_.GetNoArena();
}
inline void NetworkCards_Item::set_adapter_name(const ::std::string& value) {
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.adapter_name)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_adapter_name(::std::string&& value) {
  
  adapter_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.adapter_name)
}
#endif
inline void NetworkCards_Item::set_adapter_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.adapter_name)
}
inline void NetworkCards_Item::set_adapter_name(const char* value, size_t size) {
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.adapter_name)
}
inline ::std::string* NetworkCards_Item::mutable_adapter_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.adapter_name)
  return adapter_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_adapter_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.adapter_name)
  
  return adapter_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_adapter_name(::std::string* adapter_name) {
  if (adapter_name != NULL) {
    
  } else {
    
  }
  adapter_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adapter_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.adapter_name)
}

// string connection_name = 2;
inline void NetworkCards_Item::clear_connection_name() {
  connection_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::connection_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.connection_name)
  return connection_name_.GetNoArena();
}
inline void NetworkCards_Item::set_connection_name(const ::std::string& value) {
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.connection_name)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_connection_name(::std::string&& value) {
  
  connection_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.connection_name)
}
#endif
inline void NetworkCards_Item::set_connection_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.connection_name)
}
inline void NetworkCards_Item::set_connection_name(const char* value, size_t size) {
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.connection_name)
}
inline ::std::string* NetworkCards_Item::mutable_connection_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.connection_name)
  return connection_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_connection_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.connection_name)
  
  return connection_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_connection_name(::std::string* connection_name) {
  if (connection_name != NULL) {
    
  } else {
    
  }
  connection_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connection_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.connection_name)
}

// string interface_type = 3;
inline void NetworkCards_Item::clear_interface_type() {
  interface_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::interface_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.interface_type)
  return interface_type_.GetNoArena();
}
inline void NetworkCards_Item::set_interface_type(const ::std::string& value) {
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.interface_type)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_interface_type(::std::string&& value) {
  
  interface_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.interface_type)
}
#endif
inline void NetworkCards_Item::set_interface_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.interface_type)
}
inline void NetworkCards_Item::set_interface_type(const char* value, size_t size) {
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.interface_type)
}
inline ::std::string* NetworkCards_Item::mutable_interface_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.interface_type)
  return interface_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_interface_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.interface_type)
  
  return interface_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_interface_type(::std::string* interface_type) {
  if (interface_type != NULL) {
    
  } else {
    
  }
  interface_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), interface_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.interface_type)
}

// uint32 mtu = 4;
inline void NetworkCards_Item::clear_mtu() {
  mtu_ = 0u;
}
inline ::google::protobuf::uint32 NetworkCards_Item::mtu() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.mtu)
  return mtu_;
}
inline void NetworkCards_Item::set_mtu(::google::protobuf::uint32 value) {
  
  mtu_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.mtu)
}

// uint32 speed = 5;
inline void NetworkCards_Item::clear_speed() {
  speed_ = 0u;
}
inline ::google::protobuf::uint32 NetworkCards_Item::speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.speed)
  return speed_;
}
inline void NetworkCards_Item::set_speed(::google::protobuf::uint32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.speed)
}

// string mac_address = 6;
inline void NetworkCards_Item::clear_mac_address() {
  mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::mac_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.mac_address)
  return mac_address_.GetNoArena();
}
inline void NetworkCards_Item::set_mac_address(const ::std::string& value) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.mac_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_mac_address(::std::string&& value) {
  
  mac_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.mac_address)
}
#endif
inline void NetworkCards_Item::set_mac_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.mac_address)
}
inline void NetworkCards_Item::set_mac_address(const char* value, size_t size) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.mac_address)
}
inline ::std::string* NetworkCards_Item::mutable_mac_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.mac_address)
  return mac_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_mac_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.mac_address)
  
  return mac_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_mac_address(::std::string* mac_address) {
  if (mac_address != NULL) {
    
  } else {
    
  }
  mac_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.mac_address)
}

// bool is_wins_enabled = 7;
inline void NetworkCards_Item::clear_is_wins_enabled() {
  is_wins_enabled_ = false;
}
inline bool NetworkCards_Item::is_wins_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.is_wins_enabled)
  return is_wins_enabled_;
}
inline void NetworkCards_Item::set_is_wins_enabled(bool value) {
  
  is_wins_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.is_wins_enabled)
}

// string primary_wins_server = 8;
inline void NetworkCards_Item::clear_primary_wins_server() {
  primary_wins_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::primary_wins_server() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.primary_wins_server)
  return primary_wins_server_.GetNoArena();
}
inline void NetworkCards_Item::set_primary_wins_server(const ::std::string& value) {
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.primary_wins_server)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_primary_wins_server(::std::string&& value) {
  
  primary_wins_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.primary_wins_server)
}
#endif
inline void NetworkCards_Item::set_primary_wins_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.primary_wins_server)
}
inline void NetworkCards_Item::set_primary_wins_server(const char* value, size_t size) {
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.primary_wins_server)
}
inline ::std::string* NetworkCards_Item::mutable_primary_wins_server() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.primary_wins_server)
  return primary_wins_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_primary_wins_server() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.primary_wins_server)
  
  return primary_wins_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_primary_wins_server(::std::string* primary_wins_server) {
  if (primary_wins_server != NULL) {
    
  } else {
    
  }
  primary_wins_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_wins_server);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.primary_wins_server)
}

// string secondary_wins_server = 9;
inline void NetworkCards_Item::clear_secondary_wins_server() {
  secondary_wins_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::secondary_wins_server() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.secondary_wins_server)
  return secondary_wins_server_.GetNoArena();
}
inline void NetworkCards_Item::set_secondary_wins_server(const ::std::string& value) {
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_secondary_wins_server(::std::string&& value) {
  
  secondary_wins_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
#endif
inline void NetworkCards_Item::set_secondary_wins_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
inline void NetworkCards_Item::set_secondary_wins_server(const char* value, size_t size) {
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
inline ::std::string* NetworkCards_Item::mutable_secondary_wins_server() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.secondary_wins_server)
  return secondary_wins_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_secondary_wins_server() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.secondary_wins_server)
  
  return secondary_wins_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_secondary_wins_server(::std::string* secondary_wins_server) {
  if (secondary_wins_server != NULL) {
    
  } else {
    
  }
  secondary_wins_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secondary_wins_server);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.secondary_wins_server)
}

// bool is_dhcp_enabled = 10;
inline void NetworkCards_Item::clear_is_dhcp_enabled() {
  is_dhcp_enabled_ = false;
}
inline bool NetworkCards_Item::is_dhcp_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.is_dhcp_enabled)
  return is_dhcp_enabled_;
}
inline void NetworkCards_Item::set_is_dhcp_enabled(bool value) {
  
  is_dhcp_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.is_dhcp_enabled)
}

// repeated .aspia.proto.NetworkCards.Item.IpAddress ip_address = 11;
inline int NetworkCards_Item::ip_address_size() const {
  return ip_address_.size();
}
inline void NetworkCards_Item::clear_ip_address() {
  ip_address_.Clear();
}
inline const ::aspia::proto::NetworkCards_Item_IpAddress& NetworkCards_Item::ip_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_.Get(index);
}
inline ::aspia::proto::NetworkCards_Item_IpAddress* NetworkCards_Item::mutable_ip_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_.Mutable(index);
}
inline ::aspia::proto::NetworkCards_Item_IpAddress* NetworkCards_Item::add_ip_address() {
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >*
NetworkCards_Item::mutable_ip_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.ip_address)
  return &ip_address_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >&
NetworkCards_Item::ip_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_;
}

// repeated string gateway_address = 12;
inline int NetworkCards_Item::gateway_address_size() const {
  return gateway_address_.size();
}
inline void NetworkCards_Item::clear_gateway_address() {
  gateway_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::gateway_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_gateway_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_.Mutable(index);
}
inline void NetworkCards_Item::set_gateway_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.gateway_address)
  gateway_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_gateway_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.gateway_address)
  gateway_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_gateway_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  gateway_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.gateway_address)
}
inline void NetworkCards_Item::set_gateway_address(int index, const char* value, size_t size) {
  gateway_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.gateway_address)
}
inline ::std::string* NetworkCards_Item::add_gateway_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_.Add();
}
inline void NetworkCards_Item::add_gateway_address(const ::std::string& value) {
  gateway_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.gateway_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_gateway_address(::std::string&& value) {
  gateway_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.gateway_address)
}
#endif
inline void NetworkCards_Item::add_gateway_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  gateway_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.proto.NetworkCards.Item.gateway_address)
}
inline void NetworkCards_Item::add_gateway_address(const char* value, size_t size) {
  gateway_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.proto.NetworkCards.Item.gateway_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::gateway_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_gateway_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.gateway_address)
  return &gateway_address_;
}

// repeated string dhcp_server_address = 13;
inline int NetworkCards_Item::dhcp_server_address_size() const {
  return dhcp_server_address_.size();
}
inline void NetworkCards_Item::clear_dhcp_server_address() {
  dhcp_server_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::dhcp_server_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_dhcp_server_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Mutable(index);
}
inline void NetworkCards_Item::set_dhcp_server_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dhcp_server_address)
  dhcp_server_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_dhcp_server_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dhcp_server_address)
  dhcp_server_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_dhcp_server_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dhcp_server_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline void NetworkCards_Item::set_dhcp_server_address(int index, const char* value, size_t size) {
  dhcp_server_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline ::std::string* NetworkCards_Item::add_dhcp_server_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Add();
}
inline void NetworkCards_Item::add_dhcp_server_address(const ::std::string& value) {
  dhcp_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_dhcp_server_address(::std::string&& value) {
  dhcp_server_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
#endif
inline void NetworkCards_Item::add_dhcp_server_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dhcp_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline void NetworkCards_Item::add_dhcp_server_address(const char* value, size_t size) {
  dhcp_server_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::dhcp_server_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_dhcp_server_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return &dhcp_server_address_;
}

// repeated string dns_server_address = 14;
inline int NetworkCards_Item::dns_server_address_size() const {
  return dns_server_address_.size();
}
inline void NetworkCards_Item::clear_dns_server_address() {
  dns_server_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::dns_server_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_dns_server_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Mutable(index);
}
inline void NetworkCards_Item::set_dns_server_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dns_server_address)
  dns_server_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_dns_server_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dns_server_address)
  dns_server_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_dns_server_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_server_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline void NetworkCards_Item::set_dns_server_address(int index, const char* value, size_t size) {
  dns_server_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline ::std::string* NetworkCards_Item::add_dns_server_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Add();
}
inline void NetworkCards_Item::add_dns_server_address(const ::std::string& value) {
  dns_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dns_server_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_dns_server_address(::std::string&& value) {
  dns_server_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dns_server_address)
}
#endif
inline void NetworkCards_Item::add_dns_server_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline void NetworkCards_Item::add_dns_server_address(const char* value, size_t size) {
  dns_server_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::dns_server_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_dns_server_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.dns_server_address)
  return &dns_server_address_;
}

// -------------------------------------------------------------------

// NetworkCards

// repeated .aspia.proto.NetworkCards.Item item = 1;
inline int NetworkCards::item_size() const {
  return item_.size();
}
inline void NetworkCards::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::NetworkCards_Item& NetworkCards::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.item)
  return item_.Get(index);
}
inline ::aspia::proto::NetworkCards_Item* NetworkCards::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::NetworkCards_Item* NetworkCards::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >*
NetworkCards::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >&
NetworkCards::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.item)
  return item_;
}

// -------------------------------------------------------------------

// OpenConnections_Item

// string process_name = 1;
inline void OpenConnections_Item::clear_process_name() {
  process_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::process_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.process_name)
  return process_name_.GetNoArena();
}
inline void OpenConnections_Item::set_process_name(const ::std::string& value) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.process_name)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_process_name(::std::string&& value) {
  
  process_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.process_name)
}
#endif
inline void OpenConnections_Item::set_process_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.process_name)
}
inline void OpenConnections_Item::set_process_name(const char* value, size_t size) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.process_name)
}
inline ::std::string* OpenConnections_Item::mutable_process_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.process_name)
  return process_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_process_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.process_name)
  
  return process_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_process_name(::std::string* process_name) {
  if (process_name != NULL) {
    
  } else {
    
  }
  process_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.process_name)
}

// .aspia.proto.OpenConnections.Item.Protocol protocol = 2;
inline void OpenConnections_Item::clear_protocol() {
  protocol_ = 0;
}
inline ::aspia::proto::OpenConnections_Item_Protocol OpenConnections_Item::protocol() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.protocol)
  return static_cast< ::aspia::proto::OpenConnections_Item_Protocol >(protocol_);
}
inline void OpenConnections_Item::set_protocol(::aspia::proto::OpenConnections_Item_Protocol value) {
  
  protocol_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.protocol)
}

// string local_address = 3;
inline void OpenConnections_Item::clear_local_address() {
  local_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::local_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.local_address)
  return local_address_.GetNoArena();
}
inline void OpenConnections_Item::set_local_address(const ::std::string& value) {
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.local_address)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_local_address(::std::string&& value) {
  
  local_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.local_address)
}
#endif
inline void OpenConnections_Item::set_local_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.local_address)
}
inline void OpenConnections_Item::set_local_address(const char* value, size_t size) {
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.local_address)
}
inline ::std::string* OpenConnections_Item::mutable_local_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.local_address)
  return local_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_local_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.local_address)
  
  return local_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_local_address(::std::string* local_address) {
  if (local_address != NULL) {
    
  } else {
    
  }
  local_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.local_address)
}

// string remote_address = 4;
inline void OpenConnections_Item::clear_remote_address() {
  remote_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::remote_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.remote_address)
  return remote_address_.GetNoArena();
}
inline void OpenConnections_Item::set_remote_address(const ::std::string& value) {
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.remote_address)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_remote_address(::std::string&& value) {
  
  remote_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.remote_address)
}
#endif
inline void OpenConnections_Item::set_remote_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.remote_address)
}
inline void OpenConnections_Item::set_remote_address(const char* value, size_t size) {
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.remote_address)
}
inline ::std::string* OpenConnections_Item::mutable_remote_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.remote_address)
  return remote_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_remote_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.remote_address)
  
  return remote_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_remote_address(::std::string* remote_address) {
  if (remote_address != NULL) {
    
  } else {
    
  }
  remote_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.remote_address)
}

// uint32 local_port = 5;
inline void OpenConnections_Item::clear_local_port() {
  local_port_ = 0u;
}
inline ::google::protobuf::uint32 OpenConnections_Item::local_port() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.local_port)
  return local_port_;
}
inline void OpenConnections_Item::set_local_port(::google::protobuf::uint32 value) {
  
  local_port_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.local_port)
}

// uint32 remote_port = 6;
inline void OpenConnections_Item::clear_remote_port() {
  remote_port_ = 0u;
}
inline ::google::protobuf::uint32 OpenConnections_Item::remote_port() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.remote_port)
  return remote_port_;
}
inline void OpenConnections_Item::set_remote_port(::google::protobuf::uint32 value) {
  
  remote_port_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.remote_port)
}

// string state = 7;
inline void OpenConnections_Item::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::state() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.state)
  return state_.GetNoArena();
}
inline void OpenConnections_Item::set_state(const ::std::string& value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.state)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_state(::std::string&& value) {
  
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.state)
}
#endif
inline void OpenConnections_Item::set_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.state)
}
inline void OpenConnections_Item::set_state(const char* value, size_t size) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.state)
}
inline ::std::string* OpenConnections_Item::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_state() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.state)
  
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.state)
}

// -------------------------------------------------------------------

// OpenConnections

// repeated .aspia.proto.OpenConnections.Item item = 1;
inline int OpenConnections::item_size() const {
  return item_.size();
}
inline void OpenConnections::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::OpenConnections_Item& OpenConnections::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.item)
  return item_.Get(index);
}
inline ::aspia::proto::OpenConnections_Item* OpenConnections::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::OpenConnections_Item* OpenConnections::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.OpenConnections.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >*
OpenConnections::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.OpenConnections.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >&
OpenConnections::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.OpenConnections.item)
  return item_;
}

// -------------------------------------------------------------------

// SharedResources_Item

// string name = 1;
inline void SharedResources_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.name)
  return name_.GetNoArena();
}
inline void SharedResources_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.name)
}
#if LANG_CXX11
inline void SharedResources_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SharedResources.Item.name)
}
#endif
inline void SharedResources_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SharedResources.Item.name)
}
inline void SharedResources_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SharedResources.Item.name)
}
inline ::std::string* SharedResources_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.SharedResources.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SharedResources.Item.name)
}

// .aspia.proto.SharedResources.Item.Type type = 2;
inline void SharedResources_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::SharedResources_Item_Type SharedResources_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.type)
  return static_cast< ::aspia::proto::SharedResources_Item_Type >(type_);
}
inline void SharedResources_Item::set_type(::aspia::proto::SharedResources_Item_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.type)
}

// string description = 3;
inline void SharedResources_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.description)
  return description_.GetNoArena();
}
inline void SharedResources_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.description)
}
#if LANG_CXX11
inline void SharedResources_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SharedResources.Item.description)
}
#endif
inline void SharedResources_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SharedResources.Item.description)
}
inline void SharedResources_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SharedResources.Item.description)
}
inline ::std::string* SharedResources_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.SharedResources.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SharedResources.Item.description)
}

// string local_path = 4;
inline void SharedResources_Item::clear_local_path() {
  local_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::local_path() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.local_path)
  return local_path_.GetNoArena();
}
inline void SharedResources_Item::set_local_path(const ::std::string& value) {
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.local_path)
}
#if LANG_CXX11
inline void SharedResources_Item::set_local_path(::std::string&& value) {
  
  local_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SharedResources.Item.local_path)
}
#endif
inline void SharedResources_Item::set_local_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SharedResources.Item.local_path)
}
inline void SharedResources_Item::set_local_path(const char* value, size_t size) {
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SharedResources.Item.local_path)
}
inline ::std::string* SharedResources_Item::mutable_local_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.Item.local_path)
  return local_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_local_path() {
  // @@protoc_insertion_point(field_release:aspia.proto.SharedResources.Item.local_path)
  
  return local_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_local_path(::std::string* local_path) {
  if (local_path != NULL) {
    
  } else {
    
  }
  local_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_path);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SharedResources.Item.local_path)
}

// uint32 current_uses = 5;
inline void SharedResources_Item::clear_current_uses() {
  current_uses_ = 0u;
}
inline ::google::protobuf::uint32 SharedResources_Item::current_uses() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.current_uses)
  return current_uses_;
}
inline void SharedResources_Item::set_current_uses(::google::protobuf::uint32 value) {
  
  current_uses_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.current_uses)
}

// uint32 maximum_uses = 6;
inline void SharedResources_Item::clear_maximum_uses() {
  maximum_uses_ = 0u;
}
inline ::google::protobuf::uint32 SharedResources_Item::maximum_uses() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.maximum_uses)
  return maximum_uses_;
}
inline void SharedResources_Item::set_maximum_uses(::google::protobuf::uint32 value) {
  
  maximum_uses_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.maximum_uses)
}

// -------------------------------------------------------------------

// SharedResources

// repeated .aspia.proto.SharedResources.Item item = 1;
inline int SharedResources::item_size() const {
  return item_.size();
}
inline void SharedResources::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::SharedResources_Item& SharedResources::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.item)
  return item_.Get(index);
}
inline ::aspia::proto::SharedResources_Item* SharedResources::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::SharedResources_Item* SharedResources::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.SharedResources.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >*
SharedResources::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.SharedResources.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >&
SharedResources::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.SharedResources.item)
  return item_;
}

// -------------------------------------------------------------------

// Routes_Item

// string destonation = 1;
inline void Routes_Item::clear_destonation() {
  destonation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::destonation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.destonation)
  return destonation_.GetNoArena();
}
inline void Routes_Item::set_destonation(const ::std::string& value) {
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.destonation)
}
#if LANG_CXX11
inline void Routes_Item::set_destonation(::std::string&& value) {
  
  destonation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Routes.Item.destonation)
}
#endif
inline void Routes_Item::set_destonation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Routes.Item.destonation)
}
inline void Routes_Item::set_destonation(const char* value, size_t size) {
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Routes.Item.destonation)
}
inline ::std::string* Routes_Item::mutable_destonation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.Item.destonation)
  return destonation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_destonation() {
  // @@protoc_insertion_point(field_release:aspia.proto.Routes.Item.destonation)
  
  return destonation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_destonation(::std::string* destonation) {
  if (destonation != NULL) {
    
  } else {
    
  }
  destonation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destonation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Routes.Item.destonation)
}

// string mask = 2;
inline void Routes_Item::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::mask() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.mask)
  return mask_.GetNoArena();
}
inline void Routes_Item::set_mask(const ::std::string& value) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.mask)
}
#if LANG_CXX11
inline void Routes_Item::set_mask(::std::string&& value) {
  
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Routes.Item.mask)
}
#endif
inline void Routes_Item::set_mask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Routes.Item.mask)
}
inline void Routes_Item::set_mask(const char* value, size_t size) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Routes.Item.mask)
}
inline ::std::string* Routes_Item::mutable_mask() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.Item.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_mask() {
  // @@protoc_insertion_point(field_release:aspia.proto.Routes.Item.mask)
  
  return mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_mask(::std::string* mask) {
  if (mask != NULL) {
    
  } else {
    
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Routes.Item.mask)
}

// string gateway = 3;
inline void Routes_Item::clear_gateway() {
  gateway_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::gateway() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.gateway)
  return gateway_.GetNoArena();
}
inline void Routes_Item::set_gateway(const ::std::string& value) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.gateway)
}
#if LANG_CXX11
inline void Routes_Item::set_gateway(::std::string&& value) {
  
  gateway_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Routes.Item.gateway)
}
#endif
inline void Routes_Item::set_gateway(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Routes.Item.gateway)
}
inline void Routes_Item::set_gateway(const char* value, size_t size) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Routes.Item.gateway)
}
inline ::std::string* Routes_Item::mutable_gateway() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.Item.gateway)
  return gateway_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_gateway() {
  // @@protoc_insertion_point(field_release:aspia.proto.Routes.Item.gateway)
  
  return gateway_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_gateway(::std::string* gateway) {
  if (gateway != NULL) {
    
  } else {
    
  }
  gateway_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gateway);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Routes.Item.gateway)
}

// uint32 metric = 4;
inline void Routes_Item::clear_metric() {
  metric_ = 0u;
}
inline ::google::protobuf::uint32 Routes_Item::metric() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.metric)
  return metric_;
}
inline void Routes_Item::set_metric(::google::protobuf::uint32 value) {
  
  metric_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.metric)
}

// -------------------------------------------------------------------

// Routes

// repeated .aspia.proto.Routes.Item item = 1;
inline int Routes::item_size() const {
  return item_.size();
}
inline void Routes::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Routes_Item& Routes::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.item)
  return item_.Get(index);
}
inline ::aspia::proto::Routes_Item* Routes::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Routes_Item* Routes::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Routes.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >*
Routes::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Routes.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >&
Routes::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Routes.item)
  return item_;
}

// -------------------------------------------------------------------

// Users_Item

// string name = 1;
inline void Users_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.name)
  return name_.GetNoArena();
}
inline void Users_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.name)
}
#if LANG_CXX11
inline void Users_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Users.Item.name)
}
#endif
inline void Users_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Users.Item.name)
}
inline void Users_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Users.Item.name)
}
inline ::std::string* Users_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Users.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Users.Item.name)
}

// string full_name = 2;
inline void Users_Item::clear_full_name() {
  full_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::full_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.full_name)
  return full_name_.GetNoArena();
}
inline void Users_Item::set_full_name(const ::std::string& value) {
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.full_name)
}
#if LANG_CXX11
inline void Users_Item::set_full_name(::std::string&& value) {
  
  full_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Users.Item.full_name)
}
#endif
inline void Users_Item::set_full_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Users.Item.full_name)
}
inline void Users_Item::set_full_name(const char* value, size_t size) {
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Users.Item.full_name)
}
inline ::std::string* Users_Item::mutable_full_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.Item.full_name)
  return full_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_full_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Users.Item.full_name)
  
  return full_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_full_name(::std::string* full_name) {
  if (full_name != NULL) {
    
  } else {
    
  }
  full_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), full_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Users.Item.full_name)
}

// string comment = 3;
inline void Users_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.comment)
  return comment_.GetNoArena();
}
inline void Users_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.comment)
}
#if LANG_CXX11
inline void Users_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Users.Item.comment)
}
#endif
inline void Users_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Users.Item.comment)
}
inline void Users_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Users.Item.comment)
}
inline ::std::string* Users_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.proto.Users.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Users.Item.comment)
}

// bool is_disabled = 4;
inline void Users_Item::clear_is_disabled() {
  is_disabled_ = false;
}
inline bool Users_Item::is_disabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_disabled)
  return is_disabled_;
}
inline void Users_Item::set_is_disabled(bool value) {
  
  is_disabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_disabled)
}

// bool is_password_cant_change = 5;
inline void Users_Item::clear_is_password_cant_change() {
  is_password_cant_change_ = false;
}
inline bool Users_Item::is_password_cant_change() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_password_cant_change)
  return is_password_cant_change_;
}
inline void Users_Item::set_is_password_cant_change(bool value) {
  
  is_password_cant_change_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_password_cant_change)
}

// bool is_password_expired = 6;
inline void Users_Item::clear_is_password_expired() {
  is_password_expired_ = false;
}
inline bool Users_Item::is_password_expired() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_password_expired)
  return is_password_expired_;
}
inline void Users_Item::set_is_password_expired(bool value) {
  
  is_password_expired_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_password_expired)
}

// bool is_dont_expire_password = 7;
inline void Users_Item::clear_is_dont_expire_password() {
  is_dont_expire_password_ = false;
}
inline bool Users_Item::is_dont_expire_password() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_dont_expire_password)
  return is_dont_expire_password_;
}
inline void Users_Item::set_is_dont_expire_password(bool value) {
  
  is_dont_expire_password_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_dont_expire_password)
}

// bool is_lockout = 8;
inline void Users_Item::clear_is_lockout() {
  is_lockout_ = false;
}
inline bool Users_Item::is_lockout() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_lockout)
  return is_lockout_;
}
inline void Users_Item::set_is_lockout(bool value) {
  
  is_lockout_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_lockout)
}

// uint32 number_logons = 9;
inline void Users_Item::clear_number_logons() {
  number_logons_ = 0u;
}
inline ::google::protobuf::uint32 Users_Item::number_logons() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.number_logons)
  return number_logons_;
}
inline void Users_Item::set_number_logons(::google::protobuf::uint32 value) {
  
  number_logons_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.number_logons)
}

// uint32 bad_password_count = 10;
inline void Users_Item::clear_bad_password_count() {
  bad_password_count_ = 0u;
}
inline ::google::protobuf::uint32 Users_Item::bad_password_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.bad_password_count)
  return bad_password_count_;
}
inline void Users_Item::set_bad_password_count(::google::protobuf::uint32 value) {
  
  bad_password_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.bad_password_count)
}

// int64 last_logon_time = 11;
inline void Users_Item::clear_last_logon_time() {
  last_logon_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Users_Item::last_logon_time() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.last_logon_time)
  return last_logon_time_;
}
inline void Users_Item::set_last_logon_time(::google::protobuf::int64 value) {
  
  last_logon_time_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.last_logon_time)
}

// -------------------------------------------------------------------

// Users

// repeated .aspia.proto.Users.Item item = 1;
inline int Users::item_size() const {
  return item_.size();
}
inline void Users::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Users_Item& Users::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.item)
  return item_.Get(index);
}
inline ::aspia::proto::Users_Item* Users::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Users_Item* Users::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Users.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >*
Users::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Users.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >&
Users::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Users.item)
  return item_;
}

// -------------------------------------------------------------------

// UserGroups_Item

// string name = 1;
inline void UserGroups_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserGroups_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.UserGroups.Item.name)
  return name_.GetNoArena();
}
inline void UserGroups_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.UserGroups.Item.name)
}
#if LANG_CXX11
inline void UserGroups_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.UserGroups.Item.name)
}
#endif
inline void UserGroups_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.UserGroups.Item.name)
}
inline void UserGroups_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.UserGroups.Item.name)
}
inline ::std::string* UserGroups_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.UserGroups.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserGroups_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.UserGroups.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserGroups_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.UserGroups.Item.name)
}

// string comment = 2;
inline void UserGroups_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserGroups_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.proto.UserGroups.Item.comment)
  return comment_.GetNoArena();
}
inline void UserGroups_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.UserGroups.Item.comment)
}
#if LANG_CXX11
inline void UserGroups_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.UserGroups.Item.comment)
}
#endif
inline void UserGroups_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.UserGroups.Item.comment)
}
inline void UserGroups_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.UserGroups.Item.comment)
}
inline ::std::string* UserGroups_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.UserGroups.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserGroups_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.proto.UserGroups.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserGroups_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.UserGroups.Item.comment)
}

// -------------------------------------------------------------------

// UserGroups

// repeated .aspia.proto.UserGroups.Item item = 1;
inline int UserGroups::item_size() const {
  return item_.size();
}
inline void UserGroups::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::UserGroups_Item& UserGroups::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.UserGroups.item)
  return item_.Get(index);
}
inline ::aspia::proto::UserGroups_Item* UserGroups::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.UserGroups.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::UserGroups_Item* UserGroups::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.UserGroups.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >*
UserGroups::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.UserGroups.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >&
UserGroups::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.UserGroups.item)
  return item_;
}

// -------------------------------------------------------------------

// Sessions_Item

// string user_name = 1;
inline void Sessions_Item::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::user_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.user_name)
  return user_name_.GetNoArena();
}
inline void Sessions_Item::set_user_name(const ::std::string& value) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.user_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_user_name(::std::string&& value) {
  
  user_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.user_name)
}
#endif
inline void Sessions_Item::set_user_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.user_name)
}
inline void Sessions_Item::set_user_name(const char* value, size_t size) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.user_name)
}
inline ::std::string* Sessions_Item::mutable_user_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_user_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.user_name)
  
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    
  } else {
    
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.user_name)
}

// string domain_name = 2;
inline void Sessions_Item::clear_domain_name() {
  domain_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::domain_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.domain_name)
  return domain_name_.GetNoArena();
}
inline void Sessions_Item::set_domain_name(const ::std::string& value) {
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.domain_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_domain_name(::std::string&& value) {
  
  domain_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.domain_name)
}
#endif
inline void Sessions_Item::set_domain_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.domain_name)
}
inline void Sessions_Item::set_domain_name(const char* value, size_t size) {
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.domain_name)
}
inline ::std::string* Sessions_Item::mutable_domain_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.domain_name)
  return domain_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_domain_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.domain_name)
  
  return domain_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_domain_name(::std::string* domain_name) {
  if (domain_name != NULL) {
    
  } else {
    
  }
  domain_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.domain_name)
}

// uint32 session_id = 3;
inline void Sessions_Item::clear_session_id() {
  session_id_ = 0u;
}
inline ::google::protobuf::uint32 Sessions_Item::session_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.session_id)
  return session_id_;
}
inline void Sessions_Item::set_session_id(::google::protobuf::uint32 value) {
  
  session_id_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.session_id)
}

// string connect_state = 4;
inline void Sessions_Item::clear_connect_state() {
  connect_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::connect_state() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.connect_state)
  return connect_state_.GetNoArena();
}
inline void Sessions_Item::set_connect_state(const ::std::string& value) {
  
  connect_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.connect_state)
}
#if LANG_CXX11
inline void Sessions_Item::set_connect_state(::std::string&& value) {
  
  connect_state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.connect_state)
}
#endif
inline void Sessions_Item::set_connect_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  connect_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.connect_state)
}
inline void Sessions_Item::set_connect_state(const char* value, size_t size) {
  
  connect_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.connect_state)
}
inline ::std::string* Sessions_Item::mutable_connect_state() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.connect_state)
  return connect_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_connect_state() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.connect_state)
  
  return connect_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_connect_state(::std::string* connect_state) {
  if (connect_state != NULL) {
    
  } else {
    
  }
  connect_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connect_state);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.connect_state)
}

// string client_name = 5;
inline void Sessions_Item::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::client_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.client_name)
  return client_name_.GetNoArena();
}
inline void Sessions_Item::set_client_name(const ::std::string& value) {
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.client_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_client_name(::std::string&& value) {
  
  client_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.client_name)
}
#endif
inline void Sessions_Item::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.client_name)
}
inline void Sessions_Item::set_client_name(const char* value, size_t size) {
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.client_name)
}
inline ::std::string* Sessions_Item::mutable_client_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.client_name)
  return client_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_client_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.client_name)
  
  return client_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_client_name(::std::string* client_name) {
  if (client_name != NULL) {
    
  } else {
    
  }
  client_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.client_name)
}

// string winstation_name = 6;
inline void Sessions_Item::clear_winstation_name() {
  winstation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::winstation_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.winstation_name)
  return winstation_name_.GetNoArena();
}
inline void Sessions_Item::set_winstation_name(const ::std::string& value) {
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.winstation_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_winstation_name(::std::string&& value) {
  
  winstation_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.winstation_name)
}
#endif
inline void Sessions_Item::set_winstation_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.winstation_name)
}
inline void Sessions_Item::set_winstation_name(const char* value, size_t size) {
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.winstation_name)
}
inline ::std::string* Sessions_Item::mutable_winstation_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.winstation_name)
  return winstation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_winstation_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.winstation_name)
  
  return winstation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_winstation_name(::std::string* winstation_name) {
  if (winstation_name != NULL) {
    
  } else {
    
  }
  winstation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), winstation_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.winstation_name)
}

// -------------------------------------------------------------------

// Sessions

// repeated .aspia.proto.Sessions.Item item = 1;
inline int Sessions::item_size() const {
  return item_.size();
}
inline void Sessions::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Sessions_Item& Sessions::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.item)
  return item_.Get(index);
}
inline ::aspia::proto::Sessions_Item* Sessions::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Sessions_Item* Sessions::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Sessions.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >*
Sessions::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Sessions.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >&
Sessions::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Sessions.item)
  return item_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace aspia

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aspia::proto::PowerOptions_Battery_State> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::PowerOptions_PowerSource> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::PowerOptions_BatteryStatus> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Printers_Item_Orientation> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Services_Item_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Services_Item_StartupType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::OpenConnections_Item_Protocol> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::SharedResources_Item_Type> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED

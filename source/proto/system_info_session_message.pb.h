// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system_info_session_message.proto

#ifndef PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED
#define PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace protobuf_system_5finfo_5fsession_5fmessage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[59];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsDmiBiosImpl();
void InitDefaultsDmiBios();
void InitDefaultsDmiSystemImpl();
void InitDefaultsDmiSystem();
void InitDefaultsDmiBaseboard_FeaturesImpl();
void InitDefaultsDmiBaseboard_Features();
void InitDefaultsDmiBaseboard_ItemImpl();
void InitDefaultsDmiBaseboard_Item();
void InitDefaultsDmiBaseboardImpl();
void InitDefaultsDmiBaseboard();
void InitDefaultsDmiChassis_ItemImpl();
void InitDefaultsDmiChassis_Item();
void InitDefaultsDmiChassisImpl();
void InitDefaultsDmiChassis();
void InitDefaultsDmiCaches_ItemImpl();
void InitDefaultsDmiCaches_Item();
void InitDefaultsDmiCachesImpl();
void InitDefaultsDmiCaches();
void InitDefaultsDmiProcessors_ItemImpl();
void InitDefaultsDmiProcessors_Item();
void InitDefaultsDmiProcessorsImpl();
void InitDefaultsDmiProcessors();
void InitDefaultsDmiMemoryDevices_ItemImpl();
void InitDefaultsDmiMemoryDevices_Item();
void InitDefaultsDmiMemoryDevicesImpl();
void InitDefaultsDmiMemoryDevices();
void InitDefaultsDmiSystemSlots_ItemImpl();
void InitDefaultsDmiSystemSlots_Item();
void InitDefaultsDmiSystemSlotsImpl();
void InitDefaultsDmiSystemSlots();
void InitDefaultsDmiPortConnectors_ItemImpl();
void InitDefaultsDmiPortConnectors_Item();
void InitDefaultsDmiPortConnectorsImpl();
void InitDefaultsDmiPortConnectors();
void InitDefaultsDmiOnBoardDevices_ItemImpl();
void InitDefaultsDmiOnBoardDevices_Item();
void InitDefaultsDmiOnBoardDevicesImpl();
void InitDefaultsDmiOnBoardDevices();
void InitDefaultsDmiPointingDevice_ItemImpl();
void InitDefaultsDmiPointingDevice_Item();
void InitDefaultsDmiPointingDeviceImpl();
void InitDefaultsDmiPointingDevice();
void InitDefaultsDmiPortableBattery_ItemImpl();
void InitDefaultsDmiPortableBattery_Item();
void InitDefaultsDmiPortableBatteryImpl();
void InitDefaultsDmiPortableBattery();
void InitDefaultsCPU_FeaturesImpl();
void InitDefaultsCPU_Features();
void InitDefaultsCPUImpl();
void InitDefaultsCPU();
void InitDefaultsAtaDrives_ItemImpl();
void InitDefaultsAtaDrives_Item();
void InitDefaultsAtaDrivesImpl();
void InitDefaultsAtaDrives();
void InitDefaultsVideoAdapters_ItemImpl();
void InitDefaultsVideoAdapters_Item();
void InitDefaultsVideoAdaptersImpl();
void InitDefaultsVideoAdapters();
void InitDefaultsMonitors_TimingImpl();
void InitDefaultsMonitors_Timing();
void InitDefaultsMonitors_ItemImpl();
void InitDefaultsMonitors_Item();
void InitDefaultsMonitorsImpl();
void InitDefaultsMonitors();
void InitDefaultsPowerOptions_BatteryImpl();
void InitDefaultsPowerOptions_Battery();
void InitDefaultsPowerOptionsImpl();
void InitDefaultsPowerOptions();
void InitDefaultsPrinters_ItemImpl();
void InitDefaultsPrinters_Item();
void InitDefaultsPrintersImpl();
void InitDefaultsPrinters();
void InitDefaultsWindowsDevices_ItemImpl();
void InitDefaultsWindowsDevices_Item();
void InitDefaultsWindowsDevicesImpl();
void InitDefaultsWindowsDevices();
void InitDefaultsPrograms_ItemImpl();
void InitDefaultsPrograms_Item();
void InitDefaultsProgramsImpl();
void InitDefaultsPrograms();
void InitDefaultsServices_ItemImpl();
void InitDefaultsServices_Item();
void InitDefaultsServicesImpl();
void InitDefaultsServices();
void InitDefaultsProcesses_ItemImpl();
void InitDefaultsProcesses_Item();
void InitDefaultsProcessesImpl();
void InitDefaultsProcesses();
void InitDefaultsNetworkCards_Item_IpAddressImpl();
void InitDefaultsNetworkCards_Item_IpAddress();
void InitDefaultsNetworkCards_ItemImpl();
void InitDefaultsNetworkCards_Item();
void InitDefaultsNetworkCardsImpl();
void InitDefaultsNetworkCards();
void InitDefaultsOpenConnections_ItemImpl();
void InitDefaultsOpenConnections_Item();
void InitDefaultsOpenConnectionsImpl();
void InitDefaultsOpenConnections();
void InitDefaultsSharedResources_ItemImpl();
void InitDefaultsSharedResources_Item();
void InitDefaultsSharedResourcesImpl();
void InitDefaultsSharedResources();
void InitDefaultsRoutes_ItemImpl();
void InitDefaultsRoutes_Item();
void InitDefaultsRoutesImpl();
void InitDefaultsRoutes();
void InitDefaultsUsers_ItemImpl();
void InitDefaultsUsers_Item();
void InitDefaultsUsersImpl();
void InitDefaultsUsers();
void InitDefaultsUserGroups_ItemImpl();
void InitDefaultsUserGroups_Item();
void InitDefaultsUserGroupsImpl();
void InitDefaultsUserGroups();
void InitDefaultsSessions_ItemImpl();
void InitDefaultsSessions_Item();
void InitDefaultsSessionsImpl();
void InitDefaultsSessions();
inline void InitDefaults() {
  InitDefaultsDmiBios();
  InitDefaultsDmiSystem();
  InitDefaultsDmiBaseboard_Features();
  InitDefaultsDmiBaseboard_Item();
  InitDefaultsDmiBaseboard();
  InitDefaultsDmiChassis_Item();
  InitDefaultsDmiChassis();
  InitDefaultsDmiCaches_Item();
  InitDefaultsDmiCaches();
  InitDefaultsDmiProcessors_Item();
  InitDefaultsDmiProcessors();
  InitDefaultsDmiMemoryDevices_Item();
  InitDefaultsDmiMemoryDevices();
  InitDefaultsDmiSystemSlots_Item();
  InitDefaultsDmiSystemSlots();
  InitDefaultsDmiPortConnectors_Item();
  InitDefaultsDmiPortConnectors();
  InitDefaultsDmiOnBoardDevices_Item();
  InitDefaultsDmiOnBoardDevices();
  InitDefaultsDmiPointingDevice_Item();
  InitDefaultsDmiPointingDevice();
  InitDefaultsDmiPortableBattery_Item();
  InitDefaultsDmiPortableBattery();
  InitDefaultsCPU_Features();
  InitDefaultsCPU();
  InitDefaultsAtaDrives_Item();
  InitDefaultsAtaDrives();
  InitDefaultsVideoAdapters_Item();
  InitDefaultsVideoAdapters();
  InitDefaultsMonitors_Timing();
  InitDefaultsMonitors_Item();
  InitDefaultsMonitors();
  InitDefaultsPowerOptions_Battery();
  InitDefaultsPowerOptions();
  InitDefaultsPrinters_Item();
  InitDefaultsPrinters();
  InitDefaultsWindowsDevices_Item();
  InitDefaultsWindowsDevices();
  InitDefaultsPrograms_Item();
  InitDefaultsPrograms();
  InitDefaultsServices_Item();
  InitDefaultsServices();
  InitDefaultsProcesses_Item();
  InitDefaultsProcesses();
  InitDefaultsNetworkCards_Item_IpAddress();
  InitDefaultsNetworkCards_Item();
  InitDefaultsNetworkCards();
  InitDefaultsOpenConnections_Item();
  InitDefaultsOpenConnections();
  InitDefaultsSharedResources_Item();
  InitDefaultsSharedResources();
  InitDefaultsRoutes_Item();
  InitDefaultsRoutes();
  InitDefaultsUsers_Item();
  InitDefaultsUsers();
  InitDefaultsUserGroups_Item();
  InitDefaultsUserGroups();
  InitDefaultsSessions_Item();
  InitDefaultsSessions();
}
}  // namespace protobuf_system_5finfo_5fsession_5fmessage_2eproto
namespace aspia {
namespace proto {
class AtaDrives;
class AtaDrivesDefaultTypeInternal;
extern AtaDrivesDefaultTypeInternal _AtaDrives_default_instance_;
class AtaDrives_Item;
class AtaDrives_ItemDefaultTypeInternal;
extern AtaDrives_ItemDefaultTypeInternal _AtaDrives_Item_default_instance_;
class CPU;
class CPUDefaultTypeInternal;
extern CPUDefaultTypeInternal _CPU_default_instance_;
class CPU_Features;
class CPU_FeaturesDefaultTypeInternal;
extern CPU_FeaturesDefaultTypeInternal _CPU_Features_default_instance_;
class DmiBaseboard;
class DmiBaseboardDefaultTypeInternal;
extern DmiBaseboardDefaultTypeInternal _DmiBaseboard_default_instance_;
class DmiBaseboard_Features;
class DmiBaseboard_FeaturesDefaultTypeInternal;
extern DmiBaseboard_FeaturesDefaultTypeInternal _DmiBaseboard_Features_default_instance_;
class DmiBaseboard_Item;
class DmiBaseboard_ItemDefaultTypeInternal;
extern DmiBaseboard_ItemDefaultTypeInternal _DmiBaseboard_Item_default_instance_;
class DmiBios;
class DmiBiosDefaultTypeInternal;
extern DmiBiosDefaultTypeInternal _DmiBios_default_instance_;
class DmiCaches;
class DmiCachesDefaultTypeInternal;
extern DmiCachesDefaultTypeInternal _DmiCaches_default_instance_;
class DmiCaches_Item;
class DmiCaches_ItemDefaultTypeInternal;
extern DmiCaches_ItemDefaultTypeInternal _DmiCaches_Item_default_instance_;
class DmiChassis;
class DmiChassisDefaultTypeInternal;
extern DmiChassisDefaultTypeInternal _DmiChassis_default_instance_;
class DmiChassis_Item;
class DmiChassis_ItemDefaultTypeInternal;
extern DmiChassis_ItemDefaultTypeInternal _DmiChassis_Item_default_instance_;
class DmiMemoryDevices;
class DmiMemoryDevicesDefaultTypeInternal;
extern DmiMemoryDevicesDefaultTypeInternal _DmiMemoryDevices_default_instance_;
class DmiMemoryDevices_Item;
class DmiMemoryDevices_ItemDefaultTypeInternal;
extern DmiMemoryDevices_ItemDefaultTypeInternal _DmiMemoryDevices_Item_default_instance_;
class DmiOnBoardDevices;
class DmiOnBoardDevicesDefaultTypeInternal;
extern DmiOnBoardDevicesDefaultTypeInternal _DmiOnBoardDevices_default_instance_;
class DmiOnBoardDevices_Item;
class DmiOnBoardDevices_ItemDefaultTypeInternal;
extern DmiOnBoardDevices_ItemDefaultTypeInternal _DmiOnBoardDevices_Item_default_instance_;
class DmiPointingDevice;
class DmiPointingDeviceDefaultTypeInternal;
extern DmiPointingDeviceDefaultTypeInternal _DmiPointingDevice_default_instance_;
class DmiPointingDevice_Item;
class DmiPointingDevice_ItemDefaultTypeInternal;
extern DmiPointingDevice_ItemDefaultTypeInternal _DmiPointingDevice_Item_default_instance_;
class DmiPortConnectors;
class DmiPortConnectorsDefaultTypeInternal;
extern DmiPortConnectorsDefaultTypeInternal _DmiPortConnectors_default_instance_;
class DmiPortConnectors_Item;
class DmiPortConnectors_ItemDefaultTypeInternal;
extern DmiPortConnectors_ItemDefaultTypeInternal _DmiPortConnectors_Item_default_instance_;
class DmiPortableBattery;
class DmiPortableBatteryDefaultTypeInternal;
extern DmiPortableBatteryDefaultTypeInternal _DmiPortableBattery_default_instance_;
class DmiPortableBattery_Item;
class DmiPortableBattery_ItemDefaultTypeInternal;
extern DmiPortableBattery_ItemDefaultTypeInternal _DmiPortableBattery_Item_default_instance_;
class DmiProcessors;
class DmiProcessorsDefaultTypeInternal;
extern DmiProcessorsDefaultTypeInternal _DmiProcessors_default_instance_;
class DmiProcessors_Item;
class DmiProcessors_ItemDefaultTypeInternal;
extern DmiProcessors_ItemDefaultTypeInternal _DmiProcessors_Item_default_instance_;
class DmiSystem;
class DmiSystemDefaultTypeInternal;
extern DmiSystemDefaultTypeInternal _DmiSystem_default_instance_;
class DmiSystemSlots;
class DmiSystemSlotsDefaultTypeInternal;
extern DmiSystemSlotsDefaultTypeInternal _DmiSystemSlots_default_instance_;
class DmiSystemSlots_Item;
class DmiSystemSlots_ItemDefaultTypeInternal;
extern DmiSystemSlots_ItemDefaultTypeInternal _DmiSystemSlots_Item_default_instance_;
class Monitors;
class MonitorsDefaultTypeInternal;
extern MonitorsDefaultTypeInternal _Monitors_default_instance_;
class Monitors_Item;
class Monitors_ItemDefaultTypeInternal;
extern Monitors_ItemDefaultTypeInternal _Monitors_Item_default_instance_;
class Monitors_Timing;
class Monitors_TimingDefaultTypeInternal;
extern Monitors_TimingDefaultTypeInternal _Monitors_Timing_default_instance_;
class NetworkCards;
class NetworkCardsDefaultTypeInternal;
extern NetworkCardsDefaultTypeInternal _NetworkCards_default_instance_;
class NetworkCards_Item;
class NetworkCards_ItemDefaultTypeInternal;
extern NetworkCards_ItemDefaultTypeInternal _NetworkCards_Item_default_instance_;
class NetworkCards_Item_IpAddress;
class NetworkCards_Item_IpAddressDefaultTypeInternal;
extern NetworkCards_Item_IpAddressDefaultTypeInternal _NetworkCards_Item_IpAddress_default_instance_;
class OpenConnections;
class OpenConnectionsDefaultTypeInternal;
extern OpenConnectionsDefaultTypeInternal _OpenConnections_default_instance_;
class OpenConnections_Item;
class OpenConnections_ItemDefaultTypeInternal;
extern OpenConnections_ItemDefaultTypeInternal _OpenConnections_Item_default_instance_;
class PowerOptions;
class PowerOptionsDefaultTypeInternal;
extern PowerOptionsDefaultTypeInternal _PowerOptions_default_instance_;
class PowerOptions_Battery;
class PowerOptions_BatteryDefaultTypeInternal;
extern PowerOptions_BatteryDefaultTypeInternal _PowerOptions_Battery_default_instance_;
class Printers;
class PrintersDefaultTypeInternal;
extern PrintersDefaultTypeInternal _Printers_default_instance_;
class Printers_Item;
class Printers_ItemDefaultTypeInternal;
extern Printers_ItemDefaultTypeInternal _Printers_Item_default_instance_;
class Processes;
class ProcessesDefaultTypeInternal;
extern ProcessesDefaultTypeInternal _Processes_default_instance_;
class Processes_Item;
class Processes_ItemDefaultTypeInternal;
extern Processes_ItemDefaultTypeInternal _Processes_Item_default_instance_;
class Programs;
class ProgramsDefaultTypeInternal;
extern ProgramsDefaultTypeInternal _Programs_default_instance_;
class Programs_Item;
class Programs_ItemDefaultTypeInternal;
extern Programs_ItemDefaultTypeInternal _Programs_Item_default_instance_;
class Routes;
class RoutesDefaultTypeInternal;
extern RoutesDefaultTypeInternal _Routes_default_instance_;
class Routes_Item;
class Routes_ItemDefaultTypeInternal;
extern Routes_ItemDefaultTypeInternal _Routes_Item_default_instance_;
class Services;
class ServicesDefaultTypeInternal;
extern ServicesDefaultTypeInternal _Services_default_instance_;
class Services_Item;
class Services_ItemDefaultTypeInternal;
extern Services_ItemDefaultTypeInternal _Services_Item_default_instance_;
class Sessions;
class SessionsDefaultTypeInternal;
extern SessionsDefaultTypeInternal _Sessions_default_instance_;
class Sessions_Item;
class Sessions_ItemDefaultTypeInternal;
extern Sessions_ItemDefaultTypeInternal _Sessions_Item_default_instance_;
class SharedResources;
class SharedResourcesDefaultTypeInternal;
extern SharedResourcesDefaultTypeInternal _SharedResources_default_instance_;
class SharedResources_Item;
class SharedResources_ItemDefaultTypeInternal;
extern SharedResources_ItemDefaultTypeInternal _SharedResources_Item_default_instance_;
class UserGroups;
class UserGroupsDefaultTypeInternal;
extern UserGroupsDefaultTypeInternal _UserGroups_default_instance_;
class UserGroups_Item;
class UserGroups_ItemDefaultTypeInternal;
extern UserGroups_ItemDefaultTypeInternal _UserGroups_Item_default_instance_;
class Users;
class UsersDefaultTypeInternal;
extern UsersDefaultTypeInternal _Users_default_instance_;
class Users_Item;
class Users_ItemDefaultTypeInternal;
extern Users_ItemDefaultTypeInternal _Users_Item_default_instance_;
class VideoAdapters;
class VideoAdaptersDefaultTypeInternal;
extern VideoAdaptersDefaultTypeInternal _VideoAdapters_default_instance_;
class VideoAdapters_Item;
class VideoAdapters_ItemDefaultTypeInternal;
extern VideoAdapters_ItemDefaultTypeInternal _VideoAdapters_Item_default_instance_;
class WindowsDevices;
class WindowsDevicesDefaultTypeInternal;
extern WindowsDevicesDefaultTypeInternal _WindowsDevices_default_instance_;
class WindowsDevices_Item;
class WindowsDevices_ItemDefaultTypeInternal;
extern WindowsDevices_ItemDefaultTypeInternal _WindowsDevices_Item_default_instance_;
}  // namespace proto
}  // namespace aspia
namespace aspia {
namespace proto {

enum DmiBios_Characteristics {
  DmiBios_Characteristics_CHARACTERISTIC_NONE = 0,
  DmiBios_Characteristics_CHARACTERISTIC_ISA = 1,
  DmiBios_Characteristics_CHARACTERISTIC_MCA = 2,
  DmiBios_Characteristics_CHARACTERISTIC_EISA = 4,
  DmiBios_Characteristics_CHARACTERISTIC_PCI = 8,
  DmiBios_Characteristics_CHARACTERISTIC_PC_CARD = 16,
  DmiBios_Characteristics_CHARACTERISTIC_PLUG_AND_PLAY = 32,
  DmiBios_Characteristics_CHARACTERISTIC_APM = 64,
  DmiBios_Characteristics_CHARACTERISTIC_BIOS_IS_UPGRADEABLE = 128,
  DmiBios_Characteristics_CHARACTERISTIC_BIOS_SHADOWING = 256,
  DmiBios_Characteristics_CHARACTERISTIC_VLB = 512,
  DmiBios_Characteristics_CHARACTERISTIC_ESCD = 1024,
  DmiBios_Characteristics_CHARACTERISTIC_BOOT_FROM_CD = 2048,
  DmiBios_Characteristics_CHARACTERISTIC_SELECTABLE_BOOT = 4096,
  DmiBios_Characteristics_CHARACTERISTIC_BOOT_ROM_IS_SOCKETED = 8192,
  DmiBios_Characteristics_CHARACTERISTIC_BOOT_FROM_PC_CARD = 16384,
  DmiBios_Characteristics_CHARACTERISTIC_EDD = 32768,
  DmiBios_Characteristics_CHARACTERISTIC_JAPANESE_FLOPPY_FOR_NEC9800 = 65536,
  DmiBios_Characteristics_CHARACTERISTIC_JAPANESE_FLOPPY_FOR_TOSHIBA = 131072,
  DmiBios_Characteristics_CHARACTERISTIC_525_360KB_FLOPPY = 262144,
  DmiBios_Characteristics_CHARACTERISTIC_525_12MB_FLOPPY = 524288,
  DmiBios_Characteristics_CHARACTERISTIC_35_720KB_FLOPPY = 1048576,
  DmiBios_Characteristics_CHARACTERISTIC_35_288MB_FLOPPY = 2097152,
  DmiBios_Characteristics_CHARACTERISTIC_PRINT_SCREEN = 4194304,
  DmiBios_Characteristics_CHARACTERISTIC_8042_KEYBOARD = 8388608,
  DmiBios_Characteristics_CHARACTERISTIC_SERIAL = 16777216,
  DmiBios_Characteristics_CHARACTERISTIC_PRINTER = 33554432,
  DmiBios_Characteristics_CHARACTERISTIC_CGA_VIDEO = 67108864,
  DmiBios_Characteristics_CHARACTERISTIC_NEC_PC98 = 134217728,
  DmiBios_Characteristics_DmiBios_Characteristics_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiBios_Characteristics_DmiBios_Characteristics_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiBios_Characteristics_IsValid(int value);
const DmiBios_Characteristics DmiBios_Characteristics_Characteristics_MIN = DmiBios_Characteristics_CHARACTERISTIC_NONE;
const DmiBios_Characteristics DmiBios_Characteristics_Characteristics_MAX = DmiBios_Characteristics_CHARACTERISTIC_NEC_PC98;
const int DmiBios_Characteristics_Characteristics_ARRAYSIZE = DmiBios_Characteristics_Characteristics_MAX + 1;

enum DmiBios_Characteristics1 {
  DmiBios_Characteristics1_CHARACTERISTIC1_NONE = 0,
  DmiBios_Characteristics1_CHARACTERISTIC1_ACPI = 1,
  DmiBios_Characteristics1_CHARACTERISTIC1_USB_LEGACY = 2,
  DmiBios_Characteristics1_CHARACTERISTIC1_AGP = 4,
  DmiBios_Characteristics1_CHARACTERISTIC1_I2O_BOOT = 8,
  DmiBios_Characteristics1_CHARACTERISTIC1_LS120_BOOT = 16,
  DmiBios_Characteristics1_CHARACTERISTIC1_ATAPI_ZIP_DRIVE_BOOT = 32,
  DmiBios_Characteristics1_CHARACTERISTIC1_IEEE1394_BOOT = 64,
  DmiBios_Characteristics1_CHARACTERISTIC1_SMART_BATTERY = 128,
  DmiBios_Characteristics1_DmiBios_Characteristics1_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiBios_Characteristics1_DmiBios_Characteristics1_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiBios_Characteristics1_IsValid(int value);
const DmiBios_Characteristics1 DmiBios_Characteristics1_Characteristics1_MIN = DmiBios_Characteristics1_CHARACTERISTIC1_NONE;
const DmiBios_Characteristics1 DmiBios_Characteristics1_Characteristics1_MAX = DmiBios_Characteristics1_CHARACTERISTIC1_SMART_BATTERY;
const int DmiBios_Characteristics1_Characteristics1_ARRAYSIZE = DmiBios_Characteristics1_Characteristics1_MAX + 1;

enum DmiBios_Characteristics2 {
  DmiBios_Characteristics2_CHARACTERISTIC2_NONE = 0,
  DmiBios_Characteristics2_CHARACTERISTIC2_BIOS_BOOT_SPECIFICATION = 1,
  DmiBios_Characteristics2_CHARACTERISTIC2_KEY_INITIALIZED_NETWORK_BOOT = 2,
  DmiBios_Characteristics2_CHARACTERISTIC2_TARGETED_CONTENT_DISTRIBUTION = 4,
  DmiBios_Characteristics2_DmiBios_Characteristics2_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiBios_Characteristics2_DmiBios_Characteristics2_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiBios_Characteristics2_IsValid(int value);
const DmiBios_Characteristics2 DmiBios_Characteristics2_Characteristics2_MIN = DmiBios_Characteristics2_CHARACTERISTIC2_NONE;
const DmiBios_Characteristics2 DmiBios_Characteristics2_Characteristics2_MAX = DmiBios_Characteristics2_CHARACTERISTIC2_TARGETED_CONTENT_DISTRIBUTION;
const int DmiBios_Characteristics2_Characteristics2_ARRAYSIZE = DmiBios_Characteristics2_Characteristics2_MAX + 1;

enum DmiSystem_WakeupType {
  DmiSystem_WakeupType_WAKEUP_TYPE_UNKNOWN = 0,
  DmiSystem_WakeupType_WAKEUP_TYPE_OTHER = 1,
  DmiSystem_WakeupType_WAKEUP_TYPE_APM_TIMER = 2,
  DmiSystem_WakeupType_WAKEUP_TYPE_MODEM_RING = 3,
  DmiSystem_WakeupType_WAKEUP_TYPE_LAN_REMOTE = 4,
  DmiSystem_WakeupType_WAKEUP_TYPE_POWER_SWITCH = 5,
  DmiSystem_WakeupType_WAKEUP_TYPE_PCI_PME = 6,
  DmiSystem_WakeupType_WAKEUP_TYPE_AC_POWER_RESTORED = 7,
  DmiSystem_WakeupType_DmiSystem_WakeupType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiSystem_WakeupType_DmiSystem_WakeupType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiSystem_WakeupType_IsValid(int value);
const DmiSystem_WakeupType DmiSystem_WakeupType_WakeupType_MIN = DmiSystem_WakeupType_WAKEUP_TYPE_UNKNOWN;
const DmiSystem_WakeupType DmiSystem_WakeupType_WakeupType_MAX = DmiSystem_WakeupType_WAKEUP_TYPE_AC_POWER_RESTORED;
const int DmiSystem_WakeupType_WakeupType_ARRAYSIZE = DmiSystem_WakeupType_WakeupType_MAX + 1;

enum DmiBaseboard_BoardType {
  DmiBaseboard_BoardType_BOARD_TYPE_UNKNOWN = 0,
  DmiBaseboard_BoardType_BOARD_TYPE_OTHER = 1,
  DmiBaseboard_BoardType_BOARD_TYPE_SERVER_BLADE = 2,
  DmiBaseboard_BoardType_BOARD_TYPE_CONNECTIVITY_SWITCH = 3,
  DmiBaseboard_BoardType_BOARD_TYPE_SYSTEM_MANAGEMENT_MODULE = 4,
  DmiBaseboard_BoardType_BOARD_TYPE_PROCESSOR_MODULE = 5,
  DmiBaseboard_BoardType_BOARD_TYPE_IO_MODULE = 6,
  DmiBaseboard_BoardType_BOARD_TYPE_MEMORY_MODULE = 7,
  DmiBaseboard_BoardType_BOARD_TYPE_DAUGHTER_BOARD = 8,
  DmiBaseboard_BoardType_BOARD_TYPE_MOTHERBOARD = 9,
  DmiBaseboard_BoardType_BOARD_TYPE_PROCESSOR_PLUS_MEMORY_MODULE = 10,
  DmiBaseboard_BoardType_BOARD_TYPE_PROCESSOR_PLUS_IO_MODULE = 11,
  DmiBaseboard_BoardType_BOARD_TYPE_INTERCONNECT_BOARD = 12,
  DmiBaseboard_BoardType_DmiBaseboard_BoardType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiBaseboard_BoardType_DmiBaseboard_BoardType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiBaseboard_BoardType_IsValid(int value);
const DmiBaseboard_BoardType DmiBaseboard_BoardType_BoardType_MIN = DmiBaseboard_BoardType_BOARD_TYPE_UNKNOWN;
const DmiBaseboard_BoardType DmiBaseboard_BoardType_BoardType_MAX = DmiBaseboard_BoardType_BOARD_TYPE_INTERCONNECT_BOARD;
const int DmiBaseboard_BoardType_BoardType_ARRAYSIZE = DmiBaseboard_BoardType_BoardType_MAX + 1;

enum DmiChassis_Type {
  DmiChassis_Type_TYPE_UNKNOWN = 0,
  DmiChassis_Type_TYPE_OTHER = 1,
  DmiChassis_Type_TYPE_DESKTOP = 2,
  DmiChassis_Type_TYPE_LOW_PROFILE_DESKTOP = 3,
  DmiChassis_Type_TYPE_PIZZA_BOX = 4,
  DmiChassis_Type_TYPE_MINI_TOWER = 5,
  DmiChassis_Type_TYPE_TOWER = 6,
  DmiChassis_Type_TYPE_PORTABLE = 7,
  DmiChassis_Type_TYPE_LAPTOP = 8,
  DmiChassis_Type_TYPE_NOTEBOOK = 9,
  DmiChassis_Type_TYPE_HAND_HELD = 10,
  DmiChassis_Type_TYPE_DOCKING_STATION = 11,
  DmiChassis_Type_TYPE_ALL_IN_ONE = 12,
  DmiChassis_Type_TYPE_SUB_NOTEBOOK = 13,
  DmiChassis_Type_TYPE_SPACE_SAVING = 14,
  DmiChassis_Type_TYPE_LUNCH_BOX = 15,
  DmiChassis_Type_TYPE_MAIN_SERVER_CHASSIS = 16,
  DmiChassis_Type_TYPE_EXPANSION_CHASSIS = 17,
  DmiChassis_Type_TYPE_SUB_CHASSIS = 18,
  DmiChassis_Type_TYPE_BUS_EXPANSION_CHASSIS = 19,
  DmiChassis_Type_TYPE_PERIPHERIAL_CHASSIS = 20,
  DmiChassis_Type_TYPE_RAID_CHASSIS = 21,
  DmiChassis_Type_TYPE_RACK_MOUNT_CHASSIS = 22,
  DmiChassis_Type_TYPE_SEALED_CASE_PC = 23,
  DmiChassis_Type_TYPE_MULTI_SYSTEM_CHASSIS = 24,
  DmiChassis_Type_TYPE_COMPACT_PCI = 25,
  DmiChassis_Type_TYPE_ADVANCED_TCA = 26,
  DmiChassis_Type_TYPE_BLADE = 27,
  DmiChassis_Type_TYPE_BLADE_ENCLOSURE = 28,
  DmiChassis_Type_DmiChassis_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiChassis_Type_DmiChassis_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiChassis_Type_IsValid(int value);
const DmiChassis_Type DmiChassis_Type_Type_MIN = DmiChassis_Type_TYPE_UNKNOWN;
const DmiChassis_Type DmiChassis_Type_Type_MAX = DmiChassis_Type_TYPE_BLADE_ENCLOSURE;
const int DmiChassis_Type_Type_ARRAYSIZE = DmiChassis_Type_Type_MAX + 1;

enum DmiChassis_Status {
  DmiChassis_Status_STATUS_UNKNOWN = 0,
  DmiChassis_Status_STATUS_OTHER = 1,
  DmiChassis_Status_STATUS_SAFE = 2,
  DmiChassis_Status_STATUS_WARNING = 3,
  DmiChassis_Status_STATUS_CRITICAL = 4,
  DmiChassis_Status_STATUS_NON_RECOVERABLE = 5,
  DmiChassis_Status_DmiChassis_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiChassis_Status_DmiChassis_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiChassis_Status_IsValid(int value);
const DmiChassis_Status DmiChassis_Status_Status_MIN = DmiChassis_Status_STATUS_UNKNOWN;
const DmiChassis_Status DmiChassis_Status_Status_MAX = DmiChassis_Status_STATUS_NON_RECOVERABLE;
const int DmiChassis_Status_Status_ARRAYSIZE = DmiChassis_Status_Status_MAX + 1;

enum DmiChassis_SecurityStatus {
  DmiChassis_SecurityStatus_SECURITY_STATUS_UNKNOWN = 0,
  DmiChassis_SecurityStatus_SECURITY_STATUS_OTHER = 1,
  DmiChassis_SecurityStatus_SECURITY_STATUS_NONE = 2,
  DmiChassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_LOCKED_OUT = 3,
  DmiChassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED = 4,
  DmiChassis_SecurityStatus_DmiChassis_SecurityStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiChassis_SecurityStatus_DmiChassis_SecurityStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiChassis_SecurityStatus_IsValid(int value);
const DmiChassis_SecurityStatus DmiChassis_SecurityStatus_SecurityStatus_MIN = DmiChassis_SecurityStatus_SECURITY_STATUS_UNKNOWN;
const DmiChassis_SecurityStatus DmiChassis_SecurityStatus_SecurityStatus_MAX = DmiChassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED;
const int DmiChassis_SecurityStatus_SecurityStatus_ARRAYSIZE = DmiChassis_SecurityStatus_SecurityStatus_MAX + 1;

enum DmiCaches_Location {
  DmiCaches_Location_LOCATION_UNKNOWN = 0,
  DmiCaches_Location_LOCATION_INTERNAL = 1,
  DmiCaches_Location_LOCATION_EXTERNAL = 2,
  DmiCaches_Location_LOCATION_RESERVED = 3,
  DmiCaches_Location_DmiCaches_Location_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_Location_DmiCaches_Location_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_Location_IsValid(int value);
const DmiCaches_Location DmiCaches_Location_Location_MIN = DmiCaches_Location_LOCATION_UNKNOWN;
const DmiCaches_Location DmiCaches_Location_Location_MAX = DmiCaches_Location_LOCATION_RESERVED;
const int DmiCaches_Location_Location_ARRAYSIZE = DmiCaches_Location_Location_MAX + 1;

enum DmiCaches_Status {
  DmiCaches_Status_STATUS_UNKNOWN = 0,
  DmiCaches_Status_STATUS_ENABLED = 1,
  DmiCaches_Status_STATUS_DISABLED = 2,
  DmiCaches_Status_DmiCaches_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_Status_DmiCaches_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_Status_IsValid(int value);
const DmiCaches_Status DmiCaches_Status_Status_MIN = DmiCaches_Status_STATUS_UNKNOWN;
const DmiCaches_Status DmiCaches_Status_Status_MAX = DmiCaches_Status_STATUS_DISABLED;
const int DmiCaches_Status_Status_ARRAYSIZE = DmiCaches_Status_Status_MAX + 1;

enum DmiCaches_Mode {
  DmiCaches_Mode_MODE_UNKNOWN = 0,
  DmiCaches_Mode_MODE_WRITE_THRU = 1,
  DmiCaches_Mode_MODE_WRITE_BACK = 2,
  DmiCaches_Mode_MODE_WRITE_WITH_MEMORY_ADDRESS = 3,
  DmiCaches_Mode_DmiCaches_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_Mode_DmiCaches_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_Mode_IsValid(int value);
const DmiCaches_Mode DmiCaches_Mode_Mode_MIN = DmiCaches_Mode_MODE_UNKNOWN;
const DmiCaches_Mode DmiCaches_Mode_Mode_MAX = DmiCaches_Mode_MODE_WRITE_WITH_MEMORY_ADDRESS;
const int DmiCaches_Mode_Mode_ARRAYSIZE = DmiCaches_Mode_Mode_MAX + 1;

enum DmiCaches_SRAMType {
  DmiCaches_SRAMType_SRAM_TYPE_BAD = 0,
  DmiCaches_SRAMType_SRAM_TYPE_OTHER = 1,
  DmiCaches_SRAMType_SRAM_TYPE_UNKNOWN = 2,
  DmiCaches_SRAMType_SRAM_TYPE_NON_BURST = 4,
  DmiCaches_SRAMType_SRAM_TYPE_BURST = 8,
  DmiCaches_SRAMType_SRAM_TYPE_PIPELINE_BURST = 16,
  DmiCaches_SRAMType_SRAM_TYPE_SYNCHRONOUS = 32,
  DmiCaches_SRAMType_SRAM_TYPE_ASYNCHRONOUS = 64,
  DmiCaches_SRAMType_DmiCaches_SRAMType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_SRAMType_DmiCaches_SRAMType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_SRAMType_IsValid(int value);
const DmiCaches_SRAMType DmiCaches_SRAMType_SRAMType_MIN = DmiCaches_SRAMType_SRAM_TYPE_BAD;
const DmiCaches_SRAMType DmiCaches_SRAMType_SRAMType_MAX = DmiCaches_SRAMType_SRAM_TYPE_ASYNCHRONOUS;
const int DmiCaches_SRAMType_SRAMType_ARRAYSIZE = DmiCaches_SRAMType_SRAMType_MAX + 1;

enum DmiCaches_ErrorCorrectionType {
  DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_UNKNOWN = 0,
  DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_OTHER = 1,
  DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_NONE = 2,
  DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_PARITY = 3,
  DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_SINGLE_BIT_ECC = 4,
  DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_MULTI_BIT_ECC = 5,
  DmiCaches_ErrorCorrectionType_DmiCaches_ErrorCorrectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_ErrorCorrectionType_DmiCaches_ErrorCorrectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_ErrorCorrectionType_IsValid(int value);
const DmiCaches_ErrorCorrectionType DmiCaches_ErrorCorrectionType_ErrorCorrectionType_MIN = DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_UNKNOWN;
const DmiCaches_ErrorCorrectionType DmiCaches_ErrorCorrectionType_ErrorCorrectionType_MAX = DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_MULTI_BIT_ECC;
const int DmiCaches_ErrorCorrectionType_ErrorCorrectionType_ARRAYSIZE = DmiCaches_ErrorCorrectionType_ErrorCorrectionType_MAX + 1;

enum DmiCaches_Type {
  DmiCaches_Type_TYPE_UNKNOWN = 0,
  DmiCaches_Type_TYPE_OTHER = 1,
  DmiCaches_Type_TYPE_INSTRUCTION = 2,
  DmiCaches_Type_TYPE_DATA = 3,
  DmiCaches_Type_TYPE_UNIFIED = 4,
  DmiCaches_Type_DmiCaches_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_Type_DmiCaches_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_Type_IsValid(int value);
const DmiCaches_Type DmiCaches_Type_Type_MIN = DmiCaches_Type_TYPE_UNKNOWN;
const DmiCaches_Type DmiCaches_Type_Type_MAX = DmiCaches_Type_TYPE_UNIFIED;
const int DmiCaches_Type_Type_ARRAYSIZE = DmiCaches_Type_Type_MAX + 1;

enum DmiCaches_Associativity {
  DmiCaches_Associativity_ASSOCIATIVITY_UNKNOWN = 0,
  DmiCaches_Associativity_ASSOCIATIVITY_OTHER = 1,
  DmiCaches_Associativity_ASSOCIATIVITY_DIRECT_MAPPED = 2,
  DmiCaches_Associativity_ASSOCIATIVITY_2_WAY = 3,
  DmiCaches_Associativity_ASSOCIATIVITY_4_WAY = 4,
  DmiCaches_Associativity_ASSOCIATIVITY_FULLY = 5,
  DmiCaches_Associativity_ASSOCIATIVITY_8_WAY = 6,
  DmiCaches_Associativity_ASSOCIATIVITY_16_WAY = 7,
  DmiCaches_Associativity_ASSOCIATIVITY_12_WAY = 8,
  DmiCaches_Associativity_ASSOCIATIVITY_24_WAY = 9,
  DmiCaches_Associativity_ASSOCIATIVITY_32_WAY = 10,
  DmiCaches_Associativity_ASSOCIATIVITY_48_WAY = 11,
  DmiCaches_Associativity_ASSOCIATIVITY_64_WAY = 12,
  DmiCaches_Associativity_ASSOCIATIVITY_20_WAY = 13,
  DmiCaches_Associativity_DmiCaches_Associativity_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiCaches_Associativity_DmiCaches_Associativity_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiCaches_Associativity_IsValid(int value);
const DmiCaches_Associativity DmiCaches_Associativity_Associativity_MIN = DmiCaches_Associativity_ASSOCIATIVITY_UNKNOWN;
const DmiCaches_Associativity DmiCaches_Associativity_Associativity_MAX = DmiCaches_Associativity_ASSOCIATIVITY_20_WAY;
const int DmiCaches_Associativity_Associativity_ARRAYSIZE = DmiCaches_Associativity_Associativity_MAX + 1;

enum DmiProcessors_Family {
  DmiProcessors_Family_FAMILY_UNKNOWN = 0,
  DmiProcessors_Family_FAMILY_OTHER = 1,
  DmiProcessors_Family_FAMILY_8086 = 2,
  DmiProcessors_Family_FAMILY_80286 = 3,
  DmiProcessors_Family_FAMILY_INTEL_386_PROCESSOR = 4,
  DmiProcessors_Family_FAMILY_INTEL_486_PROCESSOR = 5,
  DmiProcessors_Family_FAMILY_8087 = 6,
  DmiProcessors_Family_FAMILY_80287 = 7,
  DmiProcessors_Family_FAMILY_80387 = 8,
  DmiProcessors_Family_FAMILY_80487 = 9,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_PROCESSOR = 10,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_PRO_PROCESSOR = 11,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_2_PROCESSOR = 12,
  DmiProcessors_Family_FAMILY_PENTIUM_PROCESSOR_WITH_MMX = 13,
  DmiProcessors_Family_FAMILY_INTEL_CELERON_PROCESSOR = 14,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_2_XEON_PROCESSOR = 15,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_3_PROCESSOR = 16,
  DmiProcessors_Family_FAMILY_M1_FAMILY = 17,
  DmiProcessors_Family_FAMILY_M2_FAMILY = 18,
  DmiProcessors_Family_FAMILY_INTEL_CELEROM_M_PROCESSOR = 19,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_4_HT_PROCESSOR = 20,
  DmiProcessors_Family_FAMILY_AMD_DURON_PROCESSOR_FAMILY = 21,
  DmiProcessors_Family_FAMILY_AMD_K5_FAMILY = 22,
  DmiProcessors_Family_FAMILY_AMD_K6_FAMILY = 23,
  DmiProcessors_Family_FAMILY_AMD_K6_2 = 24,
  DmiProcessors_Family_FAMILY_AMD_K6_3 = 25,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_PROCESSOR_FAMILY = 26,
  DmiProcessors_Family_FAMILY_AMD_29000_FAMILY = 27,
  DmiProcessors_Family_FAMILY_AMD_K6_2_PLUS = 28,
  DmiProcessors_Family_FAMILY_POWER_PC_FAMILY = 29,
  DmiProcessors_Family_FAMILY_POWER_PC_601 = 30,
  DmiProcessors_Family_FAMILY_POWER_PC_603 = 31,
  DmiProcessors_Family_FAMILY_POWER_PC_603_PLUS = 32,
  DmiProcessors_Family_FAMILY_POWER_PC_604 = 33,
  DmiProcessors_Family_FAMILY_POWER_PC_620 = 34,
  DmiProcessors_Family_FAMILY_POWER_PC_X704 = 35,
  DmiProcessors_Family_FAMILY_POWER_PC_750 = 36,
  DmiProcessors_Family_FAMILY_INTEL_CORE_DUO_PROCESSOR = 37,
  DmiProcessors_Family_FAMILY_INTEL_CORE_DUO_MOBILE_PROCESSOR = 38,
  DmiProcessors_Family_FAMILY_INTEL_CORE_SOLO_MOBILE_PROCESSOR = 39,
  DmiProcessors_Family_FAMILY_INTEL_ATOM_PROCESSOR = 40,
  DmiProcessors_Family_FAMILY_INTEL_CORE_M_PROCESSOR = 41,
  DmiProcessors_Family_FAMILY_INTEL_CORE_M3_PROCESSOR = 42,
  DmiProcessors_Family_FAMILY_INTEL_CORE_M5_PROCESSOR = 43,
  DmiProcessors_Family_FAMILY_INTEL_CORE_M7_PROCESSOR = 44,
  DmiProcessors_Family_FAMILY_ALPHA_FAMILY = 45,
  DmiProcessors_Family_FAMILY_ALPHA_21064 = 46,
  DmiProcessors_Family_FAMILY_ALPHA_21066 = 47,
  DmiProcessors_Family_FAMILY_ALPHA_21164 = 48,
  DmiProcessors_Family_FAMILY_ALPHA_21164PC = 49,
  DmiProcessors_Family_FAMILY_ALPHA_21164A = 50,
  DmiProcessors_Family_FAMILY_ALPHA_21264 = 51,
  DmiProcessors_Family_FAMILY_ALPHA_21364 = 52,
  DmiProcessors_Family_FAMILY_AMD_TURION_2_ULTRA_DUAL_CORE_MOBILE_M_FAMILY = 53,
  DmiProcessors_Family_FAMILY_AMD_TURION_2_DUAL_CORE_MOBILE_M_FAMILY = 54,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_2_DUAL_CORE_M_FAMILY = 55,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_6100_SERIES_PROCESSOR = 56,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_4100_SERIES_PROCESSOR = 57,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_6200_SERIES_PROCESSOR = 58,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_4200_SERIES_PROCESSOR = 59,
  DmiProcessors_Family_FAMILY_AMD_FX_SERIES_PROCESSOR = 60,
  DmiProcessors_Family_FAMILY_MIPS_FAMILY = 61,
  DmiProcessors_Family_FAMILY_MIPS_R4000 = 62,
  DmiProcessors_Family_FAMILY_MIPS_R4200 = 63,
  DmiProcessors_Family_FAMILY_MIPS_R4400 = 64,
  DmiProcessors_Family_FAMILY_MIPS_R4600 = 65,
  DmiProcessors_Family_FAMILY_MIPS_R10000 = 66,
  DmiProcessors_Family_FAMILY_AMD_C_SERIES_PROCESSOR = 67,
  DmiProcessors_Family_FAMILY_AMD_E_SERIES_PROCESSOR = 68,
  DmiProcessors_Family_FAMILY_AMD_A_SERIES_PROCESSOR = 69,
  DmiProcessors_Family_FAMILY_AMD_G_SERIES_PROCESSOR = 70,
  DmiProcessors_Family_FAMILY_AMD_Z_SERIES_PROCESSOR = 71,
  DmiProcessors_Family_FAMILY_AMD_R_SERIES_PROCESSOR = 72,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_4300_SERIES_PROCESSOR = 73,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_6300_SERIES_PROCESSOR = 74,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_3300_SERIES_PROCESSOR = 75,
  DmiProcessors_Family_FAMILY_AMD_FIREPRO_SERIES_PROCESSOR = 76,
  DmiProcessors_Family_FAMILY_SPARC_FAMILY = 77,
  DmiProcessors_Family_FAMILY_SUPER_SPARC = 78,
  DmiProcessors_Family_FAMILY_MICRO_SPARC_2 = 79,
  DmiProcessors_Family_FAMILY_MICRO_SPARC_2EP = 80,
  DmiProcessors_Family_FAMILY_ULTRA_SPARC = 81,
  DmiProcessors_Family_FAMILY_ULTRA_SPARC_2 = 82,
  DmiProcessors_Family_FAMILY_ULTRA_SPARC_2I = 83,
  DmiProcessors_Family_FAMILY_ULTRA_SPARC_3 = 84,
  DmiProcessors_Family_FAMILY_ULTRA_SPARC_3I = 85,
  DmiProcessors_Family_FAMILY_68040_FAMILY = 86,
  DmiProcessors_Family_FAMILY_68XXX = 87,
  DmiProcessors_Family_FAMILY_68000 = 88,
  DmiProcessors_Family_FAMILY_68010 = 89,
  DmiProcessors_Family_FAMILY_68020 = 90,
  DmiProcessors_Family_FAMILY_68030 = 91,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_X4_QUAD_CORE_PROCESSOR_FAMILY = 92,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_X1000_SERIES_PROCESSOR = 93,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_X2000_SERIES_APU = 94,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_A_SERIES_PROCESSOR = 95,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_X3000_SERIES_APU = 96,
  DmiProcessors_Family_FAMILY_AMD_ZEN_PROCESSOR_FAMILY = 97,
  DmiProcessors_Family_FAMILY_HOBBIT_FAMILY = 98,
  DmiProcessors_Family_FAMILY_CRUSOE_TM5000_FAMILY = 99,
  DmiProcessors_Family_FAMILY_CRUSOE_TM3000_FAMILY = 100,
  DmiProcessors_Family_FAMILY_EFFICEON_TM8000_FAMILY = 101,
  DmiProcessors_Family_FAMILY_WEITEK = 102,
  DmiProcessors_Family_FAMILY_INTEL_ITANIUM_PROCESSOR = 103,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_64_PROCESSOR_FAMILY = 104,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_PROCESSOR_FAMILY = 105,
  DmiProcessors_Family_FAMILY_AMD_SEMPRON_PROCESSOR_FAMILY = 106,
  DmiProcessors_Family_FAMILY_AMD_TURION_64_MOBILE_TECHNOLOGY = 107,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_DUAL_CORE_PROCESSOR_FAMILY = 108,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_64_X2_DUAL_CORE_PROCESSOR_FAMILY = 109,
  DmiProcessors_Family_FAMILY_AMD_TURION_64_X2_MOBILE_TECHNOLOGY = 110,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_QUAD_CORE_PROCESSOR_FAMILY = 111,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_THIRD_GEN_PROCESSOR_FAMILY = 112,
  DmiProcessors_Family_FAMILY_AMD_PHENOM_FX_QUAD_CORE_PROCESSOR_FAMILY = 113,
  DmiProcessors_Family_FAMILY_AMD_PHENOM_X4_QUAD_CORE_PROCESSOR_FAMILY = 114,
  DmiProcessors_Family_FAMILY_AMD_PHENOM_X2_DUAL_CORE_PROCESSOR_FAMILY = 115,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_X2_DUAL_CORE_PROCESSOR_FAMILY = 116,
  DmiProcessors_Family_FAMILY_PA_RISC_FAMILY = 117,
  DmiProcessors_Family_FAMILY_PA_RISC_8500 = 118,
  DmiProcessors_Family_FAMILY_PA_RISC_8000 = 119,
  DmiProcessors_Family_FAMILY_PA_RISC_7300LC = 120,
  DmiProcessors_Family_FAMILY_PA_RISC_7200 = 121,
  DmiProcessors_Family_FAMILY_PA_RISC_7100LC = 122,
  DmiProcessors_Family_FAMILY_PA_RISC_7100 = 123,
  DmiProcessors_Family_FAMILY_V30_FAMILY = 124,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_3200_PROCESSOR_SERIES = 125,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_3000_PROCESSOR_SERIES = 126,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_5300_PROCESSOR_SERIES = 127,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5100_PROCESSOR_SERIES = 128,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5000_PROCESSOR_SERIES = 129,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_LV_PROCESSOR = 130,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_ULV_PROCESSOR = 131,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_7100_PROCESSOR_SERIES = 132,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_5400_PROCESSOR_SERIES = 133,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_PROCESSOR = 134,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5200_PROCESSOR_SERIES = 135,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_7200_PROCESSOR_SERIES = 136,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_7300_PROCESSOR_SERIES = 137,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_7400_PROCESSOR_SERIES = 138,
  DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_7400_PROCESSOR_SERIES = 139,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_3_XEON_PROCESSOR = 140,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_3_PROCESSOR_WITH_SPEED_STEP = 141,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_4_PROCESSOR = 142,
  DmiProcessors_Family_FAMILY_INTEL_XEON_PROCESSOR = 143,
  DmiProcessors_Family_FAMILY_AS400_FAMILY = 144,
  DmiProcessors_Family_FAMILY_INTEL_XEON_MP_PROCESSOR = 145,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_XP_PROCESSOR_FAMILY = 146,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_MP_PROCESSOR_FAMILY = 147,
  DmiProcessors_Family_FAMILY_INTEL_ITANIUM_2_PROCESSOR = 148,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_M_PROCESSOR = 149,
  DmiProcessors_Family_FAMILY_INTEL_CELERON_D_PROCESSOR = 150,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_D_PROCESSOR = 151,
  DmiProcessors_Family_FAMILY_INTEL_PENTIUM_PROCESSOR_EXTREME_EDITION = 152,
  DmiProcessors_Family_FAMILY_INTEL_CORE_SOLO_PROCESSOR = 153,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_DUO_PROCESSOR = 154,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_SOLO_PROCESSOR = 155,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_EXTREME_PROCESSOR = 156,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_QUAD_PROCESSOR = 157,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_EXTREME_MOBILE_PROCESSOR = 158,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_DUO_MOBILE_PROCESSOR = 159,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_SOLO_MOBILE_PROCESSOR = 160,
  DmiProcessors_Family_FAMILY_INTEL_CORE_I7_PROCESSOR = 161,
  DmiProcessors_Family_FAMILY_INTEL_CELERON_DUAL_CORE_PROCESSOR = 162,
  DmiProcessors_Family_FAMILY_IBM390_FAMILY = 163,
  DmiProcessors_Family_FAMILY_G4 = 164,
  DmiProcessors_Family_FAMILY_G5 = 165,
  DmiProcessors_Family_FAMILY_ESA_390_G6 = 166,
  DmiProcessors_Family_FAMILY_Z_ARCHITECTURE_BASE = 167,
  DmiProcessors_Family_FAMILY_INTEL_CORE_I5_PROCESSOR = 168,
  DmiProcessors_Family_FAMILY_INTEL_CORE_I3_PROCESSOR = 169,
  DmiProcessors_Family_FAMILY_VIA_C7_M_PROCESSOR_FAMILY = 170,
  DmiProcessors_Family_FAMILY_VIA_C7_D_PROCESSOR_FAMILY = 171,
  DmiProcessors_Family_FAMILY_VIA_C7_PROCESSOR_FAMILY = 172,
  DmiProcessors_Family_FAMILY_VIA_EDEN_PROCESSOR_FAMILY = 173,
  DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_PROCESSOR = 174,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_3XXX_PROCESSOR_SERIES = 175,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_3XXX_PROCESSOR_SERIES = 176,
  DmiProcessors_Family_FAMILY_VIA_NANO_PROCESSOR_FAMILY = 177,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5XXX_PROCESSOR_SERIES = 178,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_5XXX_PROCESSOR_SERIES = 179,
  DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_7XXX_PROCESSOR_SERIES = 180,
  DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_7XXX_PROCESSOR_SERIES = 181,
  DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_7XXX_PROCESSOR_SERIES = 182,
  DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_3400_PROCESSOR_SERIES = 183,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_3000_PROCESSOR_SERIES = 184,
  DmiProcessors_Family_FAMILY_AMD_SEMPRON_II_PROCESSOR = 185,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_QUAD_CORE_EMBEDDED_PROCESSOR_FAMILY = 186,
  DmiProcessors_Family_FAMILY_AMD_PHENOM_TRIPLE_CORE_PROCESSOR_FAMILY = 187,
  DmiProcessors_Family_FAMILY_AMD_TURION_ULTRA_DUAL_CORE_MOBILE_PROCESSOR_FAMILY = 188,
  DmiProcessors_Family_FAMILY_AMD_TURION_DUAL_CORE_MOBILE_PROCESSOR_FAMILY = 189,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_DUAL_CORE_PROCESSOR_FAMILY = 190,
  DmiProcessors_Family_FAMILY_AMD_SEMPRON_SI_PROCESSOR_FAMILY = 191,
  DmiProcessors_Family_FAMILY_AMD_PHENOM_2_PROCESSOR_FAMILY = 192,
  DmiProcessors_Family_FAMILY_AMD_ATHLON_2_PROCESSOR_FAMILY = 193,
  DmiProcessors_Family_FAMILY_AMD_OPTERON_SIX_CORE_PROCESSOR_FAMILY = 194,
  DmiProcessors_Family_FAMILY_AMD_SEMPRON_M_PROCESSOR_FAMILY = 195,
  DmiProcessors_Family_FAMILY_I860 = 196,
  DmiProcessors_Family_FAMILY_I960 = 197,
  DmiProcessors_Family_FAMILY_ARM_V7 = 198,
  DmiProcessors_Family_FAMILY_ARM_V8 = 199,
  DmiProcessors_Family_FAMILY_SH_3 = 200,
  DmiProcessors_Family_FAMILY_SH_4 = 201,
  DmiProcessors_Family_FAMILY_ARM = 202,
  DmiProcessors_Family_FAMILY_STRONG_ARM = 203,
  DmiProcessors_Family_FAMILY_6X86 = 204,
  DmiProcessors_Family_FAMILY_MEDIA_GX = 205,
  DmiProcessors_Family_FAMILY_MII = 206,
  DmiProcessors_Family_FAMILY_WIN_CHIP = 207,
  DmiProcessors_Family_FAMILY_DSP = 208,
  DmiProcessors_Family_FAMILY_VIDEO_PROCESSOR = 209,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_FAMILY = 210,
  DmiProcessors_Family_FAMILY_AMD_K7_FAMILY = 211,
  DmiProcessors_Family_FAMILY_INTEL_CORE_2_OR_AMD_K7_FAMILY = 212,
  DmiProcessors_Family_DmiProcessors_Family_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiProcessors_Family_DmiProcessors_Family_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiProcessors_Family_IsValid(int value);
const DmiProcessors_Family DmiProcessors_Family_Family_MIN = DmiProcessors_Family_FAMILY_UNKNOWN;
const DmiProcessors_Family DmiProcessors_Family_Family_MAX = DmiProcessors_Family_FAMILY_INTEL_CORE_2_OR_AMD_K7_FAMILY;
const int DmiProcessors_Family_Family_ARRAYSIZE = DmiProcessors_Family_Family_MAX + 1;

enum DmiProcessors_Type {
  DmiProcessors_Type_TYPE_UNKNOWN = 0,
  DmiProcessors_Type_TYPE_OTHER = 1,
  DmiProcessors_Type_TYPE_CENTRAL_PROCESSOR = 2,
  DmiProcessors_Type_TYPE_MATH_PROCESSOR = 3,
  DmiProcessors_Type_TYPE_DSP_PROCESSOR = 4,
  DmiProcessors_Type_TYPE_VIDEO_PROCESSOR = 5,
  DmiProcessors_Type_DmiProcessors_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiProcessors_Type_DmiProcessors_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiProcessors_Type_IsValid(int value);
const DmiProcessors_Type DmiProcessors_Type_Type_MIN = DmiProcessors_Type_TYPE_UNKNOWN;
const DmiProcessors_Type DmiProcessors_Type_Type_MAX = DmiProcessors_Type_TYPE_VIDEO_PROCESSOR;
const int DmiProcessors_Type_Type_ARRAYSIZE = DmiProcessors_Type_Type_MAX + 1;

enum DmiProcessors_Status {
  DmiProcessors_Status_STATUS_UNKNOWN = 0,
  DmiProcessors_Status_STATUS_ENABLED = 1,
  DmiProcessors_Status_STATUS_DISABLED_BY_USER = 2,
  DmiProcessors_Status_STATUS_DISABLED_BY_BIOS = 3,
  DmiProcessors_Status_STATUS_IDLE = 4,
  DmiProcessors_Status_STATUS_OTHER = 5,
  DmiProcessors_Status_DmiProcessors_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiProcessors_Status_DmiProcessors_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiProcessors_Status_IsValid(int value);
const DmiProcessors_Status DmiProcessors_Status_Status_MIN = DmiProcessors_Status_STATUS_UNKNOWN;
const DmiProcessors_Status DmiProcessors_Status_Status_MAX = DmiProcessors_Status_STATUS_OTHER;
const int DmiProcessors_Status_Status_ARRAYSIZE = DmiProcessors_Status_Status_MAX + 1;

enum DmiProcessors_Upgrade {
  DmiProcessors_Upgrade_UPGRADE_UNKNOWN = 0,
  DmiProcessors_Upgrade_UPGRADE_OTHER = 1,
  DmiProcessors_Upgrade_UPGRADE_DAUGHTER_BOARD = 2,
  DmiProcessors_Upgrade_UPGRADE_ZIF_SOCKET = 3,
  DmiProcessors_Upgrade_UPGRADE_REPLACEABLE_PIGGY_BACK = 4,
  DmiProcessors_Upgrade_UPGRADE_NONE = 5,
  DmiProcessors_Upgrade_UPGRADE_LIF_SOCKET = 6,
  DmiProcessors_Upgrade_UPGRADE_SLOT_1 = 7,
  DmiProcessors_Upgrade_UPGRADE_SLOT_2 = 8,
  DmiProcessors_Upgrade_UPGRADE_370_PIN_SOCKET = 9,
  DmiProcessors_Upgrade_UPGRADE_SLOT_A = 10,
  DmiProcessors_Upgrade_UPGRADE_SLOT_M = 11,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_423 = 12,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_462 = 13,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_478 = 14,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_754 = 15,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_940 = 16,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_939 = 17,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_MPGA604 = 18,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA771 = 19,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA775 = 20,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_S1 = 21,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_AM2 = 22,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_F = 23,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1366 = 24,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_G34 = 25,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_AM3 = 26,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_C32 = 27,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1156 = 28,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1567 = 29,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_PGA988A = 30,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1288 = 31,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_RPGA988B = 32,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1023 = 33,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1224 = 34,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1155 = 35,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1356 = 36,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA2011 = 37,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_FS1 = 38,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_FS2 = 39,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_FM1 = 40,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_FM2 = 41,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA2011_3 = 42,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1356_3 = 43,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1150 = 44,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1168 = 45,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1234 = 46,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1364 = 47,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_AM4 = 48,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1151 = 49,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1356 = 50,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1440 = 51,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1515 = 52,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA3647_1 = 53,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_SP3 = 54,
  DmiProcessors_Upgrade_UPGRADE_SOCKET_SP3_R2 = 55,
  DmiProcessors_Upgrade_DmiProcessors_Upgrade_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiProcessors_Upgrade_DmiProcessors_Upgrade_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiProcessors_Upgrade_IsValid(int value);
const DmiProcessors_Upgrade DmiProcessors_Upgrade_Upgrade_MIN = DmiProcessors_Upgrade_UPGRADE_UNKNOWN;
const DmiProcessors_Upgrade DmiProcessors_Upgrade_Upgrade_MAX = DmiProcessors_Upgrade_UPGRADE_SOCKET_SP3_R2;
const int DmiProcessors_Upgrade_Upgrade_ARRAYSIZE = DmiProcessors_Upgrade_Upgrade_MAX + 1;

enum DmiProcessors_Characteristics {
  DmiProcessors_Characteristics_CHARACTERISTIC_NONE = 0,
  DmiProcessors_Characteristics_CHARACTERISTIC_64BIT_CAPABLE = 1,
  DmiProcessors_Characteristics_CHARACTERISTIC_MULTI_CORE = 2,
  DmiProcessors_Characteristics_CHARACTERISTIC_HARDWARE_THREAD = 4,
  DmiProcessors_Characteristics_CHARACTERISTIC_EXECUTE_PROTECTION = 8,
  DmiProcessors_Characteristics_CHARACTERISTIC_ENHANCED_VIRTUALIZATION = 16,
  DmiProcessors_Characteristics_CHARACTERISTIC_POWER_CONTROL = 32,
  DmiProcessors_Characteristics_DmiProcessors_Characteristics_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiProcessors_Characteristics_DmiProcessors_Characteristics_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiProcessors_Characteristics_IsValid(int value);
const DmiProcessors_Characteristics DmiProcessors_Characteristics_Characteristics_MIN = DmiProcessors_Characteristics_CHARACTERISTIC_NONE;
const DmiProcessors_Characteristics DmiProcessors_Characteristics_Characteristics_MAX = DmiProcessors_Characteristics_CHARACTERISTIC_POWER_CONTROL;
const int DmiProcessors_Characteristics_Characteristics_ARRAYSIZE = DmiProcessors_Characteristics_Characteristics_MAX + 1;

enum DmiMemoryDevices_Type {
  DmiMemoryDevices_Type_TYPE_UNKNOWN = 0,
  DmiMemoryDevices_Type_TYPE_OTHER = 1,
  DmiMemoryDevices_Type_TYPE_DRAM = 2,
  DmiMemoryDevices_Type_TYPE_EDRAM = 3,
  DmiMemoryDevices_Type_TYPE_VRAM = 4,
  DmiMemoryDevices_Type_TYPE_SRAM = 5,
  DmiMemoryDevices_Type_TYPE_RAM = 6,
  DmiMemoryDevices_Type_TYPE_ROM = 7,
  DmiMemoryDevices_Type_TYPE_FLASH = 8,
  DmiMemoryDevices_Type_TYPE_EEPROM = 9,
  DmiMemoryDevices_Type_TYPE_FEPROM = 10,
  DmiMemoryDevices_Type_TYPE_EPROM = 11,
  DmiMemoryDevices_Type_TYPE_CDRAM = 12,
  DmiMemoryDevices_Type_TYPE_3DRAM = 13,
  DmiMemoryDevices_Type_TYPE_SDRAM = 14,
  DmiMemoryDevices_Type_TYPE_SGRAM = 15,
  DmiMemoryDevices_Type_TYPE_RDRAM = 16,
  DmiMemoryDevices_Type_TYPE_DDR = 17,
  DmiMemoryDevices_Type_TYPE_DDR2 = 18,
  DmiMemoryDevices_Type_TYPE_DDR2_FB_DIMM = 19,
  DmiMemoryDevices_Type_TYPE_DDR3 = 20,
  DmiMemoryDevices_Type_TYPE_FBD2 = 21,
  DmiMemoryDevices_Type_TYPE_DDR4 = 22,
  DmiMemoryDevices_Type_TYPE_LPDDR = 23,
  DmiMemoryDevices_Type_TYPE_LPDDR2 = 24,
  DmiMemoryDevices_Type_TYPE_LPDDR3 = 25,
  DmiMemoryDevices_Type_TYPE_LPDDR4 = 26,
  DmiMemoryDevices_Type_DmiMemoryDevices_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiMemoryDevices_Type_DmiMemoryDevices_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiMemoryDevices_Type_IsValid(int value);
const DmiMemoryDevices_Type DmiMemoryDevices_Type_Type_MIN = DmiMemoryDevices_Type_TYPE_UNKNOWN;
const DmiMemoryDevices_Type DmiMemoryDevices_Type_Type_MAX = DmiMemoryDevices_Type_TYPE_LPDDR4;
const int DmiMemoryDevices_Type_Type_ARRAYSIZE = DmiMemoryDevices_Type_Type_MAX + 1;

enum DmiMemoryDevices_FormFactor {
  DmiMemoryDevices_FormFactor_FORM_FACTOR_UNKNOWN = 0,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_OTHER = 1,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_SIMM = 2,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_SIP = 3,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_CHIP = 4,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_DIP = 5,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_ZIP = 6,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_PROPRIETARY_CARD = 7,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_DIMM = 8,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_TSOP = 9,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_ROW_OF_CHIPS = 10,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_RIMM = 11,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_SODIMM = 12,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_SRIMM = 13,
  DmiMemoryDevices_FormFactor_FORM_FACTOR_FB_DIMM = 14,
  DmiMemoryDevices_FormFactor_DmiMemoryDevices_FormFactor_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiMemoryDevices_FormFactor_DmiMemoryDevices_FormFactor_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiMemoryDevices_FormFactor_IsValid(int value);
const DmiMemoryDevices_FormFactor DmiMemoryDevices_FormFactor_FormFactor_MIN = DmiMemoryDevices_FormFactor_FORM_FACTOR_UNKNOWN;
const DmiMemoryDevices_FormFactor DmiMemoryDevices_FormFactor_FormFactor_MAX = DmiMemoryDevices_FormFactor_FORM_FACTOR_FB_DIMM;
const int DmiMemoryDevices_FormFactor_FormFactor_ARRAYSIZE = DmiMemoryDevices_FormFactor_FormFactor_MAX + 1;

enum DmiSystemSlots_Type {
  DmiSystemSlots_Type_TYPE_UNKNOWN = 0,
  DmiSystemSlots_Type_TYPE_OTHER = 1,
  DmiSystemSlots_Type_TYPE_ISA = 2,
  DmiSystemSlots_Type_TYPE_MCA = 3,
  DmiSystemSlots_Type_TYPE_EISA = 4,
  DmiSystemSlots_Type_TYPE_PCI = 5,
  DmiSystemSlots_Type_TYPE_PC_CARD = 6,
  DmiSystemSlots_Type_TYPE_VLB = 7,
  DmiSystemSlots_Type_TYPE_PROPRIETARY = 8,
  DmiSystemSlots_Type_TYPE_PROCESSOR_CARD = 9,
  DmiSystemSlots_Type_TYPE_PROPRIETARY_MEMORY_CARD = 10,
  DmiSystemSlots_Type_TYPE_IO_RISER_CARD = 11,
  DmiSystemSlots_Type_TYPE_NUBUS = 12,
  DmiSystemSlots_Type_TYPE_PCI_66 = 13,
  DmiSystemSlots_Type_TYPE_AGP = 14,
  DmiSystemSlots_Type_TYPE_AGP_2X = 15,
  DmiSystemSlots_Type_TYPE_AGP_4X = 16,
  DmiSystemSlots_Type_TYPE_PCI_X = 17,
  DmiSystemSlots_Type_TYPE_AGP_8X = 18,
  DmiSystemSlots_Type_TYPE_M2_SOCKET_1DP = 19,
  DmiSystemSlots_Type_TYPE_M2_SOCKET_1SD = 20,
  DmiSystemSlots_Type_TYPE_M2_SOCKET_2 = 21,
  DmiSystemSlots_Type_TYPE_M2_SOCKET_3 = 22,
  DmiSystemSlots_Type_TYPE_MXM_TYPE_I = 23,
  DmiSystemSlots_Type_TYPE_MXM_TYPE_II = 24,
  DmiSystemSlots_Type_TYPE_MXM_TYPE_III = 25,
  DmiSystemSlots_Type_TYPE_MXM_TYPE_III_HE = 26,
  DmiSystemSlots_Type_TYPE_MXM_TYPE_IV = 27,
  DmiSystemSlots_Type_TYPE_MXM_30_TYPE_A = 28,
  DmiSystemSlots_Type_TYPE_MXM_30_TYPE_B = 29,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_SFF_8639 = 30,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_SFF_8639 = 31,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_MINI_52PIN_WITH_BOTTOM_SIDE = 32,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_MINI_52PIN = 33,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_MINI_76PIN = 34,
  DmiSystemSlots_Type_TYPE_PC98_C20 = 35,
  DmiSystemSlots_Type_TYPE_PC98_C24 = 36,
  DmiSystemSlots_Type_TYPE_PC98_E = 37,
  DmiSystemSlots_Type_TYPE_PC98_LOCAL_BUS = 38,
  DmiSystemSlots_Type_TYPE_PC98_CARD = 39,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS = 40,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X1 = 41,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X2 = 42,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X4 = 43,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X8 = 44,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X16 = 45,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2 = 46,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X1 = 47,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X2 = 48,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X4 = 49,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X8 = 50,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X16 = 51,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3 = 52,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X1 = 53,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X2 = 54,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X4 = 55,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X8 = 56,
  DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X16 = 57,
  DmiSystemSlots_Type_DmiSystemSlots_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiSystemSlots_Type_DmiSystemSlots_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiSystemSlots_Type_IsValid(int value);
const DmiSystemSlots_Type DmiSystemSlots_Type_Type_MIN = DmiSystemSlots_Type_TYPE_UNKNOWN;
const DmiSystemSlots_Type DmiSystemSlots_Type_Type_MAX = DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X16;
const int DmiSystemSlots_Type_Type_ARRAYSIZE = DmiSystemSlots_Type_Type_MAX + 1;

enum DmiSystemSlots_Usage {
  DmiSystemSlots_Usage_USAGE_UNKNOWN = 0,
  DmiSystemSlots_Usage_USAGE_OTHER = 1,
  DmiSystemSlots_Usage_USAGE_AVAILABLE = 2,
  DmiSystemSlots_Usage_USAGE_IN_USE = 3,
  DmiSystemSlots_Usage_DmiSystemSlots_Usage_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiSystemSlots_Usage_DmiSystemSlots_Usage_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiSystemSlots_Usage_IsValid(int value);
const DmiSystemSlots_Usage DmiSystemSlots_Usage_Usage_MIN = DmiSystemSlots_Usage_USAGE_UNKNOWN;
const DmiSystemSlots_Usage DmiSystemSlots_Usage_Usage_MAX = DmiSystemSlots_Usage_USAGE_IN_USE;
const int DmiSystemSlots_Usage_Usage_ARRAYSIZE = DmiSystemSlots_Usage_Usage_MAX + 1;

enum DmiSystemSlots_BusWidth {
  DmiSystemSlots_BusWidth_BUS_WIDTH_UNKNOWN = 0,
  DmiSystemSlots_BusWidth_BUS_WIDTH_OTHER = 1,
  DmiSystemSlots_BusWidth_BUS_WIDTH_8_BIT = 2,
  DmiSystemSlots_BusWidth_BUS_WIDTH_16_BIT = 3,
  DmiSystemSlots_BusWidth_BUS_WIDTH_32_BIT = 4,
  DmiSystemSlots_BusWidth_BUS_WIDTH_64_BIT = 5,
  DmiSystemSlots_BusWidth_BUS_WIDTH_128_BIT = 6,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X1 = 7,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X2 = 8,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X4 = 9,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X8 = 10,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X12 = 11,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X16 = 12,
  DmiSystemSlots_BusWidth_BUS_WIDTH_X32 = 13,
  DmiSystemSlots_BusWidth_DmiSystemSlots_BusWidth_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiSystemSlots_BusWidth_DmiSystemSlots_BusWidth_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiSystemSlots_BusWidth_IsValid(int value);
const DmiSystemSlots_BusWidth DmiSystemSlots_BusWidth_BusWidth_MIN = DmiSystemSlots_BusWidth_BUS_WIDTH_UNKNOWN;
const DmiSystemSlots_BusWidth DmiSystemSlots_BusWidth_BusWidth_MAX = DmiSystemSlots_BusWidth_BUS_WIDTH_X32;
const int DmiSystemSlots_BusWidth_BusWidth_ARRAYSIZE = DmiSystemSlots_BusWidth_BusWidth_MAX + 1;

enum DmiSystemSlots_Length {
  DmiSystemSlots_Length_LENGTH_UNKNOWN = 0,
  DmiSystemSlots_Length_LENGTH_OTHER = 1,
  DmiSystemSlots_Length_LENGTH_SHORT = 2,
  DmiSystemSlots_Length_LENGTH_LONG = 3,
  DmiSystemSlots_Length_DmiSystemSlots_Length_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiSystemSlots_Length_DmiSystemSlots_Length_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiSystemSlots_Length_IsValid(int value);
const DmiSystemSlots_Length DmiSystemSlots_Length_Length_MIN = DmiSystemSlots_Length_LENGTH_UNKNOWN;
const DmiSystemSlots_Length DmiSystemSlots_Length_Length_MAX = DmiSystemSlots_Length_LENGTH_LONG;
const int DmiSystemSlots_Length_Length_ARRAYSIZE = DmiSystemSlots_Length_Length_MAX + 1;

enum DmiPortConnectors_Type {
  DmiPortConnectors_Type_TYPE_UNKNOWN = 0,
  DmiPortConnectors_Type_TYPE_NONE = 1,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_XT_AT_COMPATIBLE = 2,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_PS_2 = 3,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_ECP = 4,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_EPP = 5,
  DmiPortConnectors_Type_TYPE_PARALLEL_PORT_ECP_EPP = 6,
  DmiPortConnectors_Type_TYPE_SERIAL_PORT_XT_AT_COMPATIBLE = 7,
  DmiPortConnectors_Type_TYPE_SERIAL_PORT_16450_COMPATIBLE = 8,
  DmiPortConnectors_Type_TYPE_SERIAL_PORT_16550_COMPATIBLE = 9,
  DmiPortConnectors_Type_TYPE_SERIAL_PORT_16550A_COMPATIBLE = 10,
  DmiPortConnectors_Type_TYPE_SCSI_PORT = 11,
  DmiPortConnectors_Type_TYPE_MIDI_PORT = 12,
  DmiPortConnectors_Type_TYPE_JOYSTICK_PORT = 13,
  DmiPortConnectors_Type_TYPE_KEYBOARD_PORT = 14,
  DmiPortConnectors_Type_TYPE_MOUSE_PORT = 15,
  DmiPortConnectors_Type_TYPE_SSA_SCSI = 16,
  DmiPortConnectors_Type_TYPE_USB = 17,
  DmiPortConnectors_Type_TYPE_FIREWIRE = 18,
  DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_I = 19,
  DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_II = 20,
  DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_III = 21,
  DmiPortConnectors_Type_TYPE_CARDBUS = 22,
  DmiPortConnectors_Type_TYPE_ACCESS_BUS_PORT = 23,
  DmiPortConnectors_Type_TYPE_SCSI_II = 24,
  DmiPortConnectors_Type_TYPE_SCSI_WIDE = 25,
  DmiPortConnectors_Type_TYPE_PC_98 = 26,
  DmiPortConnectors_Type_TYPE_PC_98_HIRESO = 27,
  DmiPortConnectors_Type_TYPE_PC_H98 = 28,
  DmiPortConnectors_Type_TYPE_VIDEO_PORT = 29,
  DmiPortConnectors_Type_TYPE_AUDIO_PORT = 30,
  DmiPortConnectors_Type_TYPE_MODEM_PORT = 31,
  DmiPortConnectors_Type_TYPE_NETWORK_PORT = 32,
  DmiPortConnectors_Type_TYPE_SATA = 33,
  DmiPortConnectors_Type_TYPE_SAS = 34,
  DmiPortConnectors_Type_TYPE_8251_COMPATIBLE = 35,
  DmiPortConnectors_Type_TYPE_8251_FIFO_COMPATIBLE = 36,
  DmiPortConnectors_Type_DmiPortConnectors_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPortConnectors_Type_DmiPortConnectors_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPortConnectors_Type_IsValid(int value);
const DmiPortConnectors_Type DmiPortConnectors_Type_Type_MIN = DmiPortConnectors_Type_TYPE_UNKNOWN;
const DmiPortConnectors_Type DmiPortConnectors_Type_Type_MAX = DmiPortConnectors_Type_TYPE_8251_FIFO_COMPATIBLE;
const int DmiPortConnectors_Type_Type_ARRAYSIZE = DmiPortConnectors_Type_Type_MAX + 1;

enum DmiPortConnectors_ConnectorType {
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_UNKNOWN = 0,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_NONE = 1,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_OTHER = 2,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CENTRONICS = 3,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS = 4,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PROPRIETARY = 5,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_25_MALE = 6,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_25_FEMALE = 7,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_15_MALE = 8,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_15_FEMALE = 9,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_9_MALE = 10,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_9_FEMALE = 11,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_RJ_11 = 12,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_RJ_45 = 13,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_50_PIN_MINISCSI = 14,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_DIN = 15,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MICRO_DIN = 16,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PS_2 = 17,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_INFRARED = 18,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_HP_HIL = 19,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ACCESS_BUS_USB = 20,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_SSA_SCSI = 21,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_MALE = 22,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_FEMALE = 23,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_IDE = 24,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_FLOPPY = 25,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_9_PIN_DUAL_INLINE = 26,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_25_PIN_DUAL_INLINE = 27,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_50_PIN_DUAL_INLINE = 28,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_68_PIN_DUAL_INLINE = 29,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_SOUND_INPUT_FROM_CDROM = 30,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_14 = 31,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_26 = 32,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_JACK = 33,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_BNC = 34,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_IEEE_1394 = 35,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_SAS_SATE_PLUG_RECEPTACLE = 36,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98 = 37,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_HIRESO = 38,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_H98 = 39,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_NOTE = 40,
  DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_FULL = 41,
  DmiPortConnectors_ConnectorType_DmiPortConnectors_ConnectorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPortConnectors_ConnectorType_DmiPortConnectors_ConnectorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPortConnectors_ConnectorType_IsValid(int value);
const DmiPortConnectors_ConnectorType DmiPortConnectors_ConnectorType_ConnectorType_MIN = DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_UNKNOWN;
const DmiPortConnectors_ConnectorType DmiPortConnectors_ConnectorType_ConnectorType_MAX = DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_FULL;
const int DmiPortConnectors_ConnectorType_ConnectorType_ARRAYSIZE = DmiPortConnectors_ConnectorType_ConnectorType_MAX + 1;

enum DmiOnBoardDevices_Type {
  DmiOnBoardDevices_Type_TYPE_UNKNOWN = 0,
  DmiOnBoardDevices_Type_TYPE_OTHER = 1,
  DmiOnBoardDevices_Type_TYPE_VIDEO = 2,
  DmiOnBoardDevices_Type_TYPE_SCSI_CONTROLLER = 3,
  DmiOnBoardDevices_Type_TYPE_ETHERNET = 4,
  DmiOnBoardDevices_Type_TYPE_TOKEN_RING = 5,
  DmiOnBoardDevices_Type_TYPE_SOUND = 6,
  DmiOnBoardDevices_Type_TYPE_PATA_CONTROLLER = 7,
  DmiOnBoardDevices_Type_TYPE_SATA_CONTROLLER = 8,
  DmiOnBoardDevices_Type_TYPE_SAS_CONTROLLER = 9,
  DmiOnBoardDevices_Type_DmiOnBoardDevices_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiOnBoardDevices_Type_DmiOnBoardDevices_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiOnBoardDevices_Type_IsValid(int value);
const DmiOnBoardDevices_Type DmiOnBoardDevices_Type_Type_MIN = DmiOnBoardDevices_Type_TYPE_UNKNOWN;
const DmiOnBoardDevices_Type DmiOnBoardDevices_Type_Type_MAX = DmiOnBoardDevices_Type_TYPE_SAS_CONTROLLER;
const int DmiOnBoardDevices_Type_Type_ARRAYSIZE = DmiOnBoardDevices_Type_Type_MAX + 1;

enum DmiPointingDevice_Type {
  DmiPointingDevice_Type_TYPE_UNKNOWN = 0,
  DmiPointingDevice_Type_TYPE_OTHER = 1,
  DmiPointingDevice_Type_TYPE_MOUSE = 2,
  DmiPointingDevice_Type_TYPE_TRACK_BALL = 3,
  DmiPointingDevice_Type_TYPE_TRACK_POINT = 4,
  DmiPointingDevice_Type_TYPE_GLIDE_POINT = 5,
  DmiPointingDevice_Type_TYPE_TOUCH_PAD = 6,
  DmiPointingDevice_Type_TYPE_TOUCH_SCREEN = 7,
  DmiPointingDevice_Type_TYPE_OPTICAL_SENSOR = 8,
  DmiPointingDevice_Type_DmiPointingDevice_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPointingDevice_Type_DmiPointingDevice_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPointingDevice_Type_IsValid(int value);
const DmiPointingDevice_Type DmiPointingDevice_Type_Type_MIN = DmiPointingDevice_Type_TYPE_UNKNOWN;
const DmiPointingDevice_Type DmiPointingDevice_Type_Type_MAX = DmiPointingDevice_Type_TYPE_OPTICAL_SENSOR;
const int DmiPointingDevice_Type_Type_ARRAYSIZE = DmiPointingDevice_Type_Type_MAX + 1;

enum DmiPointingDevice_Interface {
  DmiPointingDevice_Interface_INTERFACE_UNKNOWN = 0,
  DmiPointingDevice_Interface_INTERFACE_OTHER = 1,
  DmiPointingDevice_Interface_INTERFACE_SERIAL = 2,
  DmiPointingDevice_Interface_INTERFACE_PS_2 = 3,
  DmiPointingDevice_Interface_INTERFACE_INFRARED = 4,
  DmiPointingDevice_Interface_INTERFACE_HP_HIL = 5,
  DmiPointingDevice_Interface_INTERFACE_BUS_MOUSE = 6,
  DmiPointingDevice_Interface_INTERFACE_ADB = 7,
  DmiPointingDevice_Interface_INTERFACE_BUS_MOUSE_DB_9 = 8,
  DmiPointingDevice_Interface_INTERFACE_BUS_MOUSE_MICRO_DIN = 9,
  DmiPointingDevice_Interface_INTERFACE_USB = 10,
  DmiPointingDevice_Interface_DmiPointingDevice_Interface_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPointingDevice_Interface_DmiPointingDevice_Interface_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPointingDevice_Interface_IsValid(int value);
const DmiPointingDevice_Interface DmiPointingDevice_Interface_Interface_MIN = DmiPointingDevice_Interface_INTERFACE_UNKNOWN;
const DmiPointingDevice_Interface DmiPointingDevice_Interface_Interface_MAX = DmiPointingDevice_Interface_INTERFACE_USB;
const int DmiPointingDevice_Interface_Interface_ARRAYSIZE = DmiPointingDevice_Interface_Interface_MAX + 1;

enum DmiPortableBattery_Chemistry {
  DmiPortableBattery_Chemistry_CHEMISTRY_UNKNOWN = 0,
  DmiPortableBattery_Chemistry_CHEMISTRY_OTHER = 1,
  DmiPortableBattery_Chemistry_CHEMISTRY_LEAD_ACID = 2,
  DmiPortableBattery_Chemistry_CHEMISTRY_NICKEL_CADMIUM = 3,
  DmiPortableBattery_Chemistry_CHEMISTRY_NICKEL_METAL_HYDRIDE = 4,
  DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_ION = 5,
  DmiPortableBattery_Chemistry_CHEMISTRY_ZINC_AIR = 6,
  DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_POLYMER = 7,
  DmiPortableBattery_Chemistry_DmiPortableBattery_Chemistry_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPortableBattery_Chemistry_DmiPortableBattery_Chemistry_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPortableBattery_Chemistry_IsValid(int value);
const DmiPortableBattery_Chemistry DmiPortableBattery_Chemistry_Chemistry_MIN = DmiPortableBattery_Chemistry_CHEMISTRY_UNKNOWN;
const DmiPortableBattery_Chemistry DmiPortableBattery_Chemistry_Chemistry_MAX = DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_POLYMER;
const int DmiPortableBattery_Chemistry_Chemistry_ARRAYSIZE = DmiPortableBattery_Chemistry_Chemistry_MAX + 1;

enum AtaDrives_BusType {
  AtaDrives_BusType_BUS_TYPE_UNKNOWN = 0,
  AtaDrives_BusType_BUS_TYPE_SCSI = 1,
  AtaDrives_BusType_BUS_TYPE_ATAPI = 2,
  AtaDrives_BusType_BUS_TYPE_ATA = 3,
  AtaDrives_BusType_BUS_TYPE_IEEE1394 = 4,
  AtaDrives_BusType_BUS_TYPE_SSA = 5,
  AtaDrives_BusType_BUS_TYPE_FIBRE = 6,
  AtaDrives_BusType_BUS_TYPE_USB = 7,
  AtaDrives_BusType_BUS_TYPE_RAID = 8,
  AtaDrives_BusType_BUS_TYPE_ISCSI = 9,
  AtaDrives_BusType_BUS_TYPE_SAS = 10,
  AtaDrives_BusType_BUS_TYPE_SATA = 11,
  AtaDrives_BusType_BUS_TYPE_SD = 12,
  AtaDrives_BusType_BUS_TYPE_MMC = 13,
  AtaDrives_BusType_BUS_TYPE_VIRTUAL = 14,
  AtaDrives_BusType_BUS_TYPE_FILE_BACKED_VIRTUAL = 15,
  AtaDrives_BusType_AtaDrives_BusType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AtaDrives_BusType_AtaDrives_BusType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AtaDrives_BusType_IsValid(int value);
const AtaDrives_BusType AtaDrives_BusType_BusType_MIN = AtaDrives_BusType_BUS_TYPE_UNKNOWN;
const AtaDrives_BusType AtaDrives_BusType_BusType_MAX = AtaDrives_BusType_BUS_TYPE_FILE_BACKED_VIRTUAL;
const int AtaDrives_BusType_BusType_ARRAYSIZE = AtaDrives_BusType_BusType_MAX + 1;

enum AtaDrives_TransferMode {
  AtaDrives_TransferMode_TRANSFER_MODE_UNKNOWN = 0,
  AtaDrives_TransferMode_TRANSFER_MODE_PIO = 1,
  AtaDrives_TransferMode_TRANSFER_MODE_PIO_DMA = 2,
  AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_133 = 3,
  AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_100 = 4,
  AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_66 = 5,
  AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_44 = 6,
  AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_33 = 7,
  AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_25 = 8,
  AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_16 = 9,
  AtaDrives_TransferMode_TRANSFER_MODE_SATA_600 = 10,
  AtaDrives_TransferMode_TRANSFER_MODE_SATA_300 = 11,
  AtaDrives_TransferMode_TRANSFER_MODE_SATA_150 = 12,
  AtaDrives_TransferMode_AtaDrives_TransferMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AtaDrives_TransferMode_AtaDrives_TransferMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AtaDrives_TransferMode_IsValid(int value);
const AtaDrives_TransferMode AtaDrives_TransferMode_TransferMode_MIN = AtaDrives_TransferMode_TRANSFER_MODE_UNKNOWN;
const AtaDrives_TransferMode AtaDrives_TransferMode_TransferMode_MAX = AtaDrives_TransferMode_TRANSFER_MODE_SATA_150;
const int AtaDrives_TransferMode_TransferMode_ARRAYSIZE = AtaDrives_TransferMode_TransferMode_MAX + 1;

enum AtaDrives_Features {
  AtaDrives_Features_FEATURE_UNKNOWN = 0,
  AtaDrives_Features_FEATURE_48BIT_LBA = 1,
  AtaDrives_Features_FEATURE_ADVANCED_POWER_MANAGEMENT = 2,
  AtaDrives_Features_FEATURE_AUTOMATIC_ACOUSTIC_MANAGEMENT = 4,
  AtaDrives_Features_FEATURE_SMART = 8,
  AtaDrives_Features_FEATURE_SMART_ERROR_LOGGING = 16,
  AtaDrives_Features_FEATURE_SMART_SELF_TEST = 32,
  AtaDrives_Features_FEATURE_STREAMING = 64,
  AtaDrives_Features_FEATURE_GENERAL_PURPOSE_LOGGING = 128,
  AtaDrives_Features_FEATURE_SECURITY_MODE = 256,
  AtaDrives_Features_FEATURE_POWER_MANAGEMENT = 512,
  AtaDrives_Features_FEATURE_WRITE_CACHE = 1024,
  AtaDrives_Features_FEATURE_READ_LOCK_AHEAD = 2048,
  AtaDrives_Features_FEATURE_HOST_PROTECTED_AREA = 4096,
  AtaDrives_Features_FEATURE_RELEASE_INTERRUPT = 8192,
  AtaDrives_Features_FEATURE_POWER_UP_IN_STANDBY = 16384,
  AtaDrives_Features_FEATURE_DEVICE_CONFIGURATION_OVERLAY = 32768,
  AtaDrives_Features_FEATURE_SERVICE_INTERRUPT = 65536,
  AtaDrives_Features_FEATURE_NATIVE_COMMAND_QUEUING = 131072,
  AtaDrives_Features_FEATURE_TRIM = 262144,
  AtaDrives_Features_AtaDrives_Features_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AtaDrives_Features_AtaDrives_Features_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AtaDrives_Features_IsValid(int value);
const AtaDrives_Features AtaDrives_Features_Features_MIN = AtaDrives_Features_FEATURE_UNKNOWN;
const AtaDrives_Features AtaDrives_Features_Features_MAX = AtaDrives_Features_FEATURE_TRIM;
const int AtaDrives_Features_Features_ARRAYSIZE = AtaDrives_Features_Features_MAX + 1;

enum Monitors_InputSignalType {
  Monitors_InputSignalType_INPUT_SIGNAL_TYPE_UNKNOWN = 0,
  Monitors_InputSignalType_INPUT_SIGNAL_TYPE_ANALOG = 1,
  Monitors_InputSignalType_INPUT_SIGNAL_TYPE_DIGITAL = 2,
  Monitors_InputSignalType_Monitors_InputSignalType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Monitors_InputSignalType_Monitors_InputSignalType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Monitors_InputSignalType_IsValid(int value);
const Monitors_InputSignalType Monitors_InputSignalType_InputSignalType_MIN = Monitors_InputSignalType_INPUT_SIGNAL_TYPE_UNKNOWN;
const Monitors_InputSignalType Monitors_InputSignalType_InputSignalType_MAX = Monitors_InputSignalType_INPUT_SIGNAL_TYPE_DIGITAL;
const int Monitors_InputSignalType_InputSignalType_ARRAYSIZE = Monitors_InputSignalType_InputSignalType_MAX + 1;

enum PowerOptions_Battery_State {
  PowerOptions_Battery_State_STATE_UNKNOWN = 0,
  PowerOptions_Battery_State_STATE_CHARGING = 1,
  PowerOptions_Battery_State_STATE_CRITICAL = 2,
  PowerOptions_Battery_State_STATE_DISCHARGING = 4,
  PowerOptions_Battery_State_STATE_POWER_ONLINE = 8,
  PowerOptions_Battery_State_PowerOptions_Battery_State_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PowerOptions_Battery_State_PowerOptions_Battery_State_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PowerOptions_Battery_State_IsValid(int value);
const PowerOptions_Battery_State PowerOptions_Battery_State_State_MIN = PowerOptions_Battery_State_STATE_UNKNOWN;
const PowerOptions_Battery_State PowerOptions_Battery_State_State_MAX = PowerOptions_Battery_State_STATE_POWER_ONLINE;
const int PowerOptions_Battery_State_State_ARRAYSIZE = PowerOptions_Battery_State_State_MAX + 1;

enum PowerOptions_PowerSource {
  PowerOptions_PowerSource_POWER_SOURCE_UNKNOWN = 0,
  PowerOptions_PowerSource_POWER_SOURCE_DC_BATTERY = 1,
  PowerOptions_PowerSource_POWER_SOURCE_AC_LINE = 2,
  PowerOptions_PowerSource_PowerOptions_PowerSource_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PowerOptions_PowerSource_PowerOptions_PowerSource_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PowerOptions_PowerSource_IsValid(int value);
const PowerOptions_PowerSource PowerOptions_PowerSource_PowerSource_MIN = PowerOptions_PowerSource_POWER_SOURCE_UNKNOWN;
const PowerOptions_PowerSource PowerOptions_PowerSource_PowerSource_MAX = PowerOptions_PowerSource_POWER_SOURCE_AC_LINE;
const int PowerOptions_PowerSource_PowerSource_ARRAYSIZE = PowerOptions_PowerSource_PowerSource_MAX + 1;

enum PowerOptions_BatteryStatus {
  PowerOptions_BatteryStatus_BATTERY_STATUS_UNKNOWN = 0,
  PowerOptions_BatteryStatus_BATTERY_STATUS_HIGH = 1,
  PowerOptions_BatteryStatus_BATTERY_STATUS_LOW = 2,
  PowerOptions_BatteryStatus_BATTERY_STATUS_CRITICAL = 3,
  PowerOptions_BatteryStatus_BATTERY_STATUS_CHARGING = 4,
  PowerOptions_BatteryStatus_BATTERY_STATUS_NO_BATTERY = 5,
  PowerOptions_BatteryStatus_PowerOptions_BatteryStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PowerOptions_BatteryStatus_PowerOptions_BatteryStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PowerOptions_BatteryStatus_IsValid(int value);
const PowerOptions_BatteryStatus PowerOptions_BatteryStatus_BatteryStatus_MIN = PowerOptions_BatteryStatus_BATTERY_STATUS_UNKNOWN;
const PowerOptions_BatteryStatus PowerOptions_BatteryStatus_BatteryStatus_MAX = PowerOptions_BatteryStatus_BATTERY_STATUS_NO_BATTERY;
const int PowerOptions_BatteryStatus_BatteryStatus_ARRAYSIZE = PowerOptions_BatteryStatus_BatteryStatus_MAX + 1;

enum Printers_Item_Orientation {
  Printers_Item_Orientation_ORIENTATION_UNKNOWN = 0,
  Printers_Item_Orientation_ORIENTATION_PORTRAIT = 1,
  Printers_Item_Orientation_ORIENTATION_LANDSCAPE = 2,
  Printers_Item_Orientation_Printers_Item_Orientation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Printers_Item_Orientation_Printers_Item_Orientation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Printers_Item_Orientation_IsValid(int value);
const Printers_Item_Orientation Printers_Item_Orientation_Orientation_MIN = Printers_Item_Orientation_ORIENTATION_UNKNOWN;
const Printers_Item_Orientation Printers_Item_Orientation_Orientation_MAX = Printers_Item_Orientation_ORIENTATION_LANDSCAPE;
const int Printers_Item_Orientation_Orientation_ARRAYSIZE = Printers_Item_Orientation_Orientation_MAX + 1;

enum Services_Item_Status {
  Services_Item_Status_STATUS_UNKNOWN = 0,
  Services_Item_Status_STATUS_CONTINUE_PENDING = 1,
  Services_Item_Status_STATUS_PAUSE_PENDING = 2,
  Services_Item_Status_STATUS_PAUSED = 3,
  Services_Item_Status_STATUS_RUNNING = 4,
  Services_Item_Status_STATUS_START_PENDING = 5,
  Services_Item_Status_STATUS_STOP_PENDING = 6,
  Services_Item_Status_STATUS_STOPPED = 7,
  Services_Item_Status_Services_Item_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Services_Item_Status_Services_Item_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Services_Item_Status_IsValid(int value);
const Services_Item_Status Services_Item_Status_Status_MIN = Services_Item_Status_STATUS_UNKNOWN;
const Services_Item_Status Services_Item_Status_Status_MAX = Services_Item_Status_STATUS_STOPPED;
const int Services_Item_Status_Status_ARRAYSIZE = Services_Item_Status_Status_MAX + 1;

enum Services_Item_StartupType {
  Services_Item_StartupType_STARTUP_TYPE_UNKNOWN = 0,
  Services_Item_StartupType_STARTUP_TYPE_AUTO_START = 1,
  Services_Item_StartupType_STARTUP_TYPE_DEMAND_START = 2,
  Services_Item_StartupType_STARTUP_TYPE_DISABLED = 3,
  Services_Item_StartupType_STARTUP_TYPE_BOOT_START = 4,
  Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START = 5,
  Services_Item_StartupType_Services_Item_StartupType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Services_Item_StartupType_Services_Item_StartupType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Services_Item_StartupType_IsValid(int value);
const Services_Item_StartupType Services_Item_StartupType_StartupType_MIN = Services_Item_StartupType_STARTUP_TYPE_UNKNOWN;
const Services_Item_StartupType Services_Item_StartupType_StartupType_MAX = Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START;
const int Services_Item_StartupType_StartupType_ARRAYSIZE = Services_Item_StartupType_StartupType_MAX + 1;

enum OpenConnections_Item_Protocol {
  OpenConnections_Item_Protocol_PROTOCOL_UNKNOWN = 0,
  OpenConnections_Item_Protocol_PROTOCOL_TCP = 1,
  OpenConnections_Item_Protocol_PROTOCOL_UDP = 2,
  OpenConnections_Item_Protocol_OpenConnections_Item_Protocol_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OpenConnections_Item_Protocol_OpenConnections_Item_Protocol_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OpenConnections_Item_Protocol_IsValid(int value);
const OpenConnections_Item_Protocol OpenConnections_Item_Protocol_Protocol_MIN = OpenConnections_Item_Protocol_PROTOCOL_UNKNOWN;
const OpenConnections_Item_Protocol OpenConnections_Item_Protocol_Protocol_MAX = OpenConnections_Item_Protocol_PROTOCOL_UDP;
const int OpenConnections_Item_Protocol_Protocol_ARRAYSIZE = OpenConnections_Item_Protocol_Protocol_MAX + 1;

enum SharedResources_Item_Type {
  SharedResources_Item_Type_TYPE_UNKNOWN = 0,
  SharedResources_Item_Type_TYPE_DISK = 1,
  SharedResources_Item_Type_TYPE_PRINTER = 2,
  SharedResources_Item_Type_TYPE_DEVICE = 3,
  SharedResources_Item_Type_TYPE_IPC = 4,
  SharedResources_Item_Type_TYPE_SPECIAL = 5,
  SharedResources_Item_Type_TYPE_TEMPORARY = 6,
  SharedResources_Item_Type_SharedResources_Item_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SharedResources_Item_Type_SharedResources_Item_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SharedResources_Item_Type_IsValid(int value);
const SharedResources_Item_Type SharedResources_Item_Type_Type_MIN = SharedResources_Item_Type_TYPE_UNKNOWN;
const SharedResources_Item_Type SharedResources_Item_Type_Type_MAX = SharedResources_Item_Type_TYPE_TEMPORARY;
const int SharedResources_Item_Type_Type_ARRAYSIZE = SharedResources_Item_Type_Type_MAX + 1;

// ===================================================================

class DmiBios : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBios) */ {
 public:
  DmiBios();
  virtual ~DmiBios();

  DmiBios(const DmiBios& from);

  inline DmiBios& operator=(const DmiBios& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBios(DmiBios&& from) noexcept
    : DmiBios() {
    *this = ::std::move(from);
  }

  inline DmiBios& operator=(DmiBios&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBios& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBios* internal_default_instance() {
    return reinterpret_cast<const DmiBios*>(
               &_DmiBios_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DmiBios* other);
  friend void swap(DmiBios& a, DmiBios& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBios* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBios* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBios& from);
  void MergeFrom(const DmiBios& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBios* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiBios_Characteristics Characteristics;
  static const Characteristics CHARACTERISTIC_NONE =
    DmiBios_Characteristics_CHARACTERISTIC_NONE;
  static const Characteristics CHARACTERISTIC_ISA =
    DmiBios_Characteristics_CHARACTERISTIC_ISA;
  static const Characteristics CHARACTERISTIC_MCA =
    DmiBios_Characteristics_CHARACTERISTIC_MCA;
  static const Characteristics CHARACTERISTIC_EISA =
    DmiBios_Characteristics_CHARACTERISTIC_EISA;
  static const Characteristics CHARACTERISTIC_PCI =
    DmiBios_Characteristics_CHARACTERISTIC_PCI;
  static const Characteristics CHARACTERISTIC_PC_CARD =
    DmiBios_Characteristics_CHARACTERISTIC_PC_CARD;
  static const Characteristics CHARACTERISTIC_PLUG_AND_PLAY =
    DmiBios_Characteristics_CHARACTERISTIC_PLUG_AND_PLAY;
  static const Characteristics CHARACTERISTIC_APM =
    DmiBios_Characteristics_CHARACTERISTIC_APM;
  static const Characteristics CHARACTERISTIC_BIOS_IS_UPGRADEABLE =
    DmiBios_Characteristics_CHARACTERISTIC_BIOS_IS_UPGRADEABLE;
  static const Characteristics CHARACTERISTIC_BIOS_SHADOWING =
    DmiBios_Characteristics_CHARACTERISTIC_BIOS_SHADOWING;
  static const Characteristics CHARACTERISTIC_VLB =
    DmiBios_Characteristics_CHARACTERISTIC_VLB;
  static const Characteristics CHARACTERISTIC_ESCD =
    DmiBios_Characteristics_CHARACTERISTIC_ESCD;
  static const Characteristics CHARACTERISTIC_BOOT_FROM_CD =
    DmiBios_Characteristics_CHARACTERISTIC_BOOT_FROM_CD;
  static const Characteristics CHARACTERISTIC_SELECTABLE_BOOT =
    DmiBios_Characteristics_CHARACTERISTIC_SELECTABLE_BOOT;
  static const Characteristics CHARACTERISTIC_BOOT_ROM_IS_SOCKETED =
    DmiBios_Characteristics_CHARACTERISTIC_BOOT_ROM_IS_SOCKETED;
  static const Characteristics CHARACTERISTIC_BOOT_FROM_PC_CARD =
    DmiBios_Characteristics_CHARACTERISTIC_BOOT_FROM_PC_CARD;
  static const Characteristics CHARACTERISTIC_EDD =
    DmiBios_Characteristics_CHARACTERISTIC_EDD;
  static const Characteristics CHARACTERISTIC_JAPANESE_FLOPPY_FOR_NEC9800 =
    DmiBios_Characteristics_CHARACTERISTIC_JAPANESE_FLOPPY_FOR_NEC9800;
  static const Characteristics CHARACTERISTIC_JAPANESE_FLOPPY_FOR_TOSHIBA =
    DmiBios_Characteristics_CHARACTERISTIC_JAPANESE_FLOPPY_FOR_TOSHIBA;
  static const Characteristics CHARACTERISTIC_525_360KB_FLOPPY =
    DmiBios_Characteristics_CHARACTERISTIC_525_360KB_FLOPPY;
  static const Characteristics CHARACTERISTIC_525_12MB_FLOPPY =
    DmiBios_Characteristics_CHARACTERISTIC_525_12MB_FLOPPY;
  static const Characteristics CHARACTERISTIC_35_720KB_FLOPPY =
    DmiBios_Characteristics_CHARACTERISTIC_35_720KB_FLOPPY;
  static const Characteristics CHARACTERISTIC_35_288MB_FLOPPY =
    DmiBios_Characteristics_CHARACTERISTIC_35_288MB_FLOPPY;
  static const Characteristics CHARACTERISTIC_PRINT_SCREEN =
    DmiBios_Characteristics_CHARACTERISTIC_PRINT_SCREEN;
  static const Characteristics CHARACTERISTIC_8042_KEYBOARD =
    DmiBios_Characteristics_CHARACTERISTIC_8042_KEYBOARD;
  static const Characteristics CHARACTERISTIC_SERIAL =
    DmiBios_Characteristics_CHARACTERISTIC_SERIAL;
  static const Characteristics CHARACTERISTIC_PRINTER =
    DmiBios_Characteristics_CHARACTERISTIC_PRINTER;
  static const Characteristics CHARACTERISTIC_CGA_VIDEO =
    DmiBios_Characteristics_CHARACTERISTIC_CGA_VIDEO;
  static const Characteristics CHARACTERISTIC_NEC_PC98 =
    DmiBios_Characteristics_CHARACTERISTIC_NEC_PC98;
  static inline bool Characteristics_IsValid(int value) {
    return DmiBios_Characteristics_IsValid(value);
  }
  static const Characteristics Characteristics_MIN =
    DmiBios_Characteristics_Characteristics_MIN;
  static const Characteristics Characteristics_MAX =
    DmiBios_Characteristics_Characteristics_MAX;
  static const int Characteristics_ARRAYSIZE =
    DmiBios_Characteristics_Characteristics_ARRAYSIZE;

  typedef DmiBios_Characteristics1 Characteristics1;
  static const Characteristics1 CHARACTERISTIC1_NONE =
    DmiBios_Characteristics1_CHARACTERISTIC1_NONE;
  static const Characteristics1 CHARACTERISTIC1_ACPI =
    DmiBios_Characteristics1_CHARACTERISTIC1_ACPI;
  static const Characteristics1 CHARACTERISTIC1_USB_LEGACY =
    DmiBios_Characteristics1_CHARACTERISTIC1_USB_LEGACY;
  static const Characteristics1 CHARACTERISTIC1_AGP =
    DmiBios_Characteristics1_CHARACTERISTIC1_AGP;
  static const Characteristics1 CHARACTERISTIC1_I2O_BOOT =
    DmiBios_Characteristics1_CHARACTERISTIC1_I2O_BOOT;
  static const Characteristics1 CHARACTERISTIC1_LS120_BOOT =
    DmiBios_Characteristics1_CHARACTERISTIC1_LS120_BOOT;
  static const Characteristics1 CHARACTERISTIC1_ATAPI_ZIP_DRIVE_BOOT =
    DmiBios_Characteristics1_CHARACTERISTIC1_ATAPI_ZIP_DRIVE_BOOT;
  static const Characteristics1 CHARACTERISTIC1_IEEE1394_BOOT =
    DmiBios_Characteristics1_CHARACTERISTIC1_IEEE1394_BOOT;
  static const Characteristics1 CHARACTERISTIC1_SMART_BATTERY =
    DmiBios_Characteristics1_CHARACTERISTIC1_SMART_BATTERY;
  static inline bool Characteristics1_IsValid(int value) {
    return DmiBios_Characteristics1_IsValid(value);
  }
  static const Characteristics1 Characteristics1_MIN =
    DmiBios_Characteristics1_Characteristics1_MIN;
  static const Characteristics1 Characteristics1_MAX =
    DmiBios_Characteristics1_Characteristics1_MAX;
  static const int Characteristics1_ARRAYSIZE =
    DmiBios_Characteristics1_Characteristics1_ARRAYSIZE;

  typedef DmiBios_Characteristics2 Characteristics2;
  static const Characteristics2 CHARACTERISTIC2_NONE =
    DmiBios_Characteristics2_CHARACTERISTIC2_NONE;
  static const Characteristics2 CHARACTERISTIC2_BIOS_BOOT_SPECIFICATION =
    DmiBios_Characteristics2_CHARACTERISTIC2_BIOS_BOOT_SPECIFICATION;
  static const Characteristics2 CHARACTERISTIC2_KEY_INITIALIZED_NETWORK_BOOT =
    DmiBios_Characteristics2_CHARACTERISTIC2_KEY_INITIALIZED_NETWORK_BOOT;
  static const Characteristics2 CHARACTERISTIC2_TARGETED_CONTENT_DISTRIBUTION =
    DmiBios_Characteristics2_CHARACTERISTIC2_TARGETED_CONTENT_DISTRIBUTION;
  static inline bool Characteristics2_IsValid(int value) {
    return DmiBios_Characteristics2_IsValid(value);
  }
  static const Characteristics2 Characteristics2_MIN =
    DmiBios_Characteristics2_Characteristics2_MIN;
  static const Characteristics2 Characteristics2_MAX =
    DmiBios_Characteristics2_Characteristics2_MAX;
  static const int Characteristics2_ARRAYSIZE =
    DmiBios_Characteristics2_Characteristics2_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string date = 3;
  void clear_date();
  static const int kDateFieldNumber = 3;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // string bios_revision = 5;
  void clear_bios_revision();
  static const int kBiosRevisionFieldNumber = 5;
  const ::std::string& bios_revision() const;
  void set_bios_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_bios_revision(::std::string&& value);
  #endif
  void set_bios_revision(const char* value);
  void set_bios_revision(const char* value, size_t size);
  ::std::string* mutable_bios_revision();
  ::std::string* release_bios_revision();
  void set_allocated_bios_revision(::std::string* bios_revision);

  // string firmware_revision = 6;
  void clear_firmware_revision();
  static const int kFirmwareRevisionFieldNumber = 6;
  const ::std::string& firmware_revision() const;
  void set_firmware_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_firmware_revision(::std::string&& value);
  #endif
  void set_firmware_revision(const char* value);
  void set_firmware_revision(const char* value, size_t size);
  ::std::string* mutable_firmware_revision();
  ::std::string* release_firmware_revision();
  void set_allocated_firmware_revision(::std::string* firmware_revision);

  // string address = 7;
  void clear_address();
  static const int kAddressFieldNumber = 7;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // uint64 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // uint64 characteristics = 9;
  void clear_characteristics();
  static const int kCharacteristicsFieldNumber = 9;
  ::google::protobuf::uint64 characteristics() const;
  void set_characteristics(::google::protobuf::uint64 value);

  // int32 runtime_size = 8;
  void clear_runtime_size();
  static const int kRuntimeSizeFieldNumber = 8;
  ::google::protobuf::int32 runtime_size() const;
  void set_runtime_size(::google::protobuf::int32 value);

  // uint32 characteristics1 = 10;
  void clear_characteristics1();
  static const int kCharacteristics1FieldNumber = 10;
  ::google::protobuf::uint32 characteristics1() const;
  void set_characteristics1(::google::protobuf::uint32 value);

  // uint32 characteristics2 = 11;
  void clear_characteristics2();
  static const int kCharacteristics2FieldNumber = 11;
  ::google::protobuf::uint32 characteristics2() const;
  void set_characteristics2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBios)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr bios_revision_;
  ::google::protobuf::internal::ArenaStringPtr firmware_revision_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 characteristics_;
  ::google::protobuf::int32 runtime_size_;
  ::google::protobuf::uint32 characteristics1_;
  ::google::protobuf::uint32 characteristics2_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBiosImpl();
};
// -------------------------------------------------------------------

class DmiSystem : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiSystem) */ {
 public:
  DmiSystem();
  virtual ~DmiSystem();

  DmiSystem(const DmiSystem& from);

  inline DmiSystem& operator=(const DmiSystem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiSystem(DmiSystem&& from) noexcept
    : DmiSystem() {
    *this = ::std::move(from);
  }

  inline DmiSystem& operator=(DmiSystem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiSystem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiSystem* internal_default_instance() {
    return reinterpret_cast<const DmiSystem*>(
               &_DmiSystem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DmiSystem* other);
  friend void swap(DmiSystem& a, DmiSystem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiSystem* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiSystem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiSystem& from);
  void MergeFrom(const DmiSystem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiSystem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiSystem_WakeupType WakeupType;
  static const WakeupType WAKEUP_TYPE_UNKNOWN =
    DmiSystem_WakeupType_WAKEUP_TYPE_UNKNOWN;
  static const WakeupType WAKEUP_TYPE_OTHER =
    DmiSystem_WakeupType_WAKEUP_TYPE_OTHER;
  static const WakeupType WAKEUP_TYPE_APM_TIMER =
    DmiSystem_WakeupType_WAKEUP_TYPE_APM_TIMER;
  static const WakeupType WAKEUP_TYPE_MODEM_RING =
    DmiSystem_WakeupType_WAKEUP_TYPE_MODEM_RING;
  static const WakeupType WAKEUP_TYPE_LAN_REMOTE =
    DmiSystem_WakeupType_WAKEUP_TYPE_LAN_REMOTE;
  static const WakeupType WAKEUP_TYPE_POWER_SWITCH =
    DmiSystem_WakeupType_WAKEUP_TYPE_POWER_SWITCH;
  static const WakeupType WAKEUP_TYPE_PCI_PME =
    DmiSystem_WakeupType_WAKEUP_TYPE_PCI_PME;
  static const WakeupType WAKEUP_TYPE_AC_POWER_RESTORED =
    DmiSystem_WakeupType_WAKEUP_TYPE_AC_POWER_RESTORED;
  static inline bool WakeupType_IsValid(int value) {
    return DmiSystem_WakeupType_IsValid(value);
  }
  static const WakeupType WakeupType_MIN =
    DmiSystem_WakeupType_WakeupType_MIN;
  static const WakeupType WakeupType_MAX =
    DmiSystem_WakeupType_WakeupType_MAX;
  static const int WakeupType_ARRAYSIZE =
    DmiSystem_WakeupType_WakeupType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string product_name = 2;
  void clear_product_name();
  static const int kProductNameFieldNumber = 2;
  const ::std::string& product_name() const;
  void set_product_name(const ::std::string& value);
  #if LANG_CXX11
  void set_product_name(::std::string&& value);
  #endif
  void set_product_name(const char* value);
  void set_product_name(const char* value, size_t size);
  ::std::string* mutable_product_name();
  ::std::string* release_product_name();
  void set_allocated_product_name(::std::string* product_name);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string uuid = 5;
  void clear_uuid();
  static const int kUuidFieldNumber = 5;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // string sku_number = 7;
  void clear_sku_number();
  static const int kSkuNumberFieldNumber = 7;
  const ::std::string& sku_number() const;
  void set_sku_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sku_number(::std::string&& value);
  #endif
  void set_sku_number(const char* value);
  void set_sku_number(const char* value, size_t size);
  ::std::string* mutable_sku_number();
  ::std::string* release_sku_number();
  void set_allocated_sku_number(::std::string* sku_number);

  // string family = 8;
  void clear_family();
  static const int kFamilyFieldNumber = 8;
  const ::std::string& family() const;
  void set_family(const ::std::string& value);
  #if LANG_CXX11
  void set_family(::std::string&& value);
  #endif
  void set_family(const char* value);
  void set_family(const char* value, size_t size);
  ::std::string* mutable_family();
  ::std::string* release_family();
  void set_allocated_family(::std::string* family);

  // .aspia.proto.DmiSystem.WakeupType wakeup_type = 6;
  void clear_wakeup_type();
  static const int kWakeupTypeFieldNumber = 6;
  ::aspia::proto::DmiSystem_WakeupType wakeup_type() const;
  void set_wakeup_type(::aspia::proto::DmiSystem_WakeupType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiSystem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr product_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr sku_number_;
  ::google::protobuf::internal::ArenaStringPtr family_;
  int wakeup_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiSystemImpl();
};
// -------------------------------------------------------------------

class DmiBaseboard_Features : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBaseboard.Features) */ {
 public:
  DmiBaseboard_Features();
  virtual ~DmiBaseboard_Features();

  DmiBaseboard_Features(const DmiBaseboard_Features& from);

  inline DmiBaseboard_Features& operator=(const DmiBaseboard_Features& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBaseboard_Features(DmiBaseboard_Features&& from) noexcept
    : DmiBaseboard_Features() {
    *this = ::std::move(from);
  }

  inline DmiBaseboard_Features& operator=(DmiBaseboard_Features&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBaseboard_Features& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBaseboard_Features* internal_default_instance() {
    return reinterpret_cast<const DmiBaseboard_Features*>(
               &_DmiBaseboard_Features_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DmiBaseboard_Features* other);
  friend void swap(DmiBaseboard_Features& a, DmiBaseboard_Features& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBaseboard_Features* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBaseboard_Features* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBaseboard_Features& from);
  void MergeFrom(const DmiBaseboard_Features& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBaseboard_Features* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_hosting_board = 1;
  void clear_is_hosting_board();
  static const int kIsHostingBoardFieldNumber = 1;
  bool is_hosting_board() const;
  void set_is_hosting_board(bool value);

  // bool is_requires_at_least_one_daughter_board = 2;
  void clear_is_requires_at_least_one_daughter_board();
  static const int kIsRequiresAtLeastOneDaughterBoardFieldNumber = 2;
  bool is_requires_at_least_one_daughter_board() const;
  void set_is_requires_at_least_one_daughter_board(bool value);

  // bool is_removable = 3;
  void clear_is_removable();
  static const int kIsRemovableFieldNumber = 3;
  bool is_removable() const;
  void set_is_removable(bool value);

  // bool is_replaceable = 4;
  void clear_is_replaceable();
  static const int kIsReplaceableFieldNumber = 4;
  bool is_replaceable() const;
  void set_is_replaceable(bool value);

  // bool is_hot_swappable = 5;
  void clear_is_hot_swappable();
  static const int kIsHotSwappableFieldNumber = 5;
  bool is_hot_swappable() const;
  void set_is_hot_swappable(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBaseboard.Features)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool is_hosting_board_;
  bool is_requires_at_least_one_daughter_board_;
  bool is_removable_;
  bool is_replaceable_;
  bool is_hot_swappable_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBaseboard_FeaturesImpl();
};
// -------------------------------------------------------------------

class DmiBaseboard_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBaseboard.Item) */ {
 public:
  DmiBaseboard_Item();
  virtual ~DmiBaseboard_Item();

  DmiBaseboard_Item(const DmiBaseboard_Item& from);

  inline DmiBaseboard_Item& operator=(const DmiBaseboard_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBaseboard_Item(DmiBaseboard_Item&& from) noexcept
    : DmiBaseboard_Item() {
    *this = ::std::move(from);
  }

  inline DmiBaseboard_Item& operator=(DmiBaseboard_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBaseboard_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBaseboard_Item* internal_default_instance() {
    return reinterpret_cast<const DmiBaseboard_Item*>(
               &_DmiBaseboard_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DmiBaseboard_Item* other);
  friend void swap(DmiBaseboard_Item& a, DmiBaseboard_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBaseboard_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBaseboard_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBaseboard_Item& from);
  void MergeFrom(const DmiBaseboard_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBaseboard_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string product_name = 2;
  void clear_product_name();
  static const int kProductNameFieldNumber = 2;
  const ::std::string& product_name() const;
  void set_product_name(const ::std::string& value);
  #if LANG_CXX11
  void set_product_name(::std::string&& value);
  #endif
  void set_product_name(const char* value);
  void set_product_name(const char* value, size_t size);
  ::std::string* mutable_product_name();
  ::std::string* release_product_name();
  void set_allocated_product_name(::std::string* product_name);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 5;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 5;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // string location_in_chassis = 7;
  void clear_location_in_chassis();
  static const int kLocationInChassisFieldNumber = 7;
  const ::std::string& location_in_chassis() const;
  void set_location_in_chassis(const ::std::string& value);
  #if LANG_CXX11
  void set_location_in_chassis(::std::string&& value);
  #endif
  void set_location_in_chassis(const char* value);
  void set_location_in_chassis(const char* value, size_t size);
  ::std::string* mutable_location_in_chassis();
  ::std::string* release_location_in_chassis();
  void set_allocated_location_in_chassis(::std::string* location_in_chassis);

  // .aspia.proto.DmiBaseboard.Features features = 6;
  bool has_features() const;
  void clear_features();
  static const int kFeaturesFieldNumber = 6;
  const ::aspia::proto::DmiBaseboard_Features& features() const;
  ::aspia::proto::DmiBaseboard_Features* release_features();
  ::aspia::proto::DmiBaseboard_Features* mutable_features();
  void set_allocated_features(::aspia::proto::DmiBaseboard_Features* features);

  // .aspia.proto.DmiBaseboard.BoardType type = 8;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  ::aspia::proto::DmiBaseboard_BoardType type() const;
  void set_type(::aspia::proto::DmiBaseboard_BoardType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBaseboard.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr product_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  ::google::protobuf::internal::ArenaStringPtr location_in_chassis_;
  ::aspia::proto::DmiBaseboard_Features* features_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBaseboard_ItemImpl();
};
// -------------------------------------------------------------------

class DmiBaseboard : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiBaseboard) */ {
 public:
  DmiBaseboard();
  virtual ~DmiBaseboard();

  DmiBaseboard(const DmiBaseboard& from);

  inline DmiBaseboard& operator=(const DmiBaseboard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiBaseboard(DmiBaseboard&& from) noexcept
    : DmiBaseboard() {
    *this = ::std::move(from);
  }

  inline DmiBaseboard& operator=(DmiBaseboard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiBaseboard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiBaseboard* internal_default_instance() {
    return reinterpret_cast<const DmiBaseboard*>(
               &_DmiBaseboard_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DmiBaseboard* other);
  friend void swap(DmiBaseboard& a, DmiBaseboard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiBaseboard* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiBaseboard* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiBaseboard& from);
  void MergeFrom(const DmiBaseboard& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiBaseboard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiBaseboard_Features Features;
  typedef DmiBaseboard_Item Item;

  typedef DmiBaseboard_BoardType BoardType;
  static const BoardType BOARD_TYPE_UNKNOWN =
    DmiBaseboard_BoardType_BOARD_TYPE_UNKNOWN;
  static const BoardType BOARD_TYPE_OTHER =
    DmiBaseboard_BoardType_BOARD_TYPE_OTHER;
  static const BoardType BOARD_TYPE_SERVER_BLADE =
    DmiBaseboard_BoardType_BOARD_TYPE_SERVER_BLADE;
  static const BoardType BOARD_TYPE_CONNECTIVITY_SWITCH =
    DmiBaseboard_BoardType_BOARD_TYPE_CONNECTIVITY_SWITCH;
  static const BoardType BOARD_TYPE_SYSTEM_MANAGEMENT_MODULE =
    DmiBaseboard_BoardType_BOARD_TYPE_SYSTEM_MANAGEMENT_MODULE;
  static const BoardType BOARD_TYPE_PROCESSOR_MODULE =
    DmiBaseboard_BoardType_BOARD_TYPE_PROCESSOR_MODULE;
  static const BoardType BOARD_TYPE_IO_MODULE =
    DmiBaseboard_BoardType_BOARD_TYPE_IO_MODULE;
  static const BoardType BOARD_TYPE_MEMORY_MODULE =
    DmiBaseboard_BoardType_BOARD_TYPE_MEMORY_MODULE;
  static const BoardType BOARD_TYPE_DAUGHTER_BOARD =
    DmiBaseboard_BoardType_BOARD_TYPE_DAUGHTER_BOARD;
  static const BoardType BOARD_TYPE_MOTHERBOARD =
    DmiBaseboard_BoardType_BOARD_TYPE_MOTHERBOARD;
  static const BoardType BOARD_TYPE_PROCESSOR_PLUS_MEMORY_MODULE =
    DmiBaseboard_BoardType_BOARD_TYPE_PROCESSOR_PLUS_MEMORY_MODULE;
  static const BoardType BOARD_TYPE_PROCESSOR_PLUS_IO_MODULE =
    DmiBaseboard_BoardType_BOARD_TYPE_PROCESSOR_PLUS_IO_MODULE;
  static const BoardType BOARD_TYPE_INTERCONNECT_BOARD =
    DmiBaseboard_BoardType_BOARD_TYPE_INTERCONNECT_BOARD;
  static inline bool BoardType_IsValid(int value) {
    return DmiBaseboard_BoardType_IsValid(value);
  }
  static const BoardType BoardType_MIN =
    DmiBaseboard_BoardType_BoardType_MIN;
  static const BoardType BoardType_MAX =
    DmiBaseboard_BoardType_BoardType_MAX;
  static const int BoardType_ARRAYSIZE =
    DmiBaseboard_BoardType_BoardType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiBaseboard.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiBaseboard_Item& item(int index) const;
  ::aspia::proto::DmiBaseboard_Item* mutable_item(int index);
  ::aspia::proto::DmiBaseboard_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiBaseboard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiBaseboardImpl();
};
// -------------------------------------------------------------------

class DmiChassis_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiChassis.Item) */ {
 public:
  DmiChassis_Item();
  virtual ~DmiChassis_Item();

  DmiChassis_Item(const DmiChassis_Item& from);

  inline DmiChassis_Item& operator=(const DmiChassis_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiChassis_Item(DmiChassis_Item&& from) noexcept
    : DmiChassis_Item() {
    *this = ::std::move(from);
  }

  inline DmiChassis_Item& operator=(DmiChassis_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiChassis_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiChassis_Item* internal_default_instance() {
    return reinterpret_cast<const DmiChassis_Item*>(
               &_DmiChassis_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(DmiChassis_Item* other);
  friend void swap(DmiChassis_Item& a, DmiChassis_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiChassis_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiChassis_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiChassis_Item& from);
  void MergeFrom(const DmiChassis_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiChassis_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 3;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 3;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 4;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 4;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // .aspia.proto.DmiChassis.Type type = 5;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::aspia::proto::DmiChassis_Type type() const;
  void set_type(::aspia::proto::DmiChassis_Type value);

  // .aspia.proto.DmiChassis.Status os_load_status = 6;
  void clear_os_load_status();
  static const int kOsLoadStatusFieldNumber = 6;
  ::aspia::proto::DmiChassis_Status os_load_status() const;
  void set_os_load_status(::aspia::proto::DmiChassis_Status value);

  // .aspia.proto.DmiChassis.Status power_source_status = 7;
  void clear_power_source_status();
  static const int kPowerSourceStatusFieldNumber = 7;
  ::aspia::proto::DmiChassis_Status power_source_status() const;
  void set_power_source_status(::aspia::proto::DmiChassis_Status value);

  // .aspia.proto.DmiChassis.Status temparature_status = 8;
  void clear_temparature_status();
  static const int kTemparatureStatusFieldNumber = 8;
  ::aspia::proto::DmiChassis_Status temparature_status() const;
  void set_temparature_status(::aspia::proto::DmiChassis_Status value);

  // .aspia.proto.DmiChassis.SecurityStatus security_status = 9;
  void clear_security_status();
  static const int kSecurityStatusFieldNumber = 9;
  ::aspia::proto::DmiChassis_SecurityStatus security_status() const;
  void set_security_status(::aspia::proto::DmiChassis_SecurityStatus value);

  // int32 height = 10;
  void clear_height();
  static const int kHeightFieldNumber = 10;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // int32 number_of_power_cords = 11;
  void clear_number_of_power_cords();
  static const int kNumberOfPowerCordsFieldNumber = 11;
  ::google::protobuf::int32 number_of_power_cords() const;
  void set_number_of_power_cords(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiChassis.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  int type_;
  int os_load_status_;
  int power_source_status_;
  int temparature_status_;
  int security_status_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 number_of_power_cords_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiChassis_ItemImpl();
};
// -------------------------------------------------------------------

class DmiChassis : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiChassis) */ {
 public:
  DmiChassis();
  virtual ~DmiChassis();

  DmiChassis(const DmiChassis& from);

  inline DmiChassis& operator=(const DmiChassis& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiChassis(DmiChassis&& from) noexcept
    : DmiChassis() {
    *this = ::std::move(from);
  }

  inline DmiChassis& operator=(DmiChassis&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiChassis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiChassis* internal_default_instance() {
    return reinterpret_cast<const DmiChassis*>(
               &_DmiChassis_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(DmiChassis* other);
  friend void swap(DmiChassis& a, DmiChassis& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiChassis* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiChassis* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiChassis& from);
  void MergeFrom(const DmiChassis& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiChassis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiChassis_Item Item;

  typedef DmiChassis_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiChassis_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiChassis_Type_TYPE_OTHER;
  static const Type TYPE_DESKTOP =
    DmiChassis_Type_TYPE_DESKTOP;
  static const Type TYPE_LOW_PROFILE_DESKTOP =
    DmiChassis_Type_TYPE_LOW_PROFILE_DESKTOP;
  static const Type TYPE_PIZZA_BOX =
    DmiChassis_Type_TYPE_PIZZA_BOX;
  static const Type TYPE_MINI_TOWER =
    DmiChassis_Type_TYPE_MINI_TOWER;
  static const Type TYPE_TOWER =
    DmiChassis_Type_TYPE_TOWER;
  static const Type TYPE_PORTABLE =
    DmiChassis_Type_TYPE_PORTABLE;
  static const Type TYPE_LAPTOP =
    DmiChassis_Type_TYPE_LAPTOP;
  static const Type TYPE_NOTEBOOK =
    DmiChassis_Type_TYPE_NOTEBOOK;
  static const Type TYPE_HAND_HELD =
    DmiChassis_Type_TYPE_HAND_HELD;
  static const Type TYPE_DOCKING_STATION =
    DmiChassis_Type_TYPE_DOCKING_STATION;
  static const Type TYPE_ALL_IN_ONE =
    DmiChassis_Type_TYPE_ALL_IN_ONE;
  static const Type TYPE_SUB_NOTEBOOK =
    DmiChassis_Type_TYPE_SUB_NOTEBOOK;
  static const Type TYPE_SPACE_SAVING =
    DmiChassis_Type_TYPE_SPACE_SAVING;
  static const Type TYPE_LUNCH_BOX =
    DmiChassis_Type_TYPE_LUNCH_BOX;
  static const Type TYPE_MAIN_SERVER_CHASSIS =
    DmiChassis_Type_TYPE_MAIN_SERVER_CHASSIS;
  static const Type TYPE_EXPANSION_CHASSIS =
    DmiChassis_Type_TYPE_EXPANSION_CHASSIS;
  static const Type TYPE_SUB_CHASSIS =
    DmiChassis_Type_TYPE_SUB_CHASSIS;
  static const Type TYPE_BUS_EXPANSION_CHASSIS =
    DmiChassis_Type_TYPE_BUS_EXPANSION_CHASSIS;
  static const Type TYPE_PERIPHERIAL_CHASSIS =
    DmiChassis_Type_TYPE_PERIPHERIAL_CHASSIS;
  static const Type TYPE_RAID_CHASSIS =
    DmiChassis_Type_TYPE_RAID_CHASSIS;
  static const Type TYPE_RACK_MOUNT_CHASSIS =
    DmiChassis_Type_TYPE_RACK_MOUNT_CHASSIS;
  static const Type TYPE_SEALED_CASE_PC =
    DmiChassis_Type_TYPE_SEALED_CASE_PC;
  static const Type TYPE_MULTI_SYSTEM_CHASSIS =
    DmiChassis_Type_TYPE_MULTI_SYSTEM_CHASSIS;
  static const Type TYPE_COMPACT_PCI =
    DmiChassis_Type_TYPE_COMPACT_PCI;
  static const Type TYPE_ADVANCED_TCA =
    DmiChassis_Type_TYPE_ADVANCED_TCA;
  static const Type TYPE_BLADE =
    DmiChassis_Type_TYPE_BLADE;
  static const Type TYPE_BLADE_ENCLOSURE =
    DmiChassis_Type_TYPE_BLADE_ENCLOSURE;
  static inline bool Type_IsValid(int value) {
    return DmiChassis_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiChassis_Type_Type_MIN;
  static const Type Type_MAX =
    DmiChassis_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiChassis_Type_Type_ARRAYSIZE;

  typedef DmiChassis_Status Status;
  static const Status STATUS_UNKNOWN =
    DmiChassis_Status_STATUS_UNKNOWN;
  static const Status STATUS_OTHER =
    DmiChassis_Status_STATUS_OTHER;
  static const Status STATUS_SAFE =
    DmiChassis_Status_STATUS_SAFE;
  static const Status STATUS_WARNING =
    DmiChassis_Status_STATUS_WARNING;
  static const Status STATUS_CRITICAL =
    DmiChassis_Status_STATUS_CRITICAL;
  static const Status STATUS_NON_RECOVERABLE =
    DmiChassis_Status_STATUS_NON_RECOVERABLE;
  static inline bool Status_IsValid(int value) {
    return DmiChassis_Status_IsValid(value);
  }
  static const Status Status_MIN =
    DmiChassis_Status_Status_MIN;
  static const Status Status_MAX =
    DmiChassis_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    DmiChassis_Status_Status_ARRAYSIZE;

  typedef DmiChassis_SecurityStatus SecurityStatus;
  static const SecurityStatus SECURITY_STATUS_UNKNOWN =
    DmiChassis_SecurityStatus_SECURITY_STATUS_UNKNOWN;
  static const SecurityStatus SECURITY_STATUS_OTHER =
    DmiChassis_SecurityStatus_SECURITY_STATUS_OTHER;
  static const SecurityStatus SECURITY_STATUS_NONE =
    DmiChassis_SecurityStatus_SECURITY_STATUS_NONE;
  static const SecurityStatus SECURITY_STATUS_EXTERNAL_INTERFACE_LOCKED_OUT =
    DmiChassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_LOCKED_OUT;
  static const SecurityStatus SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED =
    DmiChassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED;
  static inline bool SecurityStatus_IsValid(int value) {
    return DmiChassis_SecurityStatus_IsValid(value);
  }
  static const SecurityStatus SecurityStatus_MIN =
    DmiChassis_SecurityStatus_SecurityStatus_MIN;
  static const SecurityStatus SecurityStatus_MAX =
    DmiChassis_SecurityStatus_SecurityStatus_MAX;
  static const int SecurityStatus_ARRAYSIZE =
    DmiChassis_SecurityStatus_SecurityStatus_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiChassis.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiChassis_Item& item(int index) const;
  ::aspia::proto::DmiChassis_Item* mutable_item(int index);
  ::aspia::proto::DmiChassis_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiChassis)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiChassisImpl();
};
// -------------------------------------------------------------------

class DmiCaches_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiCaches.Item) */ {
 public:
  DmiCaches_Item();
  virtual ~DmiCaches_Item();

  DmiCaches_Item(const DmiCaches_Item& from);

  inline DmiCaches_Item& operator=(const DmiCaches_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiCaches_Item(DmiCaches_Item&& from) noexcept
    : DmiCaches_Item() {
    *this = ::std::move(from);
  }

  inline DmiCaches_Item& operator=(DmiCaches_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiCaches_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiCaches_Item* internal_default_instance() {
    return reinterpret_cast<const DmiCaches_Item*>(
               &_DmiCaches_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(DmiCaches_Item* other);
  friend void swap(DmiCaches_Item& a, DmiCaches_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiCaches_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiCaches_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiCaches_Item& from);
  void MergeFrom(const DmiCaches_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiCaches_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .aspia.proto.DmiCaches.Location location = 2;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  ::aspia::proto::DmiCaches_Location location() const;
  void set_location(::aspia::proto::DmiCaches_Location value);

  // .aspia.proto.DmiCaches.Status status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::aspia::proto::DmiCaches_Status status() const;
  void set_status(::aspia::proto::DmiCaches_Status value);

  // .aspia.proto.DmiCaches.Mode mode = 4;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::aspia::proto::DmiCaches_Mode mode() const;
  void set_mode(::aspia::proto::DmiCaches_Mode value);

  // int32 level = 5;
  void clear_level();
  static const int kLevelFieldNumber = 5;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // int32 maximum_size = 6;
  void clear_maximum_size();
  static const int kMaximumSizeFieldNumber = 6;
  ::google::protobuf::int32 maximum_size() const;
  void set_maximum_size(::google::protobuf::int32 value);

  // int32 current_size = 7;
  void clear_current_size();
  static const int kCurrentSizeFieldNumber = 7;
  ::google::protobuf::int32 current_size() const;
  void set_current_size(::google::protobuf::int32 value);

  // uint32 supported_sram_types = 8;
  void clear_supported_sram_types();
  static const int kSupportedSramTypesFieldNumber = 8;
  ::google::protobuf::uint32 supported_sram_types() const;
  void set_supported_sram_types(::google::protobuf::uint32 value);

  // .aspia.proto.DmiCaches.SRAMType current_sram_type = 9;
  void clear_current_sram_type();
  static const int kCurrentSramTypeFieldNumber = 9;
  ::aspia::proto::DmiCaches_SRAMType current_sram_type() const;
  void set_current_sram_type(::aspia::proto::DmiCaches_SRAMType value);

  // int32 speed = 10;
  void clear_speed();
  static const int kSpeedFieldNumber = 10;
  ::google::protobuf::int32 speed() const;
  void set_speed(::google::protobuf::int32 value);

  // .aspia.proto.DmiCaches.ErrorCorrectionType error_correction_type = 11;
  void clear_error_correction_type();
  static const int kErrorCorrectionTypeFieldNumber = 11;
  ::aspia::proto::DmiCaches_ErrorCorrectionType error_correction_type() const;
  void set_error_correction_type(::aspia::proto::DmiCaches_ErrorCorrectionType value);

  // .aspia.proto.DmiCaches.Type type = 12;
  void clear_type();
  static const int kTypeFieldNumber = 12;
  ::aspia::proto::DmiCaches_Type type() const;
  void set_type(::aspia::proto::DmiCaches_Type value);

  // .aspia.proto.DmiCaches.Associativity associativity = 13;
  void clear_associativity();
  static const int kAssociativityFieldNumber = 13;
  ::aspia::proto::DmiCaches_Associativity associativity() const;
  void set_associativity(::aspia::proto::DmiCaches_Associativity value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiCaches.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int location_;
  int status_;
  int mode_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 maximum_size_;
  ::google::protobuf::int32 current_size_;
  ::google::protobuf::uint32 supported_sram_types_;
  int current_sram_type_;
  ::google::protobuf::int32 speed_;
  int error_correction_type_;
  int type_;
  int associativity_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiCaches_ItemImpl();
};
// -------------------------------------------------------------------

class DmiCaches : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiCaches) */ {
 public:
  DmiCaches();
  virtual ~DmiCaches();

  DmiCaches(const DmiCaches& from);

  inline DmiCaches& operator=(const DmiCaches& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiCaches(DmiCaches&& from) noexcept
    : DmiCaches() {
    *this = ::std::move(from);
  }

  inline DmiCaches& operator=(DmiCaches&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiCaches& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiCaches* internal_default_instance() {
    return reinterpret_cast<const DmiCaches*>(
               &_DmiCaches_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(DmiCaches* other);
  friend void swap(DmiCaches& a, DmiCaches& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiCaches* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiCaches* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiCaches& from);
  void MergeFrom(const DmiCaches& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiCaches* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiCaches_Item Item;

  typedef DmiCaches_Location Location;
  static const Location LOCATION_UNKNOWN =
    DmiCaches_Location_LOCATION_UNKNOWN;
  static const Location LOCATION_INTERNAL =
    DmiCaches_Location_LOCATION_INTERNAL;
  static const Location LOCATION_EXTERNAL =
    DmiCaches_Location_LOCATION_EXTERNAL;
  static const Location LOCATION_RESERVED =
    DmiCaches_Location_LOCATION_RESERVED;
  static inline bool Location_IsValid(int value) {
    return DmiCaches_Location_IsValid(value);
  }
  static const Location Location_MIN =
    DmiCaches_Location_Location_MIN;
  static const Location Location_MAX =
    DmiCaches_Location_Location_MAX;
  static const int Location_ARRAYSIZE =
    DmiCaches_Location_Location_ARRAYSIZE;

  typedef DmiCaches_Status Status;
  static const Status STATUS_UNKNOWN =
    DmiCaches_Status_STATUS_UNKNOWN;
  static const Status STATUS_ENABLED =
    DmiCaches_Status_STATUS_ENABLED;
  static const Status STATUS_DISABLED =
    DmiCaches_Status_STATUS_DISABLED;
  static inline bool Status_IsValid(int value) {
    return DmiCaches_Status_IsValid(value);
  }
  static const Status Status_MIN =
    DmiCaches_Status_Status_MIN;
  static const Status Status_MAX =
    DmiCaches_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    DmiCaches_Status_Status_ARRAYSIZE;

  typedef DmiCaches_Mode Mode;
  static const Mode MODE_UNKNOWN =
    DmiCaches_Mode_MODE_UNKNOWN;
  static const Mode MODE_WRITE_THRU =
    DmiCaches_Mode_MODE_WRITE_THRU;
  static const Mode MODE_WRITE_BACK =
    DmiCaches_Mode_MODE_WRITE_BACK;
  static const Mode MODE_WRITE_WITH_MEMORY_ADDRESS =
    DmiCaches_Mode_MODE_WRITE_WITH_MEMORY_ADDRESS;
  static inline bool Mode_IsValid(int value) {
    return DmiCaches_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    DmiCaches_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    DmiCaches_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    DmiCaches_Mode_Mode_ARRAYSIZE;

  typedef DmiCaches_SRAMType SRAMType;
  static const SRAMType SRAM_TYPE_BAD =
    DmiCaches_SRAMType_SRAM_TYPE_BAD;
  static const SRAMType SRAM_TYPE_OTHER =
    DmiCaches_SRAMType_SRAM_TYPE_OTHER;
  static const SRAMType SRAM_TYPE_UNKNOWN =
    DmiCaches_SRAMType_SRAM_TYPE_UNKNOWN;
  static const SRAMType SRAM_TYPE_NON_BURST =
    DmiCaches_SRAMType_SRAM_TYPE_NON_BURST;
  static const SRAMType SRAM_TYPE_BURST =
    DmiCaches_SRAMType_SRAM_TYPE_BURST;
  static const SRAMType SRAM_TYPE_PIPELINE_BURST =
    DmiCaches_SRAMType_SRAM_TYPE_PIPELINE_BURST;
  static const SRAMType SRAM_TYPE_SYNCHRONOUS =
    DmiCaches_SRAMType_SRAM_TYPE_SYNCHRONOUS;
  static const SRAMType SRAM_TYPE_ASYNCHRONOUS =
    DmiCaches_SRAMType_SRAM_TYPE_ASYNCHRONOUS;
  static inline bool SRAMType_IsValid(int value) {
    return DmiCaches_SRAMType_IsValid(value);
  }
  static const SRAMType SRAMType_MIN =
    DmiCaches_SRAMType_SRAMType_MIN;
  static const SRAMType SRAMType_MAX =
    DmiCaches_SRAMType_SRAMType_MAX;
  static const int SRAMType_ARRAYSIZE =
    DmiCaches_SRAMType_SRAMType_ARRAYSIZE;

  typedef DmiCaches_ErrorCorrectionType ErrorCorrectionType;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_UNKNOWN =
    DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_UNKNOWN;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_OTHER =
    DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_OTHER;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_NONE =
    DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_NONE;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_PARITY =
    DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_PARITY;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_SINGLE_BIT_ECC =
    DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_SINGLE_BIT_ECC;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_MULTI_BIT_ECC =
    DmiCaches_ErrorCorrectionType_ERROR_CORRECTION_TYPE_MULTI_BIT_ECC;
  static inline bool ErrorCorrectionType_IsValid(int value) {
    return DmiCaches_ErrorCorrectionType_IsValid(value);
  }
  static const ErrorCorrectionType ErrorCorrectionType_MIN =
    DmiCaches_ErrorCorrectionType_ErrorCorrectionType_MIN;
  static const ErrorCorrectionType ErrorCorrectionType_MAX =
    DmiCaches_ErrorCorrectionType_ErrorCorrectionType_MAX;
  static const int ErrorCorrectionType_ARRAYSIZE =
    DmiCaches_ErrorCorrectionType_ErrorCorrectionType_ARRAYSIZE;

  typedef DmiCaches_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiCaches_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiCaches_Type_TYPE_OTHER;
  static const Type TYPE_INSTRUCTION =
    DmiCaches_Type_TYPE_INSTRUCTION;
  static const Type TYPE_DATA =
    DmiCaches_Type_TYPE_DATA;
  static const Type TYPE_UNIFIED =
    DmiCaches_Type_TYPE_UNIFIED;
  static inline bool Type_IsValid(int value) {
    return DmiCaches_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiCaches_Type_Type_MIN;
  static const Type Type_MAX =
    DmiCaches_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiCaches_Type_Type_ARRAYSIZE;

  typedef DmiCaches_Associativity Associativity;
  static const Associativity ASSOCIATIVITY_UNKNOWN =
    DmiCaches_Associativity_ASSOCIATIVITY_UNKNOWN;
  static const Associativity ASSOCIATIVITY_OTHER =
    DmiCaches_Associativity_ASSOCIATIVITY_OTHER;
  static const Associativity ASSOCIATIVITY_DIRECT_MAPPED =
    DmiCaches_Associativity_ASSOCIATIVITY_DIRECT_MAPPED;
  static const Associativity ASSOCIATIVITY_2_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_2_WAY;
  static const Associativity ASSOCIATIVITY_4_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_4_WAY;
  static const Associativity ASSOCIATIVITY_FULLY =
    DmiCaches_Associativity_ASSOCIATIVITY_FULLY;
  static const Associativity ASSOCIATIVITY_8_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_8_WAY;
  static const Associativity ASSOCIATIVITY_16_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_16_WAY;
  static const Associativity ASSOCIATIVITY_12_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_12_WAY;
  static const Associativity ASSOCIATIVITY_24_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_24_WAY;
  static const Associativity ASSOCIATIVITY_32_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_32_WAY;
  static const Associativity ASSOCIATIVITY_48_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_48_WAY;
  static const Associativity ASSOCIATIVITY_64_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_64_WAY;
  static const Associativity ASSOCIATIVITY_20_WAY =
    DmiCaches_Associativity_ASSOCIATIVITY_20_WAY;
  static inline bool Associativity_IsValid(int value) {
    return DmiCaches_Associativity_IsValid(value);
  }
  static const Associativity Associativity_MIN =
    DmiCaches_Associativity_Associativity_MIN;
  static const Associativity Associativity_MAX =
    DmiCaches_Associativity_Associativity_MAX;
  static const int Associativity_ARRAYSIZE =
    DmiCaches_Associativity_Associativity_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiCaches.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiCaches_Item& item(int index) const;
  ::aspia::proto::DmiCaches_Item* mutable_item(int index);
  ::aspia::proto::DmiCaches_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiCaches)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiCachesImpl();
};
// -------------------------------------------------------------------

class DmiProcessors_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiProcessors.Item) */ {
 public:
  DmiProcessors_Item();
  virtual ~DmiProcessors_Item();

  DmiProcessors_Item(const DmiProcessors_Item& from);

  inline DmiProcessors_Item& operator=(const DmiProcessors_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiProcessors_Item(DmiProcessors_Item&& from) noexcept
    : DmiProcessors_Item() {
    *this = ::std::move(from);
  }

  inline DmiProcessors_Item& operator=(DmiProcessors_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiProcessors_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiProcessors_Item* internal_default_instance() {
    return reinterpret_cast<const DmiProcessors_Item*>(
               &_DmiProcessors_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(DmiProcessors_Item* other);
  friend void swap(DmiProcessors_Item& a, DmiProcessors_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiProcessors_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiProcessors_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiProcessors_Item& from);
  void MergeFrom(const DmiProcessors_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiProcessors_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string socket = 6;
  void clear_socket();
  static const int kSocketFieldNumber = 6;
  const ::std::string& socket() const;
  void set_socket(const ::std::string& value);
  #if LANG_CXX11
  void set_socket(::std::string&& value);
  #endif
  void set_socket(const char* value);
  void set_socket(const char* value, size_t size);
  ::std::string* mutable_socket();
  ::std::string* release_socket();
  void set_allocated_socket(::std::string* socket);

  // string serial_number = 12;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 12;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 13;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 13;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // string part_number = 14;
  void clear_part_number();
  static const int kPartNumberFieldNumber = 14;
  const ::std::string& part_number() const;
  void set_part_number(const ::std::string& value);
  #if LANG_CXX11
  void set_part_number(::std::string&& value);
  #endif
  void set_part_number(const char* value);
  void set_part_number(const char* value, size_t size);
  ::std::string* mutable_part_number();
  ::std::string* release_part_number();
  void set_allocated_part_number(::std::string* part_number);

  // .aspia.proto.DmiProcessors.Family family = 3;
  void clear_family();
  static const int kFamilyFieldNumber = 3;
  ::aspia::proto::DmiProcessors_Family family() const;
  void set_family(::aspia::proto::DmiProcessors_Family value);

  // .aspia.proto.DmiProcessors.Type type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::aspia::proto::DmiProcessors_Type type() const;
  void set_type(::aspia::proto::DmiProcessors_Type value);

  // .aspia.proto.DmiProcessors.Status status = 5;
  void clear_status();
  static const int kStatusFieldNumber = 5;
  ::aspia::proto::DmiProcessors_Status status() const;
  void set_status(::aspia::proto::DmiProcessors_Status value);

  // .aspia.proto.DmiProcessors.Upgrade upgrade = 7;
  void clear_upgrade();
  static const int kUpgradeFieldNumber = 7;
  ::aspia::proto::DmiProcessors_Upgrade upgrade() const;
  void set_upgrade(::aspia::proto::DmiProcessors_Upgrade value);

  // int32 external_clock = 8;
  void clear_external_clock();
  static const int kExternalClockFieldNumber = 8;
  ::google::protobuf::int32 external_clock() const;
  void set_external_clock(::google::protobuf::int32 value);

  // int32 current_speed = 9;
  void clear_current_speed();
  static const int kCurrentSpeedFieldNumber = 9;
  ::google::protobuf::int32 current_speed() const;
  void set_current_speed(::google::protobuf::int32 value);

  // double voltage = 11;
  void clear_voltage();
  static const int kVoltageFieldNumber = 11;
  double voltage() const;
  void set_voltage(double value);

  // int32 maximum_speed = 10;
  void clear_maximum_speed();
  static const int kMaximumSpeedFieldNumber = 10;
  ::google::protobuf::int32 maximum_speed() const;
  void set_maximum_speed(::google::protobuf::int32 value);

  // int32 core_count = 15;
  void clear_core_count();
  static const int kCoreCountFieldNumber = 15;
  ::google::protobuf::int32 core_count() const;
  void set_core_count(::google::protobuf::int32 value);

  // int32 core_enabled = 16;
  void clear_core_enabled();
  static const int kCoreEnabledFieldNumber = 16;
  ::google::protobuf::int32 core_enabled() const;
  void set_core_enabled(::google::protobuf::int32 value);

  // int32 thread_count = 17;
  void clear_thread_count();
  static const int kThreadCountFieldNumber = 17;
  ::google::protobuf::int32 thread_count() const;
  void set_thread_count(::google::protobuf::int32 value);

  // uint32 characteristics = 18;
  void clear_characteristics();
  static const int kCharacteristicsFieldNumber = 18;
  ::google::protobuf::uint32 characteristics() const;
  void set_characteristics(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiProcessors.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr socket_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  ::google::protobuf::internal::ArenaStringPtr part_number_;
  int family_;
  int type_;
  int status_;
  int upgrade_;
  ::google::protobuf::int32 external_clock_;
  ::google::protobuf::int32 current_speed_;
  double voltage_;
  ::google::protobuf::int32 maximum_speed_;
  ::google::protobuf::int32 core_count_;
  ::google::protobuf::int32 core_enabled_;
  ::google::protobuf::int32 thread_count_;
  ::google::protobuf::uint32 characteristics_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiProcessors_ItemImpl();
};
// -------------------------------------------------------------------

class DmiProcessors : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiProcessors) */ {
 public:
  DmiProcessors();
  virtual ~DmiProcessors();

  DmiProcessors(const DmiProcessors& from);

  inline DmiProcessors& operator=(const DmiProcessors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiProcessors(DmiProcessors&& from) noexcept
    : DmiProcessors() {
    *this = ::std::move(from);
  }

  inline DmiProcessors& operator=(DmiProcessors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiProcessors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiProcessors* internal_default_instance() {
    return reinterpret_cast<const DmiProcessors*>(
               &_DmiProcessors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(DmiProcessors* other);
  friend void swap(DmiProcessors& a, DmiProcessors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiProcessors* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiProcessors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiProcessors& from);
  void MergeFrom(const DmiProcessors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiProcessors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiProcessors_Item Item;

  typedef DmiProcessors_Family Family;
  static const Family FAMILY_UNKNOWN =
    DmiProcessors_Family_FAMILY_UNKNOWN;
  static const Family FAMILY_OTHER =
    DmiProcessors_Family_FAMILY_OTHER;
  static const Family FAMILY_8086 =
    DmiProcessors_Family_FAMILY_8086;
  static const Family FAMILY_80286 =
    DmiProcessors_Family_FAMILY_80286;
  static const Family FAMILY_INTEL_386_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_386_PROCESSOR;
  static const Family FAMILY_INTEL_486_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_486_PROCESSOR;
  static const Family FAMILY_8087 =
    DmiProcessors_Family_FAMILY_8087;
  static const Family FAMILY_80287 =
    DmiProcessors_Family_FAMILY_80287;
  static const Family FAMILY_80387 =
    DmiProcessors_Family_FAMILY_80387;
  static const Family FAMILY_80487 =
    DmiProcessors_Family_FAMILY_80487;
  static const Family FAMILY_INTEL_PENTIUM_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_PRO_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_PRO_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_2_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_2_PROCESSOR;
  static const Family FAMILY_PENTIUM_PROCESSOR_WITH_MMX =
    DmiProcessors_Family_FAMILY_PENTIUM_PROCESSOR_WITH_MMX;
  static const Family FAMILY_INTEL_CELERON_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CELERON_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_2_XEON_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_2_XEON_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_3_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_3_PROCESSOR;
  static const Family FAMILY_M1_FAMILY =
    DmiProcessors_Family_FAMILY_M1_FAMILY;
  static const Family FAMILY_M2_FAMILY =
    DmiProcessors_Family_FAMILY_M2_FAMILY;
  static const Family FAMILY_INTEL_CELEROM_M_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CELEROM_M_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_4_HT_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_4_HT_PROCESSOR;
  static const Family FAMILY_AMD_DURON_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_DURON_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_K5_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_K5_FAMILY;
  static const Family FAMILY_AMD_K6_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_K6_FAMILY;
  static const Family FAMILY_AMD_K6_2 =
    DmiProcessors_Family_FAMILY_AMD_K6_2;
  static const Family FAMILY_AMD_K6_3 =
    DmiProcessors_Family_FAMILY_AMD_K6_3;
  static const Family FAMILY_AMD_ATHLON_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_29000_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_29000_FAMILY;
  static const Family FAMILY_AMD_K6_2_PLUS =
    DmiProcessors_Family_FAMILY_AMD_K6_2_PLUS;
  static const Family FAMILY_POWER_PC_FAMILY =
    DmiProcessors_Family_FAMILY_POWER_PC_FAMILY;
  static const Family FAMILY_POWER_PC_601 =
    DmiProcessors_Family_FAMILY_POWER_PC_601;
  static const Family FAMILY_POWER_PC_603 =
    DmiProcessors_Family_FAMILY_POWER_PC_603;
  static const Family FAMILY_POWER_PC_603_PLUS =
    DmiProcessors_Family_FAMILY_POWER_PC_603_PLUS;
  static const Family FAMILY_POWER_PC_604 =
    DmiProcessors_Family_FAMILY_POWER_PC_604;
  static const Family FAMILY_POWER_PC_620 =
    DmiProcessors_Family_FAMILY_POWER_PC_620;
  static const Family FAMILY_POWER_PC_X704 =
    DmiProcessors_Family_FAMILY_POWER_PC_X704;
  static const Family FAMILY_POWER_PC_750 =
    DmiProcessors_Family_FAMILY_POWER_PC_750;
  static const Family FAMILY_INTEL_CORE_DUO_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_DUO_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_DUO_MOBILE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_DUO_MOBILE_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_SOLO_MOBILE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_SOLO_MOBILE_PROCESSOR;
  static const Family FAMILY_INTEL_ATOM_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_ATOM_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_M_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_M_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_M3_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_M3_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_M5_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_M5_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_M7_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_M7_PROCESSOR;
  static const Family FAMILY_ALPHA_FAMILY =
    DmiProcessors_Family_FAMILY_ALPHA_FAMILY;
  static const Family FAMILY_ALPHA_21064 =
    DmiProcessors_Family_FAMILY_ALPHA_21064;
  static const Family FAMILY_ALPHA_21066 =
    DmiProcessors_Family_FAMILY_ALPHA_21066;
  static const Family FAMILY_ALPHA_21164 =
    DmiProcessors_Family_FAMILY_ALPHA_21164;
  static const Family FAMILY_ALPHA_21164PC =
    DmiProcessors_Family_FAMILY_ALPHA_21164PC;
  static const Family FAMILY_ALPHA_21164A =
    DmiProcessors_Family_FAMILY_ALPHA_21164A;
  static const Family FAMILY_ALPHA_21264 =
    DmiProcessors_Family_FAMILY_ALPHA_21264;
  static const Family FAMILY_ALPHA_21364 =
    DmiProcessors_Family_FAMILY_ALPHA_21364;
  static const Family FAMILY_AMD_TURION_2_ULTRA_DUAL_CORE_MOBILE_M_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_TURION_2_ULTRA_DUAL_CORE_MOBILE_M_FAMILY;
  static const Family FAMILY_AMD_TURION_2_DUAL_CORE_MOBILE_M_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_TURION_2_DUAL_CORE_MOBILE_M_FAMILY;
  static const Family FAMILY_AMD_ATHLON_2_DUAL_CORE_M_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_2_DUAL_CORE_M_FAMILY;
  static const Family FAMILY_AMD_OPTERON_6100_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_6100_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_4100_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_4100_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_6200_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_6200_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_4200_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_4200_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_FX_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_FX_SERIES_PROCESSOR;
  static const Family FAMILY_MIPS_FAMILY =
    DmiProcessors_Family_FAMILY_MIPS_FAMILY;
  static const Family FAMILY_MIPS_R4000 =
    DmiProcessors_Family_FAMILY_MIPS_R4000;
  static const Family FAMILY_MIPS_R4200 =
    DmiProcessors_Family_FAMILY_MIPS_R4200;
  static const Family FAMILY_MIPS_R4400 =
    DmiProcessors_Family_FAMILY_MIPS_R4400;
  static const Family FAMILY_MIPS_R4600 =
    DmiProcessors_Family_FAMILY_MIPS_R4600;
  static const Family FAMILY_MIPS_R10000 =
    DmiProcessors_Family_FAMILY_MIPS_R10000;
  static const Family FAMILY_AMD_C_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_C_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_E_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_E_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_A_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_A_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_G_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_G_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_Z_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_Z_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_R_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_R_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_4300_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_4300_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_6300_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_6300_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_3300_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_3300_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_FIREPRO_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_FIREPRO_SERIES_PROCESSOR;
  static const Family FAMILY_SPARC_FAMILY =
    DmiProcessors_Family_FAMILY_SPARC_FAMILY;
  static const Family FAMILY_SUPER_SPARC =
    DmiProcessors_Family_FAMILY_SUPER_SPARC;
  static const Family FAMILY_MICRO_SPARC_2 =
    DmiProcessors_Family_FAMILY_MICRO_SPARC_2;
  static const Family FAMILY_MICRO_SPARC_2EP =
    DmiProcessors_Family_FAMILY_MICRO_SPARC_2EP;
  static const Family FAMILY_ULTRA_SPARC =
    DmiProcessors_Family_FAMILY_ULTRA_SPARC;
  static const Family FAMILY_ULTRA_SPARC_2 =
    DmiProcessors_Family_FAMILY_ULTRA_SPARC_2;
  static const Family FAMILY_ULTRA_SPARC_2I =
    DmiProcessors_Family_FAMILY_ULTRA_SPARC_2I;
  static const Family FAMILY_ULTRA_SPARC_3 =
    DmiProcessors_Family_FAMILY_ULTRA_SPARC_3;
  static const Family FAMILY_ULTRA_SPARC_3I =
    DmiProcessors_Family_FAMILY_ULTRA_SPARC_3I;
  static const Family FAMILY_68040_FAMILY =
    DmiProcessors_Family_FAMILY_68040_FAMILY;
  static const Family FAMILY_68XXX =
    DmiProcessors_Family_FAMILY_68XXX;
  static const Family FAMILY_68000 =
    DmiProcessors_Family_FAMILY_68000;
  static const Family FAMILY_68010 =
    DmiProcessors_Family_FAMILY_68010;
  static const Family FAMILY_68020 =
    DmiProcessors_Family_FAMILY_68020;
  static const Family FAMILY_68030 =
    DmiProcessors_Family_FAMILY_68030;
  static const Family FAMILY_AMD_ATHLON_X4_QUAD_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_X4_QUAD_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_OPTERON_X1000_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_X1000_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_X2000_SERIES_APU =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_X2000_SERIES_APU;
  static const Family FAMILY_AMD_OPTERON_A_SERIES_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_A_SERIES_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_X3000_SERIES_APU =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_X3000_SERIES_APU;
  static const Family FAMILY_AMD_ZEN_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ZEN_PROCESSOR_FAMILY;
  static const Family FAMILY_HOBBIT_FAMILY =
    DmiProcessors_Family_FAMILY_HOBBIT_FAMILY;
  static const Family FAMILY_CRUSOE_TM5000_FAMILY =
    DmiProcessors_Family_FAMILY_CRUSOE_TM5000_FAMILY;
  static const Family FAMILY_CRUSOE_TM3000_FAMILY =
    DmiProcessors_Family_FAMILY_CRUSOE_TM3000_FAMILY;
  static const Family FAMILY_EFFICEON_TM8000_FAMILY =
    DmiProcessors_Family_FAMILY_EFFICEON_TM8000_FAMILY;
  static const Family FAMILY_WEITEK =
    DmiProcessors_Family_FAMILY_WEITEK;
  static const Family FAMILY_INTEL_ITANIUM_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_ITANIUM_PROCESSOR;
  static const Family FAMILY_AMD_ATHLON_64_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_64_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_OPTERON_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_SEMPRON_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_SEMPRON_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_TURION_64_MOBILE_TECHNOLOGY =
    DmiProcessors_Family_FAMILY_AMD_TURION_64_MOBILE_TECHNOLOGY;
  static const Family FAMILY_AMD_OPTERON_DUAL_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_DUAL_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_ATHLON_64_X2_DUAL_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_64_X2_DUAL_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_TURION_64_X2_MOBILE_TECHNOLOGY =
    DmiProcessors_Family_FAMILY_AMD_TURION_64_X2_MOBILE_TECHNOLOGY;
  static const Family FAMILY_AMD_OPTERON_QUAD_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_QUAD_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_OPTERON_THIRD_GEN_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_THIRD_GEN_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_PHENOM_FX_QUAD_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_PHENOM_FX_QUAD_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_PHENOM_X4_QUAD_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_PHENOM_X4_QUAD_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_PHENOM_X2_DUAL_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_PHENOM_X2_DUAL_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_ATHLON_X2_DUAL_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_X2_DUAL_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_PA_RISC_FAMILY =
    DmiProcessors_Family_FAMILY_PA_RISC_FAMILY;
  static const Family FAMILY_PA_RISC_8500 =
    DmiProcessors_Family_FAMILY_PA_RISC_8500;
  static const Family FAMILY_PA_RISC_8000 =
    DmiProcessors_Family_FAMILY_PA_RISC_8000;
  static const Family FAMILY_PA_RISC_7300LC =
    DmiProcessors_Family_FAMILY_PA_RISC_7300LC;
  static const Family FAMILY_PA_RISC_7200 =
    DmiProcessors_Family_FAMILY_PA_RISC_7200;
  static const Family FAMILY_PA_RISC_7100LC =
    DmiProcessors_Family_FAMILY_PA_RISC_7100LC;
  static const Family FAMILY_PA_RISC_7100 =
    DmiProcessors_Family_FAMILY_PA_RISC_7100;
  static const Family FAMILY_V30_FAMILY =
    DmiProcessors_Family_FAMILY_V30_FAMILY;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_3200_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_3200_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_3000_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_3000_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_5300_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_5300_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_5100_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5100_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_5000_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5000_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_LV_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_LV_PROCESSOR;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_ULV_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_ULV_PROCESSOR;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_7100_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_7100_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_5400_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_5400_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_PROCESSOR;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_5200_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5200_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_7200_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_7200_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_7300_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_7300_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_7400_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_7400_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_MULTI_CORE_7400_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_7400_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_PENTIUM_3_XEON_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_3_XEON_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_3_PROCESSOR_WITH_SPEED_STEP =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_3_PROCESSOR_WITH_SPEED_STEP;
  static const Family FAMILY_INTEL_PENTIUM_4_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_4_PROCESSOR;
  static const Family FAMILY_INTEL_XEON_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_XEON_PROCESSOR;
  static const Family FAMILY_AS400_FAMILY =
    DmiProcessors_Family_FAMILY_AS400_FAMILY;
  static const Family FAMILY_INTEL_XEON_MP_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_XEON_MP_PROCESSOR;
  static const Family FAMILY_AMD_ATHLON_XP_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_XP_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_ATHLON_MP_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_MP_PROCESSOR_FAMILY;
  static const Family FAMILY_INTEL_ITANIUM_2_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_ITANIUM_2_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_M_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_M_PROCESSOR;
  static const Family FAMILY_INTEL_CELERON_D_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CELERON_D_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_D_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_D_PROCESSOR;
  static const Family FAMILY_INTEL_PENTIUM_PROCESSOR_EXTREME_EDITION =
    DmiProcessors_Family_FAMILY_INTEL_PENTIUM_PROCESSOR_EXTREME_EDITION;
  static const Family FAMILY_INTEL_CORE_SOLO_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_SOLO_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_DUO_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_DUO_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_SOLO_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_SOLO_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_EXTREME_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_EXTREME_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_QUAD_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_QUAD_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_EXTREME_MOBILE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_EXTREME_MOBILE_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_DUO_MOBILE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_DUO_MOBILE_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_SOLO_MOBILE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_SOLO_MOBILE_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_I7_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_I7_PROCESSOR;
  static const Family FAMILY_INTEL_CELERON_DUAL_CORE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CELERON_DUAL_CORE_PROCESSOR;
  static const Family FAMILY_IBM390_FAMILY =
    DmiProcessors_Family_FAMILY_IBM390_FAMILY;
  static const Family FAMILY_G4 =
    DmiProcessors_Family_FAMILY_G4;
  static const Family FAMILY_G5 =
    DmiProcessors_Family_FAMILY_G5;
  static const Family FAMILY_ESA_390_G6 =
    DmiProcessors_Family_FAMILY_ESA_390_G6;
  static const Family FAMILY_Z_ARCHITECTURE_BASE =
    DmiProcessors_Family_FAMILY_Z_ARCHITECTURE_BASE;
  static const Family FAMILY_INTEL_CORE_I5_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_I5_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_I3_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_CORE_I3_PROCESSOR;
  static const Family FAMILY_VIA_C7_M_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_VIA_C7_M_PROCESSOR_FAMILY;
  static const Family FAMILY_VIA_C7_D_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_VIA_C7_D_PROCESSOR_FAMILY;
  static const Family FAMILY_VIA_C7_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_VIA_C7_PROCESSOR_FAMILY;
  static const Family FAMILY_VIA_EDEN_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_VIA_EDEN_PROCESSOR_FAMILY;
  static const Family FAMILY_INTEL_XEON_MULTI_CORE_PROCESSOR =
    DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_PROCESSOR;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_3XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_3XXX_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_3XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_3XXX_PROCESSOR_SERIES;
  static const Family FAMILY_VIA_NANO_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_VIA_NANO_PROCESSOR_FAMILY;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_5XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_5XXX_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_5XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_5XXX_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_DUAL_CORE_7XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_DUAL_CORE_7XXX_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_QUAD_CORE_7XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_QUAD_CORE_7XXX_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_MULTI_CORE_7XXX_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_7XXX_PROCESSOR_SERIES;
  static const Family FAMILY_INTEL_XEON_MULTI_CORE_3400_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_INTEL_XEON_MULTI_CORE_3400_PROCESSOR_SERIES;
  static const Family FAMILY_AMD_OPTERON_3000_PROCESSOR_SERIES =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_3000_PROCESSOR_SERIES;
  static const Family FAMILY_AMD_SEMPRON_II_PROCESSOR =
    DmiProcessors_Family_FAMILY_AMD_SEMPRON_II_PROCESSOR;
  static const Family FAMILY_AMD_OPTERON_QUAD_CORE_EMBEDDED_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_QUAD_CORE_EMBEDDED_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_PHENOM_TRIPLE_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_PHENOM_TRIPLE_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_TURION_ULTRA_DUAL_CORE_MOBILE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_TURION_ULTRA_DUAL_CORE_MOBILE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_TURION_DUAL_CORE_MOBILE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_TURION_DUAL_CORE_MOBILE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_ATHLON_DUAL_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_DUAL_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_SEMPRON_SI_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_SEMPRON_SI_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_PHENOM_2_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_PHENOM_2_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_ATHLON_2_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_ATHLON_2_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_OPTERON_SIX_CORE_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_OPTERON_SIX_CORE_PROCESSOR_FAMILY;
  static const Family FAMILY_AMD_SEMPRON_M_PROCESSOR_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_SEMPRON_M_PROCESSOR_FAMILY;
  static const Family FAMILY_I860 =
    DmiProcessors_Family_FAMILY_I860;
  static const Family FAMILY_I960 =
    DmiProcessors_Family_FAMILY_I960;
  static const Family FAMILY_ARM_V7 =
    DmiProcessors_Family_FAMILY_ARM_V7;
  static const Family FAMILY_ARM_V8 =
    DmiProcessors_Family_FAMILY_ARM_V8;
  static const Family FAMILY_SH_3 =
    DmiProcessors_Family_FAMILY_SH_3;
  static const Family FAMILY_SH_4 =
    DmiProcessors_Family_FAMILY_SH_4;
  static const Family FAMILY_ARM =
    DmiProcessors_Family_FAMILY_ARM;
  static const Family FAMILY_STRONG_ARM =
    DmiProcessors_Family_FAMILY_STRONG_ARM;
  static const Family FAMILY_6X86 =
    DmiProcessors_Family_FAMILY_6X86;
  static const Family FAMILY_MEDIA_GX =
    DmiProcessors_Family_FAMILY_MEDIA_GX;
  static const Family FAMILY_MII =
    DmiProcessors_Family_FAMILY_MII;
  static const Family FAMILY_WIN_CHIP =
    DmiProcessors_Family_FAMILY_WIN_CHIP;
  static const Family FAMILY_DSP =
    DmiProcessors_Family_FAMILY_DSP;
  static const Family FAMILY_VIDEO_PROCESSOR =
    DmiProcessors_Family_FAMILY_VIDEO_PROCESSOR;
  static const Family FAMILY_INTEL_CORE_2_FAMILY =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_FAMILY;
  static const Family FAMILY_AMD_K7_FAMILY =
    DmiProcessors_Family_FAMILY_AMD_K7_FAMILY;
  static const Family FAMILY_INTEL_CORE_2_OR_AMD_K7_FAMILY =
    DmiProcessors_Family_FAMILY_INTEL_CORE_2_OR_AMD_K7_FAMILY;
  static inline bool Family_IsValid(int value) {
    return DmiProcessors_Family_IsValid(value);
  }
  static const Family Family_MIN =
    DmiProcessors_Family_Family_MIN;
  static const Family Family_MAX =
    DmiProcessors_Family_Family_MAX;
  static const int Family_ARRAYSIZE =
    DmiProcessors_Family_Family_ARRAYSIZE;

  typedef DmiProcessors_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiProcessors_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiProcessors_Type_TYPE_OTHER;
  static const Type TYPE_CENTRAL_PROCESSOR =
    DmiProcessors_Type_TYPE_CENTRAL_PROCESSOR;
  static const Type TYPE_MATH_PROCESSOR =
    DmiProcessors_Type_TYPE_MATH_PROCESSOR;
  static const Type TYPE_DSP_PROCESSOR =
    DmiProcessors_Type_TYPE_DSP_PROCESSOR;
  static const Type TYPE_VIDEO_PROCESSOR =
    DmiProcessors_Type_TYPE_VIDEO_PROCESSOR;
  static inline bool Type_IsValid(int value) {
    return DmiProcessors_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiProcessors_Type_Type_MIN;
  static const Type Type_MAX =
    DmiProcessors_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiProcessors_Type_Type_ARRAYSIZE;

  typedef DmiProcessors_Status Status;
  static const Status STATUS_UNKNOWN =
    DmiProcessors_Status_STATUS_UNKNOWN;
  static const Status STATUS_ENABLED =
    DmiProcessors_Status_STATUS_ENABLED;
  static const Status STATUS_DISABLED_BY_USER =
    DmiProcessors_Status_STATUS_DISABLED_BY_USER;
  static const Status STATUS_DISABLED_BY_BIOS =
    DmiProcessors_Status_STATUS_DISABLED_BY_BIOS;
  static const Status STATUS_IDLE =
    DmiProcessors_Status_STATUS_IDLE;
  static const Status STATUS_OTHER =
    DmiProcessors_Status_STATUS_OTHER;
  static inline bool Status_IsValid(int value) {
    return DmiProcessors_Status_IsValid(value);
  }
  static const Status Status_MIN =
    DmiProcessors_Status_Status_MIN;
  static const Status Status_MAX =
    DmiProcessors_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    DmiProcessors_Status_Status_ARRAYSIZE;

  typedef DmiProcessors_Upgrade Upgrade;
  static const Upgrade UPGRADE_UNKNOWN =
    DmiProcessors_Upgrade_UPGRADE_UNKNOWN;
  static const Upgrade UPGRADE_OTHER =
    DmiProcessors_Upgrade_UPGRADE_OTHER;
  static const Upgrade UPGRADE_DAUGHTER_BOARD =
    DmiProcessors_Upgrade_UPGRADE_DAUGHTER_BOARD;
  static const Upgrade UPGRADE_ZIF_SOCKET =
    DmiProcessors_Upgrade_UPGRADE_ZIF_SOCKET;
  static const Upgrade UPGRADE_REPLACEABLE_PIGGY_BACK =
    DmiProcessors_Upgrade_UPGRADE_REPLACEABLE_PIGGY_BACK;
  static const Upgrade UPGRADE_NONE =
    DmiProcessors_Upgrade_UPGRADE_NONE;
  static const Upgrade UPGRADE_LIF_SOCKET =
    DmiProcessors_Upgrade_UPGRADE_LIF_SOCKET;
  static const Upgrade UPGRADE_SLOT_1 =
    DmiProcessors_Upgrade_UPGRADE_SLOT_1;
  static const Upgrade UPGRADE_SLOT_2 =
    DmiProcessors_Upgrade_UPGRADE_SLOT_2;
  static const Upgrade UPGRADE_370_PIN_SOCKET =
    DmiProcessors_Upgrade_UPGRADE_370_PIN_SOCKET;
  static const Upgrade UPGRADE_SLOT_A =
    DmiProcessors_Upgrade_UPGRADE_SLOT_A;
  static const Upgrade UPGRADE_SLOT_M =
    DmiProcessors_Upgrade_UPGRADE_SLOT_M;
  static const Upgrade UPGRADE_SOCKET_423 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_423;
  static const Upgrade UPGRADE_SOCKET_462 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_462;
  static const Upgrade UPGRADE_SOCKET_478 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_478;
  static const Upgrade UPGRADE_SOCKET_754 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_754;
  static const Upgrade UPGRADE_SOCKET_940 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_940;
  static const Upgrade UPGRADE_SOCKET_939 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_939;
  static const Upgrade UPGRADE_SOCKET_MPGA604 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_MPGA604;
  static const Upgrade UPGRADE_SOCKET_LGA771 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA771;
  static const Upgrade UPGRADE_SOCKET_LGA775 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA775;
  static const Upgrade UPGRADE_SOCKET_S1 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_S1;
  static const Upgrade UPGRADE_SOCKET_AM2 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_AM2;
  static const Upgrade UPGRADE_SOCKET_F =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_F;
  static const Upgrade UPGRADE_SOCKET_LGA1366 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1366;
  static const Upgrade UPGRADE_SOCKET_G34 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_G34;
  static const Upgrade UPGRADE_SOCKET_AM3 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_AM3;
  static const Upgrade UPGRADE_SOCKET_C32 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_C32;
  static const Upgrade UPGRADE_SOCKET_LGA1156 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1156;
  static const Upgrade UPGRADE_SOCKET_LGA1567 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1567;
  static const Upgrade UPGRADE_SOCKET_PGA988A =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_PGA988A;
  static const Upgrade UPGRADE_SOCKET_BGA1288 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1288;
  static const Upgrade UPGRADE_SOCKET_RPGA988B =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_RPGA988B;
  static const Upgrade UPGRADE_SOCKET_BGA1023 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1023;
  static const Upgrade UPGRADE_SOCKET_BGA1224 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1224;
  static const Upgrade UPGRADE_SOCKET_BGA1155 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1155;
  static const Upgrade UPGRADE_SOCKET_LGA1356 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1356;
  static const Upgrade UPGRADE_SOCKET_LGA2011 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA2011;
  static const Upgrade UPGRADE_SOCKET_FS1 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_FS1;
  static const Upgrade UPGRADE_SOCKET_FS2 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_FS2;
  static const Upgrade UPGRADE_SOCKET_FM1 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_FM1;
  static const Upgrade UPGRADE_SOCKET_FM2 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_FM2;
  static const Upgrade UPGRADE_SOCKET_LGA2011_3 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA2011_3;
  static const Upgrade UPGRADE_SOCKET_LGA1356_3 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1356_3;
  static const Upgrade UPGRADE_SOCKET_LGA1150 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1150;
  static const Upgrade UPGRADE_SOCKET_BGA1168 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1168;
  static const Upgrade UPGRADE_SOCKET_BGA1234 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1234;
  static const Upgrade UPGRADE_SOCKET_BGA1364 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1364;
  static const Upgrade UPGRADE_SOCKET_AM4 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_AM4;
  static const Upgrade UPGRADE_SOCKET_LGA1151 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA1151;
  static const Upgrade UPGRADE_SOCKET_BGA1356 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1356;
  static const Upgrade UPGRADE_SOCKET_BGA1440 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1440;
  static const Upgrade UPGRADE_SOCKET_BGA1515 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_BGA1515;
  static const Upgrade UPGRADE_SOCKET_LGA3647_1 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_LGA3647_1;
  static const Upgrade UPGRADE_SOCKET_SP3 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_SP3;
  static const Upgrade UPGRADE_SOCKET_SP3_R2 =
    DmiProcessors_Upgrade_UPGRADE_SOCKET_SP3_R2;
  static inline bool Upgrade_IsValid(int value) {
    return DmiProcessors_Upgrade_IsValid(value);
  }
  static const Upgrade Upgrade_MIN =
    DmiProcessors_Upgrade_Upgrade_MIN;
  static const Upgrade Upgrade_MAX =
    DmiProcessors_Upgrade_Upgrade_MAX;
  static const int Upgrade_ARRAYSIZE =
    DmiProcessors_Upgrade_Upgrade_ARRAYSIZE;

  typedef DmiProcessors_Characteristics Characteristics;
  static const Characteristics CHARACTERISTIC_NONE =
    DmiProcessors_Characteristics_CHARACTERISTIC_NONE;
  static const Characteristics CHARACTERISTIC_64BIT_CAPABLE =
    DmiProcessors_Characteristics_CHARACTERISTIC_64BIT_CAPABLE;
  static const Characteristics CHARACTERISTIC_MULTI_CORE =
    DmiProcessors_Characteristics_CHARACTERISTIC_MULTI_CORE;
  static const Characteristics CHARACTERISTIC_HARDWARE_THREAD =
    DmiProcessors_Characteristics_CHARACTERISTIC_HARDWARE_THREAD;
  static const Characteristics CHARACTERISTIC_EXECUTE_PROTECTION =
    DmiProcessors_Characteristics_CHARACTERISTIC_EXECUTE_PROTECTION;
  static const Characteristics CHARACTERISTIC_ENHANCED_VIRTUALIZATION =
    DmiProcessors_Characteristics_CHARACTERISTIC_ENHANCED_VIRTUALIZATION;
  static const Characteristics CHARACTERISTIC_POWER_CONTROL =
    DmiProcessors_Characteristics_CHARACTERISTIC_POWER_CONTROL;
  static inline bool Characteristics_IsValid(int value) {
    return DmiProcessors_Characteristics_IsValid(value);
  }
  static const Characteristics Characteristics_MIN =
    DmiProcessors_Characteristics_Characteristics_MIN;
  static const Characteristics Characteristics_MAX =
    DmiProcessors_Characteristics_Characteristics_MAX;
  static const int Characteristics_ARRAYSIZE =
    DmiProcessors_Characteristics_Characteristics_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiProcessors.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiProcessors_Item& item(int index) const;
  ::aspia::proto::DmiProcessors_Item* mutable_item(int index);
  ::aspia::proto::DmiProcessors_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiProcessors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiProcessorsImpl();
};
// -------------------------------------------------------------------

class DmiMemoryDevices_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiMemoryDevices.Item) */ {
 public:
  DmiMemoryDevices_Item();
  virtual ~DmiMemoryDevices_Item();

  DmiMemoryDevices_Item(const DmiMemoryDevices_Item& from);

  inline DmiMemoryDevices_Item& operator=(const DmiMemoryDevices_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiMemoryDevices_Item(DmiMemoryDevices_Item&& from) noexcept
    : DmiMemoryDevices_Item() {
    *this = ::std::move(from);
  }

  inline DmiMemoryDevices_Item& operator=(DmiMemoryDevices_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiMemoryDevices_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiMemoryDevices_Item* internal_default_instance() {
    return reinterpret_cast<const DmiMemoryDevices_Item*>(
               &_DmiMemoryDevices_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(DmiMemoryDevices_Item* other);
  friend void swap(DmiMemoryDevices_Item& a, DmiMemoryDevices_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiMemoryDevices_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiMemoryDevices_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiMemoryDevices_Item& from);
  void MergeFrom(const DmiMemoryDevices_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiMemoryDevices_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device_locator = 1;
  void clear_device_locator();
  static const int kDeviceLocatorFieldNumber = 1;
  const ::std::string& device_locator() const;
  void set_device_locator(const ::std::string& value);
  #if LANG_CXX11
  void set_device_locator(::std::string&& value);
  #endif
  void set_device_locator(const char* value);
  void set_device_locator(const char* value, size_t size);
  ::std::string* mutable_device_locator();
  ::std::string* release_device_locator();
  void set_allocated_device_locator(::std::string* device_locator);

  // string serial_number = 6;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 6;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string part_number = 7;
  void clear_part_number();
  static const int kPartNumberFieldNumber = 7;
  const ::std::string& part_number() const;
  void set_part_number(const ::std::string& value);
  #if LANG_CXX11
  void set_part_number(::std::string&& value);
  #endif
  void set_part_number(const char* value);
  void set_part_number(const char* value, size_t size);
  ::std::string* mutable_part_number();
  ::std::string* release_part_number();
  void set_allocated_part_number(::std::string* part_number);

  // string manufactorer = 8;
  void clear_manufactorer();
  static const int kManufactorerFieldNumber = 8;
  const ::std::string& manufactorer() const;
  void set_manufactorer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufactorer(::std::string&& value);
  #endif
  void set_manufactorer(const char* value);
  void set_manufactorer(const char* value, size_t size);
  ::std::string* mutable_manufactorer();
  ::std::string* release_manufactorer();
  void set_allocated_manufactorer(::std::string* manufactorer);

  // string bank = 9;
  void clear_bank();
  static const int kBankFieldNumber = 9;
  const ::std::string& bank() const;
  void set_bank(const ::std::string& value);
  #if LANG_CXX11
  void set_bank(::std::string&& value);
  #endif
  void set_bank(const char* value);
  void set_bank(const char* value, size_t size);
  ::std::string* mutable_bank();
  ::std::string* release_bank();
  void set_allocated_bank(::std::string* bank);

  // int32 size = 2;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // .aspia.proto.DmiMemoryDevices.Type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::aspia::proto::DmiMemoryDevices_Type type() const;
  void set_type(::aspia::proto::DmiMemoryDevices_Type value);

  // int32 speed = 4;
  void clear_speed();
  static const int kSpeedFieldNumber = 4;
  ::google::protobuf::int32 speed() const;
  void set_speed(::google::protobuf::int32 value);

  // .aspia.proto.DmiMemoryDevices.FormFactor form_factor = 5;
  void clear_form_factor();
  static const int kFormFactorFieldNumber = 5;
  ::aspia::proto::DmiMemoryDevices_FormFactor form_factor() const;
  void set_form_factor(::aspia::proto::DmiMemoryDevices_FormFactor value);

  // int32 total_width = 10;
  void clear_total_width();
  static const int kTotalWidthFieldNumber = 10;
  ::google::protobuf::int32 total_width() const;
  void set_total_width(::google::protobuf::int32 value);

  // int32 data_width = 11;
  void clear_data_width();
  static const int kDataWidthFieldNumber = 11;
  ::google::protobuf::int32 data_width() const;
  void set_data_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiMemoryDevices.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_locator_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr part_number_;
  ::google::protobuf::internal::ArenaStringPtr manufactorer_;
  ::google::protobuf::internal::ArenaStringPtr bank_;
  ::google::protobuf::int32 size_;
  int type_;
  ::google::protobuf::int32 speed_;
  int form_factor_;
  ::google::protobuf::int32 total_width_;
  ::google::protobuf::int32 data_width_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiMemoryDevices_ItemImpl();
};
// -------------------------------------------------------------------

class DmiMemoryDevices : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiMemoryDevices) */ {
 public:
  DmiMemoryDevices();
  virtual ~DmiMemoryDevices();

  DmiMemoryDevices(const DmiMemoryDevices& from);

  inline DmiMemoryDevices& operator=(const DmiMemoryDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiMemoryDevices(DmiMemoryDevices&& from) noexcept
    : DmiMemoryDevices() {
    *this = ::std::move(from);
  }

  inline DmiMemoryDevices& operator=(DmiMemoryDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiMemoryDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiMemoryDevices* internal_default_instance() {
    return reinterpret_cast<const DmiMemoryDevices*>(
               &_DmiMemoryDevices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DmiMemoryDevices* other);
  friend void swap(DmiMemoryDevices& a, DmiMemoryDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiMemoryDevices* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiMemoryDevices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiMemoryDevices& from);
  void MergeFrom(const DmiMemoryDevices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiMemoryDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiMemoryDevices_Item Item;

  typedef DmiMemoryDevices_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiMemoryDevices_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiMemoryDevices_Type_TYPE_OTHER;
  static const Type TYPE_DRAM =
    DmiMemoryDevices_Type_TYPE_DRAM;
  static const Type TYPE_EDRAM =
    DmiMemoryDevices_Type_TYPE_EDRAM;
  static const Type TYPE_VRAM =
    DmiMemoryDevices_Type_TYPE_VRAM;
  static const Type TYPE_SRAM =
    DmiMemoryDevices_Type_TYPE_SRAM;
  static const Type TYPE_RAM =
    DmiMemoryDevices_Type_TYPE_RAM;
  static const Type TYPE_ROM =
    DmiMemoryDevices_Type_TYPE_ROM;
  static const Type TYPE_FLASH =
    DmiMemoryDevices_Type_TYPE_FLASH;
  static const Type TYPE_EEPROM =
    DmiMemoryDevices_Type_TYPE_EEPROM;
  static const Type TYPE_FEPROM =
    DmiMemoryDevices_Type_TYPE_FEPROM;
  static const Type TYPE_EPROM =
    DmiMemoryDevices_Type_TYPE_EPROM;
  static const Type TYPE_CDRAM =
    DmiMemoryDevices_Type_TYPE_CDRAM;
  static const Type TYPE_3DRAM =
    DmiMemoryDevices_Type_TYPE_3DRAM;
  static const Type TYPE_SDRAM =
    DmiMemoryDevices_Type_TYPE_SDRAM;
  static const Type TYPE_SGRAM =
    DmiMemoryDevices_Type_TYPE_SGRAM;
  static const Type TYPE_RDRAM =
    DmiMemoryDevices_Type_TYPE_RDRAM;
  static const Type TYPE_DDR =
    DmiMemoryDevices_Type_TYPE_DDR;
  static const Type TYPE_DDR2 =
    DmiMemoryDevices_Type_TYPE_DDR2;
  static const Type TYPE_DDR2_FB_DIMM =
    DmiMemoryDevices_Type_TYPE_DDR2_FB_DIMM;
  static const Type TYPE_DDR3 =
    DmiMemoryDevices_Type_TYPE_DDR3;
  static const Type TYPE_FBD2 =
    DmiMemoryDevices_Type_TYPE_FBD2;
  static const Type TYPE_DDR4 =
    DmiMemoryDevices_Type_TYPE_DDR4;
  static const Type TYPE_LPDDR =
    DmiMemoryDevices_Type_TYPE_LPDDR;
  static const Type TYPE_LPDDR2 =
    DmiMemoryDevices_Type_TYPE_LPDDR2;
  static const Type TYPE_LPDDR3 =
    DmiMemoryDevices_Type_TYPE_LPDDR3;
  static const Type TYPE_LPDDR4 =
    DmiMemoryDevices_Type_TYPE_LPDDR4;
  static inline bool Type_IsValid(int value) {
    return DmiMemoryDevices_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiMemoryDevices_Type_Type_MIN;
  static const Type Type_MAX =
    DmiMemoryDevices_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiMemoryDevices_Type_Type_ARRAYSIZE;

  typedef DmiMemoryDevices_FormFactor FormFactor;
  static const FormFactor FORM_FACTOR_UNKNOWN =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_UNKNOWN;
  static const FormFactor FORM_FACTOR_OTHER =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_OTHER;
  static const FormFactor FORM_FACTOR_SIMM =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_SIMM;
  static const FormFactor FORM_FACTOR_SIP =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_SIP;
  static const FormFactor FORM_FACTOR_CHIP =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_CHIP;
  static const FormFactor FORM_FACTOR_DIP =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_DIP;
  static const FormFactor FORM_FACTOR_ZIP =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_ZIP;
  static const FormFactor FORM_FACTOR_PROPRIETARY_CARD =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_PROPRIETARY_CARD;
  static const FormFactor FORM_FACTOR_DIMM =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_DIMM;
  static const FormFactor FORM_FACTOR_TSOP =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_TSOP;
  static const FormFactor FORM_FACTOR_ROW_OF_CHIPS =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_ROW_OF_CHIPS;
  static const FormFactor FORM_FACTOR_RIMM =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_RIMM;
  static const FormFactor FORM_FACTOR_SODIMM =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_SODIMM;
  static const FormFactor FORM_FACTOR_SRIMM =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_SRIMM;
  static const FormFactor FORM_FACTOR_FB_DIMM =
    DmiMemoryDevices_FormFactor_FORM_FACTOR_FB_DIMM;
  static inline bool FormFactor_IsValid(int value) {
    return DmiMemoryDevices_FormFactor_IsValid(value);
  }
  static const FormFactor FormFactor_MIN =
    DmiMemoryDevices_FormFactor_FormFactor_MIN;
  static const FormFactor FormFactor_MAX =
    DmiMemoryDevices_FormFactor_FormFactor_MAX;
  static const int FormFactor_ARRAYSIZE =
    DmiMemoryDevices_FormFactor_FormFactor_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiMemoryDevices.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiMemoryDevices_Item& item(int index) const;
  ::aspia::proto::DmiMemoryDevices_Item* mutable_item(int index);
  ::aspia::proto::DmiMemoryDevices_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiMemoryDevices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiMemoryDevicesImpl();
};
// -------------------------------------------------------------------

class DmiSystemSlots_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiSystemSlots.Item) */ {
 public:
  DmiSystemSlots_Item();
  virtual ~DmiSystemSlots_Item();

  DmiSystemSlots_Item(const DmiSystemSlots_Item& from);

  inline DmiSystemSlots_Item& operator=(const DmiSystemSlots_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiSystemSlots_Item(DmiSystemSlots_Item&& from) noexcept
    : DmiSystemSlots_Item() {
    *this = ::std::move(from);
  }

  inline DmiSystemSlots_Item& operator=(DmiSystemSlots_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiSystemSlots_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiSystemSlots_Item* internal_default_instance() {
    return reinterpret_cast<const DmiSystemSlots_Item*>(
               &_DmiSystemSlots_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(DmiSystemSlots_Item* other);
  friend void swap(DmiSystemSlots_Item& a, DmiSystemSlots_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiSystemSlots_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiSystemSlots_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiSystemSlots_Item& from);
  void MergeFrom(const DmiSystemSlots_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiSystemSlots_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string slot_designation = 1;
  void clear_slot_designation();
  static const int kSlotDesignationFieldNumber = 1;
  const ::std::string& slot_designation() const;
  void set_slot_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_slot_designation(::std::string&& value);
  #endif
  void set_slot_designation(const char* value);
  void set_slot_designation(const char* value, size_t size);
  ::std::string* mutable_slot_designation();
  ::std::string* release_slot_designation();
  void set_allocated_slot_designation(::std::string* slot_designation);

  // .aspia.proto.DmiSystemSlots.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::aspia::proto::DmiSystemSlots_Type type() const;
  void set_type(::aspia::proto::DmiSystemSlots_Type value);

  // .aspia.proto.DmiSystemSlots.Usage usage = 3;
  void clear_usage();
  static const int kUsageFieldNumber = 3;
  ::aspia::proto::DmiSystemSlots_Usage usage() const;
  void set_usage(::aspia::proto::DmiSystemSlots_Usage value);

  // .aspia.proto.DmiSystemSlots.BusWidth bus_width = 4;
  void clear_bus_width();
  static const int kBusWidthFieldNumber = 4;
  ::aspia::proto::DmiSystemSlots_BusWidth bus_width() const;
  void set_bus_width(::aspia::proto::DmiSystemSlots_BusWidth value);

  // .aspia.proto.DmiSystemSlots.Length length = 5;
  void clear_length();
  static const int kLengthFieldNumber = 5;
  ::aspia::proto::DmiSystemSlots_Length length() const;
  void set_length(::aspia::proto::DmiSystemSlots_Length value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiSystemSlots.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr slot_designation_;
  int type_;
  int usage_;
  int bus_width_;
  int length_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiSystemSlots_ItemImpl();
};
// -------------------------------------------------------------------

class DmiSystemSlots : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiSystemSlots) */ {
 public:
  DmiSystemSlots();
  virtual ~DmiSystemSlots();

  DmiSystemSlots(const DmiSystemSlots& from);

  inline DmiSystemSlots& operator=(const DmiSystemSlots& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiSystemSlots(DmiSystemSlots&& from) noexcept
    : DmiSystemSlots() {
    *this = ::std::move(from);
  }

  inline DmiSystemSlots& operator=(DmiSystemSlots&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiSystemSlots& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiSystemSlots* internal_default_instance() {
    return reinterpret_cast<const DmiSystemSlots*>(
               &_DmiSystemSlots_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(DmiSystemSlots* other);
  friend void swap(DmiSystemSlots& a, DmiSystemSlots& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiSystemSlots* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiSystemSlots* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiSystemSlots& from);
  void MergeFrom(const DmiSystemSlots& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiSystemSlots* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiSystemSlots_Item Item;

  typedef DmiSystemSlots_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiSystemSlots_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiSystemSlots_Type_TYPE_OTHER;
  static const Type TYPE_ISA =
    DmiSystemSlots_Type_TYPE_ISA;
  static const Type TYPE_MCA =
    DmiSystemSlots_Type_TYPE_MCA;
  static const Type TYPE_EISA =
    DmiSystemSlots_Type_TYPE_EISA;
  static const Type TYPE_PCI =
    DmiSystemSlots_Type_TYPE_PCI;
  static const Type TYPE_PC_CARD =
    DmiSystemSlots_Type_TYPE_PC_CARD;
  static const Type TYPE_VLB =
    DmiSystemSlots_Type_TYPE_VLB;
  static const Type TYPE_PROPRIETARY =
    DmiSystemSlots_Type_TYPE_PROPRIETARY;
  static const Type TYPE_PROCESSOR_CARD =
    DmiSystemSlots_Type_TYPE_PROCESSOR_CARD;
  static const Type TYPE_PROPRIETARY_MEMORY_CARD =
    DmiSystemSlots_Type_TYPE_PROPRIETARY_MEMORY_CARD;
  static const Type TYPE_IO_RISER_CARD =
    DmiSystemSlots_Type_TYPE_IO_RISER_CARD;
  static const Type TYPE_NUBUS =
    DmiSystemSlots_Type_TYPE_NUBUS;
  static const Type TYPE_PCI_66 =
    DmiSystemSlots_Type_TYPE_PCI_66;
  static const Type TYPE_AGP =
    DmiSystemSlots_Type_TYPE_AGP;
  static const Type TYPE_AGP_2X =
    DmiSystemSlots_Type_TYPE_AGP_2X;
  static const Type TYPE_AGP_4X =
    DmiSystemSlots_Type_TYPE_AGP_4X;
  static const Type TYPE_PCI_X =
    DmiSystemSlots_Type_TYPE_PCI_X;
  static const Type TYPE_AGP_8X =
    DmiSystemSlots_Type_TYPE_AGP_8X;
  static const Type TYPE_M2_SOCKET_1DP =
    DmiSystemSlots_Type_TYPE_M2_SOCKET_1DP;
  static const Type TYPE_M2_SOCKET_1SD =
    DmiSystemSlots_Type_TYPE_M2_SOCKET_1SD;
  static const Type TYPE_M2_SOCKET_2 =
    DmiSystemSlots_Type_TYPE_M2_SOCKET_2;
  static const Type TYPE_M2_SOCKET_3 =
    DmiSystemSlots_Type_TYPE_M2_SOCKET_3;
  static const Type TYPE_MXM_TYPE_I =
    DmiSystemSlots_Type_TYPE_MXM_TYPE_I;
  static const Type TYPE_MXM_TYPE_II =
    DmiSystemSlots_Type_TYPE_MXM_TYPE_II;
  static const Type TYPE_MXM_TYPE_III =
    DmiSystemSlots_Type_TYPE_MXM_TYPE_III;
  static const Type TYPE_MXM_TYPE_III_HE =
    DmiSystemSlots_Type_TYPE_MXM_TYPE_III_HE;
  static const Type TYPE_MXM_TYPE_IV =
    DmiSystemSlots_Type_TYPE_MXM_TYPE_IV;
  static const Type TYPE_MXM_30_TYPE_A =
    DmiSystemSlots_Type_TYPE_MXM_30_TYPE_A;
  static const Type TYPE_MXM_30_TYPE_B =
    DmiSystemSlots_Type_TYPE_MXM_30_TYPE_B;
  static const Type TYPE_PCI_EXPRESS_2_SFF_8639 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_SFF_8639;
  static const Type TYPE_PCI_EXPRESS_3_SFF_8639 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_SFF_8639;
  static const Type TYPE_PCI_EXPRESS_MINI_52PIN_WITH_BOTTOM_SIDE =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_MINI_52PIN_WITH_BOTTOM_SIDE;
  static const Type TYPE_PCI_EXPRESS_MINI_52PIN =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_MINI_52PIN;
  static const Type TYPE_PCI_EXPRESS_MINI_76PIN =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_MINI_76PIN;
  static const Type TYPE_PC98_C20 =
    DmiSystemSlots_Type_TYPE_PC98_C20;
  static const Type TYPE_PC98_C24 =
    DmiSystemSlots_Type_TYPE_PC98_C24;
  static const Type TYPE_PC98_E =
    DmiSystemSlots_Type_TYPE_PC98_E;
  static const Type TYPE_PC98_LOCAL_BUS =
    DmiSystemSlots_Type_TYPE_PC98_LOCAL_BUS;
  static const Type TYPE_PC98_CARD =
    DmiSystemSlots_Type_TYPE_PC98_CARD;
  static const Type TYPE_PCI_EXPRESS =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS;
  static const Type TYPE_PCI_EXPRESS_X1 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X1;
  static const Type TYPE_PCI_EXPRESS_X2 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X2;
  static const Type TYPE_PCI_EXPRESS_X4 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X4;
  static const Type TYPE_PCI_EXPRESS_X8 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X8;
  static const Type TYPE_PCI_EXPRESS_X16 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_X16;
  static const Type TYPE_PCI_EXPRESS_2 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2;
  static const Type TYPE_PCI_EXPRESS_2_X1 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X1;
  static const Type TYPE_PCI_EXPRESS_2_X2 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X2;
  static const Type TYPE_PCI_EXPRESS_2_X4 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X4;
  static const Type TYPE_PCI_EXPRESS_2_X8 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X8;
  static const Type TYPE_PCI_EXPRESS_2_X16 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_2_X16;
  static const Type TYPE_PCI_EXPRESS_3 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3;
  static const Type TYPE_PCI_EXPRESS_3_X1 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X1;
  static const Type TYPE_PCI_EXPRESS_3_X2 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X2;
  static const Type TYPE_PCI_EXPRESS_3_X4 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X4;
  static const Type TYPE_PCI_EXPRESS_3_X8 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X8;
  static const Type TYPE_PCI_EXPRESS_3_X16 =
    DmiSystemSlots_Type_TYPE_PCI_EXPRESS_3_X16;
  static inline bool Type_IsValid(int value) {
    return DmiSystemSlots_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiSystemSlots_Type_Type_MIN;
  static const Type Type_MAX =
    DmiSystemSlots_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiSystemSlots_Type_Type_ARRAYSIZE;

  typedef DmiSystemSlots_Usage Usage;
  static const Usage USAGE_UNKNOWN =
    DmiSystemSlots_Usage_USAGE_UNKNOWN;
  static const Usage USAGE_OTHER =
    DmiSystemSlots_Usage_USAGE_OTHER;
  static const Usage USAGE_AVAILABLE =
    DmiSystemSlots_Usage_USAGE_AVAILABLE;
  static const Usage USAGE_IN_USE =
    DmiSystemSlots_Usage_USAGE_IN_USE;
  static inline bool Usage_IsValid(int value) {
    return DmiSystemSlots_Usage_IsValid(value);
  }
  static const Usage Usage_MIN =
    DmiSystemSlots_Usage_Usage_MIN;
  static const Usage Usage_MAX =
    DmiSystemSlots_Usage_Usage_MAX;
  static const int Usage_ARRAYSIZE =
    DmiSystemSlots_Usage_Usage_ARRAYSIZE;

  typedef DmiSystemSlots_BusWidth BusWidth;
  static const BusWidth BUS_WIDTH_UNKNOWN =
    DmiSystemSlots_BusWidth_BUS_WIDTH_UNKNOWN;
  static const BusWidth BUS_WIDTH_OTHER =
    DmiSystemSlots_BusWidth_BUS_WIDTH_OTHER;
  static const BusWidth BUS_WIDTH_8_BIT =
    DmiSystemSlots_BusWidth_BUS_WIDTH_8_BIT;
  static const BusWidth BUS_WIDTH_16_BIT =
    DmiSystemSlots_BusWidth_BUS_WIDTH_16_BIT;
  static const BusWidth BUS_WIDTH_32_BIT =
    DmiSystemSlots_BusWidth_BUS_WIDTH_32_BIT;
  static const BusWidth BUS_WIDTH_64_BIT =
    DmiSystemSlots_BusWidth_BUS_WIDTH_64_BIT;
  static const BusWidth BUS_WIDTH_128_BIT =
    DmiSystemSlots_BusWidth_BUS_WIDTH_128_BIT;
  static const BusWidth BUS_WIDTH_X1 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X1;
  static const BusWidth BUS_WIDTH_X2 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X2;
  static const BusWidth BUS_WIDTH_X4 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X4;
  static const BusWidth BUS_WIDTH_X8 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X8;
  static const BusWidth BUS_WIDTH_X12 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X12;
  static const BusWidth BUS_WIDTH_X16 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X16;
  static const BusWidth BUS_WIDTH_X32 =
    DmiSystemSlots_BusWidth_BUS_WIDTH_X32;
  static inline bool BusWidth_IsValid(int value) {
    return DmiSystemSlots_BusWidth_IsValid(value);
  }
  static const BusWidth BusWidth_MIN =
    DmiSystemSlots_BusWidth_BusWidth_MIN;
  static const BusWidth BusWidth_MAX =
    DmiSystemSlots_BusWidth_BusWidth_MAX;
  static const int BusWidth_ARRAYSIZE =
    DmiSystemSlots_BusWidth_BusWidth_ARRAYSIZE;

  typedef DmiSystemSlots_Length Length;
  static const Length LENGTH_UNKNOWN =
    DmiSystemSlots_Length_LENGTH_UNKNOWN;
  static const Length LENGTH_OTHER =
    DmiSystemSlots_Length_LENGTH_OTHER;
  static const Length LENGTH_SHORT =
    DmiSystemSlots_Length_LENGTH_SHORT;
  static const Length LENGTH_LONG =
    DmiSystemSlots_Length_LENGTH_LONG;
  static inline bool Length_IsValid(int value) {
    return DmiSystemSlots_Length_IsValid(value);
  }
  static const Length Length_MIN =
    DmiSystemSlots_Length_Length_MIN;
  static const Length Length_MAX =
    DmiSystemSlots_Length_Length_MAX;
  static const int Length_ARRAYSIZE =
    DmiSystemSlots_Length_Length_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiSystemSlots.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiSystemSlots_Item& item(int index) const;
  ::aspia::proto::DmiSystemSlots_Item* mutable_item(int index);
  ::aspia::proto::DmiSystemSlots_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiSystemSlots)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiSystemSlotsImpl();
};
// -------------------------------------------------------------------

class DmiPortConnectors_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortConnectors.Item) */ {
 public:
  DmiPortConnectors_Item();
  virtual ~DmiPortConnectors_Item();

  DmiPortConnectors_Item(const DmiPortConnectors_Item& from);

  inline DmiPortConnectors_Item& operator=(const DmiPortConnectors_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortConnectors_Item(DmiPortConnectors_Item&& from) noexcept
    : DmiPortConnectors_Item() {
    *this = ::std::move(from);
  }

  inline DmiPortConnectors_Item& operator=(DmiPortConnectors_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortConnectors_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortConnectors_Item* internal_default_instance() {
    return reinterpret_cast<const DmiPortConnectors_Item*>(
               &_DmiPortConnectors_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(DmiPortConnectors_Item* other);
  friend void swap(DmiPortConnectors_Item& a, DmiPortConnectors_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortConnectors_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortConnectors_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortConnectors_Item& from);
  void MergeFrom(const DmiPortConnectors_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortConnectors_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string internal_designation = 1;
  void clear_internal_designation();
  static const int kInternalDesignationFieldNumber = 1;
  const ::std::string& internal_designation() const;
  void set_internal_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_internal_designation(::std::string&& value);
  #endif
  void set_internal_designation(const char* value);
  void set_internal_designation(const char* value, size_t size);
  ::std::string* mutable_internal_designation();
  ::std::string* release_internal_designation();
  void set_allocated_internal_designation(::std::string* internal_designation);

  // string external_designation = 2;
  void clear_external_designation();
  static const int kExternalDesignationFieldNumber = 2;
  const ::std::string& external_designation() const;
  void set_external_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_external_designation(::std::string&& value);
  #endif
  void set_external_designation(const char* value);
  void set_external_designation(const char* value, size_t size);
  ::std::string* mutable_external_designation();
  ::std::string* release_external_designation();
  void set_allocated_external_designation(::std::string* external_designation);

  // .aspia.proto.DmiPortConnectors.Type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::aspia::proto::DmiPortConnectors_Type type() const;
  void set_type(::aspia::proto::DmiPortConnectors_Type value);

  // .aspia.proto.DmiPortConnectors.ConnectorType internal_connector_type = 4;
  void clear_internal_connector_type();
  static const int kInternalConnectorTypeFieldNumber = 4;
  ::aspia::proto::DmiPortConnectors_ConnectorType internal_connector_type() const;
  void set_internal_connector_type(::aspia::proto::DmiPortConnectors_ConnectorType value);

  // .aspia.proto.DmiPortConnectors.ConnectorType external_connector_type = 5;
  void clear_external_connector_type();
  static const int kExternalConnectorTypeFieldNumber = 5;
  ::aspia::proto::DmiPortConnectors_ConnectorType external_connector_type() const;
  void set_external_connector_type(::aspia::proto::DmiPortConnectors_ConnectorType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortConnectors.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr internal_designation_;
  ::google::protobuf::internal::ArenaStringPtr external_designation_;
  int type_;
  int internal_connector_type_;
  int external_connector_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortConnectors_ItemImpl();
};
// -------------------------------------------------------------------

class DmiPortConnectors : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortConnectors) */ {
 public:
  DmiPortConnectors();
  virtual ~DmiPortConnectors();

  DmiPortConnectors(const DmiPortConnectors& from);

  inline DmiPortConnectors& operator=(const DmiPortConnectors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortConnectors(DmiPortConnectors&& from) noexcept
    : DmiPortConnectors() {
    *this = ::std::move(from);
  }

  inline DmiPortConnectors& operator=(DmiPortConnectors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortConnectors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortConnectors* internal_default_instance() {
    return reinterpret_cast<const DmiPortConnectors*>(
               &_DmiPortConnectors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(DmiPortConnectors* other);
  friend void swap(DmiPortConnectors& a, DmiPortConnectors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortConnectors* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortConnectors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortConnectors& from);
  void MergeFrom(const DmiPortConnectors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortConnectors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiPortConnectors_Item Item;

  typedef DmiPortConnectors_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiPortConnectors_Type_TYPE_UNKNOWN;
  static const Type TYPE_NONE =
    DmiPortConnectors_Type_TYPE_NONE;
  static const Type TYPE_PARALLEL_PORT_XT_AT_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_XT_AT_COMPATIBLE;
  static const Type TYPE_PARALLEL_PORT_PS_2 =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_PS_2;
  static const Type TYPE_PARALLEL_PORT_ECP =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_ECP;
  static const Type TYPE_PARALLEL_PORT_EPP =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_EPP;
  static const Type TYPE_PARALLEL_PORT_ECP_EPP =
    DmiPortConnectors_Type_TYPE_PARALLEL_PORT_ECP_EPP;
  static const Type TYPE_SERIAL_PORT_XT_AT_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_SERIAL_PORT_XT_AT_COMPATIBLE;
  static const Type TYPE_SERIAL_PORT_16450_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_SERIAL_PORT_16450_COMPATIBLE;
  static const Type TYPE_SERIAL_PORT_16550_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_SERIAL_PORT_16550_COMPATIBLE;
  static const Type TYPE_SERIAL_PORT_16550A_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_SERIAL_PORT_16550A_COMPATIBLE;
  static const Type TYPE_SCSI_PORT =
    DmiPortConnectors_Type_TYPE_SCSI_PORT;
  static const Type TYPE_MIDI_PORT =
    DmiPortConnectors_Type_TYPE_MIDI_PORT;
  static const Type TYPE_JOYSTICK_PORT =
    DmiPortConnectors_Type_TYPE_JOYSTICK_PORT;
  static const Type TYPE_KEYBOARD_PORT =
    DmiPortConnectors_Type_TYPE_KEYBOARD_PORT;
  static const Type TYPE_MOUSE_PORT =
    DmiPortConnectors_Type_TYPE_MOUSE_PORT;
  static const Type TYPE_SSA_SCSI =
    DmiPortConnectors_Type_TYPE_SSA_SCSI;
  static const Type TYPE_USB =
    DmiPortConnectors_Type_TYPE_USB;
  static const Type TYPE_FIREWIRE =
    DmiPortConnectors_Type_TYPE_FIREWIRE;
  static const Type TYPE_PCMCIA_TYPE_I =
    DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_I;
  static const Type TYPE_PCMCIA_TYPE_II =
    DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_II;
  static const Type TYPE_PCMCIA_TYPE_III =
    DmiPortConnectors_Type_TYPE_PCMCIA_TYPE_III;
  static const Type TYPE_CARDBUS =
    DmiPortConnectors_Type_TYPE_CARDBUS;
  static const Type TYPE_ACCESS_BUS_PORT =
    DmiPortConnectors_Type_TYPE_ACCESS_BUS_PORT;
  static const Type TYPE_SCSI_II =
    DmiPortConnectors_Type_TYPE_SCSI_II;
  static const Type TYPE_SCSI_WIDE =
    DmiPortConnectors_Type_TYPE_SCSI_WIDE;
  static const Type TYPE_PC_98 =
    DmiPortConnectors_Type_TYPE_PC_98;
  static const Type TYPE_PC_98_HIRESO =
    DmiPortConnectors_Type_TYPE_PC_98_HIRESO;
  static const Type TYPE_PC_H98 =
    DmiPortConnectors_Type_TYPE_PC_H98;
  static const Type TYPE_VIDEO_PORT =
    DmiPortConnectors_Type_TYPE_VIDEO_PORT;
  static const Type TYPE_AUDIO_PORT =
    DmiPortConnectors_Type_TYPE_AUDIO_PORT;
  static const Type TYPE_MODEM_PORT =
    DmiPortConnectors_Type_TYPE_MODEM_PORT;
  static const Type TYPE_NETWORK_PORT =
    DmiPortConnectors_Type_TYPE_NETWORK_PORT;
  static const Type TYPE_SATA =
    DmiPortConnectors_Type_TYPE_SATA;
  static const Type TYPE_SAS =
    DmiPortConnectors_Type_TYPE_SAS;
  static const Type TYPE_8251_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_8251_COMPATIBLE;
  static const Type TYPE_8251_FIFO_COMPATIBLE =
    DmiPortConnectors_Type_TYPE_8251_FIFO_COMPATIBLE;
  static inline bool Type_IsValid(int value) {
    return DmiPortConnectors_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiPortConnectors_Type_Type_MIN;
  static const Type Type_MAX =
    DmiPortConnectors_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiPortConnectors_Type_Type_ARRAYSIZE;

  typedef DmiPortConnectors_ConnectorType ConnectorType;
  static const ConnectorType CONNECTOR_TYPE_UNKNOWN =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_UNKNOWN;
  static const ConnectorType CONNECTOR_TYPE_NONE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_NONE;
  static const ConnectorType CONNECTOR_TYPE_OTHER =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_OTHER;
  static const ConnectorType CONNECTOR_TYPE_CENTRONICS =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CENTRONICS;
  static const ConnectorType CONNECTOR_TYPE_MINI_CENTRONICS =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS;
  static const ConnectorType CONNECTOR_TYPE_PROPRIETARY =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PROPRIETARY;
  static const ConnectorType CONNECTOR_TYPE_DB_25_MALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_25_MALE;
  static const ConnectorType CONNECTOR_TYPE_DB_25_FEMALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_25_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_DB_15_MALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_15_MALE;
  static const ConnectorType CONNECTOR_TYPE_DB_15_FEMALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_15_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_DB_9_MALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_9_MALE;
  static const ConnectorType CONNECTOR_TYPE_DB_9_FEMALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_DB_9_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_RJ_11 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_RJ_11;
  static const ConnectorType CONNECTOR_TYPE_RJ_45 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_RJ_45;
  static const ConnectorType CONNECTOR_TYPE_50_PIN_MINISCSI =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_50_PIN_MINISCSI;
  static const ConnectorType CONNECTOR_TYPE_MINI_DIN =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_DIN;
  static const ConnectorType CONNECTOR_TYPE_MICRO_DIN =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MICRO_DIN;
  static const ConnectorType CONNECTOR_TYPE_PS_2 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PS_2;
  static const ConnectorType CONNECTOR_TYPE_INFRARED =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_INFRARED;
  static const ConnectorType CONNECTOR_TYPE_HP_HIL =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_HP_HIL;
  static const ConnectorType CONNECTOR_TYPE_ACCESS_BUS_USB =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ACCESS_BUS_USB;
  static const ConnectorType CONNECTOR_TYPE_SSA_SCSI =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_SSA_SCSI;
  static const ConnectorType CONNECTOR_TYPE_CIRCULAR_DIN_8_MALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_MALE;
  static const ConnectorType CONNECTOR_TYPE_CIRCULAR_DIN_8_FEMALE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_ONBOARD_IDE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_IDE;
  static const ConnectorType CONNECTOR_TYPE_ONBOARD_FLOPPY =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_FLOPPY;
  static const ConnectorType CONNECTOR_TYPE_9_PIN_DUAL_INLINE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_9_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_25_PIN_DUAL_INLINE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_25_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_50_PIN_DUAL_INLINE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_50_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_68_PIN_DUAL_INLINE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_68_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_ONBOARD_SOUND_INPUT_FROM_CDROM =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_ONBOARD_SOUND_INPUT_FROM_CDROM;
  static const ConnectorType CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_14 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_14;
  static const ConnectorType CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_26 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_26;
  static const ConnectorType CONNECTOR_TYPE_MINI_JACK =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_MINI_JACK;
  static const ConnectorType CONNECTOR_TYPE_BNC =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_BNC;
  static const ConnectorType CONNECTOR_TYPE_IEEE_1394 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_IEEE_1394;
  static const ConnectorType CONNECTOR_TYPE_SAS_SATE_PLUG_RECEPTACLE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_SAS_SATE_PLUG_RECEPTACLE;
  static const ConnectorType CONNECTOR_TYPE_PC_98 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98;
  static const ConnectorType CONNECTOR_TYPE_PC_98_HIRESO =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_HIRESO;
  static const ConnectorType CONNECTOR_TYPE_PC_H98 =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_H98;
  static const ConnectorType CONNECTOR_TYPE_PC_98_NOTE =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_NOTE;
  static const ConnectorType CONNECTOR_TYPE_PC_98_FULL =
    DmiPortConnectors_ConnectorType_CONNECTOR_TYPE_PC_98_FULL;
  static inline bool ConnectorType_IsValid(int value) {
    return DmiPortConnectors_ConnectorType_IsValid(value);
  }
  static const ConnectorType ConnectorType_MIN =
    DmiPortConnectors_ConnectorType_ConnectorType_MIN;
  static const ConnectorType ConnectorType_MAX =
    DmiPortConnectors_ConnectorType_ConnectorType_MAX;
  static const int ConnectorType_ARRAYSIZE =
    DmiPortConnectors_ConnectorType_ConnectorType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiPortConnectors.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiPortConnectors_Item& item(int index) const;
  ::aspia::proto::DmiPortConnectors_Item* mutable_item(int index);
  ::aspia::proto::DmiPortConnectors_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortConnectors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortConnectorsImpl();
};
// -------------------------------------------------------------------

class DmiOnBoardDevices_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiOnBoardDevices.Item) */ {
 public:
  DmiOnBoardDevices_Item();
  virtual ~DmiOnBoardDevices_Item();

  DmiOnBoardDevices_Item(const DmiOnBoardDevices_Item& from);

  inline DmiOnBoardDevices_Item& operator=(const DmiOnBoardDevices_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiOnBoardDevices_Item(DmiOnBoardDevices_Item&& from) noexcept
    : DmiOnBoardDevices_Item() {
    *this = ::std::move(from);
  }

  inline DmiOnBoardDevices_Item& operator=(DmiOnBoardDevices_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiOnBoardDevices_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiOnBoardDevices_Item* internal_default_instance() {
    return reinterpret_cast<const DmiOnBoardDevices_Item*>(
               &_DmiOnBoardDevices_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(DmiOnBoardDevices_Item* other);
  friend void swap(DmiOnBoardDevices_Item& a, DmiOnBoardDevices_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiOnBoardDevices_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiOnBoardDevices_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiOnBoardDevices_Item& from);
  void MergeFrom(const DmiOnBoardDevices_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiOnBoardDevices_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string description = 1;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .aspia.proto.DmiOnBoardDevices.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::aspia::proto::DmiOnBoardDevices_Type type() const;
  void set_type(::aspia::proto::DmiOnBoardDevices_Type value);

  // bool enabled = 3;
  void clear_enabled();
  static const int kEnabledFieldNumber = 3;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiOnBoardDevices.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  int type_;
  bool enabled_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiOnBoardDevices_ItemImpl();
};
// -------------------------------------------------------------------

class DmiOnBoardDevices : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiOnBoardDevices) */ {
 public:
  DmiOnBoardDevices();
  virtual ~DmiOnBoardDevices();

  DmiOnBoardDevices(const DmiOnBoardDevices& from);

  inline DmiOnBoardDevices& operator=(const DmiOnBoardDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiOnBoardDevices(DmiOnBoardDevices&& from) noexcept
    : DmiOnBoardDevices() {
    *this = ::std::move(from);
  }

  inline DmiOnBoardDevices& operator=(DmiOnBoardDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiOnBoardDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiOnBoardDevices* internal_default_instance() {
    return reinterpret_cast<const DmiOnBoardDevices*>(
               &_DmiOnBoardDevices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(DmiOnBoardDevices* other);
  friend void swap(DmiOnBoardDevices& a, DmiOnBoardDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiOnBoardDevices* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiOnBoardDevices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiOnBoardDevices& from);
  void MergeFrom(const DmiOnBoardDevices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiOnBoardDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiOnBoardDevices_Item Item;

  typedef DmiOnBoardDevices_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiOnBoardDevices_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiOnBoardDevices_Type_TYPE_OTHER;
  static const Type TYPE_VIDEO =
    DmiOnBoardDevices_Type_TYPE_VIDEO;
  static const Type TYPE_SCSI_CONTROLLER =
    DmiOnBoardDevices_Type_TYPE_SCSI_CONTROLLER;
  static const Type TYPE_ETHERNET =
    DmiOnBoardDevices_Type_TYPE_ETHERNET;
  static const Type TYPE_TOKEN_RING =
    DmiOnBoardDevices_Type_TYPE_TOKEN_RING;
  static const Type TYPE_SOUND =
    DmiOnBoardDevices_Type_TYPE_SOUND;
  static const Type TYPE_PATA_CONTROLLER =
    DmiOnBoardDevices_Type_TYPE_PATA_CONTROLLER;
  static const Type TYPE_SATA_CONTROLLER =
    DmiOnBoardDevices_Type_TYPE_SATA_CONTROLLER;
  static const Type TYPE_SAS_CONTROLLER =
    DmiOnBoardDevices_Type_TYPE_SAS_CONTROLLER;
  static inline bool Type_IsValid(int value) {
    return DmiOnBoardDevices_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiOnBoardDevices_Type_Type_MIN;
  static const Type Type_MAX =
    DmiOnBoardDevices_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiOnBoardDevices_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiOnBoardDevices.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiOnBoardDevices_Item& item(int index) const;
  ::aspia::proto::DmiOnBoardDevices_Item* mutable_item(int index);
  ::aspia::proto::DmiOnBoardDevices_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiOnBoardDevices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiOnBoardDevicesImpl();
};
// -------------------------------------------------------------------

class DmiPointingDevice_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPointingDevice.Item) */ {
 public:
  DmiPointingDevice_Item();
  virtual ~DmiPointingDevice_Item();

  DmiPointingDevice_Item(const DmiPointingDevice_Item& from);

  inline DmiPointingDevice_Item& operator=(const DmiPointingDevice_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPointingDevice_Item(DmiPointingDevice_Item&& from) noexcept
    : DmiPointingDevice_Item() {
    *this = ::std::move(from);
  }

  inline DmiPointingDevice_Item& operator=(DmiPointingDevice_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPointingDevice_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPointingDevice_Item* internal_default_instance() {
    return reinterpret_cast<const DmiPointingDevice_Item*>(
               &_DmiPointingDevice_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(DmiPointingDevice_Item* other);
  friend void swap(DmiPointingDevice_Item& a, DmiPointingDevice_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPointingDevice_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPointingDevice_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPointingDevice_Item& from);
  void MergeFrom(const DmiPointingDevice_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPointingDevice_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .aspia.proto.DmiPointingDevice.Type device_type = 1;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 1;
  ::aspia::proto::DmiPointingDevice_Type device_type() const;
  void set_device_type(::aspia::proto::DmiPointingDevice_Type value);

  // .aspia.proto.DmiPointingDevice.Interface device_interface = 2;
  void clear_device_interface();
  static const int kDeviceInterfaceFieldNumber = 2;
  ::aspia::proto::DmiPointingDevice_Interface device_interface() const;
  void set_device_interface(::aspia::proto::DmiPointingDevice_Interface value);

  // int32 button_count = 3;
  void clear_button_count();
  static const int kButtonCountFieldNumber = 3;
  ::google::protobuf::int32 button_count() const;
  void set_button_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPointingDevice.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int device_type_;
  int device_interface_;
  ::google::protobuf::int32 button_count_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPointingDevice_ItemImpl();
};
// -------------------------------------------------------------------

class DmiPointingDevice : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPointingDevice) */ {
 public:
  DmiPointingDevice();
  virtual ~DmiPointingDevice();

  DmiPointingDevice(const DmiPointingDevice& from);

  inline DmiPointingDevice& operator=(const DmiPointingDevice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPointingDevice(DmiPointingDevice&& from) noexcept
    : DmiPointingDevice() {
    *this = ::std::move(from);
  }

  inline DmiPointingDevice& operator=(DmiPointingDevice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPointingDevice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPointingDevice* internal_default_instance() {
    return reinterpret_cast<const DmiPointingDevice*>(
               &_DmiPointingDevice_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(DmiPointingDevice* other);
  friend void swap(DmiPointingDevice& a, DmiPointingDevice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPointingDevice* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPointingDevice* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPointingDevice& from);
  void MergeFrom(const DmiPointingDevice& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPointingDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiPointingDevice_Item Item;

  typedef DmiPointingDevice_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiPointingDevice_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    DmiPointingDevice_Type_TYPE_OTHER;
  static const Type TYPE_MOUSE =
    DmiPointingDevice_Type_TYPE_MOUSE;
  static const Type TYPE_TRACK_BALL =
    DmiPointingDevice_Type_TYPE_TRACK_BALL;
  static const Type TYPE_TRACK_POINT =
    DmiPointingDevice_Type_TYPE_TRACK_POINT;
  static const Type TYPE_GLIDE_POINT =
    DmiPointingDevice_Type_TYPE_GLIDE_POINT;
  static const Type TYPE_TOUCH_PAD =
    DmiPointingDevice_Type_TYPE_TOUCH_PAD;
  static const Type TYPE_TOUCH_SCREEN =
    DmiPointingDevice_Type_TYPE_TOUCH_SCREEN;
  static const Type TYPE_OPTICAL_SENSOR =
    DmiPointingDevice_Type_TYPE_OPTICAL_SENSOR;
  static inline bool Type_IsValid(int value) {
    return DmiPointingDevice_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiPointingDevice_Type_Type_MIN;
  static const Type Type_MAX =
    DmiPointingDevice_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiPointingDevice_Type_Type_ARRAYSIZE;

  typedef DmiPointingDevice_Interface Interface;
  static const Interface INTERFACE_UNKNOWN =
    DmiPointingDevice_Interface_INTERFACE_UNKNOWN;
  static const Interface INTERFACE_OTHER =
    DmiPointingDevice_Interface_INTERFACE_OTHER;
  static const Interface INTERFACE_SERIAL =
    DmiPointingDevice_Interface_INTERFACE_SERIAL;
  static const Interface INTERFACE_PS_2 =
    DmiPointingDevice_Interface_INTERFACE_PS_2;
  static const Interface INTERFACE_INFRARED =
    DmiPointingDevice_Interface_INTERFACE_INFRARED;
  static const Interface INTERFACE_HP_HIL =
    DmiPointingDevice_Interface_INTERFACE_HP_HIL;
  static const Interface INTERFACE_BUS_MOUSE =
    DmiPointingDevice_Interface_INTERFACE_BUS_MOUSE;
  static const Interface INTERFACE_ADB =
    DmiPointingDevice_Interface_INTERFACE_ADB;
  static const Interface INTERFACE_BUS_MOUSE_DB_9 =
    DmiPointingDevice_Interface_INTERFACE_BUS_MOUSE_DB_9;
  static const Interface INTERFACE_BUS_MOUSE_MICRO_DIN =
    DmiPointingDevice_Interface_INTERFACE_BUS_MOUSE_MICRO_DIN;
  static const Interface INTERFACE_USB =
    DmiPointingDevice_Interface_INTERFACE_USB;
  static inline bool Interface_IsValid(int value) {
    return DmiPointingDevice_Interface_IsValid(value);
  }
  static const Interface Interface_MIN =
    DmiPointingDevice_Interface_Interface_MIN;
  static const Interface Interface_MAX =
    DmiPointingDevice_Interface_Interface_MAX;
  static const int Interface_ARRAYSIZE =
    DmiPointingDevice_Interface_Interface_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiPointingDevice.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiPointingDevice_Item& item(int index) const;
  ::aspia::proto::DmiPointingDevice_Item* mutable_item(int index);
  ::aspia::proto::DmiPointingDevice_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevice_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevice_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPointingDevice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevice_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPointingDeviceImpl();
};
// -------------------------------------------------------------------

class DmiPortableBattery_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortableBattery.Item) */ {
 public:
  DmiPortableBattery_Item();
  virtual ~DmiPortableBattery_Item();

  DmiPortableBattery_Item(const DmiPortableBattery_Item& from);

  inline DmiPortableBattery_Item& operator=(const DmiPortableBattery_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortableBattery_Item(DmiPortableBattery_Item&& from) noexcept
    : DmiPortableBattery_Item() {
    *this = ::std::move(from);
  }

  inline DmiPortableBattery_Item& operator=(DmiPortableBattery_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortableBattery_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortableBattery_Item* internal_default_instance() {
    return reinterpret_cast<const DmiPortableBattery_Item*>(
               &_DmiPortableBattery_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(DmiPortableBattery_Item* other);
  friend void swap(DmiPortableBattery_Item& a, DmiPortableBattery_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortableBattery_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortableBattery_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortableBattery_Item& from);
  void MergeFrom(const DmiPortableBattery_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortableBattery_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string location = 1;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // string manufacturer = 2;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 2;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string manufacture_date = 3;
  void clear_manufacture_date();
  static const int kManufactureDateFieldNumber = 3;
  const ::std::string& manufacture_date() const;
  void set_manufacture_date(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacture_date(::std::string&& value);
  #endif
  void set_manufacture_date(const char* value);
  void set_manufacture_date(const char* value, size_t size);
  ::std::string* mutable_manufacture_date();
  ::std::string* release_manufacture_date();
  void set_allocated_manufacture_date(::std::string* manufacture_date);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string device_name = 5;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 5;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  #if LANG_CXX11
  void set_device_name(::std::string&& value);
  #endif
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // string sbds_version_number = 9;
  void clear_sbds_version_number();
  static const int kSbdsVersionNumberFieldNumber = 9;
  const ::std::string& sbds_version_number() const;
  void set_sbds_version_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_version_number(::std::string&& value);
  #endif
  void set_sbds_version_number(const char* value);
  void set_sbds_version_number(const char* value, size_t size);
  ::std::string* mutable_sbds_version_number();
  ::std::string* release_sbds_version_number();
  void set_allocated_sbds_version_number(::std::string* sbds_version_number);

  // string sbds_serial_number = 11;
  void clear_sbds_serial_number();
  static const int kSbdsSerialNumberFieldNumber = 11;
  const ::std::string& sbds_serial_number() const;
  void set_sbds_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_serial_number(::std::string&& value);
  #endif
  void set_sbds_serial_number(const char* value);
  void set_sbds_serial_number(const char* value, size_t size);
  ::std::string* mutable_sbds_serial_number();
  ::std::string* release_sbds_serial_number();
  void set_allocated_sbds_serial_number(::std::string* sbds_serial_number);

  // string sbds_manufacture_date = 12;
  void clear_sbds_manufacture_date();
  static const int kSbdsManufactureDateFieldNumber = 12;
  const ::std::string& sbds_manufacture_date() const;
  void set_sbds_manufacture_date(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_manufacture_date(::std::string&& value);
  #endif
  void set_sbds_manufacture_date(const char* value);
  void set_sbds_manufacture_date(const char* value, size_t size);
  ::std::string* mutable_sbds_manufacture_date();
  ::std::string* release_sbds_manufacture_date();
  void set_allocated_sbds_manufacture_date(::std::string* sbds_manufacture_date);

  // string sbds_device_chemistry = 13;
  void clear_sbds_device_chemistry();
  static const int kSbdsDeviceChemistryFieldNumber = 13;
  const ::std::string& sbds_device_chemistry() const;
  void set_sbds_device_chemistry(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_device_chemistry(::std::string&& value);
  #endif
  void set_sbds_device_chemistry(const char* value);
  void set_sbds_device_chemistry(const char* value, size_t size);
  ::std::string* mutable_sbds_device_chemistry();
  ::std::string* release_sbds_device_chemistry();
  void set_allocated_sbds_device_chemistry(::std::string* sbds_device_chemistry);

  // .aspia.proto.DmiPortableBattery.Chemistry chemistry = 6;
  void clear_chemistry();
  static const int kChemistryFieldNumber = 6;
  ::aspia::proto::DmiPortableBattery_Chemistry chemistry() const;
  void set_chemistry(::aspia::proto::DmiPortableBattery_Chemistry value);

  // int32 design_capacity = 7;
  void clear_design_capacity();
  static const int kDesignCapacityFieldNumber = 7;
  ::google::protobuf::int32 design_capacity() const;
  void set_design_capacity(::google::protobuf::int32 value);

  // int32 design_voltage = 8;
  void clear_design_voltage();
  static const int kDesignVoltageFieldNumber = 8;
  ::google::protobuf::int32 design_voltage() const;
  void set_design_voltage(::google::protobuf::int32 value);

  // int32 max_error_in_battery_data = 10;
  void clear_max_error_in_battery_data();
  static const int kMaxErrorInBatteryDataFieldNumber = 10;
  ::google::protobuf::int32 max_error_in_battery_data() const;
  void set_max_error_in_battery_data(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortableBattery.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr manufacture_date_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  ::google::protobuf::internal::ArenaStringPtr sbds_version_number_;
  ::google::protobuf::internal::ArenaStringPtr sbds_serial_number_;
  ::google::protobuf::internal::ArenaStringPtr sbds_manufacture_date_;
  ::google::protobuf::internal::ArenaStringPtr sbds_device_chemistry_;
  int chemistry_;
  ::google::protobuf::int32 design_capacity_;
  ::google::protobuf::int32 design_voltage_;
  ::google::protobuf::int32 max_error_in_battery_data_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortableBattery_ItemImpl();
};
// -------------------------------------------------------------------

class DmiPortableBattery : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortableBattery) */ {
 public:
  DmiPortableBattery();
  virtual ~DmiPortableBattery();

  DmiPortableBattery(const DmiPortableBattery& from);

  inline DmiPortableBattery& operator=(const DmiPortableBattery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortableBattery(DmiPortableBattery&& from) noexcept
    : DmiPortableBattery() {
    *this = ::std::move(from);
  }

  inline DmiPortableBattery& operator=(DmiPortableBattery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortableBattery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortableBattery* internal_default_instance() {
    return reinterpret_cast<const DmiPortableBattery*>(
               &_DmiPortableBattery_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(DmiPortableBattery* other);
  friend void swap(DmiPortableBattery& a, DmiPortableBattery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortableBattery* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortableBattery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortableBattery& from);
  void MergeFrom(const DmiPortableBattery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortableBattery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiPortableBattery_Item Item;

  typedef DmiPortableBattery_Chemistry Chemistry;
  static const Chemistry CHEMISTRY_UNKNOWN =
    DmiPortableBattery_Chemistry_CHEMISTRY_UNKNOWN;
  static const Chemistry CHEMISTRY_OTHER =
    DmiPortableBattery_Chemistry_CHEMISTRY_OTHER;
  static const Chemistry CHEMISTRY_LEAD_ACID =
    DmiPortableBattery_Chemistry_CHEMISTRY_LEAD_ACID;
  static const Chemistry CHEMISTRY_NICKEL_CADMIUM =
    DmiPortableBattery_Chemistry_CHEMISTRY_NICKEL_CADMIUM;
  static const Chemistry CHEMISTRY_NICKEL_METAL_HYDRIDE =
    DmiPortableBattery_Chemistry_CHEMISTRY_NICKEL_METAL_HYDRIDE;
  static const Chemistry CHEMISTRY_LITHIUM_ION =
    DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_ION;
  static const Chemistry CHEMISTRY_ZINC_AIR =
    DmiPortableBattery_Chemistry_CHEMISTRY_ZINC_AIR;
  static const Chemistry CHEMISTRY_LITHIUM_POLYMER =
    DmiPortableBattery_Chemistry_CHEMISTRY_LITHIUM_POLYMER;
  static inline bool Chemistry_IsValid(int value) {
    return DmiPortableBattery_Chemistry_IsValid(value);
  }
  static const Chemistry Chemistry_MIN =
    DmiPortableBattery_Chemistry_Chemistry_MIN;
  static const Chemistry Chemistry_MAX =
    DmiPortableBattery_Chemistry_Chemistry_MAX;
  static const int Chemistry_ARRAYSIZE =
    DmiPortableBattery_Chemistry_Chemistry_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiPortableBattery.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiPortableBattery_Item& item(int index) const;
  ::aspia::proto::DmiPortableBattery_Item* mutable_item(int index);
  ::aspia::proto::DmiPortableBattery_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortableBattery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsDmiPortableBatteryImpl();
};
// -------------------------------------------------------------------

class CPU_Features : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.CPU.Features) */ {
 public:
  CPU_Features();
  virtual ~CPU_Features();

  CPU_Features(const CPU_Features& from);

  inline CPU_Features& operator=(const CPU_Features& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CPU_Features(CPU_Features&& from) noexcept
    : CPU_Features() {
    *this = ::std::move(from);
  }

  inline CPU_Features& operator=(CPU_Features&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CPU_Features& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CPU_Features* internal_default_instance() {
    return reinterpret_cast<const CPU_Features*>(
               &_CPU_Features_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(CPU_Features* other);
  friend void swap(CPU_Features& a, CPU_Features& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CPU_Features* New() const PROTOBUF_FINAL { return New(NULL); }

  CPU_Features* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CPU_Features& from);
  void MergeFrom(const CPU_Features& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CPU_Features* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool has_fpu = 1;
  void clear_has_fpu();
  static const int kHasFpuFieldNumber = 1;
  bool has_fpu() const;
  void set_has_fpu(bool value);

  // bool has_vme = 2;
  void clear_has_vme();
  static const int kHasVmeFieldNumber = 2;
  bool has_vme() const;
  void set_has_vme(bool value);

  // bool has_de = 3;
  void clear_has_de();
  static const int kHasDeFieldNumber = 3;
  bool has_de() const;
  void set_has_de(bool value);

  // bool has_pse = 4;
  void clear_has_pse();
  static const int kHasPseFieldNumber = 4;
  bool has_pse() const;
  void set_has_pse(bool value);

  // bool has_tsc = 5;
  void clear_has_tsc();
  static const int kHasTscFieldNumber = 5;
  bool has_tsc() const;
  void set_has_tsc(bool value);

  // bool has_msr = 6;
  void clear_has_msr();
  static const int kHasMsrFieldNumber = 6;
  bool has_msr() const;
  void set_has_msr(bool value);

  // bool has_pae = 7;
  void clear_has_pae();
  static const int kHasPaeFieldNumber = 7;
  bool has_pae() const;
  void set_has_pae(bool value);

  // bool has_mce = 8;
  void clear_has_mce();
  static const int kHasMceFieldNumber = 8;
  bool has_mce() const;
  void set_has_mce(bool value);

  // bool has_cx8 = 9;
  void clear_has_cx8();
  static const int kHasCx8FieldNumber = 9;
  bool has_cx8() const;
  void set_has_cx8(bool value);

  // bool has_apic = 10;
  void clear_has_apic();
  static const int kHasApicFieldNumber = 10;
  bool has_apic() const;
  void set_has_apic(bool value);

  // bool has_sep = 11;
  void clear_has_sep();
  static const int kHasSepFieldNumber = 11;
  bool has_sep() const;
  void set_has_sep(bool value);

  // bool has_mtrr = 12;
  void clear_has_mtrr();
  static const int kHasMtrrFieldNumber = 12;
  bool has_mtrr() const;
  void set_has_mtrr(bool value);

  // bool has_pge = 13;
  void clear_has_pge();
  static const int kHasPgeFieldNumber = 13;
  bool has_pge() const;
  void set_has_pge(bool value);

  // bool has_mca = 14;
  void clear_has_mca();
  static const int kHasMcaFieldNumber = 14;
  bool has_mca() const;
  void set_has_mca(bool value);

  // bool has_cmov = 15;
  void clear_has_cmov();
  static const int kHasCmovFieldNumber = 15;
  bool has_cmov() const;
  void set_has_cmov(bool value);

  // bool has_pat = 16;
  void clear_has_pat();
  static const int kHasPatFieldNumber = 16;
  bool has_pat() const;
  void set_has_pat(bool value);

  // bool has_pse36 = 17;
  void clear_has_pse36();
  static const int kHasPse36FieldNumber = 17;
  bool has_pse36() const;
  void set_has_pse36(bool value);

  // bool has_psn = 18;
  void clear_has_psn();
  static const int kHasPsnFieldNumber = 18;
  bool has_psn() const;
  void set_has_psn(bool value);

  // bool has_clfsh = 19;
  void clear_has_clfsh();
  static const int kHasClfshFieldNumber = 19;
  bool has_clfsh() const;
  void set_has_clfsh(bool value);

  // bool has_ds = 20;
  void clear_has_ds();
  static const int kHasDsFieldNumber = 20;
  bool has_ds() const;
  void set_has_ds(bool value);

  // bool has_acpu = 21;
  void clear_has_acpu();
  static const int kHasAcpuFieldNumber = 21;
  bool has_acpu() const;
  void set_has_acpu(bool value);

  // bool has_mmx = 22;
  void clear_has_mmx();
  static const int kHasMmxFieldNumber = 22;
  bool has_mmx() const;
  void set_has_mmx(bool value);

  // bool has_fxsr = 23;
  void clear_has_fxsr();
  static const int kHasFxsrFieldNumber = 23;
  bool has_fxsr() const;
  void set_has_fxsr(bool value);

  // bool has_sse = 24;
  void clear_has_sse();
  static const int kHasSseFieldNumber = 24;
  bool has_sse() const;
  void set_has_sse(bool value);

  // bool has_sse2 = 25;
  void clear_has_sse2();
  static const int kHasSse2FieldNumber = 25;
  bool has_sse2() const;
  void set_has_sse2(bool value);

  // bool has_ss = 26;
  void clear_has_ss();
  static const int kHasSsFieldNumber = 26;
  bool has_ss() const;
  void set_has_ss(bool value);

  // bool has_htt = 27;
  void clear_has_htt();
  static const int kHasHttFieldNumber = 27;
  bool has_htt() const;
  void set_has_htt(bool value);

  // bool has_tm = 28;
  void clear_has_tm();
  static const int kHasTmFieldNumber = 28;
  bool has_tm() const;
  void set_has_tm(bool value);

  // bool has_ia64 = 29;
  void clear_has_ia64();
  static const int kHasIa64FieldNumber = 29;
  bool has_ia64() const;
  void set_has_ia64(bool value);

  // bool has_pbe = 30;
  void clear_has_pbe();
  static const int kHasPbeFieldNumber = 30;
  bool has_pbe() const;
  void set_has_pbe(bool value);

  // bool has_sse3 = 31;
  void clear_has_sse3();
  static const int kHasSse3FieldNumber = 31;
  bool has_sse3() const;
  void set_has_sse3(bool value);

  // bool has_pclmuldq = 32;
  void clear_has_pclmuldq();
  static const int kHasPclmuldqFieldNumber = 32;
  bool has_pclmuldq() const;
  void set_has_pclmuldq(bool value);

  // bool has_dtes64 = 33;
  void clear_has_dtes64();
  static const int kHasDtes64FieldNumber = 33;
  bool has_dtes64() const;
  void set_has_dtes64(bool value);

  // bool has_monitor = 34;
  void clear_has_monitor();
  static const int kHasMonitorFieldNumber = 34;
  bool has_monitor() const;
  void set_has_monitor(bool value);

  // bool has_ds_cpl = 35;
  void clear_has_ds_cpl();
  static const int kHasDsCplFieldNumber = 35;
  bool has_ds_cpl() const;
  void set_has_ds_cpl(bool value);

  // bool has_vmx = 36;
  void clear_has_vmx();
  static const int kHasVmxFieldNumber = 36;
  bool has_vmx() const;
  void set_has_vmx(bool value);

  // bool has_smx = 37;
  void clear_has_smx();
  static const int kHasSmxFieldNumber = 37;
  bool has_smx() const;
  void set_has_smx(bool value);

  // bool has_est = 38;
  void clear_has_est();
  static const int kHasEstFieldNumber = 38;
  bool has_est() const;
  void set_has_est(bool value);

  // bool has_tm2 = 39;
  void clear_has_tm2();
  static const int kHasTm2FieldNumber = 39;
  bool has_tm2() const;
  void set_has_tm2(bool value);

  // bool has_ssse3 = 40;
  void clear_has_ssse3();
  static const int kHasSsse3FieldNumber = 40;
  bool has_ssse3() const;
  void set_has_ssse3(bool value);

  // bool has_cnxt_id = 41;
  void clear_has_cnxt_id();
  static const int kHasCnxtIdFieldNumber = 41;
  bool has_cnxt_id() const;
  void set_has_cnxt_id(bool value);

  // bool has_sdbg = 42;
  void clear_has_sdbg();
  static const int kHasSdbgFieldNumber = 42;
  bool has_sdbg() const;
  void set_has_sdbg(bool value);

  // bool has_fma = 43;
  void clear_has_fma();
  static const int kHasFmaFieldNumber = 43;
  bool has_fma() const;
  void set_has_fma(bool value);

  // bool has_cx16 = 44;
  void clear_has_cx16();
  static const int kHasCx16FieldNumber = 44;
  bool has_cx16() const;
  void set_has_cx16(bool value);

  // bool has_xtpr = 45;
  void clear_has_xtpr();
  static const int kHasXtprFieldNumber = 45;
  bool has_xtpr() const;
  void set_has_xtpr(bool value);

  // bool has_pdcm = 46;
  void clear_has_pdcm();
  static const int kHasPdcmFieldNumber = 46;
  bool has_pdcm() const;
  void set_has_pdcm(bool value);

  // bool has_pcid = 47;
  void clear_has_pcid();
  static const int kHasPcidFieldNumber = 47;
  bool has_pcid() const;
  void set_has_pcid(bool value);

  // bool has_dca = 48;
  void clear_has_dca();
  static const int kHasDcaFieldNumber = 48;
  bool has_dca() const;
  void set_has_dca(bool value);

  // bool has_sse41 = 49;
  void clear_has_sse41();
  static const int kHasSse41FieldNumber = 49;
  bool has_sse41() const;
  void set_has_sse41(bool value);

  // bool has_sse42 = 50;
  void clear_has_sse42();
  static const int kHasSse42FieldNumber = 50;
  bool has_sse42() const;
  void set_has_sse42(bool value);

  // bool has_x2apic = 51;
  void clear_has_x2apic();
  static const int kHasX2ApicFieldNumber = 51;
  bool has_x2apic() const;
  void set_has_x2apic(bool value);

  // bool has_movbe = 52;
  void clear_has_movbe();
  static const int kHasMovbeFieldNumber = 52;
  bool has_movbe() const;
  void set_has_movbe(bool value);

  // bool has_popcnt = 53;
  void clear_has_popcnt();
  static const int kHasPopcntFieldNumber = 53;
  bool has_popcnt() const;
  void set_has_popcnt(bool value);

  // bool has_tsc_deadline = 54;
  void clear_has_tsc_deadline();
  static const int kHasTscDeadlineFieldNumber = 54;
  bool has_tsc_deadline() const;
  void set_has_tsc_deadline(bool value);

  // bool has_aes = 55;
  void clear_has_aes();
  static const int kHasAesFieldNumber = 55;
  bool has_aes() const;
  void set_has_aes(bool value);

  // bool has_xsave = 56;
  void clear_has_xsave();
  static const int kHasXsaveFieldNumber = 56;
  bool has_xsave() const;
  void set_has_xsave(bool value);

  // bool has_osxsave = 57;
  void clear_has_osxsave();
  static const int kHasOsxsaveFieldNumber = 57;
  bool has_osxsave() const;
  void set_has_osxsave(bool value);

  // bool has_avx = 58;
  void clear_has_avx();
  static const int kHasAvxFieldNumber = 58;
  bool has_avx() const;
  void set_has_avx(bool value);

  // bool has_f16c = 59;
  void clear_has_f16c();
  static const int kHasF16CFieldNumber = 59;
  bool has_f16c() const;
  void set_has_f16c(bool value);

  // bool has_rdrand = 60;
  void clear_has_rdrand();
  static const int kHasRdrandFieldNumber = 60;
  bool has_rdrand() const;
  void set_has_rdrand(bool value);

  // bool has_hypervisor = 61;
  void clear_has_hypervisor();
  static const int kHasHypervisorFieldNumber = 61;
  bool has_hypervisor() const;
  void set_has_hypervisor(bool value);

  // bool has_syscall = 62;
  void clear_has_syscall();
  static const int kHasSyscallFieldNumber = 62;
  bool has_syscall() const;
  void set_has_syscall(bool value);

  // bool has_xd_bit = 63;
  void clear_has_xd_bit();
  static const int kHasXdBitFieldNumber = 63;
  bool has_xd_bit() const;
  void set_has_xd_bit(bool value);

  // bool has_mmxext = 64;
  void clear_has_mmxext();
  static const int kHasMmxextFieldNumber = 64;
  bool has_mmxext() const;
  void set_has_mmxext(bool value);

  // bool has_1gb_pages = 65;
  void clear_has_1gb_pages();
  static const int kHas1GbPagesFieldNumber = 65;
  bool has_1gb_pages() const;
  void set_has_1gb_pages(bool value);

  // bool has_rdtscp = 66;
  void clear_has_rdtscp();
  static const int kHasRdtscpFieldNumber = 66;
  bool has_rdtscp() const;
  void set_has_rdtscp(bool value);

  // bool has_intel64 = 67;
  void clear_has_intel64();
  static const int kHasIntel64FieldNumber = 67;
  bool has_intel64() const;
  void set_has_intel64(bool value);

  // bool has_3dnowext = 68;
  void clear_has_3dnowext();
  static const int kHas3DnowextFieldNumber = 68;
  bool has_3dnowext() const;
  void set_has_3dnowext(bool value);

  // bool has_3dnow = 69;
  void clear_has_3dnow();
  static const int kHas3DnowFieldNumber = 69;
  bool has_3dnow() const;
  void set_has_3dnow(bool value);

  // bool has_lahf = 70;
  void clear_has_lahf();
  static const int kHasLahfFieldNumber = 70;
  bool has_lahf() const;
  void set_has_lahf(bool value);

  // bool has_svm = 71;
  void clear_has_svm();
  static const int kHasSvmFieldNumber = 71;
  bool has_svm() const;
  void set_has_svm(bool value);

  // bool has_lzcnt = 72;
  void clear_has_lzcnt();
  static const int kHasLzcntFieldNumber = 72;
  bool has_lzcnt() const;
  void set_has_lzcnt(bool value);

  // bool has_sse4a = 73;
  void clear_has_sse4a();
  static const int kHasSse4AFieldNumber = 73;
  bool has_sse4a() const;
  void set_has_sse4a(bool value);

  // bool has_misalignsse = 74;
  void clear_has_misalignsse();
  static const int kHasMisalignsseFieldNumber = 74;
  bool has_misalignsse() const;
  void set_has_misalignsse(bool value);

  // bool has_3dnow_prefetch = 75;
  void clear_has_3dnow_prefetch();
  static const int kHas3DnowPrefetchFieldNumber = 75;
  bool has_3dnow_prefetch() const;
  void set_has_3dnow_prefetch(bool value);

  // bool has_xop = 76;
  void clear_has_xop();
  static const int kHasXopFieldNumber = 76;
  bool has_xop() const;
  void set_has_xop(bool value);

  // bool has_wdt = 77;
  void clear_has_wdt();
  static const int kHasWdtFieldNumber = 77;
  bool has_wdt() const;
  void set_has_wdt(bool value);

  // bool has_fma4 = 78;
  void clear_has_fma4();
  static const int kHasFma4FieldNumber = 78;
  bool has_fma4() const;
  void set_has_fma4(bool value);

  // bool has_fsgsbase = 79;
  void clear_has_fsgsbase();
  static const int kHasFsgsbaseFieldNumber = 79;
  bool has_fsgsbase() const;
  void set_has_fsgsbase(bool value);

  // bool has_sgx = 80;
  void clear_has_sgx();
  static const int kHasSgxFieldNumber = 80;
  bool has_sgx() const;
  void set_has_sgx(bool value);

  // bool has_bmi1 = 81;
  void clear_has_bmi1();
  static const int kHasBmi1FieldNumber = 81;
  bool has_bmi1() const;
  void set_has_bmi1(bool value);

  // bool has_hle = 82;
  void clear_has_hle();
  static const int kHasHleFieldNumber = 82;
  bool has_hle() const;
  void set_has_hle(bool value);

  // bool has_avx2 = 83;
  void clear_has_avx2();
  static const int kHasAvx2FieldNumber = 83;
  bool has_avx2() const;
  void set_has_avx2(bool value);

  // bool has_smep = 84;
  void clear_has_smep();
  static const int kHasSmepFieldNumber = 84;
  bool has_smep() const;
  void set_has_smep(bool value);

  // bool has_bmi2 = 85;
  void clear_has_bmi2();
  static const int kHasBmi2FieldNumber = 85;
  bool has_bmi2() const;
  void set_has_bmi2(bool value);

  // bool has_erms = 86;
  void clear_has_erms();
  static const int kHasErmsFieldNumber = 86;
  bool has_erms() const;
  void set_has_erms(bool value);

  // bool has_invpcid = 87;
  void clear_has_invpcid();
  static const int kHasInvpcidFieldNumber = 87;
  bool has_invpcid() const;
  void set_has_invpcid(bool value);

  // bool has_rtm = 88;
  void clear_has_rtm();
  static const int kHasRtmFieldNumber = 88;
  bool has_rtm() const;
  void set_has_rtm(bool value);

  // bool has_pqm = 89;
  void clear_has_pqm();
  static const int kHasPqmFieldNumber = 89;
  bool has_pqm() const;
  void set_has_pqm(bool value);

  // bool has_mpx = 90;
  void clear_has_mpx();
  static const int kHasMpxFieldNumber = 90;
  bool has_mpx() const;
  void set_has_mpx(bool value);

  // bool has_pqe = 91;
  void clear_has_pqe();
  static const int kHasPqeFieldNumber = 91;
  bool has_pqe() const;
  void set_has_pqe(bool value);

  // bool has_avx512f = 92;
  void clear_has_avx512f();
  static const int kHasAvx512FFieldNumber = 92;
  bool has_avx512f() const;
  void set_has_avx512f(bool value);

  // bool has_avx512dq = 93;
  void clear_has_avx512dq();
  static const int kHasAvx512DqFieldNumber = 93;
  bool has_avx512dq() const;
  void set_has_avx512dq(bool value);

  // bool has_rdseed = 94;
  void clear_has_rdseed();
  static const int kHasRdseedFieldNumber = 94;
  bool has_rdseed() const;
  void set_has_rdseed(bool value);

  // bool has_adx = 95;
  void clear_has_adx();
  static const int kHasAdxFieldNumber = 95;
  bool has_adx() const;
  void set_has_adx(bool value);

  // bool has_smap = 96;
  void clear_has_smap();
  static const int kHasSmapFieldNumber = 96;
  bool has_smap() const;
  void set_has_smap(bool value);

  // bool has_avx512ifma = 97;
  void clear_has_avx512ifma();
  static const int kHasAvx512IfmaFieldNumber = 97;
  bool has_avx512ifma() const;
  void set_has_avx512ifma(bool value);

  // bool has_pcommit = 98;
  void clear_has_pcommit();
  static const int kHasPcommitFieldNumber = 98;
  bool has_pcommit() const;
  void set_has_pcommit(bool value);

  // bool has_clflushopt = 99;
  void clear_has_clflushopt();
  static const int kHasClflushoptFieldNumber = 99;
  bool has_clflushopt() const;
  void set_has_clflushopt(bool value);

  // bool has_clwb = 100;
  void clear_has_clwb();
  static const int kHasClwbFieldNumber = 100;
  bool has_clwb() const;
  void set_has_clwb(bool value);

  // bool has_intel_pt = 101;
  void clear_has_intel_pt();
  static const int kHasIntelPtFieldNumber = 101;
  bool has_intel_pt() const;
  void set_has_intel_pt(bool value);

  // bool has_avx512pf = 102;
  void clear_has_avx512pf();
  static const int kHasAvx512PfFieldNumber = 102;
  bool has_avx512pf() const;
  void set_has_avx512pf(bool value);

  // bool has_avx512er = 103;
  void clear_has_avx512er();
  static const int kHasAvx512ErFieldNumber = 103;
  bool has_avx512er() const;
  void set_has_avx512er(bool value);

  // bool has_avx512cd = 104;
  void clear_has_avx512cd();
  static const int kHasAvx512CdFieldNumber = 104;
  bool has_avx512cd() const;
  void set_has_avx512cd(bool value);

  // bool has_sha = 105;
  void clear_has_sha();
  static const int kHasShaFieldNumber = 105;
  bool has_sha() const;
  void set_has_sha(bool value);

  // bool has_avx512bw = 106;
  void clear_has_avx512bw();
  static const int kHasAvx512BwFieldNumber = 106;
  bool has_avx512bw() const;
  void set_has_avx512bw(bool value);

  // bool has_avx512vl = 107;
  void clear_has_avx512vl();
  static const int kHasAvx512VlFieldNumber = 107;
  bool has_avx512vl() const;
  void set_has_avx512vl(bool value);

  // bool has_prefetchwt1 = 108;
  void clear_has_prefetchwt1();
  static const int kHasPrefetchwt1FieldNumber = 108;
  bool has_prefetchwt1() const;
  void set_has_prefetchwt1(bool value);

  // bool has_avx512vbmi = 109;
  void clear_has_avx512vbmi();
  static const int kHasAvx512VbmiFieldNumber = 109;
  bool has_avx512vbmi() const;
  void set_has_avx512vbmi(bool value);

  // bool has_umip = 110;
  void clear_has_umip();
  static const int kHasUmipFieldNumber = 110;
  bool has_umip() const;
  void set_has_umip(bool value);

  // bool has_pku = 111;
  void clear_has_pku();
  static const int kHasPkuFieldNumber = 111;
  bool has_pku() const;
  void set_has_pku(bool value);

  // bool has_ospke = 112;
  void clear_has_ospke();
  static const int kHasOspkeFieldNumber = 112;
  bool has_ospke() const;
  void set_has_ospke(bool value);

  // bool has_avx512vbmi2 = 113;
  void clear_has_avx512vbmi2();
  static const int kHasAvx512Vbmi2FieldNumber = 113;
  bool has_avx512vbmi2() const;
  void set_has_avx512vbmi2(bool value);

  // bool has_gfni = 114;
  void clear_has_gfni();
  static const int kHasGfniFieldNumber = 114;
  bool has_gfni() const;
  void set_has_gfni(bool value);

  // bool has_vaes = 115;
  void clear_has_vaes();
  static const int kHasVaesFieldNumber = 115;
  bool has_vaes() const;
  void set_has_vaes(bool value);

  // bool has_vpclmulqdq = 116;
  void clear_has_vpclmulqdq();
  static const int kHasVpclmulqdqFieldNumber = 116;
  bool has_vpclmulqdq() const;
  void set_has_vpclmulqdq(bool value);

  // bool has_avx512vnni = 117;
  void clear_has_avx512vnni();
  static const int kHasAvx512VnniFieldNumber = 117;
  bool has_avx512vnni() const;
  void set_has_avx512vnni(bool value);

  // bool has_avx512bitalg = 118;
  void clear_has_avx512bitalg();
  static const int kHasAvx512BitalgFieldNumber = 118;
  bool has_avx512bitalg() const;
  void set_has_avx512bitalg(bool value);

  // bool has_avx512vpopcntdq = 119;
  void clear_has_avx512vpopcntdq();
  static const int kHasAvx512VpopcntdqFieldNumber = 119;
  bool has_avx512vpopcntdq() const;
  void set_has_avx512vpopcntdq(bool value);

  // bool has_rdpid = 120;
  void clear_has_rdpid();
  static const int kHasRdpidFieldNumber = 120;
  bool has_rdpid() const;
  void set_has_rdpid(bool value);

  // bool has_sgx_lc = 121;
  void clear_has_sgx_lc();
  static const int kHasSgxLcFieldNumber = 121;
  bool has_sgx_lc() const;
  void set_has_sgx_lc(bool value);

  // bool has_avx512_4vnniw = 122;
  void clear_has_avx512_4vnniw();
  static const int kHasAvx5124VnniwFieldNumber = 122;
  bool has_avx512_4vnniw() const;
  void set_has_avx512_4vnniw(bool value);

  // bool has_avx512_4fmaps = 123;
  void clear_has_avx512_4fmaps();
  static const int kHasAvx5124FmapsFieldNumber = 123;
  bool has_avx512_4fmaps() const;
  void set_has_avx512_4fmaps(bool value);

  // bool has_ais = 124;
  void clear_has_ais();
  static const int kHasAisFieldNumber = 124;
  bool has_ais() const;
  void set_has_ais(bool value);

  // bool has_rng = 125;
  void clear_has_rng();
  static const int kHasRngFieldNumber = 125;
  bool has_rng() const;
  void set_has_rng(bool value);

  // bool has_lh = 126;
  void clear_has_lh();
  static const int kHasLhFieldNumber = 126;
  bool has_lh() const;
  void set_has_lh(bool value);

  // bool has_femms = 127;
  void clear_has_femms();
  static const int kHasFemmsFieldNumber = 127;
  bool has_femms() const;
  void set_has_femms(bool value);

  // bool has_ace = 128;
  void clear_has_ace();
  static const int kHasAceFieldNumber = 128;
  bool has_ace() const;
  void set_has_ace(bool value);

  // bool has_ace2 = 129;
  void clear_has_ace2();
  static const int kHasAce2FieldNumber = 129;
  bool has_ace2() const;
  void set_has_ace2(bool value);

  // bool has_phe = 130;
  void clear_has_phe();
  static const int kHasPheFieldNumber = 130;
  bool has_phe() const;
  void set_has_phe(bool value);

  // bool has_pmm = 131;
  void clear_has_pmm();
  static const int kHasPmmFieldNumber = 131;
  bool has_pmm() const;
  void set_has_pmm(bool value);

  // bool has_parallax = 132;
  void clear_has_parallax();
  static const int kHasParallaxFieldNumber = 132;
  bool has_parallax() const;
  void set_has_parallax(bool value);

  // bool has_overstress = 133;
  void clear_has_overstress();
  static const int kHasOverstressFieldNumber = 133;
  bool has_overstress() const;
  void set_has_overstress(bool value);

  // bool has_tm3 = 134;
  void clear_has_tm3();
  static const int kHasTm3FieldNumber = 134;
  bool has_tm3() const;
  void set_has_tm3(bool value);

  // bool has_rng2 = 135;
  void clear_has_rng2();
  static const int kHasRng2FieldNumber = 135;
  bool has_rng2() const;
  void set_has_rng2(bool value);

  // bool has_phe2 = 136;
  void clear_has_phe2();
  static const int kHasPhe2FieldNumber = 136;
  bool has_phe2() const;
  void set_has_phe2(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.CPU.Features)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool has_fpu_;
  bool has_vme_;
  bool has_de_;
  bool has_pse_;
  bool has_tsc_;
  bool has_msr_;
  bool has_pae_;
  bool has_mce_;
  bool has_cx8_;
  bool has_apic_;
  bool has_sep_;
  bool has_mtrr_;
  bool has_pge_;
  bool has_mca_;
  bool has_cmov_;
  bool has_pat_;
  bool has_pse36_;
  bool has_psn_;
  bool has_clfsh_;
  bool has_ds_;
  bool has_acpu_;
  bool has_mmx_;
  bool has_fxsr_;
  bool has_sse_;
  bool has_sse2_;
  bool has_ss_;
  bool has_htt_;
  bool has_tm_;
  bool has_ia64_;
  bool has_pbe_;
  bool has_sse3_;
  bool has_pclmuldq_;
  bool has_dtes64_;
  bool has_monitor_;
  bool has_ds_cpl_;
  bool has_vmx_;
  bool has_smx_;
  bool has_est_;
  bool has_tm2_;
  bool has_ssse3_;
  bool has_cnxt_id_;
  bool has_sdbg_;
  bool has_fma_;
  bool has_cx16_;
  bool has_xtpr_;
  bool has_pdcm_;
  bool has_pcid_;
  bool has_dca_;
  bool has_sse41_;
  bool has_sse42_;
  bool has_x2apic_;
  bool has_movbe_;
  bool has_popcnt_;
  bool has_tsc_deadline_;
  bool has_aes_;
  bool has_xsave_;
  bool has_osxsave_;
  bool has_avx_;
  bool has_f16c_;
  bool has_rdrand_;
  bool has_hypervisor_;
  bool has_syscall_;
  bool has_xd_bit_;
  bool has_mmxext_;
  bool has_1gb_pages_;
  bool has_rdtscp_;
  bool has_intel64_;
  bool has_3dnowext_;
  bool has_3dnow_;
  bool has_lahf_;
  bool has_svm_;
  bool has_lzcnt_;
  bool has_sse4a_;
  bool has_misalignsse_;
  bool has_3dnow_prefetch_;
  bool has_xop_;
  bool has_wdt_;
  bool has_fma4_;
  bool has_fsgsbase_;
  bool has_sgx_;
  bool has_bmi1_;
  bool has_hle_;
  bool has_avx2_;
  bool has_smep_;
  bool has_bmi2_;
  bool has_erms_;
  bool has_invpcid_;
  bool has_rtm_;
  bool has_pqm_;
  bool has_mpx_;
  bool has_pqe_;
  bool has_avx512f_;
  bool has_avx512dq_;
  bool has_rdseed_;
  bool has_adx_;
  bool has_smap_;
  bool has_avx512ifma_;
  bool has_pcommit_;
  bool has_clflushopt_;
  bool has_clwb_;
  bool has_intel_pt_;
  bool has_avx512pf_;
  bool has_avx512er_;
  bool has_avx512cd_;
  bool has_sha_;
  bool has_avx512bw_;
  bool has_avx512vl_;
  bool has_prefetchwt1_;
  bool has_avx512vbmi_;
  bool has_umip_;
  bool has_pku_;
  bool has_ospke_;
  bool has_avx512vbmi2_;
  bool has_gfni_;
  bool has_vaes_;
  bool has_vpclmulqdq_;
  bool has_avx512vnni_;
  bool has_avx512bitalg_;
  bool has_avx512vpopcntdq_;
  bool has_rdpid_;
  bool has_sgx_lc_;
  bool has_avx512_4vnniw_;
  bool has_avx512_4fmaps_;
  bool has_ais_;
  bool has_rng_;
  bool has_lh_;
  bool has_femms_;
  bool has_ace_;
  bool has_ace2_;
  bool has_phe_;
  bool has_pmm_;
  bool has_parallax_;
  bool has_overstress_;
  bool has_tm3_;
  bool has_rng2_;
  bool has_phe2_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsCPU_FeaturesImpl();
};
// -------------------------------------------------------------------

class CPU : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.CPU) */ {
 public:
  CPU();
  virtual ~CPU();

  CPU(const CPU& from);

  inline CPU& operator=(const CPU& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CPU(CPU&& from) noexcept
    : CPU() {
    *this = ::std::move(from);
  }

  inline CPU& operator=(CPU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const CPU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CPU* internal_default_instance() {
    return reinterpret_cast<const CPU*>(
               &_CPU_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(CPU* other);
  friend void swap(CPU& a, CPU& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CPU* New() const PROTOBUF_FINAL { return New(NULL); }

  CPU* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CPU& from);
  void MergeFrom(const CPU& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CPU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CPU_Features Features;

  // accessors -------------------------------------------------------

  // string brand_string = 1;
  void clear_brand_string();
  static const int kBrandStringFieldNumber = 1;
  const ::std::string& brand_string() const;
  void set_brand_string(const ::std::string& value);
  #if LANG_CXX11
  void set_brand_string(::std::string&& value);
  #endif
  void set_brand_string(const char* value);
  void set_brand_string(const char* value, size_t size);
  ::std::string* mutable_brand_string();
  ::std::string* release_brand_string();
  void set_allocated_brand_string(::std::string* brand_string);

  // string vendor = 2;
  void clear_vendor();
  static const int kVendorFieldNumber = 2;
  const ::std::string& vendor() const;
  void set_vendor(const ::std::string& value);
  #if LANG_CXX11
  void set_vendor(::std::string&& value);
  #endif
  void set_vendor(const char* value);
  void set_vendor(const char* value, size_t size);
  ::std::string* mutable_vendor();
  ::std::string* release_vendor();
  void set_allocated_vendor(::std::string* vendor);

  // .aspia.proto.CPU.Features features = 12;
  bool has_features() const;
  void clear_features();
  static const int kFeaturesFieldNumber = 12;
  const ::aspia::proto::CPU_Features& features() const;
  ::aspia::proto::CPU_Features* release_features();
  ::aspia::proto::CPU_Features* mutable_features();
  void set_allocated_features(::aspia::proto::CPU_Features* features);

  // uint32 stepping = 3;
  void clear_stepping();
  static const int kSteppingFieldNumber = 3;
  ::google::protobuf::uint32 stepping() const;
  void set_stepping(::google::protobuf::uint32 value);

  // uint32 model = 4;
  void clear_model();
  static const int kModelFieldNumber = 4;
  ::google::protobuf::uint32 model() const;
  void set_model(::google::protobuf::uint32 value);

  // uint32 family = 5;
  void clear_family();
  static const int kFamilyFieldNumber = 5;
  ::google::protobuf::uint32 family() const;
  void set_family(::google::protobuf::uint32 value);

  // uint32 extended_model = 6;
  void clear_extended_model();
  static const int kExtendedModelFieldNumber = 6;
  ::google::protobuf::uint32 extended_model() const;
  void set_extended_model(::google::protobuf::uint32 value);

  // uint32 extended_family = 7;
  void clear_extended_family();
  static const int kExtendedFamilyFieldNumber = 7;
  ::google::protobuf::uint32 extended_family() const;
  void set_extended_family(::google::protobuf::uint32 value);

  // uint32 brand_id = 8;
  void clear_brand_id();
  static const int kBrandIdFieldNumber = 8;
  ::google::protobuf::uint32 brand_id() const;
  void set_brand_id(::google::protobuf::uint32 value);

  // uint32 packages = 9;
  void clear_packages();
  static const int kPackagesFieldNumber = 9;
  ::google::protobuf::uint32 packages() const;
  void set_packages(::google::protobuf::uint32 value);

  // uint32 physical_cores = 10;
  void clear_physical_cores();
  static const int kPhysicalCoresFieldNumber = 10;
  ::google::protobuf::uint32 physical_cores() const;
  void set_physical_cores(::google::protobuf::uint32 value);

  // uint32 logical_cores = 11;
  void clear_logical_cores();
  static const int kLogicalCoresFieldNumber = 11;
  ::google::protobuf::uint32 logical_cores() const;
  void set_logical_cores(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.CPU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr brand_string_;
  ::google::protobuf::internal::ArenaStringPtr vendor_;
  ::aspia::proto::CPU_Features* features_;
  ::google::protobuf::uint32 stepping_;
  ::google::protobuf::uint32 model_;
  ::google::protobuf::uint32 family_;
  ::google::protobuf::uint32 extended_model_;
  ::google::protobuf::uint32 extended_family_;
  ::google::protobuf::uint32 brand_id_;
  ::google::protobuf::uint32 packages_;
  ::google::protobuf::uint32 physical_cores_;
  ::google::protobuf::uint32 logical_cores_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsCPUImpl();
};
// -------------------------------------------------------------------

class AtaDrives_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.AtaDrives.Item) */ {
 public:
  AtaDrives_Item();
  virtual ~AtaDrives_Item();

  AtaDrives_Item(const AtaDrives_Item& from);

  inline AtaDrives_Item& operator=(const AtaDrives_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AtaDrives_Item(AtaDrives_Item&& from) noexcept
    : AtaDrives_Item() {
    *this = ::std::move(from);
  }

  inline AtaDrives_Item& operator=(AtaDrives_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AtaDrives_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AtaDrives_Item* internal_default_instance() {
    return reinterpret_cast<const AtaDrives_Item*>(
               &_AtaDrives_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(AtaDrives_Item* other);
  friend void swap(AtaDrives_Item& a, AtaDrives_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AtaDrives_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  AtaDrives_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AtaDrives_Item& from);
  void MergeFrom(const AtaDrives_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AtaDrives_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string model_number = 1;
  void clear_model_number();
  static const int kModelNumberFieldNumber = 1;
  const ::std::string& model_number() const;
  void set_model_number(const ::std::string& value);
  #if LANG_CXX11
  void set_model_number(::std::string&& value);
  #endif
  void set_model_number(const char* value);
  void set_model_number(const char* value, size_t size);
  ::std::string* mutable_model_number();
  ::std::string* release_model_number();
  void set_allocated_model_number(::std::string* model_number);

  // string serial_number = 2;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string firmware_revision = 3;
  void clear_firmware_revision();
  static const int kFirmwareRevisionFieldNumber = 3;
  const ::std::string& firmware_revision() const;
  void set_firmware_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_firmware_revision(::std::string&& value);
  #endif
  void set_firmware_revision(const char* value);
  void set_firmware_revision(const char* value, size_t size);
  ::std::string* mutable_firmware_revision();
  ::std::string* release_firmware_revision();
  void set_allocated_firmware_revision(::std::string* firmware_revision);

  // .aspia.proto.AtaDrives.BusType bus_type = 4;
  void clear_bus_type();
  static const int kBusTypeFieldNumber = 4;
  ::aspia::proto::AtaDrives_BusType bus_type() const;
  void set_bus_type(::aspia::proto::AtaDrives_BusType value);

  // .aspia.proto.AtaDrives.TransferMode transfer_mode = 5;
  void clear_transfer_mode();
  static const int kTransferModeFieldNumber = 5;
  ::aspia::proto::AtaDrives_TransferMode transfer_mode() const;
  void set_transfer_mode(::aspia::proto::AtaDrives_TransferMode value);

  // uint64 drive_size = 7;
  void clear_drive_size();
  static const int kDriveSizeFieldNumber = 7;
  ::google::protobuf::uint64 drive_size() const;
  void set_drive_size(::google::protobuf::uint64 value);

  // uint32 rotation_rate = 6;
  void clear_rotation_rate();
  static const int kRotationRateFieldNumber = 6;
  ::google::protobuf::uint32 rotation_rate() const;
  void set_rotation_rate(::google::protobuf::uint32 value);

  // uint32 buffer_size = 8;
  void clear_buffer_size();
  static const int kBufferSizeFieldNumber = 8;
  ::google::protobuf::uint32 buffer_size() const;
  void set_buffer_size(::google::protobuf::uint32 value);

  // uint32 multisectors = 9;
  void clear_multisectors();
  static const int kMultisectorsFieldNumber = 9;
  ::google::protobuf::uint32 multisectors() const;
  void set_multisectors(::google::protobuf::uint32 value);

  // uint32 ecc_size = 10;
  void clear_ecc_size();
  static const int kEccSizeFieldNumber = 10;
  ::google::protobuf::uint32 ecc_size() const;
  void set_ecc_size(::google::protobuf::uint32 value);

  // uint64 cylinders_number = 12;
  void clear_cylinders_number();
  static const int kCylindersNumberFieldNumber = 12;
  ::google::protobuf::uint64 cylinders_number() const;
  void set_cylinders_number(::google::protobuf::uint64 value);

  // bool is_removable = 11;
  void clear_is_removable();
  static const int kIsRemovableFieldNumber = 11;
  bool is_removable() const;
  void set_is_removable(bool value);

  // uint32 tracks_per_cylinder = 13;
  void clear_tracks_per_cylinder();
  static const int kTracksPerCylinderFieldNumber = 13;
  ::google::protobuf::uint32 tracks_per_cylinder() const;
  void set_tracks_per_cylinder(::google::protobuf::uint32 value);

  // uint32 sectors_per_track = 14;
  void clear_sectors_per_track();
  static const int kSectorsPerTrackFieldNumber = 14;
  ::google::protobuf::uint32 sectors_per_track() const;
  void set_sectors_per_track(::google::protobuf::uint32 value);

  // uint32 bytes_per_sector = 15;
  void clear_bytes_per_sector();
  static const int kBytesPerSectorFieldNumber = 15;
  ::google::protobuf::uint32 bytes_per_sector() const;
  void set_bytes_per_sector(::google::protobuf::uint32 value);

  // uint64 supported_features = 17;
  void clear_supported_features();
  static const int kSupportedFeaturesFieldNumber = 17;
  ::google::protobuf::uint64 supported_features() const;
  void set_supported_features(::google::protobuf::uint64 value);

  // uint64 enabled_features = 18;
  void clear_enabled_features();
  static const int kEnabledFeaturesFieldNumber = 18;
  ::google::protobuf::uint64 enabled_features() const;
  void set_enabled_features(::google::protobuf::uint64 value);

  // uint32 heads_number = 16;
  void clear_heads_number();
  static const int kHeadsNumberFieldNumber = 16;
  ::google::protobuf::uint32 heads_number() const;
  void set_heads_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.AtaDrives.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr model_number_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr firmware_revision_;
  int bus_type_;
  int transfer_mode_;
  ::google::protobuf::uint64 drive_size_;
  ::google::protobuf::uint32 rotation_rate_;
  ::google::protobuf::uint32 buffer_size_;
  ::google::protobuf::uint32 multisectors_;
  ::google::protobuf::uint32 ecc_size_;
  ::google::protobuf::uint64 cylinders_number_;
  bool is_removable_;
  ::google::protobuf::uint32 tracks_per_cylinder_;
  ::google::protobuf::uint32 sectors_per_track_;
  ::google::protobuf::uint32 bytes_per_sector_;
  ::google::protobuf::uint64 supported_features_;
  ::google::protobuf::uint64 enabled_features_;
  ::google::protobuf::uint32 heads_number_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsAtaDrives_ItemImpl();
};
// -------------------------------------------------------------------

class AtaDrives : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.AtaDrives) */ {
 public:
  AtaDrives();
  virtual ~AtaDrives();

  AtaDrives(const AtaDrives& from);

  inline AtaDrives& operator=(const AtaDrives& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AtaDrives(AtaDrives&& from) noexcept
    : AtaDrives() {
    *this = ::std::move(from);
  }

  inline AtaDrives& operator=(AtaDrives&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const AtaDrives& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AtaDrives* internal_default_instance() {
    return reinterpret_cast<const AtaDrives*>(
               &_AtaDrives_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(AtaDrives* other);
  friend void swap(AtaDrives& a, AtaDrives& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AtaDrives* New() const PROTOBUF_FINAL { return New(NULL); }

  AtaDrives* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AtaDrives& from);
  void MergeFrom(const AtaDrives& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AtaDrives* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AtaDrives_Item Item;

  typedef AtaDrives_BusType BusType;
  static const BusType BUS_TYPE_UNKNOWN =
    AtaDrives_BusType_BUS_TYPE_UNKNOWN;
  static const BusType BUS_TYPE_SCSI =
    AtaDrives_BusType_BUS_TYPE_SCSI;
  static const BusType BUS_TYPE_ATAPI =
    AtaDrives_BusType_BUS_TYPE_ATAPI;
  static const BusType BUS_TYPE_ATA =
    AtaDrives_BusType_BUS_TYPE_ATA;
  static const BusType BUS_TYPE_IEEE1394 =
    AtaDrives_BusType_BUS_TYPE_IEEE1394;
  static const BusType BUS_TYPE_SSA =
    AtaDrives_BusType_BUS_TYPE_SSA;
  static const BusType BUS_TYPE_FIBRE =
    AtaDrives_BusType_BUS_TYPE_FIBRE;
  static const BusType BUS_TYPE_USB =
    AtaDrives_BusType_BUS_TYPE_USB;
  static const BusType BUS_TYPE_RAID =
    AtaDrives_BusType_BUS_TYPE_RAID;
  static const BusType BUS_TYPE_ISCSI =
    AtaDrives_BusType_BUS_TYPE_ISCSI;
  static const BusType BUS_TYPE_SAS =
    AtaDrives_BusType_BUS_TYPE_SAS;
  static const BusType BUS_TYPE_SATA =
    AtaDrives_BusType_BUS_TYPE_SATA;
  static const BusType BUS_TYPE_SD =
    AtaDrives_BusType_BUS_TYPE_SD;
  static const BusType BUS_TYPE_MMC =
    AtaDrives_BusType_BUS_TYPE_MMC;
  static const BusType BUS_TYPE_VIRTUAL =
    AtaDrives_BusType_BUS_TYPE_VIRTUAL;
  static const BusType BUS_TYPE_FILE_BACKED_VIRTUAL =
    AtaDrives_BusType_BUS_TYPE_FILE_BACKED_VIRTUAL;
  static inline bool BusType_IsValid(int value) {
    return AtaDrives_BusType_IsValid(value);
  }
  static const BusType BusType_MIN =
    AtaDrives_BusType_BusType_MIN;
  static const BusType BusType_MAX =
    AtaDrives_BusType_BusType_MAX;
  static const int BusType_ARRAYSIZE =
    AtaDrives_BusType_BusType_ARRAYSIZE;

  typedef AtaDrives_TransferMode TransferMode;
  static const TransferMode TRANSFER_MODE_UNKNOWN =
    AtaDrives_TransferMode_TRANSFER_MODE_UNKNOWN;
  static const TransferMode TRANSFER_MODE_PIO =
    AtaDrives_TransferMode_TRANSFER_MODE_PIO;
  static const TransferMode TRANSFER_MODE_PIO_DMA =
    AtaDrives_TransferMode_TRANSFER_MODE_PIO_DMA;
  static const TransferMode TRANSFER_MODE_ULTRA_DMA_133 =
    AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_133;
  static const TransferMode TRANSFER_MODE_ULTRA_DMA_100 =
    AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_100;
  static const TransferMode TRANSFER_MODE_ULTRA_DMA_66 =
    AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_66;
  static const TransferMode TRANSFER_MODE_ULTRA_DMA_44 =
    AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_44;
  static const TransferMode TRANSFER_MODE_ULTRA_DMA_33 =
    AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_33;
  static const TransferMode TRANSFER_MODE_ULTRA_DMA_25 =
    AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_25;
  static const TransferMode TRANSFER_MODE_ULTRA_DMA_16 =
    AtaDrives_TransferMode_TRANSFER_MODE_ULTRA_DMA_16;
  static const TransferMode TRANSFER_MODE_SATA_600 =
    AtaDrives_TransferMode_TRANSFER_MODE_SATA_600;
  static const TransferMode TRANSFER_MODE_SATA_300 =
    AtaDrives_TransferMode_TRANSFER_MODE_SATA_300;
  static const TransferMode TRANSFER_MODE_SATA_150 =
    AtaDrives_TransferMode_TRANSFER_MODE_SATA_150;
  static inline bool TransferMode_IsValid(int value) {
    return AtaDrives_TransferMode_IsValid(value);
  }
  static const TransferMode TransferMode_MIN =
    AtaDrives_TransferMode_TransferMode_MIN;
  static const TransferMode TransferMode_MAX =
    AtaDrives_TransferMode_TransferMode_MAX;
  static const int TransferMode_ARRAYSIZE =
    AtaDrives_TransferMode_TransferMode_ARRAYSIZE;

  typedef AtaDrives_Features Features;
  static const Features FEATURE_UNKNOWN =
    AtaDrives_Features_FEATURE_UNKNOWN;
  static const Features FEATURE_48BIT_LBA =
    AtaDrives_Features_FEATURE_48BIT_LBA;
  static const Features FEATURE_ADVANCED_POWER_MANAGEMENT =
    AtaDrives_Features_FEATURE_ADVANCED_POWER_MANAGEMENT;
  static const Features FEATURE_AUTOMATIC_ACOUSTIC_MANAGEMENT =
    AtaDrives_Features_FEATURE_AUTOMATIC_ACOUSTIC_MANAGEMENT;
  static const Features FEATURE_SMART =
    AtaDrives_Features_FEATURE_SMART;
  static const Features FEATURE_SMART_ERROR_LOGGING =
    AtaDrives_Features_FEATURE_SMART_ERROR_LOGGING;
  static const Features FEATURE_SMART_SELF_TEST =
    AtaDrives_Features_FEATURE_SMART_SELF_TEST;
  static const Features FEATURE_STREAMING =
    AtaDrives_Features_FEATURE_STREAMING;
  static const Features FEATURE_GENERAL_PURPOSE_LOGGING =
    AtaDrives_Features_FEATURE_GENERAL_PURPOSE_LOGGING;
  static const Features FEATURE_SECURITY_MODE =
    AtaDrives_Features_FEATURE_SECURITY_MODE;
  static const Features FEATURE_POWER_MANAGEMENT =
    AtaDrives_Features_FEATURE_POWER_MANAGEMENT;
  static const Features FEATURE_WRITE_CACHE =
    AtaDrives_Features_FEATURE_WRITE_CACHE;
  static const Features FEATURE_READ_LOCK_AHEAD =
    AtaDrives_Features_FEATURE_READ_LOCK_AHEAD;
  static const Features FEATURE_HOST_PROTECTED_AREA =
    AtaDrives_Features_FEATURE_HOST_PROTECTED_AREA;
  static const Features FEATURE_RELEASE_INTERRUPT =
    AtaDrives_Features_FEATURE_RELEASE_INTERRUPT;
  static const Features FEATURE_POWER_UP_IN_STANDBY =
    AtaDrives_Features_FEATURE_POWER_UP_IN_STANDBY;
  static const Features FEATURE_DEVICE_CONFIGURATION_OVERLAY =
    AtaDrives_Features_FEATURE_DEVICE_CONFIGURATION_OVERLAY;
  static const Features FEATURE_SERVICE_INTERRUPT =
    AtaDrives_Features_FEATURE_SERVICE_INTERRUPT;
  static const Features FEATURE_NATIVE_COMMAND_QUEUING =
    AtaDrives_Features_FEATURE_NATIVE_COMMAND_QUEUING;
  static const Features FEATURE_TRIM =
    AtaDrives_Features_FEATURE_TRIM;
  static inline bool Features_IsValid(int value) {
    return AtaDrives_Features_IsValid(value);
  }
  static const Features Features_MIN =
    AtaDrives_Features_Features_MIN;
  static const Features Features_MAX =
    AtaDrives_Features_Features_MAX;
  static const int Features_ARRAYSIZE =
    AtaDrives_Features_Features_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.AtaDrives.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::AtaDrives_Item& item(int index) const;
  ::aspia::proto::AtaDrives_Item* mutable_item(int index);
  ::aspia::proto::AtaDrives_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.AtaDrives)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsAtaDrivesImpl();
};
// -------------------------------------------------------------------

class VideoAdapters_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.VideoAdapters.Item) */ {
 public:
  VideoAdapters_Item();
  virtual ~VideoAdapters_Item();

  VideoAdapters_Item(const VideoAdapters_Item& from);

  inline VideoAdapters_Item& operator=(const VideoAdapters_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VideoAdapters_Item(VideoAdapters_Item&& from) noexcept
    : VideoAdapters_Item() {
    *this = ::std::move(from);
  }

  inline VideoAdapters_Item& operator=(VideoAdapters_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const VideoAdapters_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoAdapters_Item* internal_default_instance() {
    return reinterpret_cast<const VideoAdapters_Item*>(
               &_VideoAdapters_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(VideoAdapters_Item* other);
  friend void swap(VideoAdapters_Item& a, VideoAdapters_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VideoAdapters_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  VideoAdapters_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VideoAdapters_Item& from);
  void MergeFrom(const VideoAdapters_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoAdapters_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string description = 1;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string adapter_string = 2;
  void clear_adapter_string();
  static const int kAdapterStringFieldNumber = 2;
  const ::std::string& adapter_string() const;
  void set_adapter_string(const ::std::string& value);
  #if LANG_CXX11
  void set_adapter_string(::std::string&& value);
  #endif
  void set_adapter_string(const char* value);
  void set_adapter_string(const char* value, size_t size);
  ::std::string* mutable_adapter_string();
  ::std::string* release_adapter_string();
  void set_allocated_adapter_string(::std::string* adapter_string);

  // string bios_string = 3;
  void clear_bios_string();
  static const int kBiosStringFieldNumber = 3;
  const ::std::string& bios_string() const;
  void set_bios_string(const ::std::string& value);
  #if LANG_CXX11
  void set_bios_string(::std::string&& value);
  #endif
  void set_bios_string(const char* value);
  void set_bios_string(const char* value, size_t size);
  ::std::string* mutable_bios_string();
  ::std::string* release_bios_string();
  void set_allocated_bios_string(::std::string* bios_string);

  // string chip_type = 4;
  void clear_chip_type();
  static const int kChipTypeFieldNumber = 4;
  const ::std::string& chip_type() const;
  void set_chip_type(const ::std::string& value);
  #if LANG_CXX11
  void set_chip_type(::std::string&& value);
  #endif
  void set_chip_type(const char* value);
  void set_chip_type(const char* value, size_t size);
  ::std::string* mutable_chip_type();
  ::std::string* release_chip_type();
  void set_allocated_chip_type(::std::string* chip_type);

  // string dac_type = 5;
  void clear_dac_type();
  static const int kDacTypeFieldNumber = 5;
  const ::std::string& dac_type() const;
  void set_dac_type(const ::std::string& value);
  #if LANG_CXX11
  void set_dac_type(::std::string&& value);
  #endif
  void set_dac_type(const char* value);
  void set_dac_type(const char* value, size_t size);
  ::std::string* mutable_dac_type();
  ::std::string* release_dac_type();
  void set_allocated_dac_type(::std::string* dac_type);

  // string driver_date = 6;
  void clear_driver_date();
  static const int kDriverDateFieldNumber = 6;
  const ::std::string& driver_date() const;
  void set_driver_date(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_date(::std::string&& value);
  #endif
  void set_driver_date(const char* value);
  void set_driver_date(const char* value, size_t size);
  ::std::string* mutable_driver_date();
  ::std::string* release_driver_date();
  void set_allocated_driver_date(::std::string* driver_date);

  // string driver_version = 7;
  void clear_driver_version();
  static const int kDriverVersionFieldNumber = 7;
  const ::std::string& driver_version() const;
  void set_driver_version(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_version(::std::string&& value);
  #endif
  void set_driver_version(const char* value);
  void set_driver_version(const char* value, size_t size);
  ::std::string* mutable_driver_version();
  ::std::string* release_driver_version();
  void set_allocated_driver_version(::std::string* driver_version);

  // string driver_provider = 8;
  void clear_driver_provider();
  static const int kDriverProviderFieldNumber = 8;
  const ::std::string& driver_provider() const;
  void set_driver_provider(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_provider(::std::string&& value);
  #endif
  void set_driver_provider(const char* value);
  void set_driver_provider(const char* value, size_t size);
  ::std::string* mutable_driver_provider();
  ::std::string* release_driver_provider();
  void set_allocated_driver_provider(::std::string* driver_provider);

  // uint64 memory_size = 9;
  void clear_memory_size();
  static const int kMemorySizeFieldNumber = 9;
  ::google::protobuf::uint64 memory_size() const;
  void set_memory_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.VideoAdapters.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr adapter_string_;
  ::google::protobuf::internal::ArenaStringPtr bios_string_;
  ::google::protobuf::internal::ArenaStringPtr chip_type_;
  ::google::protobuf::internal::ArenaStringPtr dac_type_;
  ::google::protobuf::internal::ArenaStringPtr driver_date_;
  ::google::protobuf::internal::ArenaStringPtr driver_version_;
  ::google::protobuf::internal::ArenaStringPtr driver_provider_;
  ::google::protobuf::uint64 memory_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsVideoAdapters_ItemImpl();
};
// -------------------------------------------------------------------

class VideoAdapters : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.VideoAdapters) */ {
 public:
  VideoAdapters();
  virtual ~VideoAdapters();

  VideoAdapters(const VideoAdapters& from);

  inline VideoAdapters& operator=(const VideoAdapters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VideoAdapters(VideoAdapters&& from) noexcept
    : VideoAdapters() {
    *this = ::std::move(from);
  }

  inline VideoAdapters& operator=(VideoAdapters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const VideoAdapters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoAdapters* internal_default_instance() {
    return reinterpret_cast<const VideoAdapters*>(
               &_VideoAdapters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(VideoAdapters* other);
  friend void swap(VideoAdapters& a, VideoAdapters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VideoAdapters* New() const PROTOBUF_FINAL { return New(NULL); }

  VideoAdapters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VideoAdapters& from);
  void MergeFrom(const VideoAdapters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoAdapters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef VideoAdapters_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.VideoAdapters.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::VideoAdapters_Item& item(int index) const;
  ::aspia::proto::VideoAdapters_Item* mutable_item(int index);
  ::aspia::proto::VideoAdapters_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::VideoAdapters_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::VideoAdapters_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.VideoAdapters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::VideoAdapters_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsVideoAdaptersImpl();
};
// -------------------------------------------------------------------

class Monitors_Timing : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Monitors.Timing) */ {
 public:
  Monitors_Timing();
  virtual ~Monitors_Timing();

  Monitors_Timing(const Monitors_Timing& from);

  inline Monitors_Timing& operator=(const Monitors_Timing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Monitors_Timing(Monitors_Timing&& from) noexcept
    : Monitors_Timing() {
    *this = ::std::move(from);
  }

  inline Monitors_Timing& operator=(Monitors_Timing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Monitors_Timing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Monitors_Timing* internal_default_instance() {
    return reinterpret_cast<const Monitors_Timing*>(
               &_Monitors_Timing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(Monitors_Timing* other);
  friend void swap(Monitors_Timing& a, Monitors_Timing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Monitors_Timing* New() const PROTOBUF_FINAL { return New(NULL); }

  Monitors_Timing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Monitors_Timing& from);
  void MergeFrom(const Monitors_Timing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Monitors_Timing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // int32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // int32 frequency = 3;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 3;
  ::google::protobuf::int32 frequency() const;
  void set_frequency(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Monitors.Timing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 frequency_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsMonitors_TimingImpl();
};
// -------------------------------------------------------------------

class Monitors_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Monitors.Item) */ {
 public:
  Monitors_Item();
  virtual ~Monitors_Item();

  Monitors_Item(const Monitors_Item& from);

  inline Monitors_Item& operator=(const Monitors_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Monitors_Item(Monitors_Item&& from) noexcept
    : Monitors_Item() {
    *this = ::std::move(from);
  }

  inline Monitors_Item& operator=(Monitors_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Monitors_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Monitors_Item* internal_default_instance() {
    return reinterpret_cast<const Monitors_Item*>(
               &_Monitors_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(Monitors_Item* other);
  friend void swap(Monitors_Item& a, Monitors_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Monitors_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Monitors_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Monitors_Item& from);
  void MergeFrom(const Monitors_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Monitors_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Monitors.Timing timings = 28;
  int timings_size() const;
  void clear_timings();
  static const int kTimingsFieldNumber = 28;
  const ::aspia::proto::Monitors_Timing& timings(int index) const;
  ::aspia::proto::Monitors_Timing* mutable_timings(int index);
  ::aspia::proto::Monitors_Timing* add_timings();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Timing >*
      mutable_timings();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Timing >&
      timings() const;

  // string system_name = 1;
  void clear_system_name();
  static const int kSystemNameFieldNumber = 1;
  const ::std::string& system_name() const;
  void set_system_name(const ::std::string& value);
  #if LANG_CXX11
  void set_system_name(::std::string&& value);
  #endif
  void set_system_name(const char* value);
  void set_system_name(const char* value, size_t size);
  ::std::string* mutable_system_name();
  ::std::string* release_system_name();
  void set_allocated_system_name(::std::string* system_name);

  // string monitor_name = 2;
  void clear_monitor_name();
  static const int kMonitorNameFieldNumber = 2;
  const ::std::string& monitor_name() const;
  void set_monitor_name(const ::std::string& value);
  #if LANG_CXX11
  void set_monitor_name(::std::string&& value);
  #endif
  void set_monitor_name(const char* value);
  void set_monitor_name(const char* value, size_t size);
  ::std::string* mutable_monitor_name();
  ::std::string* release_monitor_name();
  void set_allocated_monitor_name(::std::string* monitor_name);

  // string manufacturer_name = 3;
  void clear_manufacturer_name();
  static const int kManufacturerNameFieldNumber = 3;
  const ::std::string& manufacturer_name() const;
  void set_manufacturer_name(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer_name(::std::string&& value);
  #endif
  void set_manufacturer_name(const char* value);
  void set_manufacturer_name(const char* value, size_t size);
  ::std::string* mutable_manufacturer_name();
  ::std::string* release_manufacturer_name();
  void set_allocated_manufacturer_name(::std::string* manufacturer_name);

  // string monitor_id = 4;
  void clear_monitor_id();
  static const int kMonitorIdFieldNumber = 4;
  const ::std::string& monitor_id() const;
  void set_monitor_id(const ::std::string& value);
  #if LANG_CXX11
  void set_monitor_id(::std::string&& value);
  #endif
  void set_monitor_id(const char* value);
  void set_monitor_id(const char* value, size_t size);
  ::std::string* mutable_monitor_id();
  ::std::string* release_monitor_id();
  void set_allocated_monitor_id(::std::string* monitor_id);

  // string serial_number = 5;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 5;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // int32 edid_version = 6;
  void clear_edid_version();
  static const int kEdidVersionFieldNumber = 6;
  ::google::protobuf::int32 edid_version() const;
  void set_edid_version(::google::protobuf::int32 value);

  // int32 edid_revision = 7;
  void clear_edid_revision();
  static const int kEdidRevisionFieldNumber = 7;
  ::google::protobuf::int32 edid_revision() const;
  void set_edid_revision(::google::protobuf::int32 value);

  // int32 week_of_manufacture = 8;
  void clear_week_of_manufacture();
  static const int kWeekOfManufactureFieldNumber = 8;
  ::google::protobuf::int32 week_of_manufacture() const;
  void set_week_of_manufacture(::google::protobuf::int32 value);

  // int32 year_of_manufacture = 9;
  void clear_year_of_manufacture();
  static const int kYearOfManufactureFieldNumber = 9;
  ::google::protobuf::int32 year_of_manufacture() const;
  void set_year_of_manufacture(::google::protobuf::int32 value);

  // int32 max_horizontal_image_size = 10;
  void clear_max_horizontal_image_size();
  static const int kMaxHorizontalImageSizeFieldNumber = 10;
  ::google::protobuf::int32 max_horizontal_image_size() const;
  void set_max_horizontal_image_size(::google::protobuf::int32 value);

  // int32 max_vertical_image_size = 11;
  void clear_max_vertical_image_size();
  static const int kMaxVerticalImageSizeFieldNumber = 11;
  ::google::protobuf::int32 max_vertical_image_size() const;
  void set_max_vertical_image_size(::google::protobuf::int32 value);

  // int32 horizontal_resolution = 12;
  void clear_horizontal_resolution();
  static const int kHorizontalResolutionFieldNumber = 12;
  ::google::protobuf::int32 horizontal_resolution() const;
  void set_horizontal_resolution(::google::protobuf::int32 value);

  // int32 vertical_resoulution = 13;
  void clear_vertical_resoulution();
  static const int kVerticalResoulutionFieldNumber = 13;
  ::google::protobuf::int32 vertical_resoulution() const;
  void set_vertical_resoulution(::google::protobuf::int32 value);

  // double gamma = 14;
  void clear_gamma();
  static const int kGammaFieldNumber = 14;
  double gamma() const;
  void set_gamma(double value);

  // int32 min_horizontal_rate = 15;
  void clear_min_horizontal_rate();
  static const int kMinHorizontalRateFieldNumber = 15;
  ::google::protobuf::int32 min_horizontal_rate() const;
  void set_min_horizontal_rate(::google::protobuf::int32 value);

  // int32 max_horizontal_rate = 16;
  void clear_max_horizontal_rate();
  static const int kMaxHorizontalRateFieldNumber = 16;
  ::google::protobuf::int32 max_horizontal_rate() const;
  void set_max_horizontal_rate(::google::protobuf::int32 value);

  // int32 min_vertical_rate = 17;
  void clear_min_vertical_rate();
  static const int kMinVerticalRateFieldNumber = 17;
  ::google::protobuf::int32 min_vertical_rate() const;
  void set_min_vertical_rate(::google::protobuf::int32 value);

  // int32 max_vertical_rate = 18;
  void clear_max_vertical_rate();
  static const int kMaxVerticalRateFieldNumber = 18;
  ::google::protobuf::int32 max_vertical_rate() const;
  void set_max_vertical_rate(::google::protobuf::int32 value);

  // double pixel_clock = 19;
  void clear_pixel_clock();
  static const int kPixelClockFieldNumber = 19;
  double pixel_clock() const;
  void set_pixel_clock(double value);

  // int32 max_pixel_clock = 20;
  void clear_max_pixel_clock();
  static const int kMaxPixelClockFieldNumber = 20;
  ::google::protobuf::int32 max_pixel_clock() const;
  void set_max_pixel_clock(::google::protobuf::int32 value);

  // .aspia.proto.Monitors.InputSignalType input_signal_type = 21;
  void clear_input_signal_type();
  static const int kInputSignalTypeFieldNumber = 21;
  ::aspia::proto::Monitors_InputSignalType input_signal_type() const;
  void set_input_signal_type(::aspia::proto::Monitors_InputSignalType value);

  // bool default_gtf_supported = 22;
  void clear_default_gtf_supported();
  static const int kDefaultGtfSupportedFieldNumber = 22;
  bool default_gtf_supported() const;
  void set_default_gtf_supported(bool value);

  // bool suspend_supported = 23;
  void clear_suspend_supported();
  static const int kSuspendSupportedFieldNumber = 23;
  bool suspend_supported() const;
  void set_suspend_supported(bool value);

  // bool standby_supported = 24;
  void clear_standby_supported();
  static const int kStandbySupportedFieldNumber = 24;
  bool standby_supported() const;
  void set_standby_supported(bool value);

  // bool active_off_supported = 25;
  void clear_active_off_supported();
  static const int kActiveOffSupportedFieldNumber = 25;
  bool active_off_supported() const;
  void set_active_off_supported(bool value);

  // bool preferred_timing_mode_supported = 26;
  void clear_preferred_timing_mode_supported();
  static const int kPreferredTimingModeSupportedFieldNumber = 26;
  bool preferred_timing_mode_supported() const;
  void set_preferred_timing_mode_supported(bool value);

  // bool srgb_supported = 27;
  void clear_srgb_supported();
  static const int kSrgbSupportedFieldNumber = 27;
  bool srgb_supported() const;
  void set_srgb_supported(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Monitors.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Timing > timings_;
  ::google::protobuf::internal::ArenaStringPtr system_name_;
  ::google::protobuf::internal::ArenaStringPtr monitor_name_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_name_;
  ::google::protobuf::internal::ArenaStringPtr monitor_id_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::int32 edid_version_;
  ::google::protobuf::int32 edid_revision_;
  ::google::protobuf::int32 week_of_manufacture_;
  ::google::protobuf::int32 year_of_manufacture_;
  ::google::protobuf::int32 max_horizontal_image_size_;
  ::google::protobuf::int32 max_vertical_image_size_;
  ::google::protobuf::int32 horizontal_resolution_;
  ::google::protobuf::int32 vertical_resoulution_;
  double gamma_;
  ::google::protobuf::int32 min_horizontal_rate_;
  ::google::protobuf::int32 max_horizontal_rate_;
  ::google::protobuf::int32 min_vertical_rate_;
  ::google::protobuf::int32 max_vertical_rate_;
  double pixel_clock_;
  ::google::protobuf::int32 max_pixel_clock_;
  int input_signal_type_;
  bool default_gtf_supported_;
  bool suspend_supported_;
  bool standby_supported_;
  bool active_off_supported_;
  bool preferred_timing_mode_supported_;
  bool srgb_supported_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsMonitors_ItemImpl();
};
// -------------------------------------------------------------------

class Monitors : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Monitors) */ {
 public:
  Monitors();
  virtual ~Monitors();

  Monitors(const Monitors& from);

  inline Monitors& operator=(const Monitors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Monitors(Monitors&& from) noexcept
    : Monitors() {
    *this = ::std::move(from);
  }

  inline Monitors& operator=(Monitors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Monitors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Monitors* internal_default_instance() {
    return reinterpret_cast<const Monitors*>(
               &_Monitors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(Monitors* other);
  friend void swap(Monitors& a, Monitors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Monitors* New() const PROTOBUF_FINAL { return New(NULL); }

  Monitors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Monitors& from);
  void MergeFrom(const Monitors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Monitors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Monitors_Timing Timing;
  typedef Monitors_Item Item;

  typedef Monitors_InputSignalType InputSignalType;
  static const InputSignalType INPUT_SIGNAL_TYPE_UNKNOWN =
    Monitors_InputSignalType_INPUT_SIGNAL_TYPE_UNKNOWN;
  static const InputSignalType INPUT_SIGNAL_TYPE_ANALOG =
    Monitors_InputSignalType_INPUT_SIGNAL_TYPE_ANALOG;
  static const InputSignalType INPUT_SIGNAL_TYPE_DIGITAL =
    Monitors_InputSignalType_INPUT_SIGNAL_TYPE_DIGITAL;
  static inline bool InputSignalType_IsValid(int value) {
    return Monitors_InputSignalType_IsValid(value);
  }
  static const InputSignalType InputSignalType_MIN =
    Monitors_InputSignalType_InputSignalType_MIN;
  static const InputSignalType InputSignalType_MAX =
    Monitors_InputSignalType_InputSignalType_MAX;
  static const int InputSignalType_ARRAYSIZE =
    Monitors_InputSignalType_InputSignalType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Monitors.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Monitors_Item& item(int index) const;
  ::aspia::proto::Monitors_Item* mutable_item(int index);
  ::aspia::proto::Monitors_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Monitors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsMonitorsImpl();
};
// -------------------------------------------------------------------

class PowerOptions_Battery : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.PowerOptions.Battery) */ {
 public:
  PowerOptions_Battery();
  virtual ~PowerOptions_Battery();

  PowerOptions_Battery(const PowerOptions_Battery& from);

  inline PowerOptions_Battery& operator=(const PowerOptions_Battery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PowerOptions_Battery(PowerOptions_Battery&& from) noexcept
    : PowerOptions_Battery() {
    *this = ::std::move(from);
  }

  inline PowerOptions_Battery& operator=(PowerOptions_Battery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PowerOptions_Battery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PowerOptions_Battery* internal_default_instance() {
    return reinterpret_cast<const PowerOptions_Battery*>(
               &_PowerOptions_Battery_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(PowerOptions_Battery* other);
  friend void swap(PowerOptions_Battery& a, PowerOptions_Battery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PowerOptions_Battery* New() const PROTOBUF_FINAL { return New(NULL); }

  PowerOptions_Battery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PowerOptions_Battery& from);
  void MergeFrom(const PowerOptions_Battery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PowerOptions_Battery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PowerOptions_Battery_State State;
  static const State STATE_UNKNOWN =
    PowerOptions_Battery_State_STATE_UNKNOWN;
  static const State STATE_CHARGING =
    PowerOptions_Battery_State_STATE_CHARGING;
  static const State STATE_CRITICAL =
    PowerOptions_Battery_State_STATE_CRITICAL;
  static const State STATE_DISCHARGING =
    PowerOptions_Battery_State_STATE_DISCHARGING;
  static const State STATE_POWER_ONLINE =
    PowerOptions_Battery_State_STATE_POWER_ONLINE;
  static inline bool State_IsValid(int value) {
    return PowerOptions_Battery_State_IsValid(value);
  }
  static const State State_MIN =
    PowerOptions_Battery_State_State_MIN;
  static const State State_MAX =
    PowerOptions_Battery_State_State_MAX;
  static const int State_ARRAYSIZE =
    PowerOptions_Battery_State_State_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string device_name = 1;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 1;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  #if LANG_CXX11
  void set_device_name(::std::string&& value);
  #endif
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // string manufacturer = 2;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 2;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string manufacture_date = 3;
  void clear_manufacture_date();
  static const int kManufactureDateFieldNumber = 3;
  const ::std::string& manufacture_date() const;
  void set_manufacture_date(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacture_date(::std::string&& value);
  #endif
  void set_manufacture_date(const char* value);
  void set_manufacture_date(const char* value, size_t size);
  ::std::string* mutable_manufacture_date();
  ::std::string* release_manufacture_date();
  void set_allocated_manufacture_date(::std::string* manufacture_date);

  // string unique_id = 4;
  void clear_unique_id();
  static const int kUniqueIdFieldNumber = 4;
  const ::std::string& unique_id() const;
  void set_unique_id(const ::std::string& value);
  #if LANG_CXX11
  void set_unique_id(::std::string&& value);
  #endif
  void set_unique_id(const char* value);
  void set_unique_id(const char* value, size_t size);
  ::std::string* mutable_unique_id();
  ::std::string* release_unique_id();
  void set_allocated_unique_id(::std::string* unique_id);

  // string serial_number = 5;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 5;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string temperature = 6;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 6;
  const ::std::string& temperature() const;
  void set_temperature(const ::std::string& value);
  #if LANG_CXX11
  void set_temperature(::std::string&& value);
  #endif
  void set_temperature(const char* value);
  void set_temperature(const char* value, size_t size);
  ::std::string* mutable_temperature();
  ::std::string* release_temperature();
  void set_allocated_temperature(::std::string* temperature);

  // string type = 8;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // int32 design_capacity = 7;
  void clear_design_capacity();
  static const int kDesignCapacityFieldNumber = 7;
  ::google::protobuf::int32 design_capacity() const;
  void set_design_capacity(::google::protobuf::int32 value);

  // int32 full_charged_capacity = 9;
  void clear_full_charged_capacity();
  static const int kFullChargedCapacityFieldNumber = 9;
  ::google::protobuf::int32 full_charged_capacity() const;
  void set_full_charged_capacity(::google::protobuf::int32 value);

  // int32 depreciation = 10;
  void clear_depreciation();
  static const int kDepreciationFieldNumber = 10;
  ::google::protobuf::int32 depreciation() const;
  void set_depreciation(::google::protobuf::int32 value);

  // int32 current_capacity = 11;
  void clear_current_capacity();
  static const int kCurrentCapacityFieldNumber = 11;
  ::google::protobuf::int32 current_capacity() const;
  void set_current_capacity(::google::protobuf::int32 value);

  // int32 voltage = 12;
  void clear_voltage();
  static const int kVoltageFieldNumber = 12;
  ::google::protobuf::int32 voltage() const;
  void set_voltage(::google::protobuf::int32 value);

  // uint32 state = 13;
  void clear_state();
  static const int kStateFieldNumber = 13;
  ::google::protobuf::uint32 state() const;
  void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.PowerOptions.Battery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr manufacture_date_;
  ::google::protobuf::internal::ArenaStringPtr unique_id_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr temperature_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::int32 design_capacity_;
  ::google::protobuf::int32 full_charged_capacity_;
  ::google::protobuf::int32 depreciation_;
  ::google::protobuf::int32 current_capacity_;
  ::google::protobuf::int32 voltage_;
  ::google::protobuf::uint32 state_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsPowerOptions_BatteryImpl();
};
// -------------------------------------------------------------------

class PowerOptions : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.PowerOptions) */ {
 public:
  PowerOptions();
  virtual ~PowerOptions();

  PowerOptions(const PowerOptions& from);

  inline PowerOptions& operator=(const PowerOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PowerOptions(PowerOptions&& from) noexcept
    : PowerOptions() {
    *this = ::std::move(from);
  }

  inline PowerOptions& operator=(PowerOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PowerOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PowerOptions* internal_default_instance() {
    return reinterpret_cast<const PowerOptions*>(
               &_PowerOptions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(PowerOptions* other);
  friend void swap(PowerOptions& a, PowerOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PowerOptions* New() const PROTOBUF_FINAL { return New(NULL); }

  PowerOptions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PowerOptions& from);
  void MergeFrom(const PowerOptions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PowerOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PowerOptions_Battery Battery;

  typedef PowerOptions_PowerSource PowerSource;
  static const PowerSource POWER_SOURCE_UNKNOWN =
    PowerOptions_PowerSource_POWER_SOURCE_UNKNOWN;
  static const PowerSource POWER_SOURCE_DC_BATTERY =
    PowerOptions_PowerSource_POWER_SOURCE_DC_BATTERY;
  static const PowerSource POWER_SOURCE_AC_LINE =
    PowerOptions_PowerSource_POWER_SOURCE_AC_LINE;
  static inline bool PowerSource_IsValid(int value) {
    return PowerOptions_PowerSource_IsValid(value);
  }
  static const PowerSource PowerSource_MIN =
    PowerOptions_PowerSource_PowerSource_MIN;
  static const PowerSource PowerSource_MAX =
    PowerOptions_PowerSource_PowerSource_MAX;
  static const int PowerSource_ARRAYSIZE =
    PowerOptions_PowerSource_PowerSource_ARRAYSIZE;

  typedef PowerOptions_BatteryStatus BatteryStatus;
  static const BatteryStatus BATTERY_STATUS_UNKNOWN =
    PowerOptions_BatteryStatus_BATTERY_STATUS_UNKNOWN;
  static const BatteryStatus BATTERY_STATUS_HIGH =
    PowerOptions_BatteryStatus_BATTERY_STATUS_HIGH;
  static const BatteryStatus BATTERY_STATUS_LOW =
    PowerOptions_BatteryStatus_BATTERY_STATUS_LOW;
  static const BatteryStatus BATTERY_STATUS_CRITICAL =
    PowerOptions_BatteryStatus_BATTERY_STATUS_CRITICAL;
  static const BatteryStatus BATTERY_STATUS_CHARGING =
    PowerOptions_BatteryStatus_BATTERY_STATUS_CHARGING;
  static const BatteryStatus BATTERY_STATUS_NO_BATTERY =
    PowerOptions_BatteryStatus_BATTERY_STATUS_NO_BATTERY;
  static inline bool BatteryStatus_IsValid(int value) {
    return PowerOptions_BatteryStatus_IsValid(value);
  }
  static const BatteryStatus BatteryStatus_MIN =
    PowerOptions_BatteryStatus_BatteryStatus_MIN;
  static const BatteryStatus BatteryStatus_MAX =
    PowerOptions_BatteryStatus_BatteryStatus_MAX;
  static const int BatteryStatus_ARRAYSIZE =
    PowerOptions_BatteryStatus_BatteryStatus_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.PowerOptions.Battery battery = 6;
  int battery_size() const;
  void clear_battery();
  static const int kBatteryFieldNumber = 6;
  const ::aspia::proto::PowerOptions_Battery& battery(int index) const;
  ::aspia::proto::PowerOptions_Battery* mutable_battery(int index);
  ::aspia::proto::PowerOptions_Battery* add_battery();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::PowerOptions_Battery >*
      mutable_battery();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::PowerOptions_Battery >&
      battery() const;

  // .aspia.proto.PowerOptions.PowerSource power_source = 1;
  void clear_power_source();
  static const int kPowerSourceFieldNumber = 1;
  ::aspia::proto::PowerOptions_PowerSource power_source() const;
  void set_power_source(::aspia::proto::PowerOptions_PowerSource value);

  // .aspia.proto.PowerOptions.BatteryStatus battery_status = 2;
  void clear_battery_status();
  static const int kBatteryStatusFieldNumber = 2;
  ::aspia::proto::PowerOptions_BatteryStatus battery_status() const;
  void set_battery_status(::aspia::proto::PowerOptions_BatteryStatus value);

  // int64 full_battery_life_time = 3;
  void clear_full_battery_life_time();
  static const int kFullBatteryLifeTimeFieldNumber = 3;
  ::google::protobuf::int64 full_battery_life_time() const;
  void set_full_battery_life_time(::google::protobuf::int64 value);

  // int64 remaining_battery_life_time = 4;
  void clear_remaining_battery_life_time();
  static const int kRemainingBatteryLifeTimeFieldNumber = 4;
  ::google::protobuf::int64 remaining_battery_life_time() const;
  void set_remaining_battery_life_time(::google::protobuf::int64 value);

  // int32 battery_life_percent = 5;
  void clear_battery_life_percent();
  static const int kBatteryLifePercentFieldNumber = 5;
  ::google::protobuf::int32 battery_life_percent() const;
  void set_battery_life_percent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.PowerOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::PowerOptions_Battery > battery_;
  int power_source_;
  int battery_status_;
  ::google::protobuf::int64 full_battery_life_time_;
  ::google::protobuf::int64 remaining_battery_life_time_;
  ::google::protobuf::int32 battery_life_percent_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsPowerOptionsImpl();
};
// -------------------------------------------------------------------

class Printers_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Printers.Item) */ {
 public:
  Printers_Item();
  virtual ~Printers_Item();

  Printers_Item(const Printers_Item& from);

  inline Printers_Item& operator=(const Printers_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Printers_Item(Printers_Item&& from) noexcept
    : Printers_Item() {
    *this = ::std::move(from);
  }

  inline Printers_Item& operator=(Printers_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Printers_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Printers_Item* internal_default_instance() {
    return reinterpret_cast<const Printers_Item*>(
               &_Printers_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(Printers_Item* other);
  friend void swap(Printers_Item& a, Printers_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Printers_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Printers_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Printers_Item& from);
  void MergeFrom(const Printers_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Printers_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Printers_Item_Orientation Orientation;
  static const Orientation ORIENTATION_UNKNOWN =
    Printers_Item_Orientation_ORIENTATION_UNKNOWN;
  static const Orientation ORIENTATION_PORTRAIT =
    Printers_Item_Orientation_ORIENTATION_PORTRAIT;
  static const Orientation ORIENTATION_LANDSCAPE =
    Printers_Item_Orientation_ORIENTATION_LANDSCAPE;
  static inline bool Orientation_IsValid(int value) {
    return Printers_Item_Orientation_IsValid(value);
  }
  static const Orientation Orientation_MIN =
    Printers_Item_Orientation_Orientation_MIN;
  static const Orientation Orientation_MAX =
    Printers_Item_Orientation_Orientation_MAX;
  static const int Orientation_ARRAYSIZE =
    Printers_Item_Orientation_Orientation_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string share_name = 4;
  void clear_share_name();
  static const int kShareNameFieldNumber = 4;
  const ::std::string& share_name() const;
  void set_share_name(const ::std::string& value);
  #if LANG_CXX11
  void set_share_name(::std::string&& value);
  #endif
  void set_share_name(const char* value);
  void set_share_name(const char* value, size_t size);
  ::std::string* mutable_share_name();
  ::std::string* release_share_name();
  void set_allocated_share_name(::std::string* share_name);

  // string port_name = 5;
  void clear_port_name();
  static const int kPortNameFieldNumber = 5;
  const ::std::string& port_name() const;
  void set_port_name(const ::std::string& value);
  #if LANG_CXX11
  void set_port_name(::std::string&& value);
  #endif
  void set_port_name(const char* value);
  void set_port_name(const char* value, size_t size);
  ::std::string* mutable_port_name();
  ::std::string* release_port_name();
  void set_allocated_port_name(::std::string* port_name);

  // string driver_name = 6;
  void clear_driver_name();
  static const int kDriverNameFieldNumber = 6;
  const ::std::string& driver_name() const;
  void set_driver_name(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_name(::std::string&& value);
  #endif
  void set_driver_name(const char* value);
  void set_driver_name(const char* value, size_t size);
  ::std::string* mutable_driver_name();
  ::std::string* release_driver_name();
  void set_allocated_driver_name(::std::string* driver_name);

  // string device_name = 7;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 7;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  #if LANG_CXX11
  void set_device_name(::std::string&& value);
  #endif
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // string print_processor = 8;
  void clear_print_processor();
  static const int kPrintProcessorFieldNumber = 8;
  const ::std::string& print_processor() const;
  void set_print_processor(const ::std::string& value);
  #if LANG_CXX11
  void set_print_processor(::std::string&& value);
  #endif
  void set_print_processor(const char* value);
  void set_print_processor(const char* value, size_t size);
  ::std::string* mutable_print_processor();
  ::std::string* release_print_processor();
  void set_allocated_print_processor(::std::string* print_processor);

  // string data_type = 9;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 9;
  const ::std::string& data_type() const;
  void set_data_type(const ::std::string& value);
  #if LANG_CXX11
  void set_data_type(::std::string&& value);
  #endif
  void set_data_type(const char* value);
  void set_data_type(const char* value, size_t size);
  ::std::string* mutable_data_type();
  ::std::string* release_data_type();
  void set_allocated_data_type(::std::string* data_type);

  // string server_name = 10;
  void clear_server_name();
  static const int kServerNameFieldNumber = 10;
  const ::std::string& server_name() const;
  void set_server_name(const ::std::string& value);
  #if LANG_CXX11
  void set_server_name(::std::string&& value);
  #endif
  void set_server_name(const char* value);
  void set_server_name(const char* value, size_t size);
  ::std::string* mutable_server_name();
  ::std::string* release_server_name();
  void set_allocated_server_name(::std::string* server_name);

  // string location = 11;
  void clear_location();
  static const int kLocationFieldNumber = 11;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // string comment = 12;
  void clear_comment();
  static const int kCommentFieldNumber = 12;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // bool is_default = 2;
  void clear_is_default();
  static const int kIsDefaultFieldNumber = 2;
  bool is_default() const;
  void set_is_default(bool value);

  // bool is_shared = 3;
  void clear_is_shared();
  static const int kIsSharedFieldNumber = 3;
  bool is_shared() const;
  void set_is_shared(bool value);

  // int32 jobs_count = 13;
  void clear_jobs_count();
  static const int kJobsCountFieldNumber = 13;
  ::google::protobuf::int32 jobs_count() const;
  void set_jobs_count(::google::protobuf::int32 value);

  // int32 paper_width = 14;
  void clear_paper_width();
  static const int kPaperWidthFieldNumber = 14;
  ::google::protobuf::int32 paper_width() const;
  void set_paper_width(::google::protobuf::int32 value);

  // int32 paper_length = 15;
  void clear_paper_length();
  static const int kPaperLengthFieldNumber = 15;
  ::google::protobuf::int32 paper_length() const;
  void set_paper_length(::google::protobuf::int32 value);

  // int32 print_quality = 16;
  void clear_print_quality();
  static const int kPrintQualityFieldNumber = 16;
  ::google::protobuf::int32 print_quality() const;
  void set_print_quality(::google::protobuf::int32 value);

  // .aspia.proto.Printers.Item.Orientation orientation = 17;
  void clear_orientation();
  static const int kOrientationFieldNumber = 17;
  ::aspia::proto::Printers_Item_Orientation orientation() const;
  void set_orientation(::aspia::proto::Printers_Item_Orientation value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Printers.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr share_name_;
  ::google::protobuf::internal::ArenaStringPtr port_name_;
  ::google::protobuf::internal::ArenaStringPtr driver_name_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  ::google::protobuf::internal::ArenaStringPtr print_processor_;
  ::google::protobuf::internal::ArenaStringPtr data_type_;
  ::google::protobuf::internal::ArenaStringPtr server_name_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  bool is_default_;
  bool is_shared_;
  ::google::protobuf::int32 jobs_count_;
  ::google::protobuf::int32 paper_width_;
  ::google::protobuf::int32 paper_length_;
  ::google::protobuf::int32 print_quality_;
  int orientation_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsPrinters_ItemImpl();
};
// -------------------------------------------------------------------

class Printers : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Printers) */ {
 public:
  Printers();
  virtual ~Printers();

  Printers(const Printers& from);

  inline Printers& operator=(const Printers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Printers(Printers&& from) noexcept
    : Printers() {
    *this = ::std::move(from);
  }

  inline Printers& operator=(Printers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Printers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Printers* internal_default_instance() {
    return reinterpret_cast<const Printers*>(
               &_Printers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(Printers* other);
  friend void swap(Printers& a, Printers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Printers* New() const PROTOBUF_FINAL { return New(NULL); }

  Printers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Printers& from);
  void MergeFrom(const Printers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Printers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Printers_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Printers.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Printers_Item& item(int index) const;
  ::aspia::proto::Printers_Item* mutable_item(int index);
  ::aspia::proto::Printers_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Printers_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Printers_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Printers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Printers_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsPrintersImpl();
};
// -------------------------------------------------------------------

class WindowsDevices_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.WindowsDevices.Item) */ {
 public:
  WindowsDevices_Item();
  virtual ~WindowsDevices_Item();

  WindowsDevices_Item(const WindowsDevices_Item& from);

  inline WindowsDevices_Item& operator=(const WindowsDevices_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WindowsDevices_Item(WindowsDevices_Item&& from) noexcept
    : WindowsDevices_Item() {
    *this = ::std::move(from);
  }

  inline WindowsDevices_Item& operator=(WindowsDevices_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const WindowsDevices_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WindowsDevices_Item* internal_default_instance() {
    return reinterpret_cast<const WindowsDevices_Item*>(
               &_WindowsDevices_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(WindowsDevices_Item* other);
  friend void swap(WindowsDevices_Item& a, WindowsDevices_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WindowsDevices_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  WindowsDevices_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const WindowsDevices_Item& from);
  void MergeFrom(const WindowsDevices_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WindowsDevices_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string friendly_name = 1;
  void clear_friendly_name();
  static const int kFriendlyNameFieldNumber = 1;
  const ::std::string& friendly_name() const;
  void set_friendly_name(const ::std::string& value);
  #if LANG_CXX11
  void set_friendly_name(::std::string&& value);
  #endif
  void set_friendly_name(const char* value);
  void set_friendly_name(const char* value, size_t size);
  ::std::string* mutable_friendly_name();
  ::std::string* release_friendly_name();
  void set_allocated_friendly_name(::std::string* friendly_name);

  // string description = 2;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string driver_version = 3;
  void clear_driver_version();
  static const int kDriverVersionFieldNumber = 3;
  const ::std::string& driver_version() const;
  void set_driver_version(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_version(::std::string&& value);
  #endif
  void set_driver_version(const char* value);
  void set_driver_version(const char* value, size_t size);
  ::std::string* mutable_driver_version();
  ::std::string* release_driver_version();
  void set_allocated_driver_version(::std::string* driver_version);

  // string driver_date = 4;
  void clear_driver_date();
  static const int kDriverDateFieldNumber = 4;
  const ::std::string& driver_date() const;
  void set_driver_date(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_date(::std::string&& value);
  #endif
  void set_driver_date(const char* value);
  void set_driver_date(const char* value, size_t size);
  ::std::string* mutable_driver_date();
  ::std::string* release_driver_date();
  void set_allocated_driver_date(::std::string* driver_date);

  // string driver_vendor = 5;
  void clear_driver_vendor();
  static const int kDriverVendorFieldNumber = 5;
  const ::std::string& driver_vendor() const;
  void set_driver_vendor(const ::std::string& value);
  #if LANG_CXX11
  void set_driver_vendor(::std::string&& value);
  #endif
  void set_driver_vendor(const char* value);
  void set_driver_vendor(const char* value, size_t size);
  ::std::string* mutable_driver_vendor();
  ::std::string* release_driver_vendor();
  void set_allocated_driver_vendor(::std::string* driver_vendor);

  // string device_id = 6;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 6;
  const ::std::string& device_id() const;
  void set_device_id(const ::std::string& value);
  #if LANG_CXX11
  void set_device_id(::std::string&& value);
  #endif
  void set_device_id(const char* value);
  void set_device_id(const char* value, size_t size);
  ::std::string* mutable_device_id();
  ::std::string* release_device_id();
  void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:aspia.proto.WindowsDevices.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr friendly_name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr driver_version_;
  ::google::protobuf::internal::ArenaStringPtr driver_date_;
  ::google::protobuf::internal::ArenaStringPtr driver_vendor_;
  ::google::protobuf::internal::ArenaStringPtr device_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsWindowsDevices_ItemImpl();
};
// -------------------------------------------------------------------

class WindowsDevices : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.WindowsDevices) */ {
 public:
  WindowsDevices();
  virtual ~WindowsDevices();

  WindowsDevices(const WindowsDevices& from);

  inline WindowsDevices& operator=(const WindowsDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WindowsDevices(WindowsDevices&& from) noexcept
    : WindowsDevices() {
    *this = ::std::move(from);
  }

  inline WindowsDevices& operator=(WindowsDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const WindowsDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WindowsDevices* internal_default_instance() {
    return reinterpret_cast<const WindowsDevices*>(
               &_WindowsDevices_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(WindowsDevices* other);
  friend void swap(WindowsDevices& a, WindowsDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WindowsDevices* New() const PROTOBUF_FINAL { return New(NULL); }

  WindowsDevices* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const WindowsDevices& from);
  void MergeFrom(const WindowsDevices& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WindowsDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef WindowsDevices_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.WindowsDevices.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::WindowsDevices_Item& item(int index) const;
  ::aspia::proto::WindowsDevices_Item* mutable_item(int index);
  ::aspia::proto::WindowsDevices_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::WindowsDevices_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::WindowsDevices_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.WindowsDevices)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::WindowsDevices_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsWindowsDevicesImpl();
};
// -------------------------------------------------------------------

class Programs_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Programs.Item) */ {
 public:
  Programs_Item();
  virtual ~Programs_Item();

  Programs_Item(const Programs_Item& from);

  inline Programs_Item& operator=(const Programs_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Programs_Item(Programs_Item&& from) noexcept
    : Programs_Item() {
    *this = ::std::move(from);
  }

  inline Programs_Item& operator=(Programs_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Programs_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Programs_Item* internal_default_instance() {
    return reinterpret_cast<const Programs_Item*>(
               &_Programs_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(Programs_Item* other);
  friend void swap(Programs_Item& a, Programs_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Programs_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Programs_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Programs_Item& from);
  void MergeFrom(const Programs_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Programs_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string publisher = 3;
  void clear_publisher();
  static const int kPublisherFieldNumber = 3;
  const ::std::string& publisher() const;
  void set_publisher(const ::std::string& value);
  #if LANG_CXX11
  void set_publisher(::std::string&& value);
  #endif
  void set_publisher(const char* value);
  void set_publisher(const char* value, size_t size);
  ::std::string* mutable_publisher();
  ::std::string* release_publisher();
  void set_allocated_publisher(::std::string* publisher);

  // string install_date = 4;
  void clear_install_date();
  static const int kInstallDateFieldNumber = 4;
  const ::std::string& install_date() const;
  void set_install_date(const ::std::string& value);
  #if LANG_CXX11
  void set_install_date(::std::string&& value);
  #endif
  void set_install_date(const char* value);
  void set_install_date(const char* value, size_t size);
  ::std::string* mutable_install_date();
  ::std::string* release_install_date();
  void set_allocated_install_date(::std::string* install_date);

  // string install_location = 5;
  void clear_install_location();
  static const int kInstallLocationFieldNumber = 5;
  const ::std::string& install_location() const;
  void set_install_location(const ::std::string& value);
  #if LANG_CXX11
  void set_install_location(::std::string&& value);
  #endif
  void set_install_location(const char* value);
  void set_install_location(const char* value, size_t size);
  ::std::string* mutable_install_location();
  ::std::string* release_install_location();
  void set_allocated_install_location(::std::string* install_location);

  // @@protoc_insertion_point(class_scope:aspia.proto.Programs.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr publisher_;
  ::google::protobuf::internal::ArenaStringPtr install_date_;
  ::google::protobuf::internal::ArenaStringPtr install_location_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsPrograms_ItemImpl();
};
// -------------------------------------------------------------------

class Programs : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Programs) */ {
 public:
  Programs();
  virtual ~Programs();

  Programs(const Programs& from);

  inline Programs& operator=(const Programs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Programs(Programs&& from) noexcept
    : Programs() {
    *this = ::std::move(from);
  }

  inline Programs& operator=(Programs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Programs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Programs* internal_default_instance() {
    return reinterpret_cast<const Programs*>(
               &_Programs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(Programs* other);
  friend void swap(Programs& a, Programs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Programs* New() const PROTOBUF_FINAL { return New(NULL); }

  Programs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Programs& from);
  void MergeFrom(const Programs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Programs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Programs_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Programs.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Programs_Item& item(int index) const;
  ::aspia::proto::Programs_Item* mutable_item(int index);
  ::aspia::proto::Programs_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Programs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsProgramsImpl();
};
// -------------------------------------------------------------------

class Services_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Services.Item) */ {
 public:
  Services_Item();
  virtual ~Services_Item();

  Services_Item(const Services_Item& from);

  inline Services_Item& operator=(const Services_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Services_Item(Services_Item&& from) noexcept
    : Services_Item() {
    *this = ::std::move(from);
  }

  inline Services_Item& operator=(Services_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Services_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Services_Item* internal_default_instance() {
    return reinterpret_cast<const Services_Item*>(
               &_Services_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(Services_Item* other);
  friend void swap(Services_Item& a, Services_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Services_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Services_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Services_Item& from);
  void MergeFrom(const Services_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Services_Item_Status Status;
  static const Status STATUS_UNKNOWN =
    Services_Item_Status_STATUS_UNKNOWN;
  static const Status STATUS_CONTINUE_PENDING =
    Services_Item_Status_STATUS_CONTINUE_PENDING;
  static const Status STATUS_PAUSE_PENDING =
    Services_Item_Status_STATUS_PAUSE_PENDING;
  static const Status STATUS_PAUSED =
    Services_Item_Status_STATUS_PAUSED;
  static const Status STATUS_RUNNING =
    Services_Item_Status_STATUS_RUNNING;
  static const Status STATUS_START_PENDING =
    Services_Item_Status_STATUS_START_PENDING;
  static const Status STATUS_STOP_PENDING =
    Services_Item_Status_STATUS_STOP_PENDING;
  static const Status STATUS_STOPPED =
    Services_Item_Status_STATUS_STOPPED;
  static inline bool Status_IsValid(int value) {
    return Services_Item_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Services_Item_Status_Status_MIN;
  static const Status Status_MAX =
    Services_Item_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Services_Item_Status_Status_ARRAYSIZE;

  typedef Services_Item_StartupType StartupType;
  static const StartupType STARTUP_TYPE_UNKNOWN =
    Services_Item_StartupType_STARTUP_TYPE_UNKNOWN;
  static const StartupType STARTUP_TYPE_AUTO_START =
    Services_Item_StartupType_STARTUP_TYPE_AUTO_START;
  static const StartupType STARTUP_TYPE_DEMAND_START =
    Services_Item_StartupType_STARTUP_TYPE_DEMAND_START;
  static const StartupType STARTUP_TYPE_DISABLED =
    Services_Item_StartupType_STARTUP_TYPE_DISABLED;
  static const StartupType STARTUP_TYPE_BOOT_START =
    Services_Item_StartupType_STARTUP_TYPE_BOOT_START;
  static const StartupType STARTUP_TYPE_SYSTEM_START =
    Services_Item_StartupType_STARTUP_TYPE_SYSTEM_START;
  static inline bool StartupType_IsValid(int value) {
    return Services_Item_StartupType_IsValid(value);
  }
  static const StartupType StartupType_MIN =
    Services_Item_StartupType_StartupType_MIN;
  static const StartupType StartupType_MAX =
    Services_Item_StartupType_StartupType_MAX;
  static const int StartupType_ARRAYSIZE =
    Services_Item_StartupType_StartupType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string display_name = 2;
  void clear_display_name();
  static const int kDisplayNameFieldNumber = 2;
  const ::std::string& display_name() const;
  void set_display_name(const ::std::string& value);
  #if LANG_CXX11
  void set_display_name(::std::string&& value);
  #endif
  void set_display_name(const char* value);
  void set_display_name(const char* value, size_t size);
  ::std::string* mutable_display_name();
  ::std::string* release_display_name();
  void set_allocated_display_name(::std::string* display_name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string binary_path = 6;
  void clear_binary_path();
  static const int kBinaryPathFieldNumber = 6;
  const ::std::string& binary_path() const;
  void set_binary_path(const ::std::string& value);
  #if LANG_CXX11
  void set_binary_path(::std::string&& value);
  #endif
  void set_binary_path(const char* value);
  void set_binary_path(const char* value, size_t size);
  ::std::string* mutable_binary_path();
  ::std::string* release_binary_path();
  void set_allocated_binary_path(::std::string* binary_path);

  // string start_name = 7;
  void clear_start_name();
  static const int kStartNameFieldNumber = 7;
  const ::std::string& start_name() const;
  void set_start_name(const ::std::string& value);
  #if LANG_CXX11
  void set_start_name(::std::string&& value);
  #endif
  void set_start_name(const char* value);
  void set_start_name(const char* value, size_t size);
  ::std::string* mutable_start_name();
  ::std::string* release_start_name();
  void set_allocated_start_name(::std::string* start_name);

  // .aspia.proto.Services.Item.Status status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::aspia::proto::Services_Item_Status status() const;
  void set_status(::aspia::proto::Services_Item_Status value);

  // .aspia.proto.Services.Item.StartupType startup_type = 5;
  void clear_startup_type();
  static const int kStartupTypeFieldNumber = 5;
  ::aspia::proto::Services_Item_StartupType startup_type() const;
  void set_startup_type(::aspia::proto::Services_Item_StartupType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Services.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr display_name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr binary_path_;
  ::google::protobuf::internal::ArenaStringPtr start_name_;
  int status_;
  int startup_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsServices_ItemImpl();
};
// -------------------------------------------------------------------

class Services : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Services) */ {
 public:
  Services();
  virtual ~Services();

  Services(const Services& from);

  inline Services& operator=(const Services& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Services(Services&& from) noexcept
    : Services() {
    *this = ::std::move(from);
  }

  inline Services& operator=(Services&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Services& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Services* internal_default_instance() {
    return reinterpret_cast<const Services*>(
               &_Services_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(Services* other);
  friend void swap(Services& a, Services& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Services* New() const PROTOBUF_FINAL { return New(NULL); }

  Services* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Services& from);
  void MergeFrom(const Services& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Services* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Services_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Services.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Services_Item& item(int index) const;
  ::aspia::proto::Services_Item* mutable_item(int index);
  ::aspia::proto::Services_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Services)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsServicesImpl();
};
// -------------------------------------------------------------------

class Processes_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Processes.Item) */ {
 public:
  Processes_Item();
  virtual ~Processes_Item();

  Processes_Item(const Processes_Item& from);

  inline Processes_Item& operator=(const Processes_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Processes_Item(Processes_Item&& from) noexcept
    : Processes_Item() {
    *this = ::std::move(from);
  }

  inline Processes_Item& operator=(Processes_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Processes_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Processes_Item* internal_default_instance() {
    return reinterpret_cast<const Processes_Item*>(
               &_Processes_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(Processes_Item* other);
  friend void swap(Processes_Item& a, Processes_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Processes_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Processes_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Processes_Item& from);
  void MergeFrom(const Processes_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Processes_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string process_name = 1;
  void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  const ::std::string& process_name() const;
  void set_process_name(const ::std::string& value);
  #if LANG_CXX11
  void set_process_name(::std::string&& value);
  #endif
  void set_process_name(const char* value);
  void set_process_name(const char* value, size_t size);
  ::std::string* mutable_process_name();
  ::std::string* release_process_name();
  void set_allocated_process_name(::std::string* process_name);

  // string file_path = 2;
  void clear_file_path();
  static const int kFilePathFieldNumber = 2;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  #if LANG_CXX11
  void set_file_path(::std::string&& value);
  #endif
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // string description = 5;
  void clear_description();
  static const int kDescriptionFieldNumber = 5;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // uint64 used_memory = 3;
  void clear_used_memory();
  static const int kUsedMemoryFieldNumber = 3;
  ::google::protobuf::uint64 used_memory() const;
  void set_used_memory(::google::protobuf::uint64 value);

  // uint64 used_swap = 4;
  void clear_used_swap();
  static const int kUsedSwapFieldNumber = 4;
  ::google::protobuf::uint64 used_swap() const;
  void set_used_swap(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Processes.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr process_name_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::uint64 used_memory_;
  ::google::protobuf::uint64 used_swap_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsProcesses_ItemImpl();
};
// -------------------------------------------------------------------

class Processes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Processes) */ {
 public:
  Processes();
  virtual ~Processes();

  Processes(const Processes& from);

  inline Processes& operator=(const Processes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Processes(Processes&& from) noexcept
    : Processes() {
    *this = ::std::move(from);
  }

  inline Processes& operator=(Processes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Processes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Processes* internal_default_instance() {
    return reinterpret_cast<const Processes*>(
               &_Processes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(Processes* other);
  friend void swap(Processes& a, Processes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Processes* New() const PROTOBUF_FINAL { return New(NULL); }

  Processes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Processes& from);
  void MergeFrom(const Processes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Processes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Processes_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Processes.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Processes_Item& item(int index) const;
  ::aspia::proto::Processes_Item* mutable_item(int index);
  ::aspia::proto::Processes_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Processes_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Processes_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Processes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Processes_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsProcessesImpl();
};
// -------------------------------------------------------------------

class NetworkCards_Item_IpAddress : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.NetworkCards.Item.IpAddress) */ {
 public:
  NetworkCards_Item_IpAddress();
  virtual ~NetworkCards_Item_IpAddress();

  NetworkCards_Item_IpAddress(const NetworkCards_Item_IpAddress& from);

  inline NetworkCards_Item_IpAddress& operator=(const NetworkCards_Item_IpAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards_Item_IpAddress(NetworkCards_Item_IpAddress&& from) noexcept
    : NetworkCards_Item_IpAddress() {
    *this = ::std::move(from);
  }

  inline NetworkCards_Item_IpAddress& operator=(NetworkCards_Item_IpAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards_Item_IpAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkCards_Item_IpAddress* internal_default_instance() {
    return reinterpret_cast<const NetworkCards_Item_IpAddress*>(
               &_NetworkCards_Item_IpAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(NetworkCards_Item_IpAddress* other);
  friend void swap(NetworkCards_Item_IpAddress& a, NetworkCards_Item_IpAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards_Item_IpAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards_Item_IpAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards_Item_IpAddress& from);
  void MergeFrom(const NetworkCards_Item_IpAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards_Item_IpAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // string mask = 2;
  void clear_mask();
  static const int kMaskFieldNumber = 2;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // @@protoc_insertion_point(class_scope:aspia.proto.NetworkCards.Item.IpAddress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsNetworkCards_Item_IpAddressImpl();
};
// -------------------------------------------------------------------

class NetworkCards_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.NetworkCards.Item) */ {
 public:
  NetworkCards_Item();
  virtual ~NetworkCards_Item();

  NetworkCards_Item(const NetworkCards_Item& from);

  inline NetworkCards_Item& operator=(const NetworkCards_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards_Item(NetworkCards_Item&& from) noexcept
    : NetworkCards_Item() {
    *this = ::std::move(from);
  }

  inline NetworkCards_Item& operator=(NetworkCards_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkCards_Item* internal_default_instance() {
    return reinterpret_cast<const NetworkCards_Item*>(
               &_NetworkCards_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(NetworkCards_Item* other);
  friend void swap(NetworkCards_Item& a, NetworkCards_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards_Item& from);
  void MergeFrom(const NetworkCards_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NetworkCards_Item_IpAddress IpAddress;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.NetworkCards.Item.IpAddress ip_address = 11;
  int ip_address_size() const;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 11;
  const ::aspia::proto::NetworkCards_Item_IpAddress& ip_address(int index) const;
  ::aspia::proto::NetworkCards_Item_IpAddress* mutable_ip_address(int index);
  ::aspia::proto::NetworkCards_Item_IpAddress* add_ip_address();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >*
      mutable_ip_address();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >&
      ip_address() const;

  // repeated string gateway_address = 12;
  int gateway_address_size() const;
  void clear_gateway_address();
  static const int kGatewayAddressFieldNumber = 12;
  const ::std::string& gateway_address(int index) const;
  ::std::string* mutable_gateway_address(int index);
  void set_gateway_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_gateway_address(int index, ::std::string&& value);
  #endif
  void set_gateway_address(int index, const char* value);
  void set_gateway_address(int index, const char* value, size_t size);
  ::std::string* add_gateway_address();
  void add_gateway_address(const ::std::string& value);
  #if LANG_CXX11
  void add_gateway_address(::std::string&& value);
  #endif
  void add_gateway_address(const char* value);
  void add_gateway_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& gateway_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_gateway_address();

  // repeated string dhcp_server_address = 13;
  int dhcp_server_address_size() const;
  void clear_dhcp_server_address();
  static const int kDhcpServerAddressFieldNumber = 13;
  const ::std::string& dhcp_server_address(int index) const;
  ::std::string* mutable_dhcp_server_address(int index);
  void set_dhcp_server_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dhcp_server_address(int index, ::std::string&& value);
  #endif
  void set_dhcp_server_address(int index, const char* value);
  void set_dhcp_server_address(int index, const char* value, size_t size);
  ::std::string* add_dhcp_server_address();
  void add_dhcp_server_address(const ::std::string& value);
  #if LANG_CXX11
  void add_dhcp_server_address(::std::string&& value);
  #endif
  void add_dhcp_server_address(const char* value);
  void add_dhcp_server_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dhcp_server_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dhcp_server_address();

  // repeated string dns_server_address = 14;
  int dns_server_address_size() const;
  void clear_dns_server_address();
  static const int kDnsServerAddressFieldNumber = 14;
  const ::std::string& dns_server_address(int index) const;
  ::std::string* mutable_dns_server_address(int index);
  void set_dns_server_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_dns_server_address(int index, ::std::string&& value);
  #endif
  void set_dns_server_address(int index, const char* value);
  void set_dns_server_address(int index, const char* value, size_t size);
  ::std::string* add_dns_server_address();
  void add_dns_server_address(const ::std::string& value);
  #if LANG_CXX11
  void add_dns_server_address(::std::string&& value);
  #endif
  void add_dns_server_address(const char* value);
  void add_dns_server_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dns_server_address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dns_server_address();

  // string adapter_name = 1;
  void clear_adapter_name();
  static const int kAdapterNameFieldNumber = 1;
  const ::std::string& adapter_name() const;
  void set_adapter_name(const ::std::string& value);
  #if LANG_CXX11
  void set_adapter_name(::std::string&& value);
  #endif
  void set_adapter_name(const char* value);
  void set_adapter_name(const char* value, size_t size);
  ::std::string* mutable_adapter_name();
  ::std::string* release_adapter_name();
  void set_allocated_adapter_name(::std::string* adapter_name);

  // string connection_name = 2;
  void clear_connection_name();
  static const int kConnectionNameFieldNumber = 2;
  const ::std::string& connection_name() const;
  void set_connection_name(const ::std::string& value);
  #if LANG_CXX11
  void set_connection_name(::std::string&& value);
  #endif
  void set_connection_name(const char* value);
  void set_connection_name(const char* value, size_t size);
  ::std::string* mutable_connection_name();
  ::std::string* release_connection_name();
  void set_allocated_connection_name(::std::string* connection_name);

  // string interface_type = 3;
  void clear_interface_type();
  static const int kInterfaceTypeFieldNumber = 3;
  const ::std::string& interface_type() const;
  void set_interface_type(const ::std::string& value);
  #if LANG_CXX11
  void set_interface_type(::std::string&& value);
  #endif
  void set_interface_type(const char* value);
  void set_interface_type(const char* value, size_t size);
  ::std::string* mutable_interface_type();
  ::std::string* release_interface_type();
  void set_allocated_interface_type(::std::string* interface_type);

  // string mac_address = 6;
  void clear_mac_address();
  static const int kMacAddressFieldNumber = 6;
  const ::std::string& mac_address() const;
  void set_mac_address(const ::std::string& value);
  #if LANG_CXX11
  void set_mac_address(::std::string&& value);
  #endif
  void set_mac_address(const char* value);
  void set_mac_address(const char* value, size_t size);
  ::std::string* mutable_mac_address();
  ::std::string* release_mac_address();
  void set_allocated_mac_address(::std::string* mac_address);

  // string primary_wins_server = 8;
  void clear_primary_wins_server();
  static const int kPrimaryWinsServerFieldNumber = 8;
  const ::std::string& primary_wins_server() const;
  void set_primary_wins_server(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_wins_server(::std::string&& value);
  #endif
  void set_primary_wins_server(const char* value);
  void set_primary_wins_server(const char* value, size_t size);
  ::std::string* mutable_primary_wins_server();
  ::std::string* release_primary_wins_server();
  void set_allocated_primary_wins_server(::std::string* primary_wins_server);

  // string secondary_wins_server = 9;
  void clear_secondary_wins_server();
  static const int kSecondaryWinsServerFieldNumber = 9;
  const ::std::string& secondary_wins_server() const;
  void set_secondary_wins_server(const ::std::string& value);
  #if LANG_CXX11
  void set_secondary_wins_server(::std::string&& value);
  #endif
  void set_secondary_wins_server(const char* value);
  void set_secondary_wins_server(const char* value, size_t size);
  ::std::string* mutable_secondary_wins_server();
  ::std::string* release_secondary_wins_server();
  void set_allocated_secondary_wins_server(::std::string* secondary_wins_server);

  // uint32 mtu = 4;
  void clear_mtu();
  static const int kMtuFieldNumber = 4;
  ::google::protobuf::uint32 mtu() const;
  void set_mtu(::google::protobuf::uint32 value);

  // uint32 speed = 5;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  ::google::protobuf::uint32 speed() const;
  void set_speed(::google::protobuf::uint32 value);

  // bool is_wins_enabled = 7;
  void clear_is_wins_enabled();
  static const int kIsWinsEnabledFieldNumber = 7;
  bool is_wins_enabled() const;
  void set_is_wins_enabled(bool value);

  // bool is_dhcp_enabled = 10;
  void clear_is_dhcp_enabled();
  static const int kIsDhcpEnabledFieldNumber = 10;
  bool is_dhcp_enabled() const;
  void set_is_dhcp_enabled(bool value);

  // @@protoc_insertion_point(class_scope:aspia.proto.NetworkCards.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress > ip_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> gateway_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dhcp_server_address_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dns_server_address_;
  ::google::protobuf::internal::ArenaStringPtr adapter_name_;
  ::google::protobuf::internal::ArenaStringPtr connection_name_;
  ::google::protobuf::internal::ArenaStringPtr interface_type_;
  ::google::protobuf::internal::ArenaStringPtr mac_address_;
  ::google::protobuf::internal::ArenaStringPtr primary_wins_server_;
  ::google::protobuf::internal::ArenaStringPtr secondary_wins_server_;
  ::google::protobuf::uint32 mtu_;
  ::google::protobuf::uint32 speed_;
  bool is_wins_enabled_;
  bool is_dhcp_enabled_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsNetworkCards_ItemImpl();
};
// -------------------------------------------------------------------

class NetworkCards : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.NetworkCards) */ {
 public:
  NetworkCards();
  virtual ~NetworkCards();

  NetworkCards(const NetworkCards& from);

  inline NetworkCards& operator=(const NetworkCards& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkCards(NetworkCards&& from) noexcept
    : NetworkCards() {
    *this = ::std::move(from);
  }

  inline NetworkCards& operator=(NetworkCards&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NetworkCards& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkCards* internal_default_instance() {
    return reinterpret_cast<const NetworkCards*>(
               &_NetworkCards_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(NetworkCards* other);
  friend void swap(NetworkCards& a, NetworkCards& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkCards* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkCards* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetworkCards& from);
  void MergeFrom(const NetworkCards& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkCards* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NetworkCards_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.NetworkCards.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::NetworkCards_Item& item(int index) const;
  ::aspia::proto::NetworkCards_Item* mutable_item(int index);
  ::aspia::proto::NetworkCards_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.NetworkCards)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsNetworkCardsImpl();
};
// -------------------------------------------------------------------

class OpenConnections_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.OpenConnections.Item) */ {
 public:
  OpenConnections_Item();
  virtual ~OpenConnections_Item();

  OpenConnections_Item(const OpenConnections_Item& from);

  inline OpenConnections_Item& operator=(const OpenConnections_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenConnections_Item(OpenConnections_Item&& from) noexcept
    : OpenConnections_Item() {
    *this = ::std::move(from);
  }

  inline OpenConnections_Item& operator=(OpenConnections_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OpenConnections_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenConnections_Item* internal_default_instance() {
    return reinterpret_cast<const OpenConnections_Item*>(
               &_OpenConnections_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(OpenConnections_Item* other);
  friend void swap(OpenConnections_Item& a, OpenConnections_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenConnections_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  OpenConnections_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpenConnections_Item& from);
  void MergeFrom(const OpenConnections_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenConnections_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef OpenConnections_Item_Protocol Protocol;
  static const Protocol PROTOCOL_UNKNOWN =
    OpenConnections_Item_Protocol_PROTOCOL_UNKNOWN;
  static const Protocol PROTOCOL_TCP =
    OpenConnections_Item_Protocol_PROTOCOL_TCP;
  static const Protocol PROTOCOL_UDP =
    OpenConnections_Item_Protocol_PROTOCOL_UDP;
  static inline bool Protocol_IsValid(int value) {
    return OpenConnections_Item_Protocol_IsValid(value);
  }
  static const Protocol Protocol_MIN =
    OpenConnections_Item_Protocol_Protocol_MIN;
  static const Protocol Protocol_MAX =
    OpenConnections_Item_Protocol_Protocol_MAX;
  static const int Protocol_ARRAYSIZE =
    OpenConnections_Item_Protocol_Protocol_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string process_name = 1;
  void clear_process_name();
  static const int kProcessNameFieldNumber = 1;
  const ::std::string& process_name() const;
  void set_process_name(const ::std::string& value);
  #if LANG_CXX11
  void set_process_name(::std::string&& value);
  #endif
  void set_process_name(const char* value);
  void set_process_name(const char* value, size_t size);
  ::std::string* mutable_process_name();
  ::std::string* release_process_name();
  void set_allocated_process_name(::std::string* process_name);

  // string local_address = 3;
  void clear_local_address();
  static const int kLocalAddressFieldNumber = 3;
  const ::std::string& local_address() const;
  void set_local_address(const ::std::string& value);
  #if LANG_CXX11
  void set_local_address(::std::string&& value);
  #endif
  void set_local_address(const char* value);
  void set_local_address(const char* value, size_t size);
  ::std::string* mutable_local_address();
  ::std::string* release_local_address();
  void set_allocated_local_address(::std::string* local_address);

  // string remote_address = 4;
  void clear_remote_address();
  static const int kRemoteAddressFieldNumber = 4;
  const ::std::string& remote_address() const;
  void set_remote_address(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_address(::std::string&& value);
  #endif
  void set_remote_address(const char* value);
  void set_remote_address(const char* value, size_t size);
  ::std::string* mutable_remote_address();
  ::std::string* release_remote_address();
  void set_allocated_remote_address(::std::string* remote_address);

  // string state = 7;
  void clear_state();
  static const int kStateFieldNumber = 7;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  #if LANG_CXX11
  void set_state(::std::string&& value);
  #endif
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // .aspia.proto.OpenConnections.Item.Protocol protocol = 2;
  void clear_protocol();
  static const int kProtocolFieldNumber = 2;
  ::aspia::proto::OpenConnections_Item_Protocol protocol() const;
  void set_protocol(::aspia::proto::OpenConnections_Item_Protocol value);

  // uint32 local_port = 5;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 5;
  ::google::protobuf::uint32 local_port() const;
  void set_local_port(::google::protobuf::uint32 value);

  // uint32 remote_port = 6;
  void clear_remote_port();
  static const int kRemotePortFieldNumber = 6;
  ::google::protobuf::uint32 remote_port() const;
  void set_remote_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.OpenConnections.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr process_name_;
  ::google::protobuf::internal::ArenaStringPtr local_address_;
  ::google::protobuf::internal::ArenaStringPtr remote_address_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  int protocol_;
  ::google::protobuf::uint32 local_port_;
  ::google::protobuf::uint32 remote_port_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsOpenConnections_ItemImpl();
};
// -------------------------------------------------------------------

class OpenConnections : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.OpenConnections) */ {
 public:
  OpenConnections();
  virtual ~OpenConnections();

  OpenConnections(const OpenConnections& from);

  inline OpenConnections& operator=(const OpenConnections& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenConnections(OpenConnections&& from) noexcept
    : OpenConnections() {
    *this = ::std::move(from);
  }

  inline OpenConnections& operator=(OpenConnections&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OpenConnections& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenConnections* internal_default_instance() {
    return reinterpret_cast<const OpenConnections*>(
               &_OpenConnections_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(OpenConnections* other);
  friend void swap(OpenConnections& a, OpenConnections& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenConnections* New() const PROTOBUF_FINAL { return New(NULL); }

  OpenConnections* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OpenConnections& from);
  void MergeFrom(const OpenConnections& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpenConnections* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef OpenConnections_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.OpenConnections.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::OpenConnections_Item& item(int index) const;
  ::aspia::proto::OpenConnections_Item* mutable_item(int index);
  ::aspia::proto::OpenConnections_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.OpenConnections)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsOpenConnectionsImpl();
};
// -------------------------------------------------------------------

class SharedResources_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.SharedResources.Item) */ {
 public:
  SharedResources_Item();
  virtual ~SharedResources_Item();

  SharedResources_Item(const SharedResources_Item& from);

  inline SharedResources_Item& operator=(const SharedResources_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SharedResources_Item(SharedResources_Item&& from) noexcept
    : SharedResources_Item() {
    *this = ::std::move(from);
  }

  inline SharedResources_Item& operator=(SharedResources_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SharedResources_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SharedResources_Item* internal_default_instance() {
    return reinterpret_cast<const SharedResources_Item*>(
               &_SharedResources_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(SharedResources_Item* other);
  friend void swap(SharedResources_Item& a, SharedResources_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SharedResources_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  SharedResources_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SharedResources_Item& from);
  void MergeFrom(const SharedResources_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedResources_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SharedResources_Item_Type Type;
  static const Type TYPE_UNKNOWN =
    SharedResources_Item_Type_TYPE_UNKNOWN;
  static const Type TYPE_DISK =
    SharedResources_Item_Type_TYPE_DISK;
  static const Type TYPE_PRINTER =
    SharedResources_Item_Type_TYPE_PRINTER;
  static const Type TYPE_DEVICE =
    SharedResources_Item_Type_TYPE_DEVICE;
  static const Type TYPE_IPC =
    SharedResources_Item_Type_TYPE_IPC;
  static const Type TYPE_SPECIAL =
    SharedResources_Item_Type_TYPE_SPECIAL;
  static const Type TYPE_TEMPORARY =
    SharedResources_Item_Type_TYPE_TEMPORARY;
  static inline bool Type_IsValid(int value) {
    return SharedResources_Item_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SharedResources_Item_Type_Type_MIN;
  static const Type Type_MAX =
    SharedResources_Item_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SharedResources_Item_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string local_path = 4;
  void clear_local_path();
  static const int kLocalPathFieldNumber = 4;
  const ::std::string& local_path() const;
  void set_local_path(const ::std::string& value);
  #if LANG_CXX11
  void set_local_path(::std::string&& value);
  #endif
  void set_local_path(const char* value);
  void set_local_path(const char* value, size_t size);
  ::std::string* mutable_local_path();
  ::std::string* release_local_path();
  void set_allocated_local_path(::std::string* local_path);

  // .aspia.proto.SharedResources.Item.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::aspia::proto::SharedResources_Item_Type type() const;
  void set_type(::aspia::proto::SharedResources_Item_Type value);

  // uint32 current_uses = 5;
  void clear_current_uses();
  static const int kCurrentUsesFieldNumber = 5;
  ::google::protobuf::uint32 current_uses() const;
  void set_current_uses(::google::protobuf::uint32 value);

  // uint32 maximum_uses = 6;
  void clear_maximum_uses();
  static const int kMaximumUsesFieldNumber = 6;
  ::google::protobuf::uint32 maximum_uses() const;
  void set_maximum_uses(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.SharedResources.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr local_path_;
  int type_;
  ::google::protobuf::uint32 current_uses_;
  ::google::protobuf::uint32 maximum_uses_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSharedResources_ItemImpl();
};
// -------------------------------------------------------------------

class SharedResources : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.SharedResources) */ {
 public:
  SharedResources();
  virtual ~SharedResources();

  SharedResources(const SharedResources& from);

  inline SharedResources& operator=(const SharedResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SharedResources(SharedResources&& from) noexcept
    : SharedResources() {
    *this = ::std::move(from);
  }

  inline SharedResources& operator=(SharedResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SharedResources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SharedResources* internal_default_instance() {
    return reinterpret_cast<const SharedResources*>(
               &_SharedResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(SharedResources* other);
  friend void swap(SharedResources& a, SharedResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SharedResources* New() const PROTOBUF_FINAL { return New(NULL); }

  SharedResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SharedResources& from);
  void MergeFrom(const SharedResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SharedResources_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.SharedResources.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::SharedResources_Item& item(int index) const;
  ::aspia::proto::SharedResources_Item* mutable_item(int index);
  ::aspia::proto::SharedResources_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.SharedResources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSharedResourcesImpl();
};
// -------------------------------------------------------------------

class Routes_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Routes.Item) */ {
 public:
  Routes_Item();
  virtual ~Routes_Item();

  Routes_Item(const Routes_Item& from);

  inline Routes_Item& operator=(const Routes_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Routes_Item(Routes_Item&& from) noexcept
    : Routes_Item() {
    *this = ::std::move(from);
  }

  inline Routes_Item& operator=(Routes_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Routes_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Routes_Item* internal_default_instance() {
    return reinterpret_cast<const Routes_Item*>(
               &_Routes_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(Routes_Item* other);
  friend void swap(Routes_Item& a, Routes_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Routes_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Routes_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Routes_Item& from);
  void MergeFrom(const Routes_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Routes_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string destonation = 1;
  void clear_destonation();
  static const int kDestonationFieldNumber = 1;
  const ::std::string& destonation() const;
  void set_destonation(const ::std::string& value);
  #if LANG_CXX11
  void set_destonation(::std::string&& value);
  #endif
  void set_destonation(const char* value);
  void set_destonation(const char* value, size_t size);
  ::std::string* mutable_destonation();
  ::std::string* release_destonation();
  void set_allocated_destonation(::std::string* destonation);

  // string mask = 2;
  void clear_mask();
  static const int kMaskFieldNumber = 2;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // string gateway = 3;
  void clear_gateway();
  static const int kGatewayFieldNumber = 3;
  const ::std::string& gateway() const;
  void set_gateway(const ::std::string& value);
  #if LANG_CXX11
  void set_gateway(::std::string&& value);
  #endif
  void set_gateway(const char* value);
  void set_gateway(const char* value, size_t size);
  ::std::string* mutable_gateway();
  ::std::string* release_gateway();
  void set_allocated_gateway(::std::string* gateway);

  // uint32 metric = 4;
  void clear_metric();
  static const int kMetricFieldNumber = 4;
  ::google::protobuf::uint32 metric() const;
  void set_metric(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Routes.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr destonation_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  ::google::protobuf::internal::ArenaStringPtr gateway_;
  ::google::protobuf::uint32 metric_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsRoutes_ItemImpl();
};
// -------------------------------------------------------------------

class Routes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Routes) */ {
 public:
  Routes();
  virtual ~Routes();

  Routes(const Routes& from);

  inline Routes& operator=(const Routes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Routes(Routes&& from) noexcept
    : Routes() {
    *this = ::std::move(from);
  }

  inline Routes& operator=(Routes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Routes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Routes* internal_default_instance() {
    return reinterpret_cast<const Routes*>(
               &_Routes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(Routes* other);
  friend void swap(Routes& a, Routes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Routes* New() const PROTOBUF_FINAL { return New(NULL); }

  Routes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Routes& from);
  void MergeFrom(const Routes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Routes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Routes_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Routes.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Routes_Item& item(int index) const;
  ::aspia::proto::Routes_Item* mutable_item(int index);
  ::aspia::proto::Routes_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Routes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsRoutesImpl();
};
// -------------------------------------------------------------------

class Users_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Users.Item) */ {
 public:
  Users_Item();
  virtual ~Users_Item();

  Users_Item(const Users_Item& from);

  inline Users_Item& operator=(const Users_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Users_Item(Users_Item&& from) noexcept
    : Users_Item() {
    *this = ::std::move(from);
  }

  inline Users_Item& operator=(Users_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Users_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Users_Item* internal_default_instance() {
    return reinterpret_cast<const Users_Item*>(
               &_Users_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(Users_Item* other);
  friend void swap(Users_Item& a, Users_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Users_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Users_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Users_Item& from);
  void MergeFrom(const Users_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Users_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string full_name = 2;
  void clear_full_name();
  static const int kFullNameFieldNumber = 2;
  const ::std::string& full_name() const;
  void set_full_name(const ::std::string& value);
  #if LANG_CXX11
  void set_full_name(::std::string&& value);
  #endif
  void set_full_name(const char* value);
  void set_full_name(const char* value, size_t size);
  ::std::string* mutable_full_name();
  ::std::string* release_full_name();
  void set_allocated_full_name(::std::string* full_name);

  // string comment = 3;
  void clear_comment();
  static const int kCommentFieldNumber = 3;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // bool is_disabled = 4;
  void clear_is_disabled();
  static const int kIsDisabledFieldNumber = 4;
  bool is_disabled() const;
  void set_is_disabled(bool value);

  // bool is_password_cant_change = 5;
  void clear_is_password_cant_change();
  static const int kIsPasswordCantChangeFieldNumber = 5;
  bool is_password_cant_change() const;
  void set_is_password_cant_change(bool value);

  // bool is_password_expired = 6;
  void clear_is_password_expired();
  static const int kIsPasswordExpiredFieldNumber = 6;
  bool is_password_expired() const;
  void set_is_password_expired(bool value);

  // bool is_dont_expire_password = 7;
  void clear_is_dont_expire_password();
  static const int kIsDontExpirePasswordFieldNumber = 7;
  bool is_dont_expire_password() const;
  void set_is_dont_expire_password(bool value);

  // bool is_lockout = 8;
  void clear_is_lockout();
  static const int kIsLockoutFieldNumber = 8;
  bool is_lockout() const;
  void set_is_lockout(bool value);

  // uint32 number_logons = 9;
  void clear_number_logons();
  static const int kNumberLogonsFieldNumber = 9;
  ::google::protobuf::uint32 number_logons() const;
  void set_number_logons(::google::protobuf::uint32 value);

  // uint32 bad_password_count = 10;
  void clear_bad_password_count();
  static const int kBadPasswordCountFieldNumber = 10;
  ::google::protobuf::uint32 bad_password_count() const;
  void set_bad_password_count(::google::protobuf::uint32 value);

  // int64 last_logon_time = 11;
  void clear_last_logon_time();
  static const int kLastLogonTimeFieldNumber = 11;
  ::google::protobuf::int64 last_logon_time() const;
  void set_last_logon_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Users.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr full_name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  bool is_disabled_;
  bool is_password_cant_change_;
  bool is_password_expired_;
  bool is_dont_expire_password_;
  bool is_lockout_;
  ::google::protobuf::uint32 number_logons_;
  ::google::protobuf::uint32 bad_password_count_;
  ::google::protobuf::int64 last_logon_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUsers_ItemImpl();
};
// -------------------------------------------------------------------

class Users : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Users) */ {
 public:
  Users();
  virtual ~Users();

  Users(const Users& from);

  inline Users& operator=(const Users& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Users(Users&& from) noexcept
    : Users() {
    *this = ::std::move(from);
  }

  inline Users& operator=(Users&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Users& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Users* internal_default_instance() {
    return reinterpret_cast<const Users*>(
               &_Users_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(Users* other);
  friend void swap(Users& a, Users& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Users* New() const PROTOBUF_FINAL { return New(NULL); }

  Users* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Users& from);
  void MergeFrom(const Users& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Users* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Users_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Users.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Users_Item& item(int index) const;
  ::aspia::proto::Users_Item* mutable_item(int index);
  ::aspia::proto::Users_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Users)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUsersImpl();
};
// -------------------------------------------------------------------

class UserGroups_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.UserGroups.Item) */ {
 public:
  UserGroups_Item();
  virtual ~UserGroups_Item();

  UserGroups_Item(const UserGroups_Item& from);

  inline UserGroups_Item& operator=(const UserGroups_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserGroups_Item(UserGroups_Item&& from) noexcept
    : UserGroups_Item() {
    *this = ::std::move(from);
  }

  inline UserGroups_Item& operator=(UserGroups_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const UserGroups_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserGroups_Item* internal_default_instance() {
    return reinterpret_cast<const UserGroups_Item*>(
               &_UserGroups_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(UserGroups_Item* other);
  friend void swap(UserGroups_Item& a, UserGroups_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserGroups_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  UserGroups_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserGroups_Item& from);
  void MergeFrom(const UserGroups_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserGroups_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string comment = 2;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:aspia.proto.UserGroups.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUserGroups_ItemImpl();
};
// -------------------------------------------------------------------

class UserGroups : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.UserGroups) */ {
 public:
  UserGroups();
  virtual ~UserGroups();

  UserGroups(const UserGroups& from);

  inline UserGroups& operator=(const UserGroups& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserGroups(UserGroups&& from) noexcept
    : UserGroups() {
    *this = ::std::move(from);
  }

  inline UserGroups& operator=(UserGroups&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const UserGroups& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserGroups* internal_default_instance() {
    return reinterpret_cast<const UserGroups*>(
               &_UserGroups_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(UserGroups* other);
  friend void swap(UserGroups& a, UserGroups& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserGroups* New() const PROTOBUF_FINAL { return New(NULL); }

  UserGroups* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserGroups& from);
  void MergeFrom(const UserGroups& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserGroups* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef UserGroups_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.UserGroups.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::UserGroups_Item& item(int index) const;
  ::aspia::proto::UserGroups_Item* mutable_item(int index);
  ::aspia::proto::UserGroups_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.UserGroups)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsUserGroupsImpl();
};
// -------------------------------------------------------------------

class Sessions_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Sessions.Item) */ {
 public:
  Sessions_Item();
  virtual ~Sessions_Item();

  Sessions_Item(const Sessions_Item& from);

  inline Sessions_Item& operator=(const Sessions_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sessions_Item(Sessions_Item&& from) noexcept
    : Sessions_Item() {
    *this = ::std::move(from);
  }

  inline Sessions_Item& operator=(Sessions_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Sessions_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sessions_Item* internal_default_instance() {
    return reinterpret_cast<const Sessions_Item*>(
               &_Sessions_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(Sessions_Item* other);
  friend void swap(Sessions_Item& a, Sessions_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sessions_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Sessions_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Sessions_Item& from);
  void MergeFrom(const Sessions_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sessions_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_name = 1;
  void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& user_name() const;
  void set_user_name(const ::std::string& value);
  #if LANG_CXX11
  void set_user_name(::std::string&& value);
  #endif
  void set_user_name(const char* value);
  void set_user_name(const char* value, size_t size);
  ::std::string* mutable_user_name();
  ::std::string* release_user_name();
  void set_allocated_user_name(::std::string* user_name);

  // string domain_name = 2;
  void clear_domain_name();
  static const int kDomainNameFieldNumber = 2;
  const ::std::string& domain_name() const;
  void set_domain_name(const ::std::string& value);
  #if LANG_CXX11
  void set_domain_name(::std::string&& value);
  #endif
  void set_domain_name(const char* value);
  void set_domain_name(const char* value, size_t size);
  ::std::string* mutable_domain_name();
  ::std::string* release_domain_name();
  void set_allocated_domain_name(::std::string* domain_name);

  // string connect_state = 4;
  void clear_connect_state();
  static const int kConnectStateFieldNumber = 4;
  const ::std::string& connect_state() const;
  void set_connect_state(const ::std::string& value);
  #if LANG_CXX11
  void set_connect_state(::std::string&& value);
  #endif
  void set_connect_state(const char* value);
  void set_connect_state(const char* value, size_t size);
  ::std::string* mutable_connect_state();
  ::std::string* release_connect_state();
  void set_allocated_connect_state(::std::string* connect_state);

  // string client_name = 5;
  void clear_client_name();
  static const int kClientNameFieldNumber = 5;
  const ::std::string& client_name() const;
  void set_client_name(const ::std::string& value);
  #if LANG_CXX11
  void set_client_name(::std::string&& value);
  #endif
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  ::std::string* mutable_client_name();
  ::std::string* release_client_name();
  void set_allocated_client_name(::std::string* client_name);

  // string winstation_name = 6;
  void clear_winstation_name();
  static const int kWinstationNameFieldNumber = 6;
  const ::std::string& winstation_name() const;
  void set_winstation_name(const ::std::string& value);
  #if LANG_CXX11
  void set_winstation_name(::std::string&& value);
  #endif
  void set_winstation_name(const char* value);
  void set_winstation_name(const char* value, size_t size);
  ::std::string* mutable_winstation_name();
  ::std::string* release_winstation_name();
  void set_allocated_winstation_name(::std::string* winstation_name);

  // uint32 session_id = 3;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  ::google::protobuf::uint32 session_id() const;
  void set_session_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.Sessions.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  ::google::protobuf::internal::ArenaStringPtr domain_name_;
  ::google::protobuf::internal::ArenaStringPtr connect_state_;
  ::google::protobuf::internal::ArenaStringPtr client_name_;
  ::google::protobuf::internal::ArenaStringPtr winstation_name_;
  ::google::protobuf::uint32 session_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSessions_ItemImpl();
};
// -------------------------------------------------------------------

class Sessions : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.Sessions) */ {
 public:
  Sessions();
  virtual ~Sessions();

  Sessions(const Sessions& from);

  inline Sessions& operator=(const Sessions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sessions(Sessions&& from) noexcept
    : Sessions() {
    *this = ::std::move(from);
  }

  inline Sessions& operator=(Sessions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Sessions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sessions* internal_default_instance() {
    return reinterpret_cast<const Sessions*>(
               &_Sessions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(Sessions* other);
  friend void swap(Sessions& a, Sessions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sessions* New() const PROTOBUF_FINAL { return New(NULL); }

  Sessions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Sessions& from);
  void MergeFrom(const Sessions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sessions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Sessions_Item Item;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.Sessions.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::Sessions_Item& item(int index) const;
  ::aspia::proto::Sessions_Item* mutable_item(int index);
  ::aspia::proto::Sessions_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.Sessions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::TableStruct;
  friend void ::protobuf_system_5finfo_5fsession_5fmessage_2eproto::InitDefaultsSessionsImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DmiBios

// string manufacturer = 1;
inline void DmiBios::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiBios::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.manufacturer)
}
#if LANG_CXX11
inline void DmiBios::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.manufacturer)
}
#endif
inline void DmiBios::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.manufacturer)
}
inline void DmiBios::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.manufacturer)
}
inline ::std::string* DmiBios::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.manufacturer)
}

// string version = 2;
inline void DmiBios::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.version)
  return version_.GetNoArena();
}
inline void DmiBios::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.version)
}
#if LANG_CXX11
inline void DmiBios::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.version)
}
#endif
inline void DmiBios::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.version)
}
inline void DmiBios::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.version)
}
inline ::std::string* DmiBios::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.version)
}

// string date = 3;
inline void DmiBios::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.date)
  return date_.GetNoArena();
}
inline void DmiBios::set_date(const ::std::string& value) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.date)
}
#if LANG_CXX11
inline void DmiBios::set_date(::std::string&& value) {
  
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.date)
}
#endif
inline void DmiBios::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.date)
}
inline void DmiBios::set_date(const char* value, size_t size) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.date)
}
inline ::std::string* DmiBios::mutable_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.date)
  
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    
  } else {
    
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.date)
}

// uint64 size = 4;
inline void DmiBios::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DmiBios::size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.size)
  return size_;
}
inline void DmiBios::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.size)
}

// string bios_revision = 5;
inline void DmiBios::clear_bios_revision() {
  bios_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::bios_revision() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.bios_revision)
  return bios_revision_.GetNoArena();
}
inline void DmiBios::set_bios_revision(const ::std::string& value) {
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.bios_revision)
}
#if LANG_CXX11
inline void DmiBios::set_bios_revision(::std::string&& value) {
  
  bios_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.bios_revision)
}
#endif
inline void DmiBios::set_bios_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.bios_revision)
}
inline void DmiBios::set_bios_revision(const char* value, size_t size) {
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.bios_revision)
}
inline ::std::string* DmiBios::mutable_bios_revision() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.bios_revision)
  return bios_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_bios_revision() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.bios_revision)
  
  return bios_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_bios_revision(::std::string* bios_revision) {
  if (bios_revision != NULL) {
    
  } else {
    
  }
  bios_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bios_revision);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.bios_revision)
}

// string firmware_revision = 6;
inline void DmiBios::clear_firmware_revision() {
  firmware_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::firmware_revision() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.firmware_revision)
  return firmware_revision_.GetNoArena();
}
inline void DmiBios::set_firmware_revision(const ::std::string& value) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.firmware_revision)
}
#if LANG_CXX11
inline void DmiBios::set_firmware_revision(::std::string&& value) {
  
  firmware_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.firmware_revision)
}
#endif
inline void DmiBios::set_firmware_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.firmware_revision)
}
inline void DmiBios::set_firmware_revision(const char* value, size_t size) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.firmware_revision)
}
inline ::std::string* DmiBios::mutable_firmware_revision() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.firmware_revision)
  return firmware_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_firmware_revision() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.firmware_revision)
  
  return firmware_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_firmware_revision(::std::string* firmware_revision) {
  if (firmware_revision != NULL) {
    
  } else {
    
  }
  firmware_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_revision);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.firmware_revision)
}

// string address = 7;
inline void DmiBios::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBios::address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.address)
  return address_.GetNoArena();
}
inline void DmiBios::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.address)
}
#if LANG_CXX11
inline void DmiBios::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBios.address)
}
#endif
inline void DmiBios::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBios.address)
}
inline void DmiBios::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBios.address)
}
inline ::std::string* DmiBios::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBios.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBios::release_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBios.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBios::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBios.address)
}

// int32 runtime_size = 8;
inline void DmiBios::clear_runtime_size() {
  runtime_size_ = 0;
}
inline ::google::protobuf::int32 DmiBios::runtime_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.runtime_size)
  return runtime_size_;
}
inline void DmiBios::set_runtime_size(::google::protobuf::int32 value) {
  
  runtime_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.runtime_size)
}

// uint64 characteristics = 9;
inline void DmiBios::clear_characteristics() {
  characteristics_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DmiBios::characteristics() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.characteristics)
  return characteristics_;
}
inline void DmiBios::set_characteristics(::google::protobuf::uint64 value) {
  
  characteristics_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.characteristics)
}

// uint32 characteristics1 = 10;
inline void DmiBios::clear_characteristics1() {
  characteristics1_ = 0u;
}
inline ::google::protobuf::uint32 DmiBios::characteristics1() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.characteristics1)
  return characteristics1_;
}
inline void DmiBios::set_characteristics1(::google::protobuf::uint32 value) {
  
  characteristics1_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.characteristics1)
}

// uint32 characteristics2 = 11;
inline void DmiBios::clear_characteristics2() {
  characteristics2_ = 0u;
}
inline ::google::protobuf::uint32 DmiBios::characteristics2() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBios.characteristics2)
  return characteristics2_;
}
inline void DmiBios::set_characteristics2(::google::protobuf::uint32 value) {
  
  characteristics2_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBios.characteristics2)
}

// -------------------------------------------------------------------

// DmiSystem

// string manufacturer = 1;
inline void DmiSystem::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiSystem::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.manufacturer)
}
#if LANG_CXX11
inline void DmiSystem::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.manufacturer)
}
#endif
inline void DmiSystem::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.manufacturer)
}
inline void DmiSystem::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.manufacturer)
}
inline ::std::string* DmiSystem::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.manufacturer)
}

// string product_name = 2;
inline void DmiSystem::clear_product_name() {
  product_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::product_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.product_name)
  return product_name_.GetNoArena();
}
inline void DmiSystem::set_product_name(const ::std::string& value) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.product_name)
}
#if LANG_CXX11
inline void DmiSystem::set_product_name(::std::string&& value) {
  
  product_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.product_name)
}
#endif
inline void DmiSystem::set_product_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.product_name)
}
inline void DmiSystem::set_product_name(const char* value, size_t size) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.product_name)
}
inline ::std::string* DmiSystem::mutable_product_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.product_name)
  return product_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_product_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.product_name)
  
  return product_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_product_name(::std::string* product_name) {
  if (product_name != NULL) {
    
  } else {
    
  }
  product_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.product_name)
}

// string version = 3;
inline void DmiSystem::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.version)
  return version_.GetNoArena();
}
inline void DmiSystem::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.version)
}
#if LANG_CXX11
inline void DmiSystem::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.version)
}
#endif
inline void DmiSystem::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.version)
}
inline void DmiSystem::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.version)
}
inline ::std::string* DmiSystem::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.version)
}

// string serial_number = 4;
inline void DmiSystem::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiSystem::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.serial_number)
}
#if LANG_CXX11
inline void DmiSystem::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.serial_number)
}
#endif
inline void DmiSystem::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.serial_number)
}
inline void DmiSystem::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.serial_number)
}
inline ::std::string* DmiSystem::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.serial_number)
}

// string uuid = 5;
inline void DmiSystem::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::uuid() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.uuid)
  return uuid_.GetNoArena();
}
inline void DmiSystem::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.uuid)
}
#if LANG_CXX11
inline void DmiSystem::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.uuid)
}
#endif
inline void DmiSystem::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.uuid)
}
inline void DmiSystem::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.uuid)
}
inline ::std::string* DmiSystem::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_uuid() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.uuid)
}

// .aspia.proto.DmiSystem.WakeupType wakeup_type = 6;
inline void DmiSystem::clear_wakeup_type() {
  wakeup_type_ = 0;
}
inline ::aspia::proto::DmiSystem_WakeupType DmiSystem::wakeup_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.wakeup_type)
  return static_cast< ::aspia::proto::DmiSystem_WakeupType >(wakeup_type_);
}
inline void DmiSystem::set_wakeup_type(::aspia::proto::DmiSystem_WakeupType value) {
  
  wakeup_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.wakeup_type)
}

// string sku_number = 7;
inline void DmiSystem::clear_sku_number() {
  sku_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::sku_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.sku_number)
  return sku_number_.GetNoArena();
}
inline void DmiSystem::set_sku_number(const ::std::string& value) {
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.sku_number)
}
#if LANG_CXX11
inline void DmiSystem::set_sku_number(::std::string&& value) {
  
  sku_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.sku_number)
}
#endif
inline void DmiSystem::set_sku_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.sku_number)
}
inline void DmiSystem::set_sku_number(const char* value, size_t size) {
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.sku_number)
}
inline ::std::string* DmiSystem::mutable_sku_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.sku_number)
  return sku_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_sku_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.sku_number)
  
  return sku_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_sku_number(::std::string* sku_number) {
  if (sku_number != NULL) {
    
  } else {
    
  }
  sku_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sku_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.sku_number)
}

// string family = 8;
inline void DmiSystem::clear_family() {
  family_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystem::family() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystem.family)
  return family_.GetNoArena();
}
inline void DmiSystem::set_family(const ::std::string& value) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystem.family)
}
#if LANG_CXX11
inline void DmiSystem::set_family(::std::string&& value) {
  
  family_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystem.family)
}
#endif
inline void DmiSystem::set_family(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystem.family)
}
inline void DmiSystem::set_family(const char* value, size_t size) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystem.family)
}
inline ::std::string* DmiSystem::mutable_family() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystem.family)
  return family_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystem::release_family() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystem.family)
  
  return family_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystem::set_allocated_family(::std::string* family) {
  if (family != NULL) {
    
  } else {
    
  }
  family_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystem.family)
}

// -------------------------------------------------------------------

// DmiBaseboard_Features

// bool is_hosting_board = 1;
inline void DmiBaseboard_Features::clear_is_hosting_board() {
  is_hosting_board_ = false;
}
inline bool DmiBaseboard_Features::is_hosting_board() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Features.is_hosting_board)
  return is_hosting_board_;
}
inline void DmiBaseboard_Features::set_is_hosting_board(bool value) {
  
  is_hosting_board_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Features.is_hosting_board)
}

// bool is_requires_at_least_one_daughter_board = 2;
inline void DmiBaseboard_Features::clear_is_requires_at_least_one_daughter_board() {
  is_requires_at_least_one_daughter_board_ = false;
}
inline bool DmiBaseboard_Features::is_requires_at_least_one_daughter_board() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Features.is_requires_at_least_one_daughter_board)
  return is_requires_at_least_one_daughter_board_;
}
inline void DmiBaseboard_Features::set_is_requires_at_least_one_daughter_board(bool value) {
  
  is_requires_at_least_one_daughter_board_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Features.is_requires_at_least_one_daughter_board)
}

// bool is_removable = 3;
inline void DmiBaseboard_Features::clear_is_removable() {
  is_removable_ = false;
}
inline bool DmiBaseboard_Features::is_removable() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Features.is_removable)
  return is_removable_;
}
inline void DmiBaseboard_Features::set_is_removable(bool value) {
  
  is_removable_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Features.is_removable)
}

// bool is_replaceable = 4;
inline void DmiBaseboard_Features::clear_is_replaceable() {
  is_replaceable_ = false;
}
inline bool DmiBaseboard_Features::is_replaceable() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Features.is_replaceable)
  return is_replaceable_;
}
inline void DmiBaseboard_Features::set_is_replaceable(bool value) {
  
  is_replaceable_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Features.is_replaceable)
}

// bool is_hot_swappable = 5;
inline void DmiBaseboard_Features::clear_is_hot_swappable() {
  is_hot_swappable_ = false;
}
inline bool DmiBaseboard_Features::is_hot_swappable() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Features.is_hot_swappable)
  return is_hot_swappable_;
}
inline void DmiBaseboard_Features::set_is_hot_swappable(bool value) {
  
  is_hot_swappable_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Features.is_hot_swappable)
}

// -------------------------------------------------------------------

// DmiBaseboard_Item

// string manufacturer = 1;
inline void DmiBaseboard_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiBaseboard_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.manufacturer)
}
#endif
inline void DmiBaseboard_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.manufacturer)
}
inline void DmiBaseboard_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.manufacturer)
}
inline ::std::string* DmiBaseboard_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.manufacturer)
}

// string product_name = 2;
inline void DmiBaseboard_Item::clear_product_name() {
  product_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::product_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.product_name)
  return product_name_.GetNoArena();
}
inline void DmiBaseboard_Item::set_product_name(const ::std::string& value) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.product_name)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_product_name(::std::string&& value) {
  
  product_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.product_name)
}
#endif
inline void DmiBaseboard_Item::set_product_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.product_name)
}
inline void DmiBaseboard_Item::set_product_name(const char* value, size_t size) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.product_name)
}
inline ::std::string* DmiBaseboard_Item::mutable_product_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.product_name)
  return product_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_product_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.product_name)
  
  return product_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_product_name(::std::string* product_name) {
  if (product_name != NULL) {
    
  } else {
    
  }
  product_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.product_name)
}

// string version = 3;
inline void DmiBaseboard_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.version)
  return version_.GetNoArena();
}
inline void DmiBaseboard_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.version)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.version)
}
#endif
inline void DmiBaseboard_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.version)
}
inline void DmiBaseboard_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.version)
}
inline ::std::string* DmiBaseboard_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.version)
}

// string serial_number = 4;
inline void DmiBaseboard_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiBaseboard_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.serial_number)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.serial_number)
}
#endif
inline void DmiBaseboard_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.serial_number)
}
inline void DmiBaseboard_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.serial_number)
}
inline ::std::string* DmiBaseboard_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.serial_number)
}

// string asset_tag = 5;
inline void DmiBaseboard_Item::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void DmiBaseboard_Item::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.asset_tag)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.asset_tag)
}
#endif
inline void DmiBaseboard_Item::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.asset_tag)
}
inline void DmiBaseboard_Item::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.asset_tag)
}
inline ::std::string* DmiBaseboard_Item::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.asset_tag)
}

// .aspia.proto.DmiBaseboard.Features features = 6;
inline bool DmiBaseboard_Item::has_features() const {
  return this != internal_default_instance() && features_ != NULL;
}
inline void DmiBaseboard_Item::clear_features() {
  if (GetArenaNoVirtual() == NULL && features_ != NULL) {
    delete features_;
  }
  features_ = NULL;
}
inline const ::aspia::proto::DmiBaseboard_Features& DmiBaseboard_Item::features() const {
  const ::aspia::proto::DmiBaseboard_Features* p = features_;
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.features)
  return p != NULL ? *p : *reinterpret_cast<const ::aspia::proto::DmiBaseboard_Features*>(
      &::aspia::proto::_DmiBaseboard_Features_default_instance_);
}
inline ::aspia::proto::DmiBaseboard_Features* DmiBaseboard_Item::release_features() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.features)
  
  ::aspia::proto::DmiBaseboard_Features* temp = features_;
  features_ = NULL;
  return temp;
}
inline ::aspia::proto::DmiBaseboard_Features* DmiBaseboard_Item::mutable_features() {
  
  if (features_ == NULL) {
    features_ = new ::aspia::proto::DmiBaseboard_Features;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.features)
  return features_;
}
inline void DmiBaseboard_Item::set_allocated_features(::aspia::proto::DmiBaseboard_Features* features) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete features_;
  }
  if (features) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      features = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, features, submessage_arena);
    }
    
  } else {
    
  }
  features_ = features;
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.features)
}

// string location_in_chassis = 7;
inline void DmiBaseboard_Item::clear_location_in_chassis() {
  location_in_chassis_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiBaseboard_Item::location_in_chassis() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.location_in_chassis)
  return location_in_chassis_.GetNoArena();
}
inline void DmiBaseboard_Item::set_location_in_chassis(const ::std::string& value) {
  
  location_in_chassis_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}
#if LANG_CXX11
inline void DmiBaseboard_Item::set_location_in_chassis(::std::string&& value) {
  
  location_in_chassis_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}
#endif
inline void DmiBaseboard_Item::set_location_in_chassis(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_in_chassis_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}
inline void DmiBaseboard_Item::set_location_in_chassis(const char* value, size_t size) {
  
  location_in_chassis_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}
inline ::std::string* DmiBaseboard_Item::mutable_location_in_chassis() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.Item.location_in_chassis)
  return location_in_chassis_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiBaseboard_Item::release_location_in_chassis() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiBaseboard.Item.location_in_chassis)
  
  return location_in_chassis_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiBaseboard_Item::set_allocated_location_in_chassis(::std::string* location_in_chassis) {
  if (location_in_chassis != NULL) {
    
  } else {
    
  }
  location_in_chassis_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location_in_chassis);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiBaseboard.Item.location_in_chassis)
}

// .aspia.proto.DmiBaseboard.BoardType type = 8;
inline void DmiBaseboard_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiBaseboard_BoardType DmiBaseboard_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.Item.type)
  return static_cast< ::aspia::proto::DmiBaseboard_BoardType >(type_);
}
inline void DmiBaseboard_Item::set_type(::aspia::proto::DmiBaseboard_BoardType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiBaseboard.Item.type)
}

// -------------------------------------------------------------------

// DmiBaseboard

// repeated .aspia.proto.DmiBaseboard.Item item = 1;
inline int DmiBaseboard::item_size() const {
  return item_.size();
}
inline void DmiBaseboard::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiBaseboard_Item& DmiBaseboard::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiBaseboard.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiBaseboard_Item* DmiBaseboard::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiBaseboard.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiBaseboard_Item* DmiBaseboard::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiBaseboard.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item >*
DmiBaseboard::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiBaseboard.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiBaseboard_Item >&
DmiBaseboard::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiBaseboard.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiChassis_Item

// string manufacturer = 1;
inline void DmiChassis_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiChassis_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.manufacturer)
}
#endif
inline void DmiChassis_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.manufacturer)
}
inline void DmiChassis_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.manufacturer)
}
inline ::std::string* DmiChassis_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.manufacturer)
}

// string version = 2;
inline void DmiChassis_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.version)
  return version_.GetNoArena();
}
inline void DmiChassis_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.version)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.version)
}
#endif
inline void DmiChassis_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.version)
}
inline void DmiChassis_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.version)
}
inline ::std::string* DmiChassis_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.version)
}

// string serial_number = 3;
inline void DmiChassis_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiChassis_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.serial_number)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.serial_number)
}
#endif
inline void DmiChassis_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.serial_number)
}
inline void DmiChassis_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.serial_number)
}
inline ::std::string* DmiChassis_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.serial_number)
}

// string asset_tag = 4;
inline void DmiChassis_Item::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiChassis_Item::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void DmiChassis_Item::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.asset_tag)
}
#if LANG_CXX11
inline void DmiChassis_Item::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiChassis.Item.asset_tag)
}
#endif
inline void DmiChassis_Item::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiChassis.Item.asset_tag)
}
inline void DmiChassis_Item::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiChassis.Item.asset_tag)
}
inline ::std::string* DmiChassis_Item::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.Item.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiChassis_Item::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiChassis.Item.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiChassis_Item::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiChassis.Item.asset_tag)
}

// .aspia.proto.DmiChassis.Type type = 5;
inline void DmiChassis_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiChassis_Type DmiChassis_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.type)
  return static_cast< ::aspia::proto::DmiChassis_Type >(type_);
}
inline void DmiChassis_Item::set_type(::aspia::proto::DmiChassis_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.type)
}

// .aspia.proto.DmiChassis.Status os_load_status = 6;
inline void DmiChassis_Item::clear_os_load_status() {
  os_load_status_ = 0;
}
inline ::aspia::proto::DmiChassis_Status DmiChassis_Item::os_load_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.os_load_status)
  return static_cast< ::aspia::proto::DmiChassis_Status >(os_load_status_);
}
inline void DmiChassis_Item::set_os_load_status(::aspia::proto::DmiChassis_Status value) {
  
  os_load_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.os_load_status)
}

// .aspia.proto.DmiChassis.Status power_source_status = 7;
inline void DmiChassis_Item::clear_power_source_status() {
  power_source_status_ = 0;
}
inline ::aspia::proto::DmiChassis_Status DmiChassis_Item::power_source_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.power_source_status)
  return static_cast< ::aspia::proto::DmiChassis_Status >(power_source_status_);
}
inline void DmiChassis_Item::set_power_source_status(::aspia::proto::DmiChassis_Status value) {
  
  power_source_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.power_source_status)
}

// .aspia.proto.DmiChassis.Status temparature_status = 8;
inline void DmiChassis_Item::clear_temparature_status() {
  temparature_status_ = 0;
}
inline ::aspia::proto::DmiChassis_Status DmiChassis_Item::temparature_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.temparature_status)
  return static_cast< ::aspia::proto::DmiChassis_Status >(temparature_status_);
}
inline void DmiChassis_Item::set_temparature_status(::aspia::proto::DmiChassis_Status value) {
  
  temparature_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.temparature_status)
}

// .aspia.proto.DmiChassis.SecurityStatus security_status = 9;
inline void DmiChassis_Item::clear_security_status() {
  security_status_ = 0;
}
inline ::aspia::proto::DmiChassis_SecurityStatus DmiChassis_Item::security_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.security_status)
  return static_cast< ::aspia::proto::DmiChassis_SecurityStatus >(security_status_);
}
inline void DmiChassis_Item::set_security_status(::aspia::proto::DmiChassis_SecurityStatus value) {
  
  security_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.security_status)
}

// int32 height = 10;
inline void DmiChassis_Item::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 DmiChassis_Item::height() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.height)
  return height_;
}
inline void DmiChassis_Item::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.height)
}

// int32 number_of_power_cords = 11;
inline void DmiChassis_Item::clear_number_of_power_cords() {
  number_of_power_cords_ = 0;
}
inline ::google::protobuf::int32 DmiChassis_Item::number_of_power_cords() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.Item.number_of_power_cords)
  return number_of_power_cords_;
}
inline void DmiChassis_Item::set_number_of_power_cords(::google::protobuf::int32 value) {
  
  number_of_power_cords_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiChassis.Item.number_of_power_cords)
}

// -------------------------------------------------------------------

// DmiChassis

// repeated .aspia.proto.DmiChassis.Item item = 1;
inline int DmiChassis::item_size() const {
  return item_.size();
}
inline void DmiChassis::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiChassis_Item& DmiChassis::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiChassis.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiChassis_Item* DmiChassis::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiChassis.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiChassis_Item* DmiChassis::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiChassis.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item >*
DmiChassis::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiChassis.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiChassis_Item >&
DmiChassis::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiChassis.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiCaches_Item

// string name = 1;
inline void DmiCaches_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiCaches_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.name)
  return name_.GetNoArena();
}
inline void DmiCaches_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.name)
}
#if LANG_CXX11
inline void DmiCaches_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiCaches.Item.name)
}
#endif
inline void DmiCaches_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiCaches.Item.name)
}
inline void DmiCaches_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiCaches.Item.name)
}
inline ::std::string* DmiCaches_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiCaches_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiCaches.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiCaches_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiCaches.Item.name)
}

// .aspia.proto.DmiCaches.Location location = 2;
inline void DmiCaches_Item::clear_location() {
  location_ = 0;
}
inline ::aspia::proto::DmiCaches_Location DmiCaches_Item::location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.location)
  return static_cast< ::aspia::proto::DmiCaches_Location >(location_);
}
inline void DmiCaches_Item::set_location(::aspia::proto::DmiCaches_Location value) {
  
  location_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.location)
}

// .aspia.proto.DmiCaches.Status status = 3;
inline void DmiCaches_Item::clear_status() {
  status_ = 0;
}
inline ::aspia::proto::DmiCaches_Status DmiCaches_Item::status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.status)
  return static_cast< ::aspia::proto::DmiCaches_Status >(status_);
}
inline void DmiCaches_Item::set_status(::aspia::proto::DmiCaches_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.status)
}

// .aspia.proto.DmiCaches.Mode mode = 4;
inline void DmiCaches_Item::clear_mode() {
  mode_ = 0;
}
inline ::aspia::proto::DmiCaches_Mode DmiCaches_Item::mode() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.mode)
  return static_cast< ::aspia::proto::DmiCaches_Mode >(mode_);
}
inline void DmiCaches_Item::set_mode(::aspia::proto::DmiCaches_Mode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.mode)
}

// int32 level = 5;
inline void DmiCaches_Item::clear_level() {
  level_ = 0;
}
inline ::google::protobuf::int32 DmiCaches_Item::level() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.level)
  return level_;
}
inline void DmiCaches_Item::set_level(::google::protobuf::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.level)
}

// int32 maximum_size = 6;
inline void DmiCaches_Item::clear_maximum_size() {
  maximum_size_ = 0;
}
inline ::google::protobuf::int32 DmiCaches_Item::maximum_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.maximum_size)
  return maximum_size_;
}
inline void DmiCaches_Item::set_maximum_size(::google::protobuf::int32 value) {
  
  maximum_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.maximum_size)
}

// int32 current_size = 7;
inline void DmiCaches_Item::clear_current_size() {
  current_size_ = 0;
}
inline ::google::protobuf::int32 DmiCaches_Item::current_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.current_size)
  return current_size_;
}
inline void DmiCaches_Item::set_current_size(::google::protobuf::int32 value) {
  
  current_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.current_size)
}

// uint32 supported_sram_types = 8;
inline void DmiCaches_Item::clear_supported_sram_types() {
  supported_sram_types_ = 0u;
}
inline ::google::protobuf::uint32 DmiCaches_Item::supported_sram_types() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.supported_sram_types)
  return supported_sram_types_;
}
inline void DmiCaches_Item::set_supported_sram_types(::google::protobuf::uint32 value) {
  
  supported_sram_types_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.supported_sram_types)
}

// .aspia.proto.DmiCaches.SRAMType current_sram_type = 9;
inline void DmiCaches_Item::clear_current_sram_type() {
  current_sram_type_ = 0;
}
inline ::aspia::proto::DmiCaches_SRAMType DmiCaches_Item::current_sram_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.current_sram_type)
  return static_cast< ::aspia::proto::DmiCaches_SRAMType >(current_sram_type_);
}
inline void DmiCaches_Item::set_current_sram_type(::aspia::proto::DmiCaches_SRAMType value) {
  
  current_sram_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.current_sram_type)
}

// int32 speed = 10;
inline void DmiCaches_Item::clear_speed() {
  speed_ = 0;
}
inline ::google::protobuf::int32 DmiCaches_Item::speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.speed)
  return speed_;
}
inline void DmiCaches_Item::set_speed(::google::protobuf::int32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.speed)
}

// .aspia.proto.DmiCaches.ErrorCorrectionType error_correction_type = 11;
inline void DmiCaches_Item::clear_error_correction_type() {
  error_correction_type_ = 0;
}
inline ::aspia::proto::DmiCaches_ErrorCorrectionType DmiCaches_Item::error_correction_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.error_correction_type)
  return static_cast< ::aspia::proto::DmiCaches_ErrorCorrectionType >(error_correction_type_);
}
inline void DmiCaches_Item::set_error_correction_type(::aspia::proto::DmiCaches_ErrorCorrectionType value) {
  
  error_correction_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.error_correction_type)
}

// .aspia.proto.DmiCaches.Type type = 12;
inline void DmiCaches_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiCaches_Type DmiCaches_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.type)
  return static_cast< ::aspia::proto::DmiCaches_Type >(type_);
}
inline void DmiCaches_Item::set_type(::aspia::proto::DmiCaches_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.type)
}

// .aspia.proto.DmiCaches.Associativity associativity = 13;
inline void DmiCaches_Item::clear_associativity() {
  associativity_ = 0;
}
inline ::aspia::proto::DmiCaches_Associativity DmiCaches_Item::associativity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.Item.associativity)
  return static_cast< ::aspia::proto::DmiCaches_Associativity >(associativity_);
}
inline void DmiCaches_Item::set_associativity(::aspia::proto::DmiCaches_Associativity value) {
  
  associativity_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiCaches.Item.associativity)
}

// -------------------------------------------------------------------

// DmiCaches

// repeated .aspia.proto.DmiCaches.Item item = 1;
inline int DmiCaches::item_size() const {
  return item_.size();
}
inline void DmiCaches::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiCaches_Item& DmiCaches::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiCaches.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiCaches_Item* DmiCaches::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiCaches.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiCaches_Item* DmiCaches::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiCaches.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item >*
DmiCaches::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiCaches.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiCaches_Item >&
DmiCaches::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiCaches.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiProcessors_Item

// string manufacturer = 1;
inline void DmiProcessors_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiProcessors_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.manufacturer)
}
#endif
inline void DmiProcessors_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.manufacturer)
}
inline void DmiProcessors_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.manufacturer)
}
inline ::std::string* DmiProcessors_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.manufacturer)
}

// string version = 2;
inline void DmiProcessors_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.version)
  return version_.GetNoArena();
}
inline void DmiProcessors_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.version)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.version)
}
#endif
inline void DmiProcessors_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.version)
}
inline void DmiProcessors_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.version)
}
inline ::std::string* DmiProcessors_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.version)
}

// .aspia.proto.DmiProcessors.Family family = 3;
inline void DmiProcessors_Item::clear_family() {
  family_ = 0;
}
inline ::aspia::proto::DmiProcessors_Family DmiProcessors_Item::family() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.family)
  return static_cast< ::aspia::proto::DmiProcessors_Family >(family_);
}
inline void DmiProcessors_Item::set_family(::aspia::proto::DmiProcessors_Family value) {
  
  family_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.family)
}

// .aspia.proto.DmiProcessors.Type type = 4;
inline void DmiProcessors_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiProcessors_Type DmiProcessors_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.type)
  return static_cast< ::aspia::proto::DmiProcessors_Type >(type_);
}
inline void DmiProcessors_Item::set_type(::aspia::proto::DmiProcessors_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.type)
}

// .aspia.proto.DmiProcessors.Status status = 5;
inline void DmiProcessors_Item::clear_status() {
  status_ = 0;
}
inline ::aspia::proto::DmiProcessors_Status DmiProcessors_Item::status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.status)
  return static_cast< ::aspia::proto::DmiProcessors_Status >(status_);
}
inline void DmiProcessors_Item::set_status(::aspia::proto::DmiProcessors_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.status)
}

// string socket = 6;
inline void DmiProcessors_Item::clear_socket() {
  socket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::socket() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.socket)
  return socket_.GetNoArena();
}
inline void DmiProcessors_Item::set_socket(const ::std::string& value) {
  
  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.socket)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_socket(::std::string&& value) {
  
  socket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.socket)
}
#endif
inline void DmiProcessors_Item::set_socket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.socket)
}
inline void DmiProcessors_Item::set_socket(const char* value, size_t size) {
  
  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.socket)
}
inline ::std::string* DmiProcessors_Item::mutable_socket() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.socket)
  return socket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_socket() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.socket)
  
  return socket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_socket(::std::string* socket) {
  if (socket != NULL) {
    
  } else {
    
  }
  socket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), socket);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.socket)
}

// .aspia.proto.DmiProcessors.Upgrade upgrade = 7;
inline void DmiProcessors_Item::clear_upgrade() {
  upgrade_ = 0;
}
inline ::aspia::proto::DmiProcessors_Upgrade DmiProcessors_Item::upgrade() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.upgrade)
  return static_cast< ::aspia::proto::DmiProcessors_Upgrade >(upgrade_);
}
inline void DmiProcessors_Item::set_upgrade(::aspia::proto::DmiProcessors_Upgrade value) {
  
  upgrade_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.upgrade)
}

// int32 external_clock = 8;
inline void DmiProcessors_Item::clear_external_clock() {
  external_clock_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::external_clock() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.external_clock)
  return external_clock_;
}
inline void DmiProcessors_Item::set_external_clock(::google::protobuf::int32 value) {
  
  external_clock_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.external_clock)
}

// int32 current_speed = 9;
inline void DmiProcessors_Item::clear_current_speed() {
  current_speed_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::current_speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.current_speed)
  return current_speed_;
}
inline void DmiProcessors_Item::set_current_speed(::google::protobuf::int32 value) {
  
  current_speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.current_speed)
}

// int32 maximum_speed = 10;
inline void DmiProcessors_Item::clear_maximum_speed() {
  maximum_speed_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::maximum_speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.maximum_speed)
  return maximum_speed_;
}
inline void DmiProcessors_Item::set_maximum_speed(::google::protobuf::int32 value) {
  
  maximum_speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.maximum_speed)
}

// double voltage = 11;
inline void DmiProcessors_Item::clear_voltage() {
  voltage_ = 0;
}
inline double DmiProcessors_Item::voltage() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.voltage)
  return voltage_;
}
inline void DmiProcessors_Item::set_voltage(double value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.voltage)
}

// string serial_number = 12;
inline void DmiProcessors_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiProcessors_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.serial_number)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.serial_number)
}
#endif
inline void DmiProcessors_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.serial_number)
}
inline void DmiProcessors_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.serial_number)
}
inline ::std::string* DmiProcessors_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.serial_number)
}

// string asset_tag = 13;
inline void DmiProcessors_Item::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void DmiProcessors_Item::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.asset_tag)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.asset_tag)
}
#endif
inline void DmiProcessors_Item::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.asset_tag)
}
inline void DmiProcessors_Item::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.asset_tag)
}
inline ::std::string* DmiProcessors_Item::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.asset_tag)
}

// string part_number = 14;
inline void DmiProcessors_Item::clear_part_number() {
  part_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiProcessors_Item::part_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.part_number)
  return part_number_.GetNoArena();
}
inline void DmiProcessors_Item::set_part_number(const ::std::string& value) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.part_number)
}
#if LANG_CXX11
inline void DmiProcessors_Item::set_part_number(::std::string&& value) {
  
  part_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiProcessors.Item.part_number)
}
#endif
inline void DmiProcessors_Item::set_part_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiProcessors.Item.part_number)
}
inline void DmiProcessors_Item::set_part_number(const char* value, size_t size) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiProcessors.Item.part_number)
}
inline ::std::string* DmiProcessors_Item::mutable_part_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.Item.part_number)
  return part_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiProcessors_Item::release_part_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiProcessors.Item.part_number)
  
  return part_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiProcessors_Item::set_allocated_part_number(::std::string* part_number) {
  if (part_number != NULL) {
    
  } else {
    
  }
  part_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), part_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiProcessors.Item.part_number)
}

// int32 core_count = 15;
inline void DmiProcessors_Item::clear_core_count() {
  core_count_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::core_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.core_count)
  return core_count_;
}
inline void DmiProcessors_Item::set_core_count(::google::protobuf::int32 value) {
  
  core_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.core_count)
}

// int32 core_enabled = 16;
inline void DmiProcessors_Item::clear_core_enabled() {
  core_enabled_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::core_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.core_enabled)
  return core_enabled_;
}
inline void DmiProcessors_Item::set_core_enabled(::google::protobuf::int32 value) {
  
  core_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.core_enabled)
}

// int32 thread_count = 17;
inline void DmiProcessors_Item::clear_thread_count() {
  thread_count_ = 0;
}
inline ::google::protobuf::int32 DmiProcessors_Item::thread_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.thread_count)
  return thread_count_;
}
inline void DmiProcessors_Item::set_thread_count(::google::protobuf::int32 value) {
  
  thread_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.thread_count)
}

// uint32 characteristics = 18;
inline void DmiProcessors_Item::clear_characteristics() {
  characteristics_ = 0u;
}
inline ::google::protobuf::uint32 DmiProcessors_Item::characteristics() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.Item.characteristics)
  return characteristics_;
}
inline void DmiProcessors_Item::set_characteristics(::google::protobuf::uint32 value) {
  
  characteristics_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiProcessors.Item.characteristics)
}

// -------------------------------------------------------------------

// DmiProcessors

// repeated .aspia.proto.DmiProcessors.Item item = 1;
inline int DmiProcessors::item_size() const {
  return item_.size();
}
inline void DmiProcessors::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiProcessors_Item& DmiProcessors::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiProcessors.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiProcessors_Item* DmiProcessors::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiProcessors.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiProcessors_Item* DmiProcessors::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiProcessors.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item >*
DmiProcessors::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiProcessors.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiProcessors_Item >&
DmiProcessors::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiProcessors.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiMemoryDevices_Item

// string device_locator = 1;
inline void DmiMemoryDevices_Item::clear_device_locator() {
  device_locator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::device_locator() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.device_locator)
  return device_locator_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_device_locator(const ::std::string& value) {
  
  device_locator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.device_locator)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_device_locator(::std::string&& value) {
  
  device_locator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.device_locator)
}
#endif
inline void DmiMemoryDevices_Item::set_device_locator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_locator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.device_locator)
}
inline void DmiMemoryDevices_Item::set_device_locator(const char* value, size_t size) {
  
  device_locator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.device_locator)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_device_locator() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.device_locator)
  return device_locator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_device_locator() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.device_locator)
  
  return device_locator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_device_locator(::std::string* device_locator) {
  if (device_locator != NULL) {
    
  } else {
    
  }
  device_locator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_locator);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.device_locator)
}

// int32 size = 2;
inline void DmiMemoryDevices_Item::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 DmiMemoryDevices_Item::size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.size)
  return size_;
}
inline void DmiMemoryDevices_Item::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.size)
}

// .aspia.proto.DmiMemoryDevices.Type type = 3;
inline void DmiMemoryDevices_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiMemoryDevices_Type DmiMemoryDevices_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.type)
  return static_cast< ::aspia::proto::DmiMemoryDevices_Type >(type_);
}
inline void DmiMemoryDevices_Item::set_type(::aspia::proto::DmiMemoryDevices_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.type)
}

// int32 speed = 4;
inline void DmiMemoryDevices_Item::clear_speed() {
  speed_ = 0;
}
inline ::google::protobuf::int32 DmiMemoryDevices_Item::speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.speed)
  return speed_;
}
inline void DmiMemoryDevices_Item::set_speed(::google::protobuf::int32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.speed)
}

// .aspia.proto.DmiMemoryDevices.FormFactor form_factor = 5;
inline void DmiMemoryDevices_Item::clear_form_factor() {
  form_factor_ = 0;
}
inline ::aspia::proto::DmiMemoryDevices_FormFactor DmiMemoryDevices_Item::form_factor() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.form_factor)
  return static_cast< ::aspia::proto::DmiMemoryDevices_FormFactor >(form_factor_);
}
inline void DmiMemoryDevices_Item::set_form_factor(::aspia::proto::DmiMemoryDevices_FormFactor value) {
  
  form_factor_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.form_factor)
}

// string serial_number = 6;
inline void DmiMemoryDevices_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.serial_number)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.serial_number)
}
#endif
inline void DmiMemoryDevices_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.serial_number)
}
inline void DmiMemoryDevices_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.serial_number)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.serial_number)
}

// string part_number = 7;
inline void DmiMemoryDevices_Item::clear_part_number() {
  part_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::part_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.part_number)
  return part_number_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_part_number(const ::std::string& value) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.part_number)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_part_number(::std::string&& value) {
  
  part_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.part_number)
}
#endif
inline void DmiMemoryDevices_Item::set_part_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.part_number)
}
inline void DmiMemoryDevices_Item::set_part_number(const char* value, size_t size) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.part_number)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_part_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.part_number)
  return part_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_part_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.part_number)
  
  return part_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_part_number(::std::string* part_number) {
  if (part_number != NULL) {
    
  } else {
    
  }
  part_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), part_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.part_number)
}

// string manufactorer = 8;
inline void DmiMemoryDevices_Item::clear_manufactorer() {
  manufactorer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::manufactorer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.manufactorer)
  return manufactorer_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_manufactorer(const ::std::string& value) {
  
  manufactorer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_manufactorer(::std::string&& value) {
  
  manufactorer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}
#endif
inline void DmiMemoryDevices_Item::set_manufactorer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufactorer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}
inline void DmiMemoryDevices_Item::set_manufactorer(const char* value, size_t size) {
  
  manufactorer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_manufactorer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.manufactorer)
  return manufactorer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_manufactorer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.manufactorer)
  
  return manufactorer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_manufactorer(::std::string* manufactorer) {
  if (manufactorer != NULL) {
    
  } else {
    
  }
  manufactorer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufactorer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.manufactorer)
}

// string bank = 9;
inline void DmiMemoryDevices_Item::clear_bank() {
  bank_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiMemoryDevices_Item::bank() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.bank)
  return bank_.GetNoArena();
}
inline void DmiMemoryDevices_Item::set_bank(const ::std::string& value) {
  
  bank_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.bank)
}
#if LANG_CXX11
inline void DmiMemoryDevices_Item::set_bank(::std::string&& value) {
  
  bank_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiMemoryDevices.Item.bank)
}
#endif
inline void DmiMemoryDevices_Item::set_bank(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bank_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiMemoryDevices.Item.bank)
}
inline void DmiMemoryDevices_Item::set_bank(const char* value, size_t size) {
  
  bank_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiMemoryDevices.Item.bank)
}
inline ::std::string* DmiMemoryDevices_Item::mutable_bank() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.Item.bank)
  return bank_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiMemoryDevices_Item::release_bank() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiMemoryDevices.Item.bank)
  
  return bank_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiMemoryDevices_Item::set_allocated_bank(::std::string* bank) {
  if (bank != NULL) {
    
  } else {
    
  }
  bank_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bank);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiMemoryDevices.Item.bank)
}

// int32 total_width = 10;
inline void DmiMemoryDevices_Item::clear_total_width() {
  total_width_ = 0;
}
inline ::google::protobuf::int32 DmiMemoryDevices_Item::total_width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.total_width)
  return total_width_;
}
inline void DmiMemoryDevices_Item::set_total_width(::google::protobuf::int32 value) {
  
  total_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.total_width)
}

// int32 data_width = 11;
inline void DmiMemoryDevices_Item::clear_data_width() {
  data_width_ = 0;
}
inline ::google::protobuf::int32 DmiMemoryDevices_Item::data_width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.Item.data_width)
  return data_width_;
}
inline void DmiMemoryDevices_Item::set_data_width(::google::protobuf::int32 value) {
  
  data_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiMemoryDevices.Item.data_width)
}

// -------------------------------------------------------------------

// DmiMemoryDevices

// repeated .aspia.proto.DmiMemoryDevices.Item item = 1;
inline int DmiMemoryDevices::item_size() const {
  return item_.size();
}
inline void DmiMemoryDevices::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiMemoryDevices_Item& DmiMemoryDevices::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiMemoryDevices.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiMemoryDevices_Item* DmiMemoryDevices::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiMemoryDevices.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiMemoryDevices_Item* DmiMemoryDevices::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiMemoryDevices.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item >*
DmiMemoryDevices::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiMemoryDevices.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiMemoryDevices_Item >&
DmiMemoryDevices::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiMemoryDevices.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiSystemSlots_Item

// string slot_designation = 1;
inline void DmiSystemSlots_Item::clear_slot_designation() {
  slot_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiSystemSlots_Item::slot_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.slot_designation)
  return slot_designation_.GetNoArena();
}
inline void DmiSystemSlots_Item::set_slot_designation(const ::std::string& value) {
  
  slot_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.slot_designation)
}
#if LANG_CXX11
inline void DmiSystemSlots_Item::set_slot_designation(::std::string&& value) {
  
  slot_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiSystemSlots.Item.slot_designation)
}
#endif
inline void DmiSystemSlots_Item::set_slot_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  slot_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiSystemSlots.Item.slot_designation)
}
inline void DmiSystemSlots_Item::set_slot_designation(const char* value, size_t size) {
  
  slot_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiSystemSlots.Item.slot_designation)
}
inline ::std::string* DmiSystemSlots_Item::mutable_slot_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystemSlots.Item.slot_designation)
  return slot_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiSystemSlots_Item::release_slot_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiSystemSlots.Item.slot_designation)
  
  return slot_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiSystemSlots_Item::set_allocated_slot_designation(::std::string* slot_designation) {
  if (slot_designation != NULL) {
    
  } else {
    
  }
  slot_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), slot_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiSystemSlots.Item.slot_designation)
}

// .aspia.proto.DmiSystemSlots.Type type = 2;
inline void DmiSystemSlots_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiSystemSlots_Type DmiSystemSlots_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.type)
  return static_cast< ::aspia::proto::DmiSystemSlots_Type >(type_);
}
inline void DmiSystemSlots_Item::set_type(::aspia::proto::DmiSystemSlots_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.type)
}

// .aspia.proto.DmiSystemSlots.Usage usage = 3;
inline void DmiSystemSlots_Item::clear_usage() {
  usage_ = 0;
}
inline ::aspia::proto::DmiSystemSlots_Usage DmiSystemSlots_Item::usage() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.usage)
  return static_cast< ::aspia::proto::DmiSystemSlots_Usage >(usage_);
}
inline void DmiSystemSlots_Item::set_usage(::aspia::proto::DmiSystemSlots_Usage value) {
  
  usage_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.usage)
}

// .aspia.proto.DmiSystemSlots.BusWidth bus_width = 4;
inline void DmiSystemSlots_Item::clear_bus_width() {
  bus_width_ = 0;
}
inline ::aspia::proto::DmiSystemSlots_BusWidth DmiSystemSlots_Item::bus_width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.bus_width)
  return static_cast< ::aspia::proto::DmiSystemSlots_BusWidth >(bus_width_);
}
inline void DmiSystemSlots_Item::set_bus_width(::aspia::proto::DmiSystemSlots_BusWidth value) {
  
  bus_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.bus_width)
}

// .aspia.proto.DmiSystemSlots.Length length = 5;
inline void DmiSystemSlots_Item::clear_length() {
  length_ = 0;
}
inline ::aspia::proto::DmiSystemSlots_Length DmiSystemSlots_Item::length() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.Item.length)
  return static_cast< ::aspia::proto::DmiSystemSlots_Length >(length_);
}
inline void DmiSystemSlots_Item::set_length(::aspia::proto::DmiSystemSlots_Length value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiSystemSlots.Item.length)
}

// -------------------------------------------------------------------

// DmiSystemSlots

// repeated .aspia.proto.DmiSystemSlots.Item item = 1;
inline int DmiSystemSlots::item_size() const {
  return item_.size();
}
inline void DmiSystemSlots::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiSystemSlots_Item& DmiSystemSlots::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiSystemSlots.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiSystemSlots_Item* DmiSystemSlots::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiSystemSlots.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiSystemSlots_Item* DmiSystemSlots::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiSystemSlots.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item >*
DmiSystemSlots::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiSystemSlots.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiSystemSlots_Item >&
DmiSystemSlots::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiSystemSlots.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiPortConnectors_Item

// string internal_designation = 1;
inline void DmiPortConnectors_Item::clear_internal_designation() {
  internal_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnectors_Item::internal_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.internal_designation)
  return internal_designation_.GetNoArena();
}
inline void DmiPortConnectors_Item::set_internal_designation(const ::std::string& value) {
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
#if LANG_CXX11
inline void DmiPortConnectors_Item::set_internal_designation(::std::string&& value) {
  
  internal_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
#endif
inline void DmiPortConnectors_Item::set_internal_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
inline void DmiPortConnectors_Item::set_internal_designation(const char* value, size_t size) {
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnectors.Item.internal_designation)
}
inline ::std::string* DmiPortConnectors_Item::mutable_internal_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.Item.internal_designation)
  return internal_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnectors_Item::release_internal_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnectors.Item.internal_designation)
  
  return internal_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnectors_Item::set_allocated_internal_designation(::std::string* internal_designation) {
  if (internal_designation != NULL) {
    
  } else {
    
  }
  internal_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), internal_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnectors.Item.internal_designation)
}

// string external_designation = 2;
inline void DmiPortConnectors_Item::clear_external_designation() {
  external_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnectors_Item::external_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.external_designation)
  return external_designation_.GetNoArena();
}
inline void DmiPortConnectors_Item::set_external_designation(const ::std::string& value) {
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.external_designation)
}
#if LANG_CXX11
inline void DmiPortConnectors_Item::set_external_designation(::std::string&& value) {
  
  external_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnectors.Item.external_designation)
}
#endif
inline void DmiPortConnectors_Item::set_external_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnectors.Item.external_designation)
}
inline void DmiPortConnectors_Item::set_external_designation(const char* value, size_t size) {
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnectors.Item.external_designation)
}
inline ::std::string* DmiPortConnectors_Item::mutable_external_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.Item.external_designation)
  return external_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnectors_Item::release_external_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnectors.Item.external_designation)
  
  return external_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnectors_Item::set_allocated_external_designation(::std::string* external_designation) {
  if (external_designation != NULL) {
    
  } else {
    
  }
  external_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), external_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnectors.Item.external_designation)
}

// .aspia.proto.DmiPortConnectors.Type type = 3;
inline void DmiPortConnectors_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiPortConnectors_Type DmiPortConnectors_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.type)
  return static_cast< ::aspia::proto::DmiPortConnectors_Type >(type_);
}
inline void DmiPortConnectors_Item::set_type(::aspia::proto::DmiPortConnectors_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.type)
}

// .aspia.proto.DmiPortConnectors.ConnectorType internal_connector_type = 4;
inline void DmiPortConnectors_Item::clear_internal_connector_type() {
  internal_connector_type_ = 0;
}
inline ::aspia::proto::DmiPortConnectors_ConnectorType DmiPortConnectors_Item::internal_connector_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
  return static_cast< ::aspia::proto::DmiPortConnectors_ConnectorType >(internal_connector_type_);
}
inline void DmiPortConnectors_Item::set_internal_connector_type(::aspia::proto::DmiPortConnectors_ConnectorType value) {
  
  internal_connector_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.internal_connector_type)
}

// .aspia.proto.DmiPortConnectors.ConnectorType external_connector_type = 5;
inline void DmiPortConnectors_Item::clear_external_connector_type() {
  external_connector_type_ = 0;
}
inline ::aspia::proto::DmiPortConnectors_ConnectorType DmiPortConnectors_Item::external_connector_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.Item.external_connector_type)
  return static_cast< ::aspia::proto::DmiPortConnectors_ConnectorType >(external_connector_type_);
}
inline void DmiPortConnectors_Item::set_external_connector_type(::aspia::proto::DmiPortConnectors_ConnectorType value) {
  
  external_connector_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnectors.Item.external_connector_type)
}

// -------------------------------------------------------------------

// DmiPortConnectors

// repeated .aspia.proto.DmiPortConnectors.Item item = 1;
inline int DmiPortConnectors::item_size() const {
  return item_.size();
}
inline void DmiPortConnectors::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiPortConnectors_Item& DmiPortConnectors::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnectors.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiPortConnectors_Item* DmiPortConnectors::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnectors.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiPortConnectors_Item* DmiPortConnectors::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiPortConnectors.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >*
DmiPortConnectors::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiPortConnectors.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnectors_Item >&
DmiPortConnectors::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiPortConnectors.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiOnBoardDevices_Item

// string description = 1;
inline void DmiOnBoardDevices_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiOnBoardDevices_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.Item.description)
  return description_.GetNoArena();
}
inline void DmiOnBoardDevices_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiOnBoardDevices.Item.description)
}
#if LANG_CXX11
inline void DmiOnBoardDevices_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiOnBoardDevices.Item.description)
}
#endif
inline void DmiOnBoardDevices_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiOnBoardDevices.Item.description)
}
inline void DmiOnBoardDevices_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiOnBoardDevices.Item.description)
}
inline ::std::string* DmiOnBoardDevices_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiOnBoardDevices.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiOnBoardDevices_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiOnBoardDevices.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiOnBoardDevices_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiOnBoardDevices.Item.description)
}

// .aspia.proto.DmiOnBoardDevices.Type type = 2;
inline void DmiOnBoardDevices_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiOnBoardDevices_Type DmiOnBoardDevices_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.Item.type)
  return static_cast< ::aspia::proto::DmiOnBoardDevices_Type >(type_);
}
inline void DmiOnBoardDevices_Item::set_type(::aspia::proto::DmiOnBoardDevices_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiOnBoardDevices.Item.type)
}

// bool enabled = 3;
inline void DmiOnBoardDevices_Item::clear_enabled() {
  enabled_ = false;
}
inline bool DmiOnBoardDevices_Item::enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.Item.enabled)
  return enabled_;
}
inline void DmiOnBoardDevices_Item::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiOnBoardDevices.Item.enabled)
}

// -------------------------------------------------------------------

// DmiOnBoardDevices

// repeated .aspia.proto.DmiOnBoardDevices.Item item = 1;
inline int DmiOnBoardDevices::item_size() const {
  return item_.size();
}
inline void DmiOnBoardDevices::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiOnBoardDevices_Item& DmiOnBoardDevices::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiOnBoardDevices.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiOnBoardDevices_Item* DmiOnBoardDevices::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiOnBoardDevices.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiOnBoardDevices_Item* DmiOnBoardDevices::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiOnBoardDevices.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >*
DmiOnBoardDevices::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiOnBoardDevices.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiOnBoardDevices_Item >&
DmiOnBoardDevices::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiOnBoardDevices.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiPointingDevice_Item

// .aspia.proto.DmiPointingDevice.Type device_type = 1;
inline void DmiPointingDevice_Item::clear_device_type() {
  device_type_ = 0;
}
inline ::aspia::proto::DmiPointingDevice_Type DmiPointingDevice_Item::device_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPointingDevice.Item.device_type)
  return static_cast< ::aspia::proto::DmiPointingDevice_Type >(device_type_);
}
inline void DmiPointingDevice_Item::set_device_type(::aspia::proto::DmiPointingDevice_Type value) {
  
  device_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPointingDevice.Item.device_type)
}

// .aspia.proto.DmiPointingDevice.Interface device_interface = 2;
inline void DmiPointingDevice_Item::clear_device_interface() {
  device_interface_ = 0;
}
inline ::aspia::proto::DmiPointingDevice_Interface DmiPointingDevice_Item::device_interface() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPointingDevice.Item.device_interface)
  return static_cast< ::aspia::proto::DmiPointingDevice_Interface >(device_interface_);
}
inline void DmiPointingDevice_Item::set_device_interface(::aspia::proto::DmiPointingDevice_Interface value) {
  
  device_interface_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPointingDevice.Item.device_interface)
}

// int32 button_count = 3;
inline void DmiPointingDevice_Item::clear_button_count() {
  button_count_ = 0;
}
inline ::google::protobuf::int32 DmiPointingDevice_Item::button_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPointingDevice.Item.button_count)
  return button_count_;
}
inline void DmiPointingDevice_Item::set_button_count(::google::protobuf::int32 value) {
  
  button_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPointingDevice.Item.button_count)
}

// -------------------------------------------------------------------

// DmiPointingDevice

// repeated .aspia.proto.DmiPointingDevice.Item item = 1;
inline int DmiPointingDevice::item_size() const {
  return item_.size();
}
inline void DmiPointingDevice::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiPointingDevice_Item& DmiPointingDevice::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPointingDevice.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiPointingDevice_Item* DmiPointingDevice::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPointingDevice.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiPointingDevice_Item* DmiPointingDevice::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiPointingDevice.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevice_Item >*
DmiPointingDevice::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiPointingDevice.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPointingDevice_Item >&
DmiPointingDevice::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiPointingDevice.item)
  return item_;
}

// -------------------------------------------------------------------

// DmiPortableBattery_Item

// string location = 1;
inline void DmiPortableBattery_Item::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.location)
  return location_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.location)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.location)
}
#endif
inline void DmiPortableBattery_Item::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.location)
}
inline void DmiPortableBattery_Item::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.location)
}
inline ::std::string* DmiPortableBattery_Item::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_location() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.location)
}

// string manufacturer = 2;
inline void DmiPortableBattery_Item::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
#endif
inline void DmiPortableBattery_Item::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
inline void DmiPortableBattery_Item::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.manufacturer)
}
inline ::std::string* DmiPortableBattery_Item::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.manufacturer)
}

// string manufacture_date = 3;
inline void DmiPortableBattery_Item::clear_manufacture_date() {
  manufacture_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::manufacture_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.manufacture_date)
  return manufacture_date_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_manufacture_date(const ::std::string& value) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_manufacture_date(::std::string&& value) {
  
  manufacture_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
#endif
inline void DmiPortableBattery_Item::set_manufacture_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
inline void DmiPortableBattery_Item::set_manufacture_date(const char* value, size_t size) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}
inline ::std::string* DmiPortableBattery_Item::mutable_manufacture_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.manufacture_date)
  return manufacture_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_manufacture_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.manufacture_date)
  
  return manufacture_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_manufacture_date(::std::string* manufacture_date) {
  if (manufacture_date != NULL) {
    
  } else {
    
  }
  manufacture_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacture_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.manufacture_date)
}

// string serial_number = 4;
inline void DmiPortableBattery_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.serial_number)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.serial_number)
}
#endif
inline void DmiPortableBattery_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.serial_number)
}
inline void DmiPortableBattery_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.serial_number)
}
inline ::std::string* DmiPortableBattery_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.serial_number)
}

// string device_name = 5;
inline void DmiPortableBattery_Item::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::device_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.device_name)
  return device_name_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_device_name(const ::std::string& value) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.device_name)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_device_name(::std::string&& value) {
  
  device_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.device_name)
}
#endif
inline void DmiPortableBattery_Item::set_device_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.device_name)
}
inline void DmiPortableBattery_Item::set_device_name(const char* value, size_t size) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.device_name)
}
inline ::std::string* DmiPortableBattery_Item::mutable_device_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_device_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.device_name)
  
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    
  } else {
    
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.device_name)
}

// .aspia.proto.DmiPortableBattery.Chemistry chemistry = 6;
inline void DmiPortableBattery_Item::clear_chemistry() {
  chemistry_ = 0;
}
inline ::aspia::proto::DmiPortableBattery_Chemistry DmiPortableBattery_Item::chemistry() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.chemistry)
  return static_cast< ::aspia::proto::DmiPortableBattery_Chemistry >(chemistry_);
}
inline void DmiPortableBattery_Item::set_chemistry(::aspia::proto::DmiPortableBattery_Chemistry value) {
  
  chemistry_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.chemistry)
}

// int32 design_capacity = 7;
inline void DmiPortableBattery_Item::clear_design_capacity() {
  design_capacity_ = 0;
}
inline ::google::protobuf::int32 DmiPortableBattery_Item::design_capacity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.design_capacity)
  return design_capacity_;
}
inline void DmiPortableBattery_Item::set_design_capacity(::google::protobuf::int32 value) {
  
  design_capacity_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.design_capacity)
}

// int32 design_voltage = 8;
inline void DmiPortableBattery_Item::clear_design_voltage() {
  design_voltage_ = 0;
}
inline ::google::protobuf::int32 DmiPortableBattery_Item::design_voltage() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.design_voltage)
  return design_voltage_;
}
inline void DmiPortableBattery_Item::set_design_voltage(::google::protobuf::int32 value) {
  
  design_voltage_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.design_voltage)
}

// string sbds_version_number = 9;
inline void DmiPortableBattery_Item::clear_sbds_version_number() {
  sbds_version_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_version_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
  return sbds_version_number_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_version_number(const ::std::string& value) {
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_version_number(::std::string&& value) {
  
  sbds_version_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_version_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
inline void DmiPortableBattery_Item::set_sbds_version_number(const char* value, size_t size) {
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_version_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
  return sbds_version_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_version_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
  
  return sbds_version_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_version_number(::std::string* sbds_version_number) {
  if (sbds_version_number != NULL) {
    
  } else {
    
  }
  sbds_version_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_version_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_version_number)
}

// int32 max_error_in_battery_data = 10;
inline void DmiPortableBattery_Item::clear_max_error_in_battery_data() {
  max_error_in_battery_data_ = 0;
}
inline ::google::protobuf::int32 DmiPortableBattery_Item::max_error_in_battery_data() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.max_error_in_battery_data)
  return max_error_in_battery_data_;
}
inline void DmiPortableBattery_Item::set_max_error_in_battery_data(::google::protobuf::int32 value) {
  
  max_error_in_battery_data_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.max_error_in_battery_data)
}

// string sbds_serial_number = 11;
inline void DmiPortableBattery_Item::clear_sbds_serial_number() {
  sbds_serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
  return sbds_serial_number_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_serial_number(const ::std::string& value) {
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_serial_number(::std::string&& value) {
  
  sbds_serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
inline void DmiPortableBattery_Item::set_sbds_serial_number(const char* value, size_t size) {
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
  return sbds_serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
  
  return sbds_serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_serial_number(::std::string* sbds_serial_number) {
  if (sbds_serial_number != NULL) {
    
  } else {
    
  }
  sbds_serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_serial_number)
}

// string sbds_manufacture_date = 12;
inline void DmiPortableBattery_Item::clear_sbds_manufacture_date() {
  sbds_manufacture_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_manufacture_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
  return sbds_manufacture_date_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(const ::std::string& value) {
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(::std::string&& value) {
  
  sbds_manufacture_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
inline void DmiPortableBattery_Item::set_sbds_manufacture_date(const char* value, size_t size) {
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_manufacture_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
  return sbds_manufacture_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_manufacture_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
  
  return sbds_manufacture_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_manufacture_date(::std::string* sbds_manufacture_date) {
  if (sbds_manufacture_date != NULL) {
    
  } else {
    
  }
  sbds_manufacture_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_manufacture_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_manufacture_date)
}

// string sbds_device_chemistry = 13;
inline void DmiPortableBattery_Item::clear_sbds_device_chemistry() {
  sbds_device_chemistry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortableBattery_Item::sbds_device_chemistry() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
  return sbds_device_chemistry_.GetNoArena();
}
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(const ::std::string& value) {
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
#if LANG_CXX11
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(::std::string&& value) {
  
  sbds_device_chemistry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
#endif
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
inline void DmiPortableBattery_Item::set_sbds_device_chemistry(const char* value, size_t size) {
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}
inline ::std::string* DmiPortableBattery_Item::mutable_sbds_device_chemistry() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
  return sbds_device_chemistry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortableBattery_Item::release_sbds_device_chemistry() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
  
  return sbds_device_chemistry_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortableBattery_Item::set_allocated_sbds_device_chemistry(::std::string* sbds_device_chemistry) {
  if (sbds_device_chemistry != NULL) {
    
  } else {
    
  }
  sbds_device_chemistry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_device_chemistry);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortableBattery.Item.sbds_device_chemistry)
}

// -------------------------------------------------------------------

// DmiPortableBattery

// repeated .aspia.proto.DmiPortableBattery.Item item = 1;
inline int DmiPortableBattery::item_size() const {
  return item_.size();
}
inline void DmiPortableBattery::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiPortableBattery_Item& DmiPortableBattery::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortableBattery.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiPortableBattery_Item* DmiPortableBattery::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortableBattery.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiPortableBattery_Item* DmiPortableBattery::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiPortableBattery.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >*
DmiPortableBattery::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiPortableBattery.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortableBattery_Item >&
DmiPortableBattery::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiPortableBattery.item)
  return item_;
}

// -------------------------------------------------------------------

// CPU_Features

// bool has_fpu = 1;
inline void CPU_Features::clear_has_fpu() {
  has_fpu_ = false;
}
inline bool CPU_Features::has_fpu() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_fpu)
  return has_fpu_;
}
inline void CPU_Features::set_has_fpu(bool value) {
  
  has_fpu_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_fpu)
}

// bool has_vme = 2;
inline void CPU_Features::clear_has_vme() {
  has_vme_ = false;
}
inline bool CPU_Features::has_vme() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_vme)
  return has_vme_;
}
inline void CPU_Features::set_has_vme(bool value) {
  
  has_vme_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_vme)
}

// bool has_de = 3;
inline void CPU_Features::clear_has_de() {
  has_de_ = false;
}
inline bool CPU_Features::has_de() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_de)
  return has_de_;
}
inline void CPU_Features::set_has_de(bool value) {
  
  has_de_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_de)
}

// bool has_pse = 4;
inline void CPU_Features::clear_has_pse() {
  has_pse_ = false;
}
inline bool CPU_Features::has_pse() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pse)
  return has_pse_;
}
inline void CPU_Features::set_has_pse(bool value) {
  
  has_pse_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pse)
}

// bool has_tsc = 5;
inline void CPU_Features::clear_has_tsc() {
  has_tsc_ = false;
}
inline bool CPU_Features::has_tsc() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_tsc)
  return has_tsc_;
}
inline void CPU_Features::set_has_tsc(bool value) {
  
  has_tsc_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_tsc)
}

// bool has_msr = 6;
inline void CPU_Features::clear_has_msr() {
  has_msr_ = false;
}
inline bool CPU_Features::has_msr() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_msr)
  return has_msr_;
}
inline void CPU_Features::set_has_msr(bool value) {
  
  has_msr_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_msr)
}

// bool has_pae = 7;
inline void CPU_Features::clear_has_pae() {
  has_pae_ = false;
}
inline bool CPU_Features::has_pae() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pae)
  return has_pae_;
}
inline void CPU_Features::set_has_pae(bool value) {
  
  has_pae_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pae)
}

// bool has_mce = 8;
inline void CPU_Features::clear_has_mce() {
  has_mce_ = false;
}
inline bool CPU_Features::has_mce() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_mce)
  return has_mce_;
}
inline void CPU_Features::set_has_mce(bool value) {
  
  has_mce_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_mce)
}

// bool has_cx8 = 9;
inline void CPU_Features::clear_has_cx8() {
  has_cx8_ = false;
}
inline bool CPU_Features::has_cx8() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_cx8)
  return has_cx8_;
}
inline void CPU_Features::set_has_cx8(bool value) {
  
  has_cx8_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_cx8)
}

// bool has_apic = 10;
inline void CPU_Features::clear_has_apic() {
  has_apic_ = false;
}
inline bool CPU_Features::has_apic() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_apic)
  return has_apic_;
}
inline void CPU_Features::set_has_apic(bool value) {
  
  has_apic_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_apic)
}

// bool has_sep = 11;
inline void CPU_Features::clear_has_sep() {
  has_sep_ = false;
}
inline bool CPU_Features::has_sep() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_sep)
  return has_sep_;
}
inline void CPU_Features::set_has_sep(bool value) {
  
  has_sep_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_sep)
}

// bool has_mtrr = 12;
inline void CPU_Features::clear_has_mtrr() {
  has_mtrr_ = false;
}
inline bool CPU_Features::has_mtrr() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_mtrr)
  return has_mtrr_;
}
inline void CPU_Features::set_has_mtrr(bool value) {
  
  has_mtrr_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_mtrr)
}

// bool has_pge = 13;
inline void CPU_Features::clear_has_pge() {
  has_pge_ = false;
}
inline bool CPU_Features::has_pge() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pge)
  return has_pge_;
}
inline void CPU_Features::set_has_pge(bool value) {
  
  has_pge_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pge)
}

// bool has_mca = 14;
inline void CPU_Features::clear_has_mca() {
  has_mca_ = false;
}
inline bool CPU_Features::has_mca() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_mca)
  return has_mca_;
}
inline void CPU_Features::set_has_mca(bool value) {
  
  has_mca_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_mca)
}

// bool has_cmov = 15;
inline void CPU_Features::clear_has_cmov() {
  has_cmov_ = false;
}
inline bool CPU_Features::has_cmov() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_cmov)
  return has_cmov_;
}
inline void CPU_Features::set_has_cmov(bool value) {
  
  has_cmov_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_cmov)
}

// bool has_pat = 16;
inline void CPU_Features::clear_has_pat() {
  has_pat_ = false;
}
inline bool CPU_Features::has_pat() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pat)
  return has_pat_;
}
inline void CPU_Features::set_has_pat(bool value) {
  
  has_pat_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pat)
}

// bool has_pse36 = 17;
inline void CPU_Features::clear_has_pse36() {
  has_pse36_ = false;
}
inline bool CPU_Features::has_pse36() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pse36)
  return has_pse36_;
}
inline void CPU_Features::set_has_pse36(bool value) {
  
  has_pse36_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pse36)
}

// bool has_psn = 18;
inline void CPU_Features::clear_has_psn() {
  has_psn_ = false;
}
inline bool CPU_Features::has_psn() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_psn)
  return has_psn_;
}
inline void CPU_Features::set_has_psn(bool value) {
  
  has_psn_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_psn)
}

// bool has_clfsh = 19;
inline void CPU_Features::clear_has_clfsh() {
  has_clfsh_ = false;
}
inline bool CPU_Features::has_clfsh() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_clfsh)
  return has_clfsh_;
}
inline void CPU_Features::set_has_clfsh(bool value) {
  
  has_clfsh_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_clfsh)
}

// bool has_ds = 20;
inline void CPU_Features::clear_has_ds() {
  has_ds_ = false;
}
inline bool CPU_Features::has_ds() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_ds)
  return has_ds_;
}
inline void CPU_Features::set_has_ds(bool value) {
  
  has_ds_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_ds)
}

// bool has_acpu = 21;
inline void CPU_Features::clear_has_acpu() {
  has_acpu_ = false;
}
inline bool CPU_Features::has_acpu() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_acpu)
  return has_acpu_;
}
inline void CPU_Features::set_has_acpu(bool value) {
  
  has_acpu_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_acpu)
}

// bool has_mmx = 22;
inline void CPU_Features::clear_has_mmx() {
  has_mmx_ = false;
}
inline bool CPU_Features::has_mmx() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_mmx)
  return has_mmx_;
}
inline void CPU_Features::set_has_mmx(bool value) {
  
  has_mmx_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_mmx)
}

// bool has_fxsr = 23;
inline void CPU_Features::clear_has_fxsr() {
  has_fxsr_ = false;
}
inline bool CPU_Features::has_fxsr() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_fxsr)
  return has_fxsr_;
}
inline void CPU_Features::set_has_fxsr(bool value) {
  
  has_fxsr_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_fxsr)
}

// bool has_sse = 24;
inline void CPU_Features::clear_has_sse() {
  has_sse_ = false;
}
inline bool CPU_Features::has_sse() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_sse)
  return has_sse_;
}
inline void CPU_Features::set_has_sse(bool value) {
  
  has_sse_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_sse)
}

// bool has_sse2 = 25;
inline void CPU_Features::clear_has_sse2() {
  has_sse2_ = false;
}
inline bool CPU_Features::has_sse2() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_sse2)
  return has_sse2_;
}
inline void CPU_Features::set_has_sse2(bool value) {
  
  has_sse2_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_sse2)
}

// bool has_ss = 26;
inline void CPU_Features::clear_has_ss() {
  has_ss_ = false;
}
inline bool CPU_Features::has_ss() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_ss)
  return has_ss_;
}
inline void CPU_Features::set_has_ss(bool value) {
  
  has_ss_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_ss)
}

// bool has_htt = 27;
inline void CPU_Features::clear_has_htt() {
  has_htt_ = false;
}
inline bool CPU_Features::has_htt() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_htt)
  return has_htt_;
}
inline void CPU_Features::set_has_htt(bool value) {
  
  has_htt_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_htt)
}

// bool has_tm = 28;
inline void CPU_Features::clear_has_tm() {
  has_tm_ = false;
}
inline bool CPU_Features::has_tm() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_tm)
  return has_tm_;
}
inline void CPU_Features::set_has_tm(bool value) {
  
  has_tm_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_tm)
}

// bool has_ia64 = 29;
inline void CPU_Features::clear_has_ia64() {
  has_ia64_ = false;
}
inline bool CPU_Features::has_ia64() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_ia64)
  return has_ia64_;
}
inline void CPU_Features::set_has_ia64(bool value) {
  
  has_ia64_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_ia64)
}

// bool has_pbe = 30;
inline void CPU_Features::clear_has_pbe() {
  has_pbe_ = false;
}
inline bool CPU_Features::has_pbe() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pbe)
  return has_pbe_;
}
inline void CPU_Features::set_has_pbe(bool value) {
  
  has_pbe_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pbe)
}

// bool has_sse3 = 31;
inline void CPU_Features::clear_has_sse3() {
  has_sse3_ = false;
}
inline bool CPU_Features::has_sse3() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_sse3)
  return has_sse3_;
}
inline void CPU_Features::set_has_sse3(bool value) {
  
  has_sse3_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_sse3)
}

// bool has_pclmuldq = 32;
inline void CPU_Features::clear_has_pclmuldq() {
  has_pclmuldq_ = false;
}
inline bool CPU_Features::has_pclmuldq() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pclmuldq)
  return has_pclmuldq_;
}
inline void CPU_Features::set_has_pclmuldq(bool value) {
  
  has_pclmuldq_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pclmuldq)
}

// bool has_dtes64 = 33;
inline void CPU_Features::clear_has_dtes64() {
  has_dtes64_ = false;
}
inline bool CPU_Features::has_dtes64() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_dtes64)
  return has_dtes64_;
}
inline void CPU_Features::set_has_dtes64(bool value) {
  
  has_dtes64_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_dtes64)
}

// bool has_monitor = 34;
inline void CPU_Features::clear_has_monitor() {
  has_monitor_ = false;
}
inline bool CPU_Features::has_monitor() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_monitor)
  return has_monitor_;
}
inline void CPU_Features::set_has_monitor(bool value) {
  
  has_monitor_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_monitor)
}

// bool has_ds_cpl = 35;
inline void CPU_Features::clear_has_ds_cpl() {
  has_ds_cpl_ = false;
}
inline bool CPU_Features::has_ds_cpl() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_ds_cpl)
  return has_ds_cpl_;
}
inline void CPU_Features::set_has_ds_cpl(bool value) {
  
  has_ds_cpl_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_ds_cpl)
}

// bool has_vmx = 36;
inline void CPU_Features::clear_has_vmx() {
  has_vmx_ = false;
}
inline bool CPU_Features::has_vmx() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_vmx)
  return has_vmx_;
}
inline void CPU_Features::set_has_vmx(bool value) {
  
  has_vmx_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_vmx)
}

// bool has_smx = 37;
inline void CPU_Features::clear_has_smx() {
  has_smx_ = false;
}
inline bool CPU_Features::has_smx() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_smx)
  return has_smx_;
}
inline void CPU_Features::set_has_smx(bool value) {
  
  has_smx_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_smx)
}

// bool has_est = 38;
inline void CPU_Features::clear_has_est() {
  has_est_ = false;
}
inline bool CPU_Features::has_est() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_est)
  return has_est_;
}
inline void CPU_Features::set_has_est(bool value) {
  
  has_est_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_est)
}

// bool has_tm2 = 39;
inline void CPU_Features::clear_has_tm2() {
  has_tm2_ = false;
}
inline bool CPU_Features::has_tm2() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_tm2)
  return has_tm2_;
}
inline void CPU_Features::set_has_tm2(bool value) {
  
  has_tm2_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_tm2)
}

// bool has_ssse3 = 40;
inline void CPU_Features::clear_has_ssse3() {
  has_ssse3_ = false;
}
inline bool CPU_Features::has_ssse3() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_ssse3)
  return has_ssse3_;
}
inline void CPU_Features::set_has_ssse3(bool value) {
  
  has_ssse3_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_ssse3)
}

// bool has_cnxt_id = 41;
inline void CPU_Features::clear_has_cnxt_id() {
  has_cnxt_id_ = false;
}
inline bool CPU_Features::has_cnxt_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_cnxt_id)
  return has_cnxt_id_;
}
inline void CPU_Features::set_has_cnxt_id(bool value) {
  
  has_cnxt_id_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_cnxt_id)
}

// bool has_sdbg = 42;
inline void CPU_Features::clear_has_sdbg() {
  has_sdbg_ = false;
}
inline bool CPU_Features::has_sdbg() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_sdbg)
  return has_sdbg_;
}
inline void CPU_Features::set_has_sdbg(bool value) {
  
  has_sdbg_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_sdbg)
}

// bool has_fma = 43;
inline void CPU_Features::clear_has_fma() {
  has_fma_ = false;
}
inline bool CPU_Features::has_fma() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_fma)
  return has_fma_;
}
inline void CPU_Features::set_has_fma(bool value) {
  
  has_fma_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_fma)
}

// bool has_cx16 = 44;
inline void CPU_Features::clear_has_cx16() {
  has_cx16_ = false;
}
inline bool CPU_Features::has_cx16() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_cx16)
  return has_cx16_;
}
inline void CPU_Features::set_has_cx16(bool value) {
  
  has_cx16_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_cx16)
}

// bool has_xtpr = 45;
inline void CPU_Features::clear_has_xtpr() {
  has_xtpr_ = false;
}
inline bool CPU_Features::has_xtpr() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_xtpr)
  return has_xtpr_;
}
inline void CPU_Features::set_has_xtpr(bool value) {
  
  has_xtpr_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_xtpr)
}

// bool has_pdcm = 46;
inline void CPU_Features::clear_has_pdcm() {
  has_pdcm_ = false;
}
inline bool CPU_Features::has_pdcm() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pdcm)
  return has_pdcm_;
}
inline void CPU_Features::set_has_pdcm(bool value) {
  
  has_pdcm_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pdcm)
}

// bool has_pcid = 47;
inline void CPU_Features::clear_has_pcid() {
  has_pcid_ = false;
}
inline bool CPU_Features::has_pcid() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pcid)
  return has_pcid_;
}
inline void CPU_Features::set_has_pcid(bool value) {
  
  has_pcid_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pcid)
}

// bool has_dca = 48;
inline void CPU_Features::clear_has_dca() {
  has_dca_ = false;
}
inline bool CPU_Features::has_dca() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_dca)
  return has_dca_;
}
inline void CPU_Features::set_has_dca(bool value) {
  
  has_dca_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_dca)
}

// bool has_sse41 = 49;
inline void CPU_Features::clear_has_sse41() {
  has_sse41_ = false;
}
inline bool CPU_Features::has_sse41() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_sse41)
  return has_sse41_;
}
inline void CPU_Features::set_has_sse41(bool value) {
  
  has_sse41_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_sse41)
}

// bool has_sse42 = 50;
inline void CPU_Features::clear_has_sse42() {
  has_sse42_ = false;
}
inline bool CPU_Features::has_sse42() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_sse42)
  return has_sse42_;
}
inline void CPU_Features::set_has_sse42(bool value) {
  
  has_sse42_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_sse42)
}

// bool has_x2apic = 51;
inline void CPU_Features::clear_has_x2apic() {
  has_x2apic_ = false;
}
inline bool CPU_Features::has_x2apic() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_x2apic)
  return has_x2apic_;
}
inline void CPU_Features::set_has_x2apic(bool value) {
  
  has_x2apic_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_x2apic)
}

// bool has_movbe = 52;
inline void CPU_Features::clear_has_movbe() {
  has_movbe_ = false;
}
inline bool CPU_Features::has_movbe() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_movbe)
  return has_movbe_;
}
inline void CPU_Features::set_has_movbe(bool value) {
  
  has_movbe_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_movbe)
}

// bool has_popcnt = 53;
inline void CPU_Features::clear_has_popcnt() {
  has_popcnt_ = false;
}
inline bool CPU_Features::has_popcnt() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_popcnt)
  return has_popcnt_;
}
inline void CPU_Features::set_has_popcnt(bool value) {
  
  has_popcnt_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_popcnt)
}

// bool has_tsc_deadline = 54;
inline void CPU_Features::clear_has_tsc_deadline() {
  has_tsc_deadline_ = false;
}
inline bool CPU_Features::has_tsc_deadline() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_tsc_deadline)
  return has_tsc_deadline_;
}
inline void CPU_Features::set_has_tsc_deadline(bool value) {
  
  has_tsc_deadline_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_tsc_deadline)
}

// bool has_aes = 55;
inline void CPU_Features::clear_has_aes() {
  has_aes_ = false;
}
inline bool CPU_Features::has_aes() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_aes)
  return has_aes_;
}
inline void CPU_Features::set_has_aes(bool value) {
  
  has_aes_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_aes)
}

// bool has_xsave = 56;
inline void CPU_Features::clear_has_xsave() {
  has_xsave_ = false;
}
inline bool CPU_Features::has_xsave() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_xsave)
  return has_xsave_;
}
inline void CPU_Features::set_has_xsave(bool value) {
  
  has_xsave_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_xsave)
}

// bool has_osxsave = 57;
inline void CPU_Features::clear_has_osxsave() {
  has_osxsave_ = false;
}
inline bool CPU_Features::has_osxsave() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_osxsave)
  return has_osxsave_;
}
inline void CPU_Features::set_has_osxsave(bool value) {
  
  has_osxsave_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_osxsave)
}

// bool has_avx = 58;
inline void CPU_Features::clear_has_avx() {
  has_avx_ = false;
}
inline bool CPU_Features::has_avx() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx)
  return has_avx_;
}
inline void CPU_Features::set_has_avx(bool value) {
  
  has_avx_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx)
}

// bool has_f16c = 59;
inline void CPU_Features::clear_has_f16c() {
  has_f16c_ = false;
}
inline bool CPU_Features::has_f16c() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_f16c)
  return has_f16c_;
}
inline void CPU_Features::set_has_f16c(bool value) {
  
  has_f16c_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_f16c)
}

// bool has_rdrand = 60;
inline void CPU_Features::clear_has_rdrand() {
  has_rdrand_ = false;
}
inline bool CPU_Features::has_rdrand() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_rdrand)
  return has_rdrand_;
}
inline void CPU_Features::set_has_rdrand(bool value) {
  
  has_rdrand_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_rdrand)
}

// bool has_hypervisor = 61;
inline void CPU_Features::clear_has_hypervisor() {
  has_hypervisor_ = false;
}
inline bool CPU_Features::has_hypervisor() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_hypervisor)
  return has_hypervisor_;
}
inline void CPU_Features::set_has_hypervisor(bool value) {
  
  has_hypervisor_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_hypervisor)
}

// bool has_syscall = 62;
inline void CPU_Features::clear_has_syscall() {
  has_syscall_ = false;
}
inline bool CPU_Features::has_syscall() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_syscall)
  return has_syscall_;
}
inline void CPU_Features::set_has_syscall(bool value) {
  
  has_syscall_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_syscall)
}

// bool has_xd_bit = 63;
inline void CPU_Features::clear_has_xd_bit() {
  has_xd_bit_ = false;
}
inline bool CPU_Features::has_xd_bit() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_xd_bit)
  return has_xd_bit_;
}
inline void CPU_Features::set_has_xd_bit(bool value) {
  
  has_xd_bit_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_xd_bit)
}

// bool has_mmxext = 64;
inline void CPU_Features::clear_has_mmxext() {
  has_mmxext_ = false;
}
inline bool CPU_Features::has_mmxext() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_mmxext)
  return has_mmxext_;
}
inline void CPU_Features::set_has_mmxext(bool value) {
  
  has_mmxext_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_mmxext)
}

// bool has_1gb_pages = 65;
inline void CPU_Features::clear_has_1gb_pages() {
  has_1gb_pages_ = false;
}
inline bool CPU_Features::has_1gb_pages() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_1gb_pages)
  return has_1gb_pages_;
}
inline void CPU_Features::set_has_1gb_pages(bool value) {
  
  has_1gb_pages_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_1gb_pages)
}

// bool has_rdtscp = 66;
inline void CPU_Features::clear_has_rdtscp() {
  has_rdtscp_ = false;
}
inline bool CPU_Features::has_rdtscp() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_rdtscp)
  return has_rdtscp_;
}
inline void CPU_Features::set_has_rdtscp(bool value) {
  
  has_rdtscp_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_rdtscp)
}

// bool has_intel64 = 67;
inline void CPU_Features::clear_has_intel64() {
  has_intel64_ = false;
}
inline bool CPU_Features::has_intel64() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_intel64)
  return has_intel64_;
}
inline void CPU_Features::set_has_intel64(bool value) {
  
  has_intel64_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_intel64)
}

// bool has_3dnowext = 68;
inline void CPU_Features::clear_has_3dnowext() {
  has_3dnowext_ = false;
}
inline bool CPU_Features::has_3dnowext() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_3dnowext)
  return has_3dnowext_;
}
inline void CPU_Features::set_has_3dnowext(bool value) {
  
  has_3dnowext_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_3dnowext)
}

// bool has_3dnow = 69;
inline void CPU_Features::clear_has_3dnow() {
  has_3dnow_ = false;
}
inline bool CPU_Features::has_3dnow() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_3dnow)
  return has_3dnow_;
}
inline void CPU_Features::set_has_3dnow(bool value) {
  
  has_3dnow_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_3dnow)
}

// bool has_lahf = 70;
inline void CPU_Features::clear_has_lahf() {
  has_lahf_ = false;
}
inline bool CPU_Features::has_lahf() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_lahf)
  return has_lahf_;
}
inline void CPU_Features::set_has_lahf(bool value) {
  
  has_lahf_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_lahf)
}

// bool has_svm = 71;
inline void CPU_Features::clear_has_svm() {
  has_svm_ = false;
}
inline bool CPU_Features::has_svm() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_svm)
  return has_svm_;
}
inline void CPU_Features::set_has_svm(bool value) {
  
  has_svm_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_svm)
}

// bool has_lzcnt = 72;
inline void CPU_Features::clear_has_lzcnt() {
  has_lzcnt_ = false;
}
inline bool CPU_Features::has_lzcnt() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_lzcnt)
  return has_lzcnt_;
}
inline void CPU_Features::set_has_lzcnt(bool value) {
  
  has_lzcnt_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_lzcnt)
}

// bool has_sse4a = 73;
inline void CPU_Features::clear_has_sse4a() {
  has_sse4a_ = false;
}
inline bool CPU_Features::has_sse4a() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_sse4a)
  return has_sse4a_;
}
inline void CPU_Features::set_has_sse4a(bool value) {
  
  has_sse4a_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_sse4a)
}

// bool has_misalignsse = 74;
inline void CPU_Features::clear_has_misalignsse() {
  has_misalignsse_ = false;
}
inline bool CPU_Features::has_misalignsse() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_misalignsse)
  return has_misalignsse_;
}
inline void CPU_Features::set_has_misalignsse(bool value) {
  
  has_misalignsse_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_misalignsse)
}

// bool has_3dnow_prefetch = 75;
inline void CPU_Features::clear_has_3dnow_prefetch() {
  has_3dnow_prefetch_ = false;
}
inline bool CPU_Features::has_3dnow_prefetch() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_3dnow_prefetch)
  return has_3dnow_prefetch_;
}
inline void CPU_Features::set_has_3dnow_prefetch(bool value) {
  
  has_3dnow_prefetch_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_3dnow_prefetch)
}

// bool has_xop = 76;
inline void CPU_Features::clear_has_xop() {
  has_xop_ = false;
}
inline bool CPU_Features::has_xop() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_xop)
  return has_xop_;
}
inline void CPU_Features::set_has_xop(bool value) {
  
  has_xop_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_xop)
}

// bool has_wdt = 77;
inline void CPU_Features::clear_has_wdt() {
  has_wdt_ = false;
}
inline bool CPU_Features::has_wdt() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_wdt)
  return has_wdt_;
}
inline void CPU_Features::set_has_wdt(bool value) {
  
  has_wdt_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_wdt)
}

// bool has_fma4 = 78;
inline void CPU_Features::clear_has_fma4() {
  has_fma4_ = false;
}
inline bool CPU_Features::has_fma4() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_fma4)
  return has_fma4_;
}
inline void CPU_Features::set_has_fma4(bool value) {
  
  has_fma4_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_fma4)
}

// bool has_fsgsbase = 79;
inline void CPU_Features::clear_has_fsgsbase() {
  has_fsgsbase_ = false;
}
inline bool CPU_Features::has_fsgsbase() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_fsgsbase)
  return has_fsgsbase_;
}
inline void CPU_Features::set_has_fsgsbase(bool value) {
  
  has_fsgsbase_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_fsgsbase)
}

// bool has_sgx = 80;
inline void CPU_Features::clear_has_sgx() {
  has_sgx_ = false;
}
inline bool CPU_Features::has_sgx() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_sgx)
  return has_sgx_;
}
inline void CPU_Features::set_has_sgx(bool value) {
  
  has_sgx_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_sgx)
}

// bool has_bmi1 = 81;
inline void CPU_Features::clear_has_bmi1() {
  has_bmi1_ = false;
}
inline bool CPU_Features::has_bmi1() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_bmi1)
  return has_bmi1_;
}
inline void CPU_Features::set_has_bmi1(bool value) {
  
  has_bmi1_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_bmi1)
}

// bool has_hle = 82;
inline void CPU_Features::clear_has_hle() {
  has_hle_ = false;
}
inline bool CPU_Features::has_hle() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_hle)
  return has_hle_;
}
inline void CPU_Features::set_has_hle(bool value) {
  
  has_hle_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_hle)
}

// bool has_avx2 = 83;
inline void CPU_Features::clear_has_avx2() {
  has_avx2_ = false;
}
inline bool CPU_Features::has_avx2() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx2)
  return has_avx2_;
}
inline void CPU_Features::set_has_avx2(bool value) {
  
  has_avx2_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx2)
}

// bool has_smep = 84;
inline void CPU_Features::clear_has_smep() {
  has_smep_ = false;
}
inline bool CPU_Features::has_smep() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_smep)
  return has_smep_;
}
inline void CPU_Features::set_has_smep(bool value) {
  
  has_smep_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_smep)
}

// bool has_bmi2 = 85;
inline void CPU_Features::clear_has_bmi2() {
  has_bmi2_ = false;
}
inline bool CPU_Features::has_bmi2() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_bmi2)
  return has_bmi2_;
}
inline void CPU_Features::set_has_bmi2(bool value) {
  
  has_bmi2_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_bmi2)
}

// bool has_erms = 86;
inline void CPU_Features::clear_has_erms() {
  has_erms_ = false;
}
inline bool CPU_Features::has_erms() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_erms)
  return has_erms_;
}
inline void CPU_Features::set_has_erms(bool value) {
  
  has_erms_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_erms)
}

// bool has_invpcid = 87;
inline void CPU_Features::clear_has_invpcid() {
  has_invpcid_ = false;
}
inline bool CPU_Features::has_invpcid() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_invpcid)
  return has_invpcid_;
}
inline void CPU_Features::set_has_invpcid(bool value) {
  
  has_invpcid_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_invpcid)
}

// bool has_rtm = 88;
inline void CPU_Features::clear_has_rtm() {
  has_rtm_ = false;
}
inline bool CPU_Features::has_rtm() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_rtm)
  return has_rtm_;
}
inline void CPU_Features::set_has_rtm(bool value) {
  
  has_rtm_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_rtm)
}

// bool has_pqm = 89;
inline void CPU_Features::clear_has_pqm() {
  has_pqm_ = false;
}
inline bool CPU_Features::has_pqm() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pqm)
  return has_pqm_;
}
inline void CPU_Features::set_has_pqm(bool value) {
  
  has_pqm_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pqm)
}

// bool has_mpx = 90;
inline void CPU_Features::clear_has_mpx() {
  has_mpx_ = false;
}
inline bool CPU_Features::has_mpx() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_mpx)
  return has_mpx_;
}
inline void CPU_Features::set_has_mpx(bool value) {
  
  has_mpx_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_mpx)
}

// bool has_pqe = 91;
inline void CPU_Features::clear_has_pqe() {
  has_pqe_ = false;
}
inline bool CPU_Features::has_pqe() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pqe)
  return has_pqe_;
}
inline void CPU_Features::set_has_pqe(bool value) {
  
  has_pqe_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pqe)
}

// bool has_avx512f = 92;
inline void CPU_Features::clear_has_avx512f() {
  has_avx512f_ = false;
}
inline bool CPU_Features::has_avx512f() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512f)
  return has_avx512f_;
}
inline void CPU_Features::set_has_avx512f(bool value) {
  
  has_avx512f_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512f)
}

// bool has_avx512dq = 93;
inline void CPU_Features::clear_has_avx512dq() {
  has_avx512dq_ = false;
}
inline bool CPU_Features::has_avx512dq() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512dq)
  return has_avx512dq_;
}
inline void CPU_Features::set_has_avx512dq(bool value) {
  
  has_avx512dq_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512dq)
}

// bool has_rdseed = 94;
inline void CPU_Features::clear_has_rdseed() {
  has_rdseed_ = false;
}
inline bool CPU_Features::has_rdseed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_rdseed)
  return has_rdseed_;
}
inline void CPU_Features::set_has_rdseed(bool value) {
  
  has_rdseed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_rdseed)
}

// bool has_adx = 95;
inline void CPU_Features::clear_has_adx() {
  has_adx_ = false;
}
inline bool CPU_Features::has_adx() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_adx)
  return has_adx_;
}
inline void CPU_Features::set_has_adx(bool value) {
  
  has_adx_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_adx)
}

// bool has_smap = 96;
inline void CPU_Features::clear_has_smap() {
  has_smap_ = false;
}
inline bool CPU_Features::has_smap() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_smap)
  return has_smap_;
}
inline void CPU_Features::set_has_smap(bool value) {
  
  has_smap_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_smap)
}

// bool has_avx512ifma = 97;
inline void CPU_Features::clear_has_avx512ifma() {
  has_avx512ifma_ = false;
}
inline bool CPU_Features::has_avx512ifma() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512ifma)
  return has_avx512ifma_;
}
inline void CPU_Features::set_has_avx512ifma(bool value) {
  
  has_avx512ifma_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512ifma)
}

// bool has_pcommit = 98;
inline void CPU_Features::clear_has_pcommit() {
  has_pcommit_ = false;
}
inline bool CPU_Features::has_pcommit() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pcommit)
  return has_pcommit_;
}
inline void CPU_Features::set_has_pcommit(bool value) {
  
  has_pcommit_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pcommit)
}

// bool has_clflushopt = 99;
inline void CPU_Features::clear_has_clflushopt() {
  has_clflushopt_ = false;
}
inline bool CPU_Features::has_clflushopt() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_clflushopt)
  return has_clflushopt_;
}
inline void CPU_Features::set_has_clflushopt(bool value) {
  
  has_clflushopt_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_clflushopt)
}

// bool has_clwb = 100;
inline void CPU_Features::clear_has_clwb() {
  has_clwb_ = false;
}
inline bool CPU_Features::has_clwb() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_clwb)
  return has_clwb_;
}
inline void CPU_Features::set_has_clwb(bool value) {
  
  has_clwb_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_clwb)
}

// bool has_intel_pt = 101;
inline void CPU_Features::clear_has_intel_pt() {
  has_intel_pt_ = false;
}
inline bool CPU_Features::has_intel_pt() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_intel_pt)
  return has_intel_pt_;
}
inline void CPU_Features::set_has_intel_pt(bool value) {
  
  has_intel_pt_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_intel_pt)
}

// bool has_avx512pf = 102;
inline void CPU_Features::clear_has_avx512pf() {
  has_avx512pf_ = false;
}
inline bool CPU_Features::has_avx512pf() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512pf)
  return has_avx512pf_;
}
inline void CPU_Features::set_has_avx512pf(bool value) {
  
  has_avx512pf_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512pf)
}

// bool has_avx512er = 103;
inline void CPU_Features::clear_has_avx512er() {
  has_avx512er_ = false;
}
inline bool CPU_Features::has_avx512er() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512er)
  return has_avx512er_;
}
inline void CPU_Features::set_has_avx512er(bool value) {
  
  has_avx512er_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512er)
}

// bool has_avx512cd = 104;
inline void CPU_Features::clear_has_avx512cd() {
  has_avx512cd_ = false;
}
inline bool CPU_Features::has_avx512cd() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512cd)
  return has_avx512cd_;
}
inline void CPU_Features::set_has_avx512cd(bool value) {
  
  has_avx512cd_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512cd)
}

// bool has_sha = 105;
inline void CPU_Features::clear_has_sha() {
  has_sha_ = false;
}
inline bool CPU_Features::has_sha() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_sha)
  return has_sha_;
}
inline void CPU_Features::set_has_sha(bool value) {
  
  has_sha_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_sha)
}

// bool has_avx512bw = 106;
inline void CPU_Features::clear_has_avx512bw() {
  has_avx512bw_ = false;
}
inline bool CPU_Features::has_avx512bw() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512bw)
  return has_avx512bw_;
}
inline void CPU_Features::set_has_avx512bw(bool value) {
  
  has_avx512bw_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512bw)
}

// bool has_avx512vl = 107;
inline void CPU_Features::clear_has_avx512vl() {
  has_avx512vl_ = false;
}
inline bool CPU_Features::has_avx512vl() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512vl)
  return has_avx512vl_;
}
inline void CPU_Features::set_has_avx512vl(bool value) {
  
  has_avx512vl_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512vl)
}

// bool has_prefetchwt1 = 108;
inline void CPU_Features::clear_has_prefetchwt1() {
  has_prefetchwt1_ = false;
}
inline bool CPU_Features::has_prefetchwt1() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_prefetchwt1)
  return has_prefetchwt1_;
}
inline void CPU_Features::set_has_prefetchwt1(bool value) {
  
  has_prefetchwt1_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_prefetchwt1)
}

// bool has_avx512vbmi = 109;
inline void CPU_Features::clear_has_avx512vbmi() {
  has_avx512vbmi_ = false;
}
inline bool CPU_Features::has_avx512vbmi() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512vbmi)
  return has_avx512vbmi_;
}
inline void CPU_Features::set_has_avx512vbmi(bool value) {
  
  has_avx512vbmi_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512vbmi)
}

// bool has_umip = 110;
inline void CPU_Features::clear_has_umip() {
  has_umip_ = false;
}
inline bool CPU_Features::has_umip() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_umip)
  return has_umip_;
}
inline void CPU_Features::set_has_umip(bool value) {
  
  has_umip_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_umip)
}

// bool has_pku = 111;
inline void CPU_Features::clear_has_pku() {
  has_pku_ = false;
}
inline bool CPU_Features::has_pku() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pku)
  return has_pku_;
}
inline void CPU_Features::set_has_pku(bool value) {
  
  has_pku_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pku)
}

// bool has_ospke = 112;
inline void CPU_Features::clear_has_ospke() {
  has_ospke_ = false;
}
inline bool CPU_Features::has_ospke() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_ospke)
  return has_ospke_;
}
inline void CPU_Features::set_has_ospke(bool value) {
  
  has_ospke_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_ospke)
}

// bool has_avx512vbmi2 = 113;
inline void CPU_Features::clear_has_avx512vbmi2() {
  has_avx512vbmi2_ = false;
}
inline bool CPU_Features::has_avx512vbmi2() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512vbmi2)
  return has_avx512vbmi2_;
}
inline void CPU_Features::set_has_avx512vbmi2(bool value) {
  
  has_avx512vbmi2_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512vbmi2)
}

// bool has_gfni = 114;
inline void CPU_Features::clear_has_gfni() {
  has_gfni_ = false;
}
inline bool CPU_Features::has_gfni() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_gfni)
  return has_gfni_;
}
inline void CPU_Features::set_has_gfni(bool value) {
  
  has_gfni_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_gfni)
}

// bool has_vaes = 115;
inline void CPU_Features::clear_has_vaes() {
  has_vaes_ = false;
}
inline bool CPU_Features::has_vaes() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_vaes)
  return has_vaes_;
}
inline void CPU_Features::set_has_vaes(bool value) {
  
  has_vaes_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_vaes)
}

// bool has_vpclmulqdq = 116;
inline void CPU_Features::clear_has_vpclmulqdq() {
  has_vpclmulqdq_ = false;
}
inline bool CPU_Features::has_vpclmulqdq() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_vpclmulqdq)
  return has_vpclmulqdq_;
}
inline void CPU_Features::set_has_vpclmulqdq(bool value) {
  
  has_vpclmulqdq_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_vpclmulqdq)
}

// bool has_avx512vnni = 117;
inline void CPU_Features::clear_has_avx512vnni() {
  has_avx512vnni_ = false;
}
inline bool CPU_Features::has_avx512vnni() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512vnni)
  return has_avx512vnni_;
}
inline void CPU_Features::set_has_avx512vnni(bool value) {
  
  has_avx512vnni_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512vnni)
}

// bool has_avx512bitalg = 118;
inline void CPU_Features::clear_has_avx512bitalg() {
  has_avx512bitalg_ = false;
}
inline bool CPU_Features::has_avx512bitalg() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512bitalg)
  return has_avx512bitalg_;
}
inline void CPU_Features::set_has_avx512bitalg(bool value) {
  
  has_avx512bitalg_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512bitalg)
}

// bool has_avx512vpopcntdq = 119;
inline void CPU_Features::clear_has_avx512vpopcntdq() {
  has_avx512vpopcntdq_ = false;
}
inline bool CPU_Features::has_avx512vpopcntdq() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512vpopcntdq)
  return has_avx512vpopcntdq_;
}
inline void CPU_Features::set_has_avx512vpopcntdq(bool value) {
  
  has_avx512vpopcntdq_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512vpopcntdq)
}

// bool has_rdpid = 120;
inline void CPU_Features::clear_has_rdpid() {
  has_rdpid_ = false;
}
inline bool CPU_Features::has_rdpid() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_rdpid)
  return has_rdpid_;
}
inline void CPU_Features::set_has_rdpid(bool value) {
  
  has_rdpid_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_rdpid)
}

// bool has_sgx_lc = 121;
inline void CPU_Features::clear_has_sgx_lc() {
  has_sgx_lc_ = false;
}
inline bool CPU_Features::has_sgx_lc() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_sgx_lc)
  return has_sgx_lc_;
}
inline void CPU_Features::set_has_sgx_lc(bool value) {
  
  has_sgx_lc_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_sgx_lc)
}

// bool has_avx512_4vnniw = 122;
inline void CPU_Features::clear_has_avx512_4vnniw() {
  has_avx512_4vnniw_ = false;
}
inline bool CPU_Features::has_avx512_4vnniw() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512_4vnniw)
  return has_avx512_4vnniw_;
}
inline void CPU_Features::set_has_avx512_4vnniw(bool value) {
  
  has_avx512_4vnniw_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512_4vnniw)
}

// bool has_avx512_4fmaps = 123;
inline void CPU_Features::clear_has_avx512_4fmaps() {
  has_avx512_4fmaps_ = false;
}
inline bool CPU_Features::has_avx512_4fmaps() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_avx512_4fmaps)
  return has_avx512_4fmaps_;
}
inline void CPU_Features::set_has_avx512_4fmaps(bool value) {
  
  has_avx512_4fmaps_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_avx512_4fmaps)
}

// bool has_ais = 124;
inline void CPU_Features::clear_has_ais() {
  has_ais_ = false;
}
inline bool CPU_Features::has_ais() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_ais)
  return has_ais_;
}
inline void CPU_Features::set_has_ais(bool value) {
  
  has_ais_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_ais)
}

// bool has_rng = 125;
inline void CPU_Features::clear_has_rng() {
  has_rng_ = false;
}
inline bool CPU_Features::has_rng() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_rng)
  return has_rng_;
}
inline void CPU_Features::set_has_rng(bool value) {
  
  has_rng_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_rng)
}

// bool has_lh = 126;
inline void CPU_Features::clear_has_lh() {
  has_lh_ = false;
}
inline bool CPU_Features::has_lh() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_lh)
  return has_lh_;
}
inline void CPU_Features::set_has_lh(bool value) {
  
  has_lh_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_lh)
}

// bool has_femms = 127;
inline void CPU_Features::clear_has_femms() {
  has_femms_ = false;
}
inline bool CPU_Features::has_femms() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_femms)
  return has_femms_;
}
inline void CPU_Features::set_has_femms(bool value) {
  
  has_femms_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_femms)
}

// bool has_ace = 128;
inline void CPU_Features::clear_has_ace() {
  has_ace_ = false;
}
inline bool CPU_Features::has_ace() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_ace)
  return has_ace_;
}
inline void CPU_Features::set_has_ace(bool value) {
  
  has_ace_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_ace)
}

// bool has_ace2 = 129;
inline void CPU_Features::clear_has_ace2() {
  has_ace2_ = false;
}
inline bool CPU_Features::has_ace2() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_ace2)
  return has_ace2_;
}
inline void CPU_Features::set_has_ace2(bool value) {
  
  has_ace2_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_ace2)
}

// bool has_phe = 130;
inline void CPU_Features::clear_has_phe() {
  has_phe_ = false;
}
inline bool CPU_Features::has_phe() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_phe)
  return has_phe_;
}
inline void CPU_Features::set_has_phe(bool value) {
  
  has_phe_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_phe)
}

// bool has_pmm = 131;
inline void CPU_Features::clear_has_pmm() {
  has_pmm_ = false;
}
inline bool CPU_Features::has_pmm() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_pmm)
  return has_pmm_;
}
inline void CPU_Features::set_has_pmm(bool value) {
  
  has_pmm_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_pmm)
}

// bool has_parallax = 132;
inline void CPU_Features::clear_has_parallax() {
  has_parallax_ = false;
}
inline bool CPU_Features::has_parallax() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_parallax)
  return has_parallax_;
}
inline void CPU_Features::set_has_parallax(bool value) {
  
  has_parallax_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_parallax)
}

// bool has_overstress = 133;
inline void CPU_Features::clear_has_overstress() {
  has_overstress_ = false;
}
inline bool CPU_Features::has_overstress() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_overstress)
  return has_overstress_;
}
inline void CPU_Features::set_has_overstress(bool value) {
  
  has_overstress_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_overstress)
}

// bool has_tm3 = 134;
inline void CPU_Features::clear_has_tm3() {
  has_tm3_ = false;
}
inline bool CPU_Features::has_tm3() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_tm3)
  return has_tm3_;
}
inline void CPU_Features::set_has_tm3(bool value) {
  
  has_tm3_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_tm3)
}

// bool has_rng2 = 135;
inline void CPU_Features::clear_has_rng2() {
  has_rng2_ = false;
}
inline bool CPU_Features::has_rng2() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_rng2)
  return has_rng2_;
}
inline void CPU_Features::set_has_rng2(bool value) {
  
  has_rng2_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_rng2)
}

// bool has_phe2 = 136;
inline void CPU_Features::clear_has_phe2() {
  has_phe2_ = false;
}
inline bool CPU_Features::has_phe2() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.Features.has_phe2)
  return has_phe2_;
}
inline void CPU_Features::set_has_phe2(bool value) {
  
  has_phe2_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.Features.has_phe2)
}

// -------------------------------------------------------------------

// CPU

// string brand_string = 1;
inline void CPU::clear_brand_string() {
  brand_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CPU::brand_string() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.brand_string)
  return brand_string_.GetNoArena();
}
inline void CPU::set_brand_string(const ::std::string& value) {
  
  brand_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.brand_string)
}
#if LANG_CXX11
inline void CPU::set_brand_string(::std::string&& value) {
  
  brand_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.CPU.brand_string)
}
#endif
inline void CPU::set_brand_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  brand_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.CPU.brand_string)
}
inline void CPU::set_brand_string(const char* value, size_t size) {
  
  brand_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.CPU.brand_string)
}
inline ::std::string* CPU::mutable_brand_string() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.CPU.brand_string)
  return brand_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CPU::release_brand_string() {
  // @@protoc_insertion_point(field_release:aspia.proto.CPU.brand_string)
  
  return brand_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CPU::set_allocated_brand_string(::std::string* brand_string) {
  if (brand_string != NULL) {
    
  } else {
    
  }
  brand_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), brand_string);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.CPU.brand_string)
}

// string vendor = 2;
inline void CPU::clear_vendor() {
  vendor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CPU::vendor() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.vendor)
  return vendor_.GetNoArena();
}
inline void CPU::set_vendor(const ::std::string& value) {
  
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.vendor)
}
#if LANG_CXX11
inline void CPU::set_vendor(::std::string&& value) {
  
  vendor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.CPU.vendor)
}
#endif
inline void CPU::set_vendor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.CPU.vendor)
}
inline void CPU::set_vendor(const char* value, size_t size) {
  
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.CPU.vendor)
}
inline ::std::string* CPU::mutable_vendor() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.CPU.vendor)
  return vendor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CPU::release_vendor() {
  // @@protoc_insertion_point(field_release:aspia.proto.CPU.vendor)
  
  return vendor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CPU::set_allocated_vendor(::std::string* vendor) {
  if (vendor != NULL) {
    
  } else {
    
  }
  vendor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vendor);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.CPU.vendor)
}

// uint32 stepping = 3;
inline void CPU::clear_stepping() {
  stepping_ = 0u;
}
inline ::google::protobuf::uint32 CPU::stepping() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.stepping)
  return stepping_;
}
inline void CPU::set_stepping(::google::protobuf::uint32 value) {
  
  stepping_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.stepping)
}

// uint32 model = 4;
inline void CPU::clear_model() {
  model_ = 0u;
}
inline ::google::protobuf::uint32 CPU::model() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.model)
  return model_;
}
inline void CPU::set_model(::google::protobuf::uint32 value) {
  
  model_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.model)
}

// uint32 family = 5;
inline void CPU::clear_family() {
  family_ = 0u;
}
inline ::google::protobuf::uint32 CPU::family() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.family)
  return family_;
}
inline void CPU::set_family(::google::protobuf::uint32 value) {
  
  family_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.family)
}

// uint32 extended_model = 6;
inline void CPU::clear_extended_model() {
  extended_model_ = 0u;
}
inline ::google::protobuf::uint32 CPU::extended_model() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.extended_model)
  return extended_model_;
}
inline void CPU::set_extended_model(::google::protobuf::uint32 value) {
  
  extended_model_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.extended_model)
}

// uint32 extended_family = 7;
inline void CPU::clear_extended_family() {
  extended_family_ = 0u;
}
inline ::google::protobuf::uint32 CPU::extended_family() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.extended_family)
  return extended_family_;
}
inline void CPU::set_extended_family(::google::protobuf::uint32 value) {
  
  extended_family_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.extended_family)
}

// uint32 brand_id = 8;
inline void CPU::clear_brand_id() {
  brand_id_ = 0u;
}
inline ::google::protobuf::uint32 CPU::brand_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.brand_id)
  return brand_id_;
}
inline void CPU::set_brand_id(::google::protobuf::uint32 value) {
  
  brand_id_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.brand_id)
}

// uint32 packages = 9;
inline void CPU::clear_packages() {
  packages_ = 0u;
}
inline ::google::protobuf::uint32 CPU::packages() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.packages)
  return packages_;
}
inline void CPU::set_packages(::google::protobuf::uint32 value) {
  
  packages_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.packages)
}

// uint32 physical_cores = 10;
inline void CPU::clear_physical_cores() {
  physical_cores_ = 0u;
}
inline ::google::protobuf::uint32 CPU::physical_cores() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.physical_cores)
  return physical_cores_;
}
inline void CPU::set_physical_cores(::google::protobuf::uint32 value) {
  
  physical_cores_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.physical_cores)
}

// uint32 logical_cores = 11;
inline void CPU::clear_logical_cores() {
  logical_cores_ = 0u;
}
inline ::google::protobuf::uint32 CPU::logical_cores() const {
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.logical_cores)
  return logical_cores_;
}
inline void CPU::set_logical_cores(::google::protobuf::uint32 value) {
  
  logical_cores_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.CPU.logical_cores)
}

// .aspia.proto.CPU.Features features = 12;
inline bool CPU::has_features() const {
  return this != internal_default_instance() && features_ != NULL;
}
inline void CPU::clear_features() {
  if (GetArenaNoVirtual() == NULL && features_ != NULL) {
    delete features_;
  }
  features_ = NULL;
}
inline const ::aspia::proto::CPU_Features& CPU::features() const {
  const ::aspia::proto::CPU_Features* p = features_;
  // @@protoc_insertion_point(field_get:aspia.proto.CPU.features)
  return p != NULL ? *p : *reinterpret_cast<const ::aspia::proto::CPU_Features*>(
      &::aspia::proto::_CPU_Features_default_instance_);
}
inline ::aspia::proto::CPU_Features* CPU::release_features() {
  // @@protoc_insertion_point(field_release:aspia.proto.CPU.features)
  
  ::aspia::proto::CPU_Features* temp = features_;
  features_ = NULL;
  return temp;
}
inline ::aspia::proto::CPU_Features* CPU::mutable_features() {
  
  if (features_ == NULL) {
    features_ = new ::aspia::proto::CPU_Features;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.CPU.features)
  return features_;
}
inline void CPU::set_allocated_features(::aspia::proto::CPU_Features* features) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete features_;
  }
  if (features) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      features = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, features, submessage_arena);
    }
    
  } else {
    
  }
  features_ = features;
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.CPU.features)
}

// -------------------------------------------------------------------

// AtaDrives_Item

// string model_number = 1;
inline void AtaDrives_Item::clear_model_number() {
  model_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AtaDrives_Item::model_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.model_number)
  return model_number_.GetNoArena();
}
inline void AtaDrives_Item::set_model_number(const ::std::string& value) {
  
  model_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.model_number)
}
#if LANG_CXX11
inline void AtaDrives_Item::set_model_number(::std::string&& value) {
  
  model_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.AtaDrives.Item.model_number)
}
#endif
inline void AtaDrives_Item::set_model_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  model_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.AtaDrives.Item.model_number)
}
inline void AtaDrives_Item::set_model_number(const char* value, size_t size) {
  
  model_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.AtaDrives.Item.model_number)
}
inline ::std::string* AtaDrives_Item::mutable_model_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.AtaDrives.Item.model_number)
  return model_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AtaDrives_Item::release_model_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.AtaDrives.Item.model_number)
  
  return model_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AtaDrives_Item::set_allocated_model_number(::std::string* model_number) {
  if (model_number != NULL) {
    
  } else {
    
  }
  model_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.AtaDrives.Item.model_number)
}

// string serial_number = 2;
inline void AtaDrives_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AtaDrives_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void AtaDrives_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.serial_number)
}
#if LANG_CXX11
inline void AtaDrives_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.AtaDrives.Item.serial_number)
}
#endif
inline void AtaDrives_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.AtaDrives.Item.serial_number)
}
inline void AtaDrives_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.AtaDrives.Item.serial_number)
}
inline ::std::string* AtaDrives_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.AtaDrives.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AtaDrives_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.AtaDrives.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AtaDrives_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.AtaDrives.Item.serial_number)
}

// string firmware_revision = 3;
inline void AtaDrives_Item::clear_firmware_revision() {
  firmware_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AtaDrives_Item::firmware_revision() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.firmware_revision)
  return firmware_revision_.GetNoArena();
}
inline void AtaDrives_Item::set_firmware_revision(const ::std::string& value) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.firmware_revision)
}
#if LANG_CXX11
inline void AtaDrives_Item::set_firmware_revision(::std::string&& value) {
  
  firmware_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.AtaDrives.Item.firmware_revision)
}
#endif
inline void AtaDrives_Item::set_firmware_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.AtaDrives.Item.firmware_revision)
}
inline void AtaDrives_Item::set_firmware_revision(const char* value, size_t size) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.AtaDrives.Item.firmware_revision)
}
inline ::std::string* AtaDrives_Item::mutable_firmware_revision() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.AtaDrives.Item.firmware_revision)
  return firmware_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AtaDrives_Item::release_firmware_revision() {
  // @@protoc_insertion_point(field_release:aspia.proto.AtaDrives.Item.firmware_revision)
  
  return firmware_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AtaDrives_Item::set_allocated_firmware_revision(::std::string* firmware_revision) {
  if (firmware_revision != NULL) {
    
  } else {
    
  }
  firmware_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_revision);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.AtaDrives.Item.firmware_revision)
}

// .aspia.proto.AtaDrives.BusType bus_type = 4;
inline void AtaDrives_Item::clear_bus_type() {
  bus_type_ = 0;
}
inline ::aspia::proto::AtaDrives_BusType AtaDrives_Item::bus_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.bus_type)
  return static_cast< ::aspia::proto::AtaDrives_BusType >(bus_type_);
}
inline void AtaDrives_Item::set_bus_type(::aspia::proto::AtaDrives_BusType value) {
  
  bus_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.bus_type)
}

// .aspia.proto.AtaDrives.TransferMode transfer_mode = 5;
inline void AtaDrives_Item::clear_transfer_mode() {
  transfer_mode_ = 0;
}
inline ::aspia::proto::AtaDrives_TransferMode AtaDrives_Item::transfer_mode() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.transfer_mode)
  return static_cast< ::aspia::proto::AtaDrives_TransferMode >(transfer_mode_);
}
inline void AtaDrives_Item::set_transfer_mode(::aspia::proto::AtaDrives_TransferMode value) {
  
  transfer_mode_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.transfer_mode)
}

// uint32 rotation_rate = 6;
inline void AtaDrives_Item::clear_rotation_rate() {
  rotation_rate_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::rotation_rate() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.rotation_rate)
  return rotation_rate_;
}
inline void AtaDrives_Item::set_rotation_rate(::google::protobuf::uint32 value) {
  
  rotation_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.rotation_rate)
}

// uint64 drive_size = 7;
inline void AtaDrives_Item::clear_drive_size() {
  drive_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AtaDrives_Item::drive_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.drive_size)
  return drive_size_;
}
inline void AtaDrives_Item::set_drive_size(::google::protobuf::uint64 value) {
  
  drive_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.drive_size)
}

// uint32 buffer_size = 8;
inline void AtaDrives_Item::clear_buffer_size() {
  buffer_size_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::buffer_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.buffer_size)
  return buffer_size_;
}
inline void AtaDrives_Item::set_buffer_size(::google::protobuf::uint32 value) {
  
  buffer_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.buffer_size)
}

// uint32 multisectors = 9;
inline void AtaDrives_Item::clear_multisectors() {
  multisectors_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::multisectors() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.multisectors)
  return multisectors_;
}
inline void AtaDrives_Item::set_multisectors(::google::protobuf::uint32 value) {
  
  multisectors_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.multisectors)
}

// uint32 ecc_size = 10;
inline void AtaDrives_Item::clear_ecc_size() {
  ecc_size_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::ecc_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.ecc_size)
  return ecc_size_;
}
inline void AtaDrives_Item::set_ecc_size(::google::protobuf::uint32 value) {
  
  ecc_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.ecc_size)
}

// bool is_removable = 11;
inline void AtaDrives_Item::clear_is_removable() {
  is_removable_ = false;
}
inline bool AtaDrives_Item::is_removable() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.is_removable)
  return is_removable_;
}
inline void AtaDrives_Item::set_is_removable(bool value) {
  
  is_removable_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.is_removable)
}

// uint64 cylinders_number = 12;
inline void AtaDrives_Item::clear_cylinders_number() {
  cylinders_number_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AtaDrives_Item::cylinders_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.cylinders_number)
  return cylinders_number_;
}
inline void AtaDrives_Item::set_cylinders_number(::google::protobuf::uint64 value) {
  
  cylinders_number_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.cylinders_number)
}

// uint32 tracks_per_cylinder = 13;
inline void AtaDrives_Item::clear_tracks_per_cylinder() {
  tracks_per_cylinder_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::tracks_per_cylinder() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.tracks_per_cylinder)
  return tracks_per_cylinder_;
}
inline void AtaDrives_Item::set_tracks_per_cylinder(::google::protobuf::uint32 value) {
  
  tracks_per_cylinder_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.tracks_per_cylinder)
}

// uint32 sectors_per_track = 14;
inline void AtaDrives_Item::clear_sectors_per_track() {
  sectors_per_track_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::sectors_per_track() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.sectors_per_track)
  return sectors_per_track_;
}
inline void AtaDrives_Item::set_sectors_per_track(::google::protobuf::uint32 value) {
  
  sectors_per_track_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.sectors_per_track)
}

// uint32 bytes_per_sector = 15;
inline void AtaDrives_Item::clear_bytes_per_sector() {
  bytes_per_sector_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::bytes_per_sector() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.bytes_per_sector)
  return bytes_per_sector_;
}
inline void AtaDrives_Item::set_bytes_per_sector(::google::protobuf::uint32 value) {
  
  bytes_per_sector_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.bytes_per_sector)
}

// uint32 heads_number = 16;
inline void AtaDrives_Item::clear_heads_number() {
  heads_number_ = 0u;
}
inline ::google::protobuf::uint32 AtaDrives_Item::heads_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.heads_number)
  return heads_number_;
}
inline void AtaDrives_Item::set_heads_number(::google::protobuf::uint32 value) {
  
  heads_number_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.heads_number)
}

// uint64 supported_features = 17;
inline void AtaDrives_Item::clear_supported_features() {
  supported_features_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AtaDrives_Item::supported_features() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.supported_features)
  return supported_features_;
}
inline void AtaDrives_Item::set_supported_features(::google::protobuf::uint64 value) {
  
  supported_features_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.supported_features)
}

// uint64 enabled_features = 18;
inline void AtaDrives_Item::clear_enabled_features() {
  enabled_features_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AtaDrives_Item::enabled_features() const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.Item.enabled_features)
  return enabled_features_;
}
inline void AtaDrives_Item::set_enabled_features(::google::protobuf::uint64 value) {
  
  enabled_features_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.AtaDrives.Item.enabled_features)
}

// -------------------------------------------------------------------

// AtaDrives

// repeated .aspia.proto.AtaDrives.Item item = 1;
inline int AtaDrives::item_size() const {
  return item_.size();
}
inline void AtaDrives::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::AtaDrives_Item& AtaDrives::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.AtaDrives.item)
  return item_.Get(index);
}
inline ::aspia::proto::AtaDrives_Item* AtaDrives::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.AtaDrives.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::AtaDrives_Item* AtaDrives::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.AtaDrives.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item >*
AtaDrives::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.AtaDrives.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::AtaDrives_Item >&
AtaDrives::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.AtaDrives.item)
  return item_;
}

// -------------------------------------------------------------------

// VideoAdapters_Item

// string description = 1;
inline void VideoAdapters_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.description)
  return description_.GetNoArena();
}
inline void VideoAdapters_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.description)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.description)
}
#endif
inline void VideoAdapters_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.description)
}
inline void VideoAdapters_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.description)
}
inline ::std::string* VideoAdapters_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.description)
}

// string adapter_string = 2;
inline void VideoAdapters_Item::clear_adapter_string() {
  adapter_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::adapter_string() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.adapter_string)
  return adapter_string_.GetNoArena();
}
inline void VideoAdapters_Item::set_adapter_string(const ::std::string& value) {
  
  adapter_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.adapter_string)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_adapter_string(::std::string&& value) {
  
  adapter_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.adapter_string)
}
#endif
inline void VideoAdapters_Item::set_adapter_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  adapter_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.adapter_string)
}
inline void VideoAdapters_Item::set_adapter_string(const char* value, size_t size) {
  
  adapter_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.adapter_string)
}
inline ::std::string* VideoAdapters_Item::mutable_adapter_string() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.adapter_string)
  return adapter_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_adapter_string() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.adapter_string)
  
  return adapter_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_adapter_string(::std::string* adapter_string) {
  if (adapter_string != NULL) {
    
  } else {
    
  }
  adapter_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adapter_string);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.adapter_string)
}

// string bios_string = 3;
inline void VideoAdapters_Item::clear_bios_string() {
  bios_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::bios_string() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.bios_string)
  return bios_string_.GetNoArena();
}
inline void VideoAdapters_Item::set_bios_string(const ::std::string& value) {
  
  bios_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.bios_string)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_bios_string(::std::string&& value) {
  
  bios_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.bios_string)
}
#endif
inline void VideoAdapters_Item::set_bios_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bios_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.bios_string)
}
inline void VideoAdapters_Item::set_bios_string(const char* value, size_t size) {
  
  bios_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.bios_string)
}
inline ::std::string* VideoAdapters_Item::mutable_bios_string() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.bios_string)
  return bios_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_bios_string() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.bios_string)
  
  return bios_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_bios_string(::std::string* bios_string) {
  if (bios_string != NULL) {
    
  } else {
    
  }
  bios_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bios_string);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.bios_string)
}

// string chip_type = 4;
inline void VideoAdapters_Item::clear_chip_type() {
  chip_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::chip_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.chip_type)
  return chip_type_.GetNoArena();
}
inline void VideoAdapters_Item::set_chip_type(const ::std::string& value) {
  
  chip_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.chip_type)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_chip_type(::std::string&& value) {
  
  chip_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.chip_type)
}
#endif
inline void VideoAdapters_Item::set_chip_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chip_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.chip_type)
}
inline void VideoAdapters_Item::set_chip_type(const char* value, size_t size) {
  
  chip_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.chip_type)
}
inline ::std::string* VideoAdapters_Item::mutable_chip_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.chip_type)
  return chip_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_chip_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.chip_type)
  
  return chip_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_chip_type(::std::string* chip_type) {
  if (chip_type != NULL) {
    
  } else {
    
  }
  chip_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chip_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.chip_type)
}

// string dac_type = 5;
inline void VideoAdapters_Item::clear_dac_type() {
  dac_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::dac_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.dac_type)
  return dac_type_.GetNoArena();
}
inline void VideoAdapters_Item::set_dac_type(const ::std::string& value) {
  
  dac_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.dac_type)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_dac_type(::std::string&& value) {
  
  dac_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.dac_type)
}
#endif
inline void VideoAdapters_Item::set_dac_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dac_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.dac_type)
}
inline void VideoAdapters_Item::set_dac_type(const char* value, size_t size) {
  
  dac_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.dac_type)
}
inline ::std::string* VideoAdapters_Item::mutable_dac_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.dac_type)
  return dac_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_dac_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.dac_type)
  
  return dac_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_dac_type(::std::string* dac_type) {
  if (dac_type != NULL) {
    
  } else {
    
  }
  dac_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dac_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.dac_type)
}

// string driver_date = 6;
inline void VideoAdapters_Item::clear_driver_date() {
  driver_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::driver_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.driver_date)
  return driver_date_.GetNoArena();
}
inline void VideoAdapters_Item::set_driver_date(const ::std::string& value) {
  
  driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.driver_date)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_driver_date(::std::string&& value) {
  
  driver_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.driver_date)
}
#endif
inline void VideoAdapters_Item::set_driver_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.driver_date)
}
inline void VideoAdapters_Item::set_driver_date(const char* value, size_t size) {
  
  driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.driver_date)
}
inline ::std::string* VideoAdapters_Item::mutable_driver_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.driver_date)
  return driver_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_driver_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.driver_date)
  
  return driver_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_driver_date(::std::string* driver_date) {
  if (driver_date != NULL) {
    
  } else {
    
  }
  driver_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.driver_date)
}

// string driver_version = 7;
inline void VideoAdapters_Item::clear_driver_version() {
  driver_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::driver_version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.driver_version)
  return driver_version_.GetNoArena();
}
inline void VideoAdapters_Item::set_driver_version(const ::std::string& value) {
  
  driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.driver_version)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_driver_version(::std::string&& value) {
  
  driver_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.driver_version)
}
#endif
inline void VideoAdapters_Item::set_driver_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.driver_version)
}
inline void VideoAdapters_Item::set_driver_version(const char* value, size_t size) {
  
  driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.driver_version)
}
inline ::std::string* VideoAdapters_Item::mutable_driver_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.driver_version)
  return driver_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_driver_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.driver_version)
  
  return driver_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_driver_version(::std::string* driver_version) {
  if (driver_version != NULL) {
    
  } else {
    
  }
  driver_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.driver_version)
}

// string driver_provider = 8;
inline void VideoAdapters_Item::clear_driver_provider() {
  driver_provider_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VideoAdapters_Item::driver_provider() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.driver_provider)
  return driver_provider_.GetNoArena();
}
inline void VideoAdapters_Item::set_driver_provider(const ::std::string& value) {
  
  driver_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.driver_provider)
}
#if LANG_CXX11
inline void VideoAdapters_Item::set_driver_provider(::std::string&& value) {
  
  driver_provider_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.VideoAdapters.Item.driver_provider)
}
#endif
inline void VideoAdapters_Item::set_driver_provider(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.VideoAdapters.Item.driver_provider)
}
inline void VideoAdapters_Item::set_driver_provider(const char* value, size_t size) {
  
  driver_provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.VideoAdapters.Item.driver_provider)
}
inline ::std::string* VideoAdapters_Item::mutable_driver_provider() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.Item.driver_provider)
  return driver_provider_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoAdapters_Item::release_driver_provider() {
  // @@protoc_insertion_point(field_release:aspia.proto.VideoAdapters.Item.driver_provider)
  
  return driver_provider_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoAdapters_Item::set_allocated_driver_provider(::std::string* driver_provider) {
  if (driver_provider != NULL) {
    
  } else {
    
  }
  driver_provider_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_provider);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.VideoAdapters.Item.driver_provider)
}

// uint64 memory_size = 9;
inline void VideoAdapters_Item::clear_memory_size() {
  memory_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 VideoAdapters_Item::memory_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.Item.memory_size)
  return memory_size_;
}
inline void VideoAdapters_Item::set_memory_size(::google::protobuf::uint64 value) {
  
  memory_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.VideoAdapters.Item.memory_size)
}

// -------------------------------------------------------------------

// VideoAdapters

// repeated .aspia.proto.VideoAdapters.Item item = 1;
inline int VideoAdapters::item_size() const {
  return item_.size();
}
inline void VideoAdapters::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::VideoAdapters_Item& VideoAdapters::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.VideoAdapters.item)
  return item_.Get(index);
}
inline ::aspia::proto::VideoAdapters_Item* VideoAdapters::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.VideoAdapters.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::VideoAdapters_Item* VideoAdapters::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.VideoAdapters.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::VideoAdapters_Item >*
VideoAdapters::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.VideoAdapters.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::VideoAdapters_Item >&
VideoAdapters::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.VideoAdapters.item)
  return item_;
}

// -------------------------------------------------------------------

// Monitors_Timing

// int32 width = 1;
inline void Monitors_Timing::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 Monitors_Timing::width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Timing.width)
  return width_;
}
inline void Monitors_Timing::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Timing.width)
}

// int32 height = 2;
inline void Monitors_Timing::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 Monitors_Timing::height() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Timing.height)
  return height_;
}
inline void Monitors_Timing::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Timing.height)
}

// int32 frequency = 3;
inline void Monitors_Timing::clear_frequency() {
  frequency_ = 0;
}
inline ::google::protobuf::int32 Monitors_Timing::frequency() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Timing.frequency)
  return frequency_;
}
inline void Monitors_Timing::set_frequency(::google::protobuf::int32 value) {
  
  frequency_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Timing.frequency)
}

// -------------------------------------------------------------------

// Monitors_Item

// string system_name = 1;
inline void Monitors_Item::clear_system_name() {
  system_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::system_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.system_name)
  return system_name_.GetNoArena();
}
inline void Monitors_Item::set_system_name(const ::std::string& value) {
  
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.system_name)
}
#if LANG_CXX11
inline void Monitors_Item::set_system_name(::std::string&& value) {
  
  system_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Monitors.Item.system_name)
}
#endif
inline void Monitors_Item::set_system_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Monitors.Item.system_name)
}
inline void Monitors_Item::set_system_name(const char* value, size_t size) {
  
  system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Monitors.Item.system_name)
}
inline ::std::string* Monitors_Item::mutable_system_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.system_name)
  return system_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_system_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Monitors.Item.system_name)
  
  return system_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_system_name(::std::string* system_name) {
  if (system_name != NULL) {
    
  } else {
    
  }
  system_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Monitors.Item.system_name)
}

// string monitor_name = 2;
inline void Monitors_Item::clear_monitor_name() {
  monitor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::monitor_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.monitor_name)
  return monitor_name_.GetNoArena();
}
inline void Monitors_Item::set_monitor_name(const ::std::string& value) {
  
  monitor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.monitor_name)
}
#if LANG_CXX11
inline void Monitors_Item::set_monitor_name(::std::string&& value) {
  
  monitor_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Monitors.Item.monitor_name)
}
#endif
inline void Monitors_Item::set_monitor_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  monitor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Monitors.Item.monitor_name)
}
inline void Monitors_Item::set_monitor_name(const char* value, size_t size) {
  
  monitor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Monitors.Item.monitor_name)
}
inline ::std::string* Monitors_Item::mutable_monitor_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.monitor_name)
  return monitor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_monitor_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Monitors.Item.monitor_name)
  
  return monitor_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_monitor_name(::std::string* monitor_name) {
  if (monitor_name != NULL) {
    
  } else {
    
  }
  monitor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), monitor_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Monitors.Item.monitor_name)
}

// string manufacturer_name = 3;
inline void Monitors_Item::clear_manufacturer_name() {
  manufacturer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::manufacturer_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.manufacturer_name)
  return manufacturer_name_.GetNoArena();
}
inline void Monitors_Item::set_manufacturer_name(const ::std::string& value) {
  
  manufacturer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.manufacturer_name)
}
#if LANG_CXX11
inline void Monitors_Item::set_manufacturer_name(::std::string&& value) {
  
  manufacturer_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Monitors.Item.manufacturer_name)
}
#endif
inline void Monitors_Item::set_manufacturer_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Monitors.Item.manufacturer_name)
}
inline void Monitors_Item::set_manufacturer_name(const char* value, size_t size) {
  
  manufacturer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Monitors.Item.manufacturer_name)
}
inline ::std::string* Monitors_Item::mutable_manufacturer_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.manufacturer_name)
  return manufacturer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_manufacturer_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Monitors.Item.manufacturer_name)
  
  return manufacturer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_manufacturer_name(::std::string* manufacturer_name) {
  if (manufacturer_name != NULL) {
    
  } else {
    
  }
  manufacturer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Monitors.Item.manufacturer_name)
}

// string monitor_id = 4;
inline void Monitors_Item::clear_monitor_id() {
  monitor_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::monitor_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.monitor_id)
  return monitor_id_.GetNoArena();
}
inline void Monitors_Item::set_monitor_id(const ::std::string& value) {
  
  monitor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.monitor_id)
}
#if LANG_CXX11
inline void Monitors_Item::set_monitor_id(::std::string&& value) {
  
  monitor_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Monitors.Item.monitor_id)
}
#endif
inline void Monitors_Item::set_monitor_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  monitor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Monitors.Item.monitor_id)
}
inline void Monitors_Item::set_monitor_id(const char* value, size_t size) {
  
  monitor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Monitors.Item.monitor_id)
}
inline ::std::string* Monitors_Item::mutable_monitor_id() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.monitor_id)
  return monitor_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_monitor_id() {
  // @@protoc_insertion_point(field_release:aspia.proto.Monitors.Item.monitor_id)
  
  return monitor_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_monitor_id(::std::string* monitor_id) {
  if (monitor_id != NULL) {
    
  } else {
    
  }
  monitor_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), monitor_id);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Monitors.Item.monitor_id)
}

// string serial_number = 5;
inline void Monitors_Item::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Monitors_Item::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.serial_number)
  return serial_number_.GetNoArena();
}
inline void Monitors_Item::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.serial_number)
}
#if LANG_CXX11
inline void Monitors_Item::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Monitors.Item.serial_number)
}
#endif
inline void Monitors_Item::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Monitors.Item.serial_number)
}
inline void Monitors_Item::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Monitors.Item.serial_number)
}
inline ::std::string* Monitors_Item::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Monitors_Item::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.Monitors.Item.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Monitors_Item::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Monitors.Item.serial_number)
}

// int32 edid_version = 6;
inline void Monitors_Item::clear_edid_version() {
  edid_version_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::edid_version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.edid_version)
  return edid_version_;
}
inline void Monitors_Item::set_edid_version(::google::protobuf::int32 value) {
  
  edid_version_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.edid_version)
}

// int32 edid_revision = 7;
inline void Monitors_Item::clear_edid_revision() {
  edid_revision_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::edid_revision() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.edid_revision)
  return edid_revision_;
}
inline void Monitors_Item::set_edid_revision(::google::protobuf::int32 value) {
  
  edid_revision_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.edid_revision)
}

// int32 week_of_manufacture = 8;
inline void Monitors_Item::clear_week_of_manufacture() {
  week_of_manufacture_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::week_of_manufacture() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.week_of_manufacture)
  return week_of_manufacture_;
}
inline void Monitors_Item::set_week_of_manufacture(::google::protobuf::int32 value) {
  
  week_of_manufacture_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.week_of_manufacture)
}

// int32 year_of_manufacture = 9;
inline void Monitors_Item::clear_year_of_manufacture() {
  year_of_manufacture_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::year_of_manufacture() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.year_of_manufacture)
  return year_of_manufacture_;
}
inline void Monitors_Item::set_year_of_manufacture(::google::protobuf::int32 value) {
  
  year_of_manufacture_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.year_of_manufacture)
}

// int32 max_horizontal_image_size = 10;
inline void Monitors_Item::clear_max_horizontal_image_size() {
  max_horizontal_image_size_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_horizontal_image_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.max_horizontal_image_size)
  return max_horizontal_image_size_;
}
inline void Monitors_Item::set_max_horizontal_image_size(::google::protobuf::int32 value) {
  
  max_horizontal_image_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.max_horizontal_image_size)
}

// int32 max_vertical_image_size = 11;
inline void Monitors_Item::clear_max_vertical_image_size() {
  max_vertical_image_size_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_vertical_image_size() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.max_vertical_image_size)
  return max_vertical_image_size_;
}
inline void Monitors_Item::set_max_vertical_image_size(::google::protobuf::int32 value) {
  
  max_vertical_image_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.max_vertical_image_size)
}

// int32 horizontal_resolution = 12;
inline void Monitors_Item::clear_horizontal_resolution() {
  horizontal_resolution_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::horizontal_resolution() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.horizontal_resolution)
  return horizontal_resolution_;
}
inline void Monitors_Item::set_horizontal_resolution(::google::protobuf::int32 value) {
  
  horizontal_resolution_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.horizontal_resolution)
}

// int32 vertical_resoulution = 13;
inline void Monitors_Item::clear_vertical_resoulution() {
  vertical_resoulution_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::vertical_resoulution() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.vertical_resoulution)
  return vertical_resoulution_;
}
inline void Monitors_Item::set_vertical_resoulution(::google::protobuf::int32 value) {
  
  vertical_resoulution_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.vertical_resoulution)
}

// double gamma = 14;
inline void Monitors_Item::clear_gamma() {
  gamma_ = 0;
}
inline double Monitors_Item::gamma() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.gamma)
  return gamma_;
}
inline void Monitors_Item::set_gamma(double value) {
  
  gamma_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.gamma)
}

// int32 min_horizontal_rate = 15;
inline void Monitors_Item::clear_min_horizontal_rate() {
  min_horizontal_rate_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::min_horizontal_rate() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.min_horizontal_rate)
  return min_horizontal_rate_;
}
inline void Monitors_Item::set_min_horizontal_rate(::google::protobuf::int32 value) {
  
  min_horizontal_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.min_horizontal_rate)
}

// int32 max_horizontal_rate = 16;
inline void Monitors_Item::clear_max_horizontal_rate() {
  max_horizontal_rate_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_horizontal_rate() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.max_horizontal_rate)
  return max_horizontal_rate_;
}
inline void Monitors_Item::set_max_horizontal_rate(::google::protobuf::int32 value) {
  
  max_horizontal_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.max_horizontal_rate)
}

// int32 min_vertical_rate = 17;
inline void Monitors_Item::clear_min_vertical_rate() {
  min_vertical_rate_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::min_vertical_rate() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.min_vertical_rate)
  return min_vertical_rate_;
}
inline void Monitors_Item::set_min_vertical_rate(::google::protobuf::int32 value) {
  
  min_vertical_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.min_vertical_rate)
}

// int32 max_vertical_rate = 18;
inline void Monitors_Item::clear_max_vertical_rate() {
  max_vertical_rate_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_vertical_rate() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.max_vertical_rate)
  return max_vertical_rate_;
}
inline void Monitors_Item::set_max_vertical_rate(::google::protobuf::int32 value) {
  
  max_vertical_rate_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.max_vertical_rate)
}

// double pixel_clock = 19;
inline void Monitors_Item::clear_pixel_clock() {
  pixel_clock_ = 0;
}
inline double Monitors_Item::pixel_clock() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.pixel_clock)
  return pixel_clock_;
}
inline void Monitors_Item::set_pixel_clock(double value) {
  
  pixel_clock_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.pixel_clock)
}

// int32 max_pixel_clock = 20;
inline void Monitors_Item::clear_max_pixel_clock() {
  max_pixel_clock_ = 0;
}
inline ::google::protobuf::int32 Monitors_Item::max_pixel_clock() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.max_pixel_clock)
  return max_pixel_clock_;
}
inline void Monitors_Item::set_max_pixel_clock(::google::protobuf::int32 value) {
  
  max_pixel_clock_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.max_pixel_clock)
}

// .aspia.proto.Monitors.InputSignalType input_signal_type = 21;
inline void Monitors_Item::clear_input_signal_type() {
  input_signal_type_ = 0;
}
inline ::aspia::proto::Monitors_InputSignalType Monitors_Item::input_signal_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.input_signal_type)
  return static_cast< ::aspia::proto::Monitors_InputSignalType >(input_signal_type_);
}
inline void Monitors_Item::set_input_signal_type(::aspia::proto::Monitors_InputSignalType value) {
  
  input_signal_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.input_signal_type)
}

// bool default_gtf_supported = 22;
inline void Monitors_Item::clear_default_gtf_supported() {
  default_gtf_supported_ = false;
}
inline bool Monitors_Item::default_gtf_supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.default_gtf_supported)
  return default_gtf_supported_;
}
inline void Monitors_Item::set_default_gtf_supported(bool value) {
  
  default_gtf_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.default_gtf_supported)
}

// bool suspend_supported = 23;
inline void Monitors_Item::clear_suspend_supported() {
  suspend_supported_ = false;
}
inline bool Monitors_Item::suspend_supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.suspend_supported)
  return suspend_supported_;
}
inline void Monitors_Item::set_suspend_supported(bool value) {
  
  suspend_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.suspend_supported)
}

// bool standby_supported = 24;
inline void Monitors_Item::clear_standby_supported() {
  standby_supported_ = false;
}
inline bool Monitors_Item::standby_supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.standby_supported)
  return standby_supported_;
}
inline void Monitors_Item::set_standby_supported(bool value) {
  
  standby_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.standby_supported)
}

// bool active_off_supported = 25;
inline void Monitors_Item::clear_active_off_supported() {
  active_off_supported_ = false;
}
inline bool Monitors_Item::active_off_supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.active_off_supported)
  return active_off_supported_;
}
inline void Monitors_Item::set_active_off_supported(bool value) {
  
  active_off_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.active_off_supported)
}

// bool preferred_timing_mode_supported = 26;
inline void Monitors_Item::clear_preferred_timing_mode_supported() {
  preferred_timing_mode_supported_ = false;
}
inline bool Monitors_Item::preferred_timing_mode_supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.preferred_timing_mode_supported)
  return preferred_timing_mode_supported_;
}
inline void Monitors_Item::set_preferred_timing_mode_supported(bool value) {
  
  preferred_timing_mode_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.preferred_timing_mode_supported)
}

// bool srgb_supported = 27;
inline void Monitors_Item::clear_srgb_supported() {
  srgb_supported_ = false;
}
inline bool Monitors_Item::srgb_supported() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.srgb_supported)
  return srgb_supported_;
}
inline void Monitors_Item::set_srgb_supported(bool value) {
  
  srgb_supported_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Monitors.Item.srgb_supported)
}

// repeated .aspia.proto.Monitors.Timing timings = 28;
inline int Monitors_Item::timings_size() const {
  return timings_.size();
}
inline void Monitors_Item::clear_timings() {
  timings_.Clear();
}
inline const ::aspia::proto::Monitors_Timing& Monitors_Item::timings(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.Item.timings)
  return timings_.Get(index);
}
inline ::aspia::proto::Monitors_Timing* Monitors_Item::mutable_timings(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.Item.timings)
  return timings_.Mutable(index);
}
inline ::aspia::proto::Monitors_Timing* Monitors_Item::add_timings() {
  // @@protoc_insertion_point(field_add:aspia.proto.Monitors.Item.timings)
  return timings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Timing >*
Monitors_Item::mutable_timings() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Monitors.Item.timings)
  return &timings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Timing >&
Monitors_Item::timings() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Monitors.Item.timings)
  return timings_;
}

// -------------------------------------------------------------------

// Monitors

// repeated .aspia.proto.Monitors.Item item = 1;
inline int Monitors::item_size() const {
  return item_.size();
}
inline void Monitors::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Monitors_Item& Monitors::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Monitors.item)
  return item_.Get(index);
}
inline ::aspia::proto::Monitors_Item* Monitors::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Monitors.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Monitors_Item* Monitors::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Monitors.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item >*
Monitors::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Monitors.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Monitors_Item >&
Monitors::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Monitors.item)
  return item_;
}

// -------------------------------------------------------------------

// PowerOptions_Battery

// string device_name = 1;
inline void PowerOptions_Battery::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::device_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.device_name)
  return device_name_.GetNoArena();
}
inline void PowerOptions_Battery::set_device_name(const ::std::string& value) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.device_name)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_device_name(::std::string&& value) {
  
  device_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.device_name)
}
#endif
inline void PowerOptions_Battery::set_device_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.device_name)
}
inline void PowerOptions_Battery::set_device_name(const char* value, size_t size) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.device_name)
}
inline ::std::string* PowerOptions_Battery::mutable_device_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_device_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.device_name)
  
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    
  } else {
    
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.device_name)
}

// string manufacturer = 2;
inline void PowerOptions_Battery::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void PowerOptions_Battery::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.manufacturer)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.manufacturer)
}
#endif
inline void PowerOptions_Battery::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.manufacturer)
}
inline void PowerOptions_Battery::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.manufacturer)
}
inline ::std::string* PowerOptions_Battery::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.manufacturer)
}

// string manufacture_date = 3;
inline void PowerOptions_Battery::clear_manufacture_date() {
  manufacture_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::manufacture_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.manufacture_date)
  return manufacture_date_.GetNoArena();
}
inline void PowerOptions_Battery::set_manufacture_date(const ::std::string& value) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.manufacture_date)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_manufacture_date(::std::string&& value) {
  
  manufacture_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.manufacture_date)
}
#endif
inline void PowerOptions_Battery::set_manufacture_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.manufacture_date)
}
inline void PowerOptions_Battery::set_manufacture_date(const char* value, size_t size) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.manufacture_date)
}
inline ::std::string* PowerOptions_Battery::mutable_manufacture_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.manufacture_date)
  return manufacture_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_manufacture_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.manufacture_date)
  
  return manufacture_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_manufacture_date(::std::string* manufacture_date) {
  if (manufacture_date != NULL) {
    
  } else {
    
  }
  manufacture_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacture_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.manufacture_date)
}

// string unique_id = 4;
inline void PowerOptions_Battery::clear_unique_id() {
  unique_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::unique_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.unique_id)
  return unique_id_.GetNoArena();
}
inline void PowerOptions_Battery::set_unique_id(const ::std::string& value) {
  
  unique_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.unique_id)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_unique_id(::std::string&& value) {
  
  unique_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.unique_id)
}
#endif
inline void PowerOptions_Battery::set_unique_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  unique_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.unique_id)
}
inline void PowerOptions_Battery::set_unique_id(const char* value, size_t size) {
  
  unique_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.unique_id)
}
inline ::std::string* PowerOptions_Battery::mutable_unique_id() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.unique_id)
  return unique_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_unique_id() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.unique_id)
  
  return unique_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_unique_id(::std::string* unique_id) {
  if (unique_id != NULL) {
    
  } else {
    
  }
  unique_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), unique_id);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.unique_id)
}

// string serial_number = 5;
inline void PowerOptions_Battery::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.serial_number)
  return serial_number_.GetNoArena();
}
inline void PowerOptions_Battery::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.serial_number)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.serial_number)
}
#endif
inline void PowerOptions_Battery::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.serial_number)
}
inline void PowerOptions_Battery::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.serial_number)
}
inline ::std::string* PowerOptions_Battery::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.serial_number)
}

// string temperature = 6;
inline void PowerOptions_Battery::clear_temperature() {
  temperature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::temperature() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.temperature)
  return temperature_.GetNoArena();
}
inline void PowerOptions_Battery::set_temperature(const ::std::string& value) {
  
  temperature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.temperature)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_temperature(::std::string&& value) {
  
  temperature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.temperature)
}
#endif
inline void PowerOptions_Battery::set_temperature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  temperature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.temperature)
}
inline void PowerOptions_Battery::set_temperature(const char* value, size_t size) {
  
  temperature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.temperature)
}
inline ::std::string* PowerOptions_Battery::mutable_temperature() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.temperature)
  return temperature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_temperature() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.temperature)
  
  return temperature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_temperature(::std::string* temperature) {
  if (temperature != NULL) {
    
  } else {
    
  }
  temperature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), temperature);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.temperature)
}

// int32 design_capacity = 7;
inline void PowerOptions_Battery::clear_design_capacity() {
  design_capacity_ = 0;
}
inline ::google::protobuf::int32 PowerOptions_Battery::design_capacity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.design_capacity)
  return design_capacity_;
}
inline void PowerOptions_Battery::set_design_capacity(::google::protobuf::int32 value) {
  
  design_capacity_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.design_capacity)
}

// string type = 8;
inline void PowerOptions_Battery::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PowerOptions_Battery::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.type)
  return type_.GetNoArena();
}
inline void PowerOptions_Battery::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.type)
}
#if LANG_CXX11
inline void PowerOptions_Battery::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.PowerOptions.Battery.type)
}
#endif
inline void PowerOptions_Battery::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.PowerOptions.Battery.type)
}
inline void PowerOptions_Battery::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.PowerOptions.Battery.type)
}
inline ::std::string* PowerOptions_Battery::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.Battery.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PowerOptions_Battery::release_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.PowerOptions.Battery.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PowerOptions_Battery::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.PowerOptions.Battery.type)
}

// int32 full_charged_capacity = 9;
inline void PowerOptions_Battery::clear_full_charged_capacity() {
  full_charged_capacity_ = 0;
}
inline ::google::protobuf::int32 PowerOptions_Battery::full_charged_capacity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.full_charged_capacity)
  return full_charged_capacity_;
}
inline void PowerOptions_Battery::set_full_charged_capacity(::google::protobuf::int32 value) {
  
  full_charged_capacity_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.full_charged_capacity)
}

// int32 depreciation = 10;
inline void PowerOptions_Battery::clear_depreciation() {
  depreciation_ = 0;
}
inline ::google::protobuf::int32 PowerOptions_Battery::depreciation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.depreciation)
  return depreciation_;
}
inline void PowerOptions_Battery::set_depreciation(::google::protobuf::int32 value) {
  
  depreciation_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.depreciation)
}

// int32 current_capacity = 11;
inline void PowerOptions_Battery::clear_current_capacity() {
  current_capacity_ = 0;
}
inline ::google::protobuf::int32 PowerOptions_Battery::current_capacity() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.current_capacity)
  return current_capacity_;
}
inline void PowerOptions_Battery::set_current_capacity(::google::protobuf::int32 value) {
  
  current_capacity_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.current_capacity)
}

// int32 voltage = 12;
inline void PowerOptions_Battery::clear_voltage() {
  voltage_ = 0;
}
inline ::google::protobuf::int32 PowerOptions_Battery::voltage() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.voltage)
  return voltage_;
}
inline void PowerOptions_Battery::set_voltage(::google::protobuf::int32 value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.voltage)
}

// uint32 state = 13;
inline void PowerOptions_Battery::clear_state() {
  state_ = 0u;
}
inline ::google::protobuf::uint32 PowerOptions_Battery::state() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.Battery.state)
  return state_;
}
inline void PowerOptions_Battery::set_state(::google::protobuf::uint32 value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.Battery.state)
}

// -------------------------------------------------------------------

// PowerOptions

// .aspia.proto.PowerOptions.PowerSource power_source = 1;
inline void PowerOptions::clear_power_source() {
  power_source_ = 0;
}
inline ::aspia::proto::PowerOptions_PowerSource PowerOptions::power_source() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.power_source)
  return static_cast< ::aspia::proto::PowerOptions_PowerSource >(power_source_);
}
inline void PowerOptions::set_power_source(::aspia::proto::PowerOptions_PowerSource value) {
  
  power_source_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.power_source)
}

// .aspia.proto.PowerOptions.BatteryStatus battery_status = 2;
inline void PowerOptions::clear_battery_status() {
  battery_status_ = 0;
}
inline ::aspia::proto::PowerOptions_BatteryStatus PowerOptions::battery_status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.battery_status)
  return static_cast< ::aspia::proto::PowerOptions_BatteryStatus >(battery_status_);
}
inline void PowerOptions::set_battery_status(::aspia::proto::PowerOptions_BatteryStatus value) {
  
  battery_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.battery_status)
}

// int64 full_battery_life_time = 3;
inline void PowerOptions::clear_full_battery_life_time() {
  full_battery_life_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PowerOptions::full_battery_life_time() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.full_battery_life_time)
  return full_battery_life_time_;
}
inline void PowerOptions::set_full_battery_life_time(::google::protobuf::int64 value) {
  
  full_battery_life_time_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.full_battery_life_time)
}

// int64 remaining_battery_life_time = 4;
inline void PowerOptions::clear_remaining_battery_life_time() {
  remaining_battery_life_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PowerOptions::remaining_battery_life_time() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.remaining_battery_life_time)
  return remaining_battery_life_time_;
}
inline void PowerOptions::set_remaining_battery_life_time(::google::protobuf::int64 value) {
  
  remaining_battery_life_time_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.remaining_battery_life_time)
}

// int32 battery_life_percent = 5;
inline void PowerOptions::clear_battery_life_percent() {
  battery_life_percent_ = 0;
}
inline ::google::protobuf::int32 PowerOptions::battery_life_percent() const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.battery_life_percent)
  return battery_life_percent_;
}
inline void PowerOptions::set_battery_life_percent(::google::protobuf::int32 value) {
  
  battery_life_percent_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.PowerOptions.battery_life_percent)
}

// repeated .aspia.proto.PowerOptions.Battery battery = 6;
inline int PowerOptions::battery_size() const {
  return battery_.size();
}
inline void PowerOptions::clear_battery() {
  battery_.Clear();
}
inline const ::aspia::proto::PowerOptions_Battery& PowerOptions::battery(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.PowerOptions.battery)
  return battery_.Get(index);
}
inline ::aspia::proto::PowerOptions_Battery* PowerOptions::mutable_battery(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.PowerOptions.battery)
  return battery_.Mutable(index);
}
inline ::aspia::proto::PowerOptions_Battery* PowerOptions::add_battery() {
  // @@protoc_insertion_point(field_add:aspia.proto.PowerOptions.battery)
  return battery_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::PowerOptions_Battery >*
PowerOptions::mutable_battery() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.PowerOptions.battery)
  return &battery_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::PowerOptions_Battery >&
PowerOptions::battery() const {
  // @@protoc_insertion_point(field_list:aspia.proto.PowerOptions.battery)
  return battery_;
}

// -------------------------------------------------------------------

// Printers_Item

// string name = 1;
inline void Printers_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.name)
  return name_.GetNoArena();
}
inline void Printers_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.name)
}
#if LANG_CXX11
inline void Printers_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.name)
}
#endif
inline void Printers_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.name)
}
inline void Printers_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.name)
}
inline ::std::string* Printers_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.name)
}

// bool is_default = 2;
inline void Printers_Item::clear_is_default() {
  is_default_ = false;
}
inline bool Printers_Item::is_default() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.is_default)
  return is_default_;
}
inline void Printers_Item::set_is_default(bool value) {
  
  is_default_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.is_default)
}

// bool is_shared = 3;
inline void Printers_Item::clear_is_shared() {
  is_shared_ = false;
}
inline bool Printers_Item::is_shared() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.is_shared)
  return is_shared_;
}
inline void Printers_Item::set_is_shared(bool value) {
  
  is_shared_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.is_shared)
}

// string share_name = 4;
inline void Printers_Item::clear_share_name() {
  share_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::share_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.share_name)
  return share_name_.GetNoArena();
}
inline void Printers_Item::set_share_name(const ::std::string& value) {
  
  share_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.share_name)
}
#if LANG_CXX11
inline void Printers_Item::set_share_name(::std::string&& value) {
  
  share_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.share_name)
}
#endif
inline void Printers_Item::set_share_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  share_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.share_name)
}
inline void Printers_Item::set_share_name(const char* value, size_t size) {
  
  share_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.share_name)
}
inline ::std::string* Printers_Item::mutable_share_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.share_name)
  return share_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_share_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.share_name)
  
  return share_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_share_name(::std::string* share_name) {
  if (share_name != NULL) {
    
  } else {
    
  }
  share_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), share_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.share_name)
}

// string port_name = 5;
inline void Printers_Item::clear_port_name() {
  port_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::port_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.port_name)
  return port_name_.GetNoArena();
}
inline void Printers_Item::set_port_name(const ::std::string& value) {
  
  port_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.port_name)
}
#if LANG_CXX11
inline void Printers_Item::set_port_name(::std::string&& value) {
  
  port_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.port_name)
}
#endif
inline void Printers_Item::set_port_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.port_name)
}
inline void Printers_Item::set_port_name(const char* value, size_t size) {
  
  port_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.port_name)
}
inline ::std::string* Printers_Item::mutable_port_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.port_name)
  return port_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_port_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.port_name)
  
  return port_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_port_name(::std::string* port_name) {
  if (port_name != NULL) {
    
  } else {
    
  }
  port_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.port_name)
}

// string driver_name = 6;
inline void Printers_Item::clear_driver_name() {
  driver_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::driver_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.driver_name)
  return driver_name_.GetNoArena();
}
inline void Printers_Item::set_driver_name(const ::std::string& value) {
  
  driver_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.driver_name)
}
#if LANG_CXX11
inline void Printers_Item::set_driver_name(::std::string&& value) {
  
  driver_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.driver_name)
}
#endif
inline void Printers_Item::set_driver_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.driver_name)
}
inline void Printers_Item::set_driver_name(const char* value, size_t size) {
  
  driver_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.driver_name)
}
inline ::std::string* Printers_Item::mutable_driver_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.driver_name)
  return driver_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_driver_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.driver_name)
  
  return driver_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_driver_name(::std::string* driver_name) {
  if (driver_name != NULL) {
    
  } else {
    
  }
  driver_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.driver_name)
}

// string device_name = 7;
inline void Printers_Item::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::device_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.device_name)
  return device_name_.GetNoArena();
}
inline void Printers_Item::set_device_name(const ::std::string& value) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.device_name)
}
#if LANG_CXX11
inline void Printers_Item::set_device_name(::std::string&& value) {
  
  device_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.device_name)
}
#endif
inline void Printers_Item::set_device_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.device_name)
}
inline void Printers_Item::set_device_name(const char* value, size_t size) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.device_name)
}
inline ::std::string* Printers_Item::mutable_device_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_device_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.device_name)
  
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    
  } else {
    
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.device_name)
}

// string print_processor = 8;
inline void Printers_Item::clear_print_processor() {
  print_processor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::print_processor() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.print_processor)
  return print_processor_.GetNoArena();
}
inline void Printers_Item::set_print_processor(const ::std::string& value) {
  
  print_processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.print_processor)
}
#if LANG_CXX11
inline void Printers_Item::set_print_processor(::std::string&& value) {
  
  print_processor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.print_processor)
}
#endif
inline void Printers_Item::set_print_processor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  print_processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.print_processor)
}
inline void Printers_Item::set_print_processor(const char* value, size_t size) {
  
  print_processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.print_processor)
}
inline ::std::string* Printers_Item::mutable_print_processor() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.print_processor)
  return print_processor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_print_processor() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.print_processor)
  
  return print_processor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_print_processor(::std::string* print_processor) {
  if (print_processor != NULL) {
    
  } else {
    
  }
  print_processor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), print_processor);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.print_processor)
}

// string data_type = 9;
inline void Printers_Item::clear_data_type() {
  data_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::data_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.data_type)
  return data_type_.GetNoArena();
}
inline void Printers_Item::set_data_type(const ::std::string& value) {
  
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.data_type)
}
#if LANG_CXX11
inline void Printers_Item::set_data_type(::std::string&& value) {
  
  data_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.data_type)
}
#endif
inline void Printers_Item::set_data_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.data_type)
}
inline void Printers_Item::set_data_type(const char* value, size_t size) {
  
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.data_type)
}
inline ::std::string* Printers_Item::mutable_data_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.data_type)
  return data_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_data_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.data_type)
  
  return data_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_data_type(::std::string* data_type) {
  if (data_type != NULL) {
    
  } else {
    
  }
  data_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.data_type)
}

// string server_name = 10;
inline void Printers_Item::clear_server_name() {
  server_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::server_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.server_name)
  return server_name_.GetNoArena();
}
inline void Printers_Item::set_server_name(const ::std::string& value) {
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.server_name)
}
#if LANG_CXX11
inline void Printers_Item::set_server_name(::std::string&& value) {
  
  server_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.server_name)
}
#endif
inline void Printers_Item::set_server_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.server_name)
}
inline void Printers_Item::set_server_name(const char* value, size_t size) {
  
  server_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.server_name)
}
inline ::std::string* Printers_Item::mutable_server_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.server_name)
  return server_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_server_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.server_name)
  
  return server_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_server_name(::std::string* server_name) {
  if (server_name != NULL) {
    
  } else {
    
  }
  server_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.server_name)
}

// string location = 11;
inline void Printers_Item::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.location)
  return location_.GetNoArena();
}
inline void Printers_Item::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.location)
}
#if LANG_CXX11
inline void Printers_Item::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.location)
}
#endif
inline void Printers_Item::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.location)
}
inline void Printers_Item::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.location)
}
inline ::std::string* Printers_Item::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_location() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.location)
}

// string comment = 12;
inline void Printers_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Printers_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.comment)
  return comment_.GetNoArena();
}
inline void Printers_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.comment)
}
#if LANG_CXX11
inline void Printers_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Printers.Item.comment)
}
#endif
inline void Printers_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Printers.Item.comment)
}
inline void Printers_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Printers.Item.comment)
}
inline ::std::string* Printers_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Printers_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.proto.Printers.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Printers_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Printers.Item.comment)
}

// int32 jobs_count = 13;
inline void Printers_Item::clear_jobs_count() {
  jobs_count_ = 0;
}
inline ::google::protobuf::int32 Printers_Item::jobs_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.jobs_count)
  return jobs_count_;
}
inline void Printers_Item::set_jobs_count(::google::protobuf::int32 value) {
  
  jobs_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.jobs_count)
}

// int32 paper_width = 14;
inline void Printers_Item::clear_paper_width() {
  paper_width_ = 0;
}
inline ::google::protobuf::int32 Printers_Item::paper_width() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.paper_width)
  return paper_width_;
}
inline void Printers_Item::set_paper_width(::google::protobuf::int32 value) {
  
  paper_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.paper_width)
}

// int32 paper_length = 15;
inline void Printers_Item::clear_paper_length() {
  paper_length_ = 0;
}
inline ::google::protobuf::int32 Printers_Item::paper_length() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.paper_length)
  return paper_length_;
}
inline void Printers_Item::set_paper_length(::google::protobuf::int32 value) {
  
  paper_length_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.paper_length)
}

// int32 print_quality = 16;
inline void Printers_Item::clear_print_quality() {
  print_quality_ = 0;
}
inline ::google::protobuf::int32 Printers_Item::print_quality() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.print_quality)
  return print_quality_;
}
inline void Printers_Item::set_print_quality(::google::protobuf::int32 value) {
  
  print_quality_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.print_quality)
}

// .aspia.proto.Printers.Item.Orientation orientation = 17;
inline void Printers_Item::clear_orientation() {
  orientation_ = 0;
}
inline ::aspia::proto::Printers_Item_Orientation Printers_Item::orientation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.Item.orientation)
  return static_cast< ::aspia::proto::Printers_Item_Orientation >(orientation_);
}
inline void Printers_Item::set_orientation(::aspia::proto::Printers_Item_Orientation value) {
  
  orientation_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Printers.Item.orientation)
}

// -------------------------------------------------------------------

// Printers

// repeated .aspia.proto.Printers.Item item = 1;
inline int Printers::item_size() const {
  return item_.size();
}
inline void Printers::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Printers_Item& Printers::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Printers.item)
  return item_.Get(index);
}
inline ::aspia::proto::Printers_Item* Printers::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Printers.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Printers_Item* Printers::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Printers.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Printers_Item >*
Printers::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Printers.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Printers_Item >&
Printers::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Printers.item)
  return item_;
}

// -------------------------------------------------------------------

// WindowsDevices_Item

// string friendly_name = 1;
inline void WindowsDevices_Item::clear_friendly_name() {
  friendly_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WindowsDevices_Item::friendly_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.Item.friendly_name)
  return friendly_name_.GetNoArena();
}
inline void WindowsDevices_Item::set_friendly_name(const ::std::string& value) {
  
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.WindowsDevices.Item.friendly_name)
}
#if LANG_CXX11
inline void WindowsDevices_Item::set_friendly_name(::std::string&& value) {
  
  friendly_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.WindowsDevices.Item.friendly_name)
}
#endif
inline void WindowsDevices_Item::set_friendly_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.WindowsDevices.Item.friendly_name)
}
inline void WindowsDevices_Item::set_friendly_name(const char* value, size_t size) {
  
  friendly_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.WindowsDevices.Item.friendly_name)
}
inline ::std::string* WindowsDevices_Item::mutable_friendly_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.Item.friendly_name)
  return friendly_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WindowsDevices_Item::release_friendly_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.WindowsDevices.Item.friendly_name)
  
  return friendly_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WindowsDevices_Item::set_allocated_friendly_name(::std::string* friendly_name) {
  if (friendly_name != NULL) {
    
  } else {
    
  }
  friendly_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), friendly_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.WindowsDevices.Item.friendly_name)
}

// string description = 2;
inline void WindowsDevices_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WindowsDevices_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.Item.description)
  return description_.GetNoArena();
}
inline void WindowsDevices_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.WindowsDevices.Item.description)
}
#if LANG_CXX11
inline void WindowsDevices_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.WindowsDevices.Item.description)
}
#endif
inline void WindowsDevices_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.WindowsDevices.Item.description)
}
inline void WindowsDevices_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.WindowsDevices.Item.description)
}
inline ::std::string* WindowsDevices_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WindowsDevices_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.WindowsDevices.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WindowsDevices_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.WindowsDevices.Item.description)
}

// string driver_version = 3;
inline void WindowsDevices_Item::clear_driver_version() {
  driver_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WindowsDevices_Item::driver_version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.Item.driver_version)
  return driver_version_.GetNoArena();
}
inline void WindowsDevices_Item::set_driver_version(const ::std::string& value) {
  
  driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.WindowsDevices.Item.driver_version)
}
#if LANG_CXX11
inline void WindowsDevices_Item::set_driver_version(::std::string&& value) {
  
  driver_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.WindowsDevices.Item.driver_version)
}
#endif
inline void WindowsDevices_Item::set_driver_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.WindowsDevices.Item.driver_version)
}
inline void WindowsDevices_Item::set_driver_version(const char* value, size_t size) {
  
  driver_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.WindowsDevices.Item.driver_version)
}
inline ::std::string* WindowsDevices_Item::mutable_driver_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.Item.driver_version)
  return driver_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WindowsDevices_Item::release_driver_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.WindowsDevices.Item.driver_version)
  
  return driver_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WindowsDevices_Item::set_allocated_driver_version(::std::string* driver_version) {
  if (driver_version != NULL) {
    
  } else {
    
  }
  driver_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.WindowsDevices.Item.driver_version)
}

// string driver_date = 4;
inline void WindowsDevices_Item::clear_driver_date() {
  driver_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WindowsDevices_Item::driver_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.Item.driver_date)
  return driver_date_.GetNoArena();
}
inline void WindowsDevices_Item::set_driver_date(const ::std::string& value) {
  
  driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.WindowsDevices.Item.driver_date)
}
#if LANG_CXX11
inline void WindowsDevices_Item::set_driver_date(::std::string&& value) {
  
  driver_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.WindowsDevices.Item.driver_date)
}
#endif
inline void WindowsDevices_Item::set_driver_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.WindowsDevices.Item.driver_date)
}
inline void WindowsDevices_Item::set_driver_date(const char* value, size_t size) {
  
  driver_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.WindowsDevices.Item.driver_date)
}
inline ::std::string* WindowsDevices_Item::mutable_driver_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.Item.driver_date)
  return driver_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WindowsDevices_Item::release_driver_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.WindowsDevices.Item.driver_date)
  
  return driver_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WindowsDevices_Item::set_allocated_driver_date(::std::string* driver_date) {
  if (driver_date != NULL) {
    
  } else {
    
  }
  driver_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.WindowsDevices.Item.driver_date)
}

// string driver_vendor = 5;
inline void WindowsDevices_Item::clear_driver_vendor() {
  driver_vendor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WindowsDevices_Item::driver_vendor() const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.Item.driver_vendor)
  return driver_vendor_.GetNoArena();
}
inline void WindowsDevices_Item::set_driver_vendor(const ::std::string& value) {
  
  driver_vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.WindowsDevices.Item.driver_vendor)
}
#if LANG_CXX11
inline void WindowsDevices_Item::set_driver_vendor(::std::string&& value) {
  
  driver_vendor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.WindowsDevices.Item.driver_vendor)
}
#endif
inline void WindowsDevices_Item::set_driver_vendor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  driver_vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.WindowsDevices.Item.driver_vendor)
}
inline void WindowsDevices_Item::set_driver_vendor(const char* value, size_t size) {
  
  driver_vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.WindowsDevices.Item.driver_vendor)
}
inline ::std::string* WindowsDevices_Item::mutable_driver_vendor() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.Item.driver_vendor)
  return driver_vendor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WindowsDevices_Item::release_driver_vendor() {
  // @@protoc_insertion_point(field_release:aspia.proto.WindowsDevices.Item.driver_vendor)
  
  return driver_vendor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WindowsDevices_Item::set_allocated_driver_vendor(::std::string* driver_vendor) {
  if (driver_vendor != NULL) {
    
  } else {
    
  }
  driver_vendor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver_vendor);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.WindowsDevices.Item.driver_vendor)
}

// string device_id = 6;
inline void WindowsDevices_Item::clear_device_id() {
  device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WindowsDevices_Item::device_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.Item.device_id)
  return device_id_.GetNoArena();
}
inline void WindowsDevices_Item::set_device_id(const ::std::string& value) {
  
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.WindowsDevices.Item.device_id)
}
#if LANG_CXX11
inline void WindowsDevices_Item::set_device_id(::std::string&& value) {
  
  device_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.WindowsDevices.Item.device_id)
}
#endif
inline void WindowsDevices_Item::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.WindowsDevices.Item.device_id)
}
inline void WindowsDevices_Item::set_device_id(const char* value, size_t size) {
  
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.WindowsDevices.Item.device_id)
}
inline ::std::string* WindowsDevices_Item::mutable_device_id() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.Item.device_id)
  return device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WindowsDevices_Item::release_device_id() {
  // @@protoc_insertion_point(field_release:aspia.proto.WindowsDevices.Item.device_id)
  
  return device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WindowsDevices_Item::set_allocated_device_id(::std::string* device_id) {
  if (device_id != NULL) {
    
  } else {
    
  }
  device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_id);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.WindowsDevices.Item.device_id)
}

// -------------------------------------------------------------------

// WindowsDevices

// repeated .aspia.proto.WindowsDevices.Item item = 1;
inline int WindowsDevices::item_size() const {
  return item_.size();
}
inline void WindowsDevices::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::WindowsDevices_Item& WindowsDevices::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.WindowsDevices.item)
  return item_.Get(index);
}
inline ::aspia::proto::WindowsDevices_Item* WindowsDevices::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.WindowsDevices.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::WindowsDevices_Item* WindowsDevices::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.WindowsDevices.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::WindowsDevices_Item >*
WindowsDevices::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.WindowsDevices.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::WindowsDevices_Item >&
WindowsDevices::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.WindowsDevices.item)
  return item_;
}

// -------------------------------------------------------------------

// Programs_Item

// string name = 1;
inline void Programs_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.name)
  return name_.GetNoArena();
}
inline void Programs_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.name)
}
#if LANG_CXX11
inline void Programs_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.name)
}
#endif
inline void Programs_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.name)
}
inline void Programs_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.name)
}
inline ::std::string* Programs_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.name)
}

// string version = 2;
inline void Programs_Item::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::version() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.version)
  return version_.GetNoArena();
}
inline void Programs_Item::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.version)
}
#if LANG_CXX11
inline void Programs_Item::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.version)
}
#endif
inline void Programs_Item::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.version)
}
inline void Programs_Item::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.version)
}
inline ::std::string* Programs_Item::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_version() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.version)
}

// string publisher = 3;
inline void Programs_Item::clear_publisher() {
  publisher_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::publisher() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.publisher)
  return publisher_.GetNoArena();
}
inline void Programs_Item::set_publisher(const ::std::string& value) {
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.publisher)
}
#if LANG_CXX11
inline void Programs_Item::set_publisher(::std::string&& value) {
  
  publisher_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.publisher)
}
#endif
inline void Programs_Item::set_publisher(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.publisher)
}
inline void Programs_Item::set_publisher(const char* value, size_t size) {
  
  publisher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.publisher)
}
inline ::std::string* Programs_Item::mutable_publisher() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.publisher)
  return publisher_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_publisher() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.publisher)
  
  return publisher_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_publisher(::std::string* publisher) {
  if (publisher != NULL) {
    
  } else {
    
  }
  publisher_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publisher);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.publisher)
}

// string install_date = 4;
inline void Programs_Item::clear_install_date() {
  install_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::install_date() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.install_date)
  return install_date_.GetNoArena();
}
inline void Programs_Item::set_install_date(const ::std::string& value) {
  
  install_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.install_date)
}
#if LANG_CXX11
inline void Programs_Item::set_install_date(::std::string&& value) {
  
  install_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.install_date)
}
#endif
inline void Programs_Item::set_install_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  install_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.install_date)
}
inline void Programs_Item::set_install_date(const char* value, size_t size) {
  
  install_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.install_date)
}
inline ::std::string* Programs_Item::mutable_install_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.install_date)
  return install_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_install_date() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.install_date)
  
  return install_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_install_date(::std::string* install_date) {
  if (install_date != NULL) {
    
  } else {
    
  }
  install_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), install_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.install_date)
}

// string install_location = 5;
inline void Programs_Item::clear_install_location() {
  install_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Programs_Item::install_location() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.Item.install_location)
  return install_location_.GetNoArena();
}
inline void Programs_Item::set_install_location(const ::std::string& value) {
  
  install_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Programs.Item.install_location)
}
#if LANG_CXX11
inline void Programs_Item::set_install_location(::std::string&& value) {
  
  install_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Programs.Item.install_location)
}
#endif
inline void Programs_Item::set_install_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  install_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Programs.Item.install_location)
}
inline void Programs_Item::set_install_location(const char* value, size_t size) {
  
  install_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Programs.Item.install_location)
}
inline ::std::string* Programs_Item::mutable_install_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.Item.install_location)
  return install_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Programs_Item::release_install_location() {
  // @@protoc_insertion_point(field_release:aspia.proto.Programs.Item.install_location)
  
  return install_location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Programs_Item::set_allocated_install_location(::std::string* install_location) {
  if (install_location != NULL) {
    
  } else {
    
  }
  install_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), install_location);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Programs.Item.install_location)
}

// -------------------------------------------------------------------

// Programs

// repeated .aspia.proto.Programs.Item item = 1;
inline int Programs::item_size() const {
  return item_.size();
}
inline void Programs::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Programs_Item& Programs::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Programs.item)
  return item_.Get(index);
}
inline ::aspia::proto::Programs_Item* Programs::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Programs.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Programs_Item* Programs::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Programs.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >*
Programs::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Programs.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Programs_Item >&
Programs::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Programs.item)
  return item_;
}

// -------------------------------------------------------------------

// Services_Item

// string name = 1;
inline void Services_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.name)
  return name_.GetNoArena();
}
inline void Services_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.name)
}
#if LANG_CXX11
inline void Services_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.name)
}
#endif
inline void Services_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.name)
}
inline void Services_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.name)
}
inline ::std::string* Services_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.name)
}

// string display_name = 2;
inline void Services_Item::clear_display_name() {
  display_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::display_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.display_name)
  return display_name_.GetNoArena();
}
inline void Services_Item::set_display_name(const ::std::string& value) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.display_name)
}
#if LANG_CXX11
inline void Services_Item::set_display_name(::std::string&& value) {
  
  display_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.display_name)
}
#endif
inline void Services_Item::set_display_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.display_name)
}
inline void Services_Item::set_display_name(const char* value, size_t size) {
  
  display_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.display_name)
}
inline ::std::string* Services_Item::mutable_display_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.display_name)
  return display_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_display_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.display_name)
  
  return display_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_display_name(::std::string* display_name) {
  if (display_name != NULL) {
    
  } else {
    
  }
  display_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.display_name)
}

// string description = 3;
inline void Services_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.description)
  return description_.GetNoArena();
}
inline void Services_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.description)
}
#if LANG_CXX11
inline void Services_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.description)
}
#endif
inline void Services_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.description)
}
inline void Services_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.description)
}
inline ::std::string* Services_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.description)
}

// .aspia.proto.Services.Item.Status status = 4;
inline void Services_Item::clear_status() {
  status_ = 0;
}
inline ::aspia::proto::Services_Item_Status Services_Item::status() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.status)
  return static_cast< ::aspia::proto::Services_Item_Status >(status_);
}
inline void Services_Item::set_status(::aspia::proto::Services_Item_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.status)
}

// .aspia.proto.Services.Item.StartupType startup_type = 5;
inline void Services_Item::clear_startup_type() {
  startup_type_ = 0;
}
inline ::aspia::proto::Services_Item_StartupType Services_Item::startup_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.startup_type)
  return static_cast< ::aspia::proto::Services_Item_StartupType >(startup_type_);
}
inline void Services_Item::set_startup_type(::aspia::proto::Services_Item_StartupType value) {
  
  startup_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.startup_type)
}

// string binary_path = 6;
inline void Services_Item::clear_binary_path() {
  binary_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::binary_path() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.binary_path)
  return binary_path_.GetNoArena();
}
inline void Services_Item::set_binary_path(const ::std::string& value) {
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.binary_path)
}
#if LANG_CXX11
inline void Services_Item::set_binary_path(::std::string&& value) {
  
  binary_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.binary_path)
}
#endif
inline void Services_Item::set_binary_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.binary_path)
}
inline void Services_Item::set_binary_path(const char* value, size_t size) {
  
  binary_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.binary_path)
}
inline ::std::string* Services_Item::mutable_binary_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.binary_path)
  return binary_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_binary_path() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.binary_path)
  
  return binary_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_binary_path(::std::string* binary_path) {
  if (binary_path != NULL) {
    
  } else {
    
  }
  binary_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), binary_path);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.binary_path)
}

// string start_name = 7;
inline void Services_Item::clear_start_name() {
  start_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Services_Item::start_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.Item.start_name)
  return start_name_.GetNoArena();
}
inline void Services_Item::set_start_name(const ::std::string& value) {
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Services.Item.start_name)
}
#if LANG_CXX11
inline void Services_Item::set_start_name(::std::string&& value) {
  
  start_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Services.Item.start_name)
}
#endif
inline void Services_Item::set_start_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Services.Item.start_name)
}
inline void Services_Item::set_start_name(const char* value, size_t size) {
  
  start_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Services.Item.start_name)
}
inline ::std::string* Services_Item::mutable_start_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.Item.start_name)
  return start_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Services_Item::release_start_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Services.Item.start_name)
  
  return start_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Services_Item::set_allocated_start_name(::std::string* start_name) {
  if (start_name != NULL) {
    
  } else {
    
  }
  start_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Services.Item.start_name)
}

// -------------------------------------------------------------------

// Services

// repeated .aspia.proto.Services.Item item = 1;
inline int Services::item_size() const {
  return item_.size();
}
inline void Services::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Services_Item& Services::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Services.item)
  return item_.Get(index);
}
inline ::aspia::proto::Services_Item* Services::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Services.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Services_Item* Services::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Services.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >*
Services::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Services.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Services_Item >&
Services::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Services.item)
  return item_;
}

// -------------------------------------------------------------------

// Processes_Item

// string process_name = 1;
inline void Processes_Item::clear_process_name() {
  process_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processes_Item::process_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Processes.Item.process_name)
  return process_name_.GetNoArena();
}
inline void Processes_Item::set_process_name(const ::std::string& value) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Processes.Item.process_name)
}
#if LANG_CXX11
inline void Processes_Item::set_process_name(::std::string&& value) {
  
  process_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Processes.Item.process_name)
}
#endif
inline void Processes_Item::set_process_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Processes.Item.process_name)
}
inline void Processes_Item::set_process_name(const char* value, size_t size) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Processes.Item.process_name)
}
inline ::std::string* Processes_Item::mutable_process_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Processes.Item.process_name)
  return process_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processes_Item::release_process_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Processes.Item.process_name)
  
  return process_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processes_Item::set_allocated_process_name(::std::string* process_name) {
  if (process_name != NULL) {
    
  } else {
    
  }
  process_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Processes.Item.process_name)
}

// string file_path = 2;
inline void Processes_Item::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processes_Item::file_path() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Processes.Item.file_path)
  return file_path_.GetNoArena();
}
inline void Processes_Item::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Processes.Item.file_path)
}
#if LANG_CXX11
inline void Processes_Item::set_file_path(::std::string&& value) {
  
  file_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Processes.Item.file_path)
}
#endif
inline void Processes_Item::set_file_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Processes.Item.file_path)
}
inline void Processes_Item::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Processes.Item.file_path)
}
inline ::std::string* Processes_Item::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Processes.Item.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processes_Item::release_file_path() {
  // @@protoc_insertion_point(field_release:aspia.proto.Processes.Item.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processes_Item::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Processes.Item.file_path)
}

// uint64 used_memory = 3;
inline void Processes_Item::clear_used_memory() {
  used_memory_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Processes_Item::used_memory() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Processes.Item.used_memory)
  return used_memory_;
}
inline void Processes_Item::set_used_memory(::google::protobuf::uint64 value) {
  
  used_memory_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Processes.Item.used_memory)
}

// uint64 used_swap = 4;
inline void Processes_Item::clear_used_swap() {
  used_swap_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Processes_Item::used_swap() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Processes.Item.used_swap)
  return used_swap_;
}
inline void Processes_Item::set_used_swap(::google::protobuf::uint64 value) {
  
  used_swap_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Processes.Item.used_swap)
}

// string description = 5;
inline void Processes_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processes_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Processes.Item.description)
  return description_.GetNoArena();
}
inline void Processes_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Processes.Item.description)
}
#if LANG_CXX11
inline void Processes_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Processes.Item.description)
}
#endif
inline void Processes_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Processes.Item.description)
}
inline void Processes_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Processes.Item.description)
}
inline ::std::string* Processes_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Processes.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processes_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.Processes.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processes_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Processes.Item.description)
}

// -------------------------------------------------------------------

// Processes

// repeated .aspia.proto.Processes.Item item = 1;
inline int Processes::item_size() const {
  return item_.size();
}
inline void Processes::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Processes_Item& Processes::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Processes.item)
  return item_.Get(index);
}
inline ::aspia::proto::Processes_Item* Processes::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Processes.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Processes_Item* Processes::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Processes.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Processes_Item >*
Processes::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Processes.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Processes_Item >&
Processes::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Processes.item)
  return item_;
}

// -------------------------------------------------------------------

// NetworkCards_Item_IpAddress

// string address = 1;
inline void NetworkCards_Item_IpAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item_IpAddress::address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.IpAddress.address)
  return address_.GetNoArena();
}
inline void NetworkCards_Item_IpAddress::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.IpAddress.address)
}
#if LANG_CXX11
inline void NetworkCards_Item_IpAddress::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.IpAddress.address)
}
#endif
inline void NetworkCards_Item_IpAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.IpAddress.address)
}
inline void NetworkCards_Item_IpAddress::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.IpAddress.address)
}
inline ::std::string* NetworkCards_Item_IpAddress::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.IpAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item_IpAddress::release_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.IpAddress.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item_IpAddress::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.IpAddress.address)
}

// string mask = 2;
inline void NetworkCards_Item_IpAddress::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item_IpAddress::mask() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.IpAddress.mask)
  return mask_.GetNoArena();
}
inline void NetworkCards_Item_IpAddress::set_mask(const ::std::string& value) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
#if LANG_CXX11
inline void NetworkCards_Item_IpAddress::set_mask(::std::string&& value) {
  
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
#endif
inline void NetworkCards_Item_IpAddress::set_mask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
inline void NetworkCards_Item_IpAddress::set_mask(const char* value, size_t size) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.IpAddress.mask)
}
inline ::std::string* NetworkCards_Item_IpAddress::mutable_mask() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.IpAddress.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item_IpAddress::release_mask() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.IpAddress.mask)
  
  return mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item_IpAddress::set_allocated_mask(::std::string* mask) {
  if (mask != NULL) {
    
  } else {
    
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.IpAddress.mask)
}

// -------------------------------------------------------------------

// NetworkCards_Item

// string adapter_name = 1;
inline void NetworkCards_Item::clear_adapter_name() {
  adapter_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::adapter_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.adapter_name)
  return adapter_name_.GetNoArena();
}
inline void NetworkCards_Item::set_adapter_name(const ::std::string& value) {
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.adapter_name)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_adapter_name(::std::string&& value) {
  
  adapter_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.adapter_name)
}
#endif
inline void NetworkCards_Item::set_adapter_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.adapter_name)
}
inline void NetworkCards_Item::set_adapter_name(const char* value, size_t size) {
  
  adapter_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.adapter_name)
}
inline ::std::string* NetworkCards_Item::mutable_adapter_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.adapter_name)
  return adapter_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_adapter_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.adapter_name)
  
  return adapter_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_adapter_name(::std::string* adapter_name) {
  if (adapter_name != NULL) {
    
  } else {
    
  }
  adapter_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adapter_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.adapter_name)
}

// string connection_name = 2;
inline void NetworkCards_Item::clear_connection_name() {
  connection_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::connection_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.connection_name)
  return connection_name_.GetNoArena();
}
inline void NetworkCards_Item::set_connection_name(const ::std::string& value) {
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.connection_name)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_connection_name(::std::string&& value) {
  
  connection_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.connection_name)
}
#endif
inline void NetworkCards_Item::set_connection_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.connection_name)
}
inline void NetworkCards_Item::set_connection_name(const char* value, size_t size) {
  
  connection_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.connection_name)
}
inline ::std::string* NetworkCards_Item::mutable_connection_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.connection_name)
  return connection_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_connection_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.connection_name)
  
  return connection_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_connection_name(::std::string* connection_name) {
  if (connection_name != NULL) {
    
  } else {
    
  }
  connection_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connection_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.connection_name)
}

// string interface_type = 3;
inline void NetworkCards_Item::clear_interface_type() {
  interface_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::interface_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.interface_type)
  return interface_type_.GetNoArena();
}
inline void NetworkCards_Item::set_interface_type(const ::std::string& value) {
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.interface_type)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_interface_type(::std::string&& value) {
  
  interface_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.interface_type)
}
#endif
inline void NetworkCards_Item::set_interface_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.interface_type)
}
inline void NetworkCards_Item::set_interface_type(const char* value, size_t size) {
  
  interface_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.interface_type)
}
inline ::std::string* NetworkCards_Item::mutable_interface_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.interface_type)
  return interface_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_interface_type() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.interface_type)
  
  return interface_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_interface_type(::std::string* interface_type) {
  if (interface_type != NULL) {
    
  } else {
    
  }
  interface_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), interface_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.interface_type)
}

// uint32 mtu = 4;
inline void NetworkCards_Item::clear_mtu() {
  mtu_ = 0u;
}
inline ::google::protobuf::uint32 NetworkCards_Item::mtu() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.mtu)
  return mtu_;
}
inline void NetworkCards_Item::set_mtu(::google::protobuf::uint32 value) {
  
  mtu_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.mtu)
}

// uint32 speed = 5;
inline void NetworkCards_Item::clear_speed() {
  speed_ = 0u;
}
inline ::google::protobuf::uint32 NetworkCards_Item::speed() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.speed)
  return speed_;
}
inline void NetworkCards_Item::set_speed(::google::protobuf::uint32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.speed)
}

// string mac_address = 6;
inline void NetworkCards_Item::clear_mac_address() {
  mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::mac_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.mac_address)
  return mac_address_.GetNoArena();
}
inline void NetworkCards_Item::set_mac_address(const ::std::string& value) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.mac_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_mac_address(::std::string&& value) {
  
  mac_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.mac_address)
}
#endif
inline void NetworkCards_Item::set_mac_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.mac_address)
}
inline void NetworkCards_Item::set_mac_address(const char* value, size_t size) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.mac_address)
}
inline ::std::string* NetworkCards_Item::mutable_mac_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.mac_address)
  return mac_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_mac_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.mac_address)
  
  return mac_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_mac_address(::std::string* mac_address) {
  if (mac_address != NULL) {
    
  } else {
    
  }
  mac_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.mac_address)
}

// bool is_wins_enabled = 7;
inline void NetworkCards_Item::clear_is_wins_enabled() {
  is_wins_enabled_ = false;
}
inline bool NetworkCards_Item::is_wins_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.is_wins_enabled)
  return is_wins_enabled_;
}
inline void NetworkCards_Item::set_is_wins_enabled(bool value) {
  
  is_wins_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.is_wins_enabled)
}

// string primary_wins_server = 8;
inline void NetworkCards_Item::clear_primary_wins_server() {
  primary_wins_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::primary_wins_server() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.primary_wins_server)
  return primary_wins_server_.GetNoArena();
}
inline void NetworkCards_Item::set_primary_wins_server(const ::std::string& value) {
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.primary_wins_server)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_primary_wins_server(::std::string&& value) {
  
  primary_wins_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.primary_wins_server)
}
#endif
inline void NetworkCards_Item::set_primary_wins_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.primary_wins_server)
}
inline void NetworkCards_Item::set_primary_wins_server(const char* value, size_t size) {
  
  primary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.primary_wins_server)
}
inline ::std::string* NetworkCards_Item::mutable_primary_wins_server() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.primary_wins_server)
  return primary_wins_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_primary_wins_server() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.primary_wins_server)
  
  return primary_wins_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_primary_wins_server(::std::string* primary_wins_server) {
  if (primary_wins_server != NULL) {
    
  } else {
    
  }
  primary_wins_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_wins_server);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.primary_wins_server)
}

// string secondary_wins_server = 9;
inline void NetworkCards_Item::clear_secondary_wins_server() {
  secondary_wins_server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkCards_Item::secondary_wins_server() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.secondary_wins_server)
  return secondary_wins_server_.GetNoArena();
}
inline void NetworkCards_Item::set_secondary_wins_server(const ::std::string& value) {
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
#if LANG_CXX11
inline void NetworkCards_Item::set_secondary_wins_server(::std::string&& value) {
  
  secondary_wins_server_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
#endif
inline void NetworkCards_Item::set_secondary_wins_server(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
inline void NetworkCards_Item::set_secondary_wins_server(const char* value, size_t size) {
  
  secondary_wins_server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.secondary_wins_server)
}
inline ::std::string* NetworkCards_Item::mutable_secondary_wins_server() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.secondary_wins_server)
  return secondary_wins_server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkCards_Item::release_secondary_wins_server() {
  // @@protoc_insertion_point(field_release:aspia.proto.NetworkCards.Item.secondary_wins_server)
  
  return secondary_wins_server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkCards_Item::set_allocated_secondary_wins_server(::std::string* secondary_wins_server) {
  if (secondary_wins_server != NULL) {
    
  } else {
    
  }
  secondary_wins_server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secondary_wins_server);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.NetworkCards.Item.secondary_wins_server)
}

// bool is_dhcp_enabled = 10;
inline void NetworkCards_Item::clear_is_dhcp_enabled() {
  is_dhcp_enabled_ = false;
}
inline bool NetworkCards_Item::is_dhcp_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.is_dhcp_enabled)
  return is_dhcp_enabled_;
}
inline void NetworkCards_Item::set_is_dhcp_enabled(bool value) {
  
  is_dhcp_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.is_dhcp_enabled)
}

// repeated .aspia.proto.NetworkCards.Item.IpAddress ip_address = 11;
inline int NetworkCards_Item::ip_address_size() const {
  return ip_address_.size();
}
inline void NetworkCards_Item::clear_ip_address() {
  ip_address_.Clear();
}
inline const ::aspia::proto::NetworkCards_Item_IpAddress& NetworkCards_Item::ip_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_.Get(index);
}
inline ::aspia::proto::NetworkCards_Item_IpAddress* NetworkCards_Item::mutable_ip_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_.Mutable(index);
}
inline ::aspia::proto::NetworkCards_Item_IpAddress* NetworkCards_Item::add_ip_address() {
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >*
NetworkCards_Item::mutable_ip_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.ip_address)
  return &ip_address_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item_IpAddress >&
NetworkCards_Item::ip_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.ip_address)
  return ip_address_;
}

// repeated string gateway_address = 12;
inline int NetworkCards_Item::gateway_address_size() const {
  return gateway_address_.size();
}
inline void NetworkCards_Item::clear_gateway_address() {
  gateway_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::gateway_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_gateway_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_.Mutable(index);
}
inline void NetworkCards_Item::set_gateway_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.gateway_address)
  gateway_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_gateway_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.gateway_address)
  gateway_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_gateway_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  gateway_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.gateway_address)
}
inline void NetworkCards_Item::set_gateway_address(int index, const char* value, size_t size) {
  gateway_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.gateway_address)
}
inline ::std::string* NetworkCards_Item::add_gateway_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_.Add();
}
inline void NetworkCards_Item::add_gateway_address(const ::std::string& value) {
  gateway_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.gateway_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_gateway_address(::std::string&& value) {
  gateway_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.gateway_address)
}
#endif
inline void NetworkCards_Item::add_gateway_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  gateway_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.proto.NetworkCards.Item.gateway_address)
}
inline void NetworkCards_Item::add_gateway_address(const char* value, size_t size) {
  gateway_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.proto.NetworkCards.Item.gateway_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::gateway_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.gateway_address)
  return gateway_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_gateway_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.gateway_address)
  return &gateway_address_;
}

// repeated string dhcp_server_address = 13;
inline int NetworkCards_Item::dhcp_server_address_size() const {
  return dhcp_server_address_.size();
}
inline void NetworkCards_Item::clear_dhcp_server_address() {
  dhcp_server_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::dhcp_server_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_dhcp_server_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Mutable(index);
}
inline void NetworkCards_Item::set_dhcp_server_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dhcp_server_address)
  dhcp_server_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_dhcp_server_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dhcp_server_address)
  dhcp_server_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_dhcp_server_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dhcp_server_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline void NetworkCards_Item::set_dhcp_server_address(int index, const char* value, size_t size) {
  dhcp_server_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline ::std::string* NetworkCards_Item::add_dhcp_server_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_.Add();
}
inline void NetworkCards_Item::add_dhcp_server_address(const ::std::string& value) {
  dhcp_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_dhcp_server_address(::std::string&& value) {
  dhcp_server_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
#endif
inline void NetworkCards_Item::add_dhcp_server_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dhcp_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline void NetworkCards_Item::add_dhcp_server_address(const char* value, size_t size) {
  dhcp_server_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.proto.NetworkCards.Item.dhcp_server_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::dhcp_server_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return dhcp_server_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_dhcp_server_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.dhcp_server_address)
  return &dhcp_server_address_;
}

// repeated string dns_server_address = 14;
inline int NetworkCards_Item::dns_server_address_size() const {
  return dns_server_address_.size();
}
inline void NetworkCards_Item::clear_dns_server_address() {
  dns_server_address_.Clear();
}
inline const ::std::string& NetworkCards_Item::dns_server_address(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Get(index);
}
inline ::std::string* NetworkCards_Item::mutable_dns_server_address(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Mutable(index);
}
inline void NetworkCards_Item::set_dns_server_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dns_server_address)
  dns_server_address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkCards_Item::set_dns_server_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:aspia.proto.NetworkCards.Item.dns_server_address)
  dns_server_address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkCards_Item::set_dns_server_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_server_address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline void NetworkCards_Item::set_dns_server_address(int index, const char* value, size_t size) {
  dns_server_address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline ::std::string* NetworkCards_Item::add_dns_server_address() {
  // @@protoc_insertion_point(field_add_mutable:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_.Add();
}
inline void NetworkCards_Item::add_dns_server_address(const ::std::string& value) {
  dns_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dns_server_address)
}
#if LANG_CXX11
inline void NetworkCards_Item::add_dns_server_address(::std::string&& value) {
  dns_server_address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.Item.dns_server_address)
}
#endif
inline void NetworkCards_Item::add_dns_server_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  dns_server_address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline void NetworkCards_Item::add_dns_server_address(const char* value, size_t size) {
  dns_server_address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:aspia.proto.NetworkCards.Item.dns_server_address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkCards_Item::dns_server_address() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.Item.dns_server_address)
  return dns_server_address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkCards_Item::mutable_dns_server_address() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.Item.dns_server_address)
  return &dns_server_address_;
}

// -------------------------------------------------------------------

// NetworkCards

// repeated .aspia.proto.NetworkCards.Item item = 1;
inline int NetworkCards::item_size() const {
  return item_.size();
}
inline void NetworkCards::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::NetworkCards_Item& NetworkCards::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.NetworkCards.item)
  return item_.Get(index);
}
inline ::aspia::proto::NetworkCards_Item* NetworkCards::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.NetworkCards.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::NetworkCards_Item* NetworkCards::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.NetworkCards.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >*
NetworkCards::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.NetworkCards.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::NetworkCards_Item >&
NetworkCards::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.NetworkCards.item)
  return item_;
}

// -------------------------------------------------------------------

// OpenConnections_Item

// string process_name = 1;
inline void OpenConnections_Item::clear_process_name() {
  process_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::process_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.process_name)
  return process_name_.GetNoArena();
}
inline void OpenConnections_Item::set_process_name(const ::std::string& value) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.process_name)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_process_name(::std::string&& value) {
  
  process_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.process_name)
}
#endif
inline void OpenConnections_Item::set_process_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.process_name)
}
inline void OpenConnections_Item::set_process_name(const char* value, size_t size) {
  
  process_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.process_name)
}
inline ::std::string* OpenConnections_Item::mutable_process_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.process_name)
  return process_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_process_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.process_name)
  
  return process_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_process_name(::std::string* process_name) {
  if (process_name != NULL) {
    
  } else {
    
  }
  process_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), process_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.process_name)
}

// .aspia.proto.OpenConnections.Item.Protocol protocol = 2;
inline void OpenConnections_Item::clear_protocol() {
  protocol_ = 0;
}
inline ::aspia::proto::OpenConnections_Item_Protocol OpenConnections_Item::protocol() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.protocol)
  return static_cast< ::aspia::proto::OpenConnections_Item_Protocol >(protocol_);
}
inline void OpenConnections_Item::set_protocol(::aspia::proto::OpenConnections_Item_Protocol value) {
  
  protocol_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.protocol)
}

// string local_address = 3;
inline void OpenConnections_Item::clear_local_address() {
  local_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::local_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.local_address)
  return local_address_.GetNoArena();
}
inline void OpenConnections_Item::set_local_address(const ::std::string& value) {
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.local_address)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_local_address(::std::string&& value) {
  
  local_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.local_address)
}
#endif
inline void OpenConnections_Item::set_local_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.local_address)
}
inline void OpenConnections_Item::set_local_address(const char* value, size_t size) {
  
  local_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.local_address)
}
inline ::std::string* OpenConnections_Item::mutable_local_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.local_address)
  return local_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_local_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.local_address)
  
  return local_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_local_address(::std::string* local_address) {
  if (local_address != NULL) {
    
  } else {
    
  }
  local_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.local_address)
}

// string remote_address = 4;
inline void OpenConnections_Item::clear_remote_address() {
  remote_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::remote_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.remote_address)
  return remote_address_.GetNoArena();
}
inline void OpenConnections_Item::set_remote_address(const ::std::string& value) {
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.remote_address)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_remote_address(::std::string&& value) {
  
  remote_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.remote_address)
}
#endif
inline void OpenConnections_Item::set_remote_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.remote_address)
}
inline void OpenConnections_Item::set_remote_address(const char* value, size_t size) {
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.remote_address)
}
inline ::std::string* OpenConnections_Item::mutable_remote_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.remote_address)
  return remote_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_remote_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.remote_address)
  
  return remote_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_remote_address(::std::string* remote_address) {
  if (remote_address != NULL) {
    
  } else {
    
  }
  remote_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.remote_address)
}

// uint32 local_port = 5;
inline void OpenConnections_Item::clear_local_port() {
  local_port_ = 0u;
}
inline ::google::protobuf::uint32 OpenConnections_Item::local_port() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.local_port)
  return local_port_;
}
inline void OpenConnections_Item::set_local_port(::google::protobuf::uint32 value) {
  
  local_port_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.local_port)
}

// uint32 remote_port = 6;
inline void OpenConnections_Item::clear_remote_port() {
  remote_port_ = 0u;
}
inline ::google::protobuf::uint32 OpenConnections_Item::remote_port() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.remote_port)
  return remote_port_;
}
inline void OpenConnections_Item::set_remote_port(::google::protobuf::uint32 value) {
  
  remote_port_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.remote_port)
}

// string state = 7;
inline void OpenConnections_Item::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenConnections_Item::state() const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.Item.state)
  return state_.GetNoArena();
}
inline void OpenConnections_Item::set_state(const ::std::string& value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.OpenConnections.Item.state)
}
#if LANG_CXX11
inline void OpenConnections_Item::set_state(::std::string&& value) {
  
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.OpenConnections.Item.state)
}
#endif
inline void OpenConnections_Item::set_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.OpenConnections.Item.state)
}
inline void OpenConnections_Item::set_state(const char* value, size_t size) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.OpenConnections.Item.state)
}
inline ::std::string* OpenConnections_Item::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.Item.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenConnections_Item::release_state() {
  // @@protoc_insertion_point(field_release:aspia.proto.OpenConnections.Item.state)
  
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenConnections_Item::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.OpenConnections.Item.state)
}

// -------------------------------------------------------------------

// OpenConnections

// repeated .aspia.proto.OpenConnections.Item item = 1;
inline int OpenConnections::item_size() const {
  return item_.size();
}
inline void OpenConnections::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::OpenConnections_Item& OpenConnections::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.OpenConnections.item)
  return item_.Get(index);
}
inline ::aspia::proto::OpenConnections_Item* OpenConnections::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.OpenConnections.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::OpenConnections_Item* OpenConnections::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.OpenConnections.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >*
OpenConnections::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.OpenConnections.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::OpenConnections_Item >&
OpenConnections::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.OpenConnections.item)
  return item_;
}

// -------------------------------------------------------------------

// SharedResources_Item

// string name = 1;
inline void SharedResources_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.name)
  return name_.GetNoArena();
}
inline void SharedResources_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.name)
}
#if LANG_CXX11
inline void SharedResources_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SharedResources.Item.name)
}
#endif
inline void SharedResources_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SharedResources.Item.name)
}
inline void SharedResources_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SharedResources.Item.name)
}
inline ::std::string* SharedResources_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.SharedResources.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SharedResources.Item.name)
}

// .aspia.proto.SharedResources.Item.Type type = 2;
inline void SharedResources_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::SharedResources_Item_Type SharedResources_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.type)
  return static_cast< ::aspia::proto::SharedResources_Item_Type >(type_);
}
inline void SharedResources_Item::set_type(::aspia::proto::SharedResources_Item_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.type)
}

// string description = 3;
inline void SharedResources_Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::description() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.description)
  return description_.GetNoArena();
}
inline void SharedResources_Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.description)
}
#if LANG_CXX11
inline void SharedResources_Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SharedResources.Item.description)
}
#endif
inline void SharedResources_Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SharedResources.Item.description)
}
inline void SharedResources_Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SharedResources.Item.description)
}
inline ::std::string* SharedResources_Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_description() {
  // @@protoc_insertion_point(field_release:aspia.proto.SharedResources.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SharedResources.Item.description)
}

// string local_path = 4;
inline void SharedResources_Item::clear_local_path() {
  local_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SharedResources_Item::local_path() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.local_path)
  return local_path_.GetNoArena();
}
inline void SharedResources_Item::set_local_path(const ::std::string& value) {
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.local_path)
}
#if LANG_CXX11
inline void SharedResources_Item::set_local_path(::std::string&& value) {
  
  local_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SharedResources.Item.local_path)
}
#endif
inline void SharedResources_Item::set_local_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SharedResources.Item.local_path)
}
inline void SharedResources_Item::set_local_path(const char* value, size_t size) {
  
  local_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SharedResources.Item.local_path)
}
inline ::std::string* SharedResources_Item::mutable_local_path() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.Item.local_path)
  return local_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SharedResources_Item::release_local_path() {
  // @@protoc_insertion_point(field_release:aspia.proto.SharedResources.Item.local_path)
  
  return local_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SharedResources_Item::set_allocated_local_path(::std::string* local_path) {
  if (local_path != NULL) {
    
  } else {
    
  }
  local_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_path);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SharedResources.Item.local_path)
}

// uint32 current_uses = 5;
inline void SharedResources_Item::clear_current_uses() {
  current_uses_ = 0u;
}
inline ::google::protobuf::uint32 SharedResources_Item::current_uses() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.current_uses)
  return current_uses_;
}
inline void SharedResources_Item::set_current_uses(::google::protobuf::uint32 value) {
  
  current_uses_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.current_uses)
}

// uint32 maximum_uses = 6;
inline void SharedResources_Item::clear_maximum_uses() {
  maximum_uses_ = 0u;
}
inline ::google::protobuf::uint32 SharedResources_Item::maximum_uses() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.Item.maximum_uses)
  return maximum_uses_;
}
inline void SharedResources_Item::set_maximum_uses(::google::protobuf::uint32 value) {
  
  maximum_uses_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SharedResources.Item.maximum_uses)
}

// -------------------------------------------------------------------

// SharedResources

// repeated .aspia.proto.SharedResources.Item item = 1;
inline int SharedResources::item_size() const {
  return item_.size();
}
inline void SharedResources::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::SharedResources_Item& SharedResources::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.SharedResources.item)
  return item_.Get(index);
}
inline ::aspia::proto::SharedResources_Item* SharedResources::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.SharedResources.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::SharedResources_Item* SharedResources::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.SharedResources.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >*
SharedResources::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.SharedResources.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::SharedResources_Item >&
SharedResources::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.SharedResources.item)
  return item_;
}

// -------------------------------------------------------------------

// Routes_Item

// string destonation = 1;
inline void Routes_Item::clear_destonation() {
  destonation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::destonation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.destonation)
  return destonation_.GetNoArena();
}
inline void Routes_Item::set_destonation(const ::std::string& value) {
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.destonation)
}
#if LANG_CXX11
inline void Routes_Item::set_destonation(::std::string&& value) {
  
  destonation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Routes.Item.destonation)
}
#endif
inline void Routes_Item::set_destonation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Routes.Item.destonation)
}
inline void Routes_Item::set_destonation(const char* value, size_t size) {
  
  destonation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Routes.Item.destonation)
}
inline ::std::string* Routes_Item::mutable_destonation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.Item.destonation)
  return destonation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_destonation() {
  // @@protoc_insertion_point(field_release:aspia.proto.Routes.Item.destonation)
  
  return destonation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_destonation(::std::string* destonation) {
  if (destonation != NULL) {
    
  } else {
    
  }
  destonation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destonation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Routes.Item.destonation)
}

// string mask = 2;
inline void Routes_Item::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::mask() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.mask)
  return mask_.GetNoArena();
}
inline void Routes_Item::set_mask(const ::std::string& value) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.mask)
}
#if LANG_CXX11
inline void Routes_Item::set_mask(::std::string&& value) {
  
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Routes.Item.mask)
}
#endif
inline void Routes_Item::set_mask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Routes.Item.mask)
}
inline void Routes_Item::set_mask(const char* value, size_t size) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Routes.Item.mask)
}
inline ::std::string* Routes_Item::mutable_mask() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.Item.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_mask() {
  // @@protoc_insertion_point(field_release:aspia.proto.Routes.Item.mask)
  
  return mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_mask(::std::string* mask) {
  if (mask != NULL) {
    
  } else {
    
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Routes.Item.mask)
}

// string gateway = 3;
inline void Routes_Item::clear_gateway() {
  gateway_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Routes_Item::gateway() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.gateway)
  return gateway_.GetNoArena();
}
inline void Routes_Item::set_gateway(const ::std::string& value) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.gateway)
}
#if LANG_CXX11
inline void Routes_Item::set_gateway(::std::string&& value) {
  
  gateway_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Routes.Item.gateway)
}
#endif
inline void Routes_Item::set_gateway(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Routes.Item.gateway)
}
inline void Routes_Item::set_gateway(const char* value, size_t size) {
  
  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Routes.Item.gateway)
}
inline ::std::string* Routes_Item::mutable_gateway() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.Item.gateway)
  return gateway_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Routes_Item::release_gateway() {
  // @@protoc_insertion_point(field_release:aspia.proto.Routes.Item.gateway)
  
  return gateway_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Routes_Item::set_allocated_gateway(::std::string* gateway) {
  if (gateway != NULL) {
    
  } else {
    
  }
  gateway_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gateway);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Routes.Item.gateway)
}

// uint32 metric = 4;
inline void Routes_Item::clear_metric() {
  metric_ = 0u;
}
inline ::google::protobuf::uint32 Routes_Item::metric() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.Item.metric)
  return metric_;
}
inline void Routes_Item::set_metric(::google::protobuf::uint32 value) {
  
  metric_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Routes.Item.metric)
}

// -------------------------------------------------------------------

// Routes

// repeated .aspia.proto.Routes.Item item = 1;
inline int Routes::item_size() const {
  return item_.size();
}
inline void Routes::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Routes_Item& Routes::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Routes.item)
  return item_.Get(index);
}
inline ::aspia::proto::Routes_Item* Routes::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Routes.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Routes_Item* Routes::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Routes.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >*
Routes::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Routes.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Routes_Item >&
Routes::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Routes.item)
  return item_;
}

// -------------------------------------------------------------------

// Users_Item

// string name = 1;
inline void Users_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.name)
  return name_.GetNoArena();
}
inline void Users_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.name)
}
#if LANG_CXX11
inline void Users_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Users.Item.name)
}
#endif
inline void Users_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Users.Item.name)
}
inline void Users_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Users.Item.name)
}
inline ::std::string* Users_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Users.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Users.Item.name)
}

// string full_name = 2;
inline void Users_Item::clear_full_name() {
  full_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::full_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.full_name)
  return full_name_.GetNoArena();
}
inline void Users_Item::set_full_name(const ::std::string& value) {
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.full_name)
}
#if LANG_CXX11
inline void Users_Item::set_full_name(::std::string&& value) {
  
  full_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Users.Item.full_name)
}
#endif
inline void Users_Item::set_full_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Users.Item.full_name)
}
inline void Users_Item::set_full_name(const char* value, size_t size) {
  
  full_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Users.Item.full_name)
}
inline ::std::string* Users_Item::mutable_full_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.Item.full_name)
  return full_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_full_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Users.Item.full_name)
  
  return full_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_full_name(::std::string* full_name) {
  if (full_name != NULL) {
    
  } else {
    
  }
  full_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), full_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Users.Item.full_name)
}

// string comment = 3;
inline void Users_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Users_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.comment)
  return comment_.GetNoArena();
}
inline void Users_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.comment)
}
#if LANG_CXX11
inline void Users_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Users.Item.comment)
}
#endif
inline void Users_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Users.Item.comment)
}
inline void Users_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Users.Item.comment)
}
inline ::std::string* Users_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Users_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.proto.Users.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Users_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Users.Item.comment)
}

// bool is_disabled = 4;
inline void Users_Item::clear_is_disabled() {
  is_disabled_ = false;
}
inline bool Users_Item::is_disabled() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_disabled)
  return is_disabled_;
}
inline void Users_Item::set_is_disabled(bool value) {
  
  is_disabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_disabled)
}

// bool is_password_cant_change = 5;
inline void Users_Item::clear_is_password_cant_change() {
  is_password_cant_change_ = false;
}
inline bool Users_Item::is_password_cant_change() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_password_cant_change)
  return is_password_cant_change_;
}
inline void Users_Item::set_is_password_cant_change(bool value) {
  
  is_password_cant_change_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_password_cant_change)
}

// bool is_password_expired = 6;
inline void Users_Item::clear_is_password_expired() {
  is_password_expired_ = false;
}
inline bool Users_Item::is_password_expired() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_password_expired)
  return is_password_expired_;
}
inline void Users_Item::set_is_password_expired(bool value) {
  
  is_password_expired_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_password_expired)
}

// bool is_dont_expire_password = 7;
inline void Users_Item::clear_is_dont_expire_password() {
  is_dont_expire_password_ = false;
}
inline bool Users_Item::is_dont_expire_password() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_dont_expire_password)
  return is_dont_expire_password_;
}
inline void Users_Item::set_is_dont_expire_password(bool value) {
  
  is_dont_expire_password_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_dont_expire_password)
}

// bool is_lockout = 8;
inline void Users_Item::clear_is_lockout() {
  is_lockout_ = false;
}
inline bool Users_Item::is_lockout() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.is_lockout)
  return is_lockout_;
}
inline void Users_Item::set_is_lockout(bool value) {
  
  is_lockout_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.is_lockout)
}

// uint32 number_logons = 9;
inline void Users_Item::clear_number_logons() {
  number_logons_ = 0u;
}
inline ::google::protobuf::uint32 Users_Item::number_logons() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.number_logons)
  return number_logons_;
}
inline void Users_Item::set_number_logons(::google::protobuf::uint32 value) {
  
  number_logons_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.number_logons)
}

// uint32 bad_password_count = 10;
inline void Users_Item::clear_bad_password_count() {
  bad_password_count_ = 0u;
}
inline ::google::protobuf::uint32 Users_Item::bad_password_count() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.bad_password_count)
  return bad_password_count_;
}
inline void Users_Item::set_bad_password_count(::google::protobuf::uint32 value) {
  
  bad_password_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.bad_password_count)
}

// int64 last_logon_time = 11;
inline void Users_Item::clear_last_logon_time() {
  last_logon_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Users_Item::last_logon_time() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.Item.last_logon_time)
  return last_logon_time_;
}
inline void Users_Item::set_last_logon_time(::google::protobuf::int64 value) {
  
  last_logon_time_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Users.Item.last_logon_time)
}

// -------------------------------------------------------------------

// Users

// repeated .aspia.proto.Users.Item item = 1;
inline int Users::item_size() const {
  return item_.size();
}
inline void Users::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Users_Item& Users::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Users.item)
  return item_.Get(index);
}
inline ::aspia::proto::Users_Item* Users::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Users.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Users_Item* Users::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Users.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >*
Users::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Users.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Users_Item >&
Users::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Users.item)
  return item_;
}

// -------------------------------------------------------------------

// UserGroups_Item

// string name = 1;
inline void UserGroups_Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserGroups_Item::name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.UserGroups.Item.name)
  return name_.GetNoArena();
}
inline void UserGroups_Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.UserGroups.Item.name)
}
#if LANG_CXX11
inline void UserGroups_Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.UserGroups.Item.name)
}
#endif
inline void UserGroups_Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.UserGroups.Item.name)
}
inline void UserGroups_Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.UserGroups.Item.name)
}
inline ::std::string* UserGroups_Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.UserGroups.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserGroups_Item::release_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.UserGroups.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserGroups_Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.UserGroups.Item.name)
}

// string comment = 2;
inline void UserGroups_Item::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserGroups_Item::comment() const {
  // @@protoc_insertion_point(field_get:aspia.proto.UserGroups.Item.comment)
  return comment_.GetNoArena();
}
inline void UserGroups_Item::set_comment(const ::std::string& value) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.UserGroups.Item.comment)
}
#if LANG_CXX11
inline void UserGroups_Item::set_comment(::std::string&& value) {
  
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.UserGroups.Item.comment)
}
#endif
inline void UserGroups_Item::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.UserGroups.Item.comment)
}
inline void UserGroups_Item::set_comment(const char* value, size_t size) {
  
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.UserGroups.Item.comment)
}
inline ::std::string* UserGroups_Item::mutable_comment() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.UserGroups.Item.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserGroups_Item::release_comment() {
  // @@protoc_insertion_point(field_release:aspia.proto.UserGroups.Item.comment)
  
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserGroups_Item::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    
  } else {
    
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.UserGroups.Item.comment)
}

// -------------------------------------------------------------------

// UserGroups

// repeated .aspia.proto.UserGroups.Item item = 1;
inline int UserGroups::item_size() const {
  return item_.size();
}
inline void UserGroups::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::UserGroups_Item& UserGroups::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.UserGroups.item)
  return item_.Get(index);
}
inline ::aspia::proto::UserGroups_Item* UserGroups::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.UserGroups.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::UserGroups_Item* UserGroups::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.UserGroups.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >*
UserGroups::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.UserGroups.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::UserGroups_Item >&
UserGroups::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.UserGroups.item)
  return item_;
}

// -------------------------------------------------------------------

// Sessions_Item

// string user_name = 1;
inline void Sessions_Item::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::user_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.user_name)
  return user_name_.GetNoArena();
}
inline void Sessions_Item::set_user_name(const ::std::string& value) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.user_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_user_name(::std::string&& value) {
  
  user_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.user_name)
}
#endif
inline void Sessions_Item::set_user_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.user_name)
}
inline void Sessions_Item::set_user_name(const char* value, size_t size) {
  
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.user_name)
}
inline ::std::string* Sessions_Item::mutable_user_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_user_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.user_name)
  
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    
  } else {
    
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.user_name)
}

// string domain_name = 2;
inline void Sessions_Item::clear_domain_name() {
  domain_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::domain_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.domain_name)
  return domain_name_.GetNoArena();
}
inline void Sessions_Item::set_domain_name(const ::std::string& value) {
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.domain_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_domain_name(::std::string&& value) {
  
  domain_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.domain_name)
}
#endif
inline void Sessions_Item::set_domain_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.domain_name)
}
inline void Sessions_Item::set_domain_name(const char* value, size_t size) {
  
  domain_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.domain_name)
}
inline ::std::string* Sessions_Item::mutable_domain_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.domain_name)
  return domain_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_domain_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.domain_name)
  
  return domain_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_domain_name(::std::string* domain_name) {
  if (domain_name != NULL) {
    
  } else {
    
  }
  domain_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.domain_name)
}

// uint32 session_id = 3;
inline void Sessions_Item::clear_session_id() {
  session_id_ = 0u;
}
inline ::google::protobuf::uint32 Sessions_Item::session_id() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.session_id)
  return session_id_;
}
inline void Sessions_Item::set_session_id(::google::protobuf::uint32 value) {
  
  session_id_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.session_id)
}

// string connect_state = 4;
inline void Sessions_Item::clear_connect_state() {
  connect_state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::connect_state() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.connect_state)
  return connect_state_.GetNoArena();
}
inline void Sessions_Item::set_connect_state(const ::std::string& value) {
  
  connect_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.connect_state)
}
#if LANG_CXX11
inline void Sessions_Item::set_connect_state(::std::string&& value) {
  
  connect_state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.connect_state)
}
#endif
inline void Sessions_Item::set_connect_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  connect_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.connect_state)
}
inline void Sessions_Item::set_connect_state(const char* value, size_t size) {
  
  connect_state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.connect_state)
}
inline ::std::string* Sessions_Item::mutable_connect_state() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.connect_state)
  return connect_state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_connect_state() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.connect_state)
  
  return connect_state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_connect_state(::std::string* connect_state) {
  if (connect_state != NULL) {
    
  } else {
    
  }
  connect_state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connect_state);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.connect_state)
}

// string client_name = 5;
inline void Sessions_Item::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::client_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.client_name)
  return client_name_.GetNoArena();
}
inline void Sessions_Item::set_client_name(const ::std::string& value) {
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.client_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_client_name(::std::string&& value) {
  
  client_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.client_name)
}
#endif
inline void Sessions_Item::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.client_name)
}
inline void Sessions_Item::set_client_name(const char* value, size_t size) {
  
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.client_name)
}
inline ::std::string* Sessions_Item::mutable_client_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.client_name)
  return client_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_client_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.client_name)
  
  return client_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_client_name(::std::string* client_name) {
  if (client_name != NULL) {
    
  } else {
    
  }
  client_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.client_name)
}

// string winstation_name = 6;
inline void Sessions_Item::clear_winstation_name() {
  winstation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Sessions_Item::winstation_name() const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.Item.winstation_name)
  return winstation_name_.GetNoArena();
}
inline void Sessions_Item::set_winstation_name(const ::std::string& value) {
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.Sessions.Item.winstation_name)
}
#if LANG_CXX11
inline void Sessions_Item::set_winstation_name(::std::string&& value) {
  
  winstation_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.Sessions.Item.winstation_name)
}
#endif
inline void Sessions_Item::set_winstation_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.Sessions.Item.winstation_name)
}
inline void Sessions_Item::set_winstation_name(const char* value, size_t size) {
  
  winstation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.Sessions.Item.winstation_name)
}
inline ::std::string* Sessions_Item::mutable_winstation_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.Item.winstation_name)
  return winstation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sessions_Item::release_winstation_name() {
  // @@protoc_insertion_point(field_release:aspia.proto.Sessions.Item.winstation_name)
  
  return winstation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sessions_Item::set_allocated_winstation_name(::std::string* winstation_name) {
  if (winstation_name != NULL) {
    
  } else {
    
  }
  winstation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), winstation_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.Sessions.Item.winstation_name)
}

// -------------------------------------------------------------------

// Sessions

// repeated .aspia.proto.Sessions.Item item = 1;
inline int Sessions::item_size() const {
  return item_.size();
}
inline void Sessions::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::Sessions_Item& Sessions::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.Sessions.item)
  return item_.Get(index);
}
inline ::aspia::proto::Sessions_Item* Sessions::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.Sessions.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::Sessions_Item* Sessions::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.Sessions.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >*
Sessions::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.Sessions.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::Sessions_Item >&
Sessions::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.Sessions.item)
  return item_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace aspia

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aspia::proto::DmiBios_Characteristics> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiBios_Characteristics1> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiBios_Characteristics2> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiSystem_WakeupType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiBaseboard_BoardType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiChassis_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiChassis_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiChassis_SecurityStatus> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_Location> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_Mode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_SRAMType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_ErrorCorrectionType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiCaches_Associativity> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiProcessors_Family> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiProcessors_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiProcessors_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiProcessors_Upgrade> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiProcessors_Characteristics> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiMemoryDevices_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiMemoryDevices_FormFactor> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiSystemSlots_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiSystemSlots_Usage> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiSystemSlots_BusWidth> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiSystemSlots_Length> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPortConnectors_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPortConnectors_ConnectorType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiOnBoardDevices_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPointingDevice_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPointingDevice_Interface> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPortableBattery_Chemistry> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::AtaDrives_BusType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::AtaDrives_TransferMode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::AtaDrives_Features> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Monitors_InputSignalType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::PowerOptions_Battery_State> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::PowerOptions_PowerSource> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::PowerOptions_BatteryStatus> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Printers_Item_Orientation> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Services_Item_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::Services_Item_StartupType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::OpenConnections_Item_Protocol> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::SharedResources_Item_Type> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_system_5finfo_5fsession_5fmessage_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: authorization.proto

#include "authorization.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace protobuf_authorization_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_authorization_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ClientChallenge;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_authorization_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_LogonRequest;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_authorization_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_LogonResult;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_authorization_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ServerChallenge;
}  // namespace protobuf_authorization_2eproto
namespace aspia {
namespace proto {
namespace auth {
class LogonRequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<LogonRequest>
      _instance;
} _LogonRequest_default_instance_;
class ServerChallengeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ServerChallenge>
      _instance;
} _ServerChallenge_default_instance_;
class ClientChallengeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ClientChallenge>
      _instance;
} _ClientChallenge_default_instance_;
class LogonResultDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<LogonResult>
      _instance;
} _LogonResult_default_instance_;
class ClientToHostDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ClientToHost>
      _instance;
} _ClientToHost_default_instance_;
class HostToClientDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<HostToClient>
      _instance;
} _HostToClient_default_instance_;
}  // namespace auth
}  // namespace proto
}  // namespace aspia
namespace protobuf_authorization_2eproto {
static void InitDefaultsLogonRequest() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::aspia::proto::auth::_LogonRequest_default_instance_;
    new (ptr) ::aspia::proto::auth::LogonRequest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::auth::LogonRequest::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_LogonRequest =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsLogonRequest}, {}};

static void InitDefaultsServerChallenge() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::aspia::proto::auth::_ServerChallenge_default_instance_;
    new (ptr) ::aspia::proto::auth::ServerChallenge();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::auth::ServerChallenge::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ServerChallenge =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsServerChallenge}, {}};

static void InitDefaultsClientChallenge() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::aspia::proto::auth::_ClientChallenge_default_instance_;
    new (ptr) ::aspia::proto::auth::ClientChallenge();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::auth::ClientChallenge::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ClientChallenge =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsClientChallenge}, {}};

static void InitDefaultsLogonResult() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::aspia::proto::auth::_LogonResult_default_instance_;
    new (ptr) ::aspia::proto::auth::LogonResult();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::auth::LogonResult::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_LogonResult =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsLogonResult}, {}};

static void InitDefaultsClientToHost() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::aspia::proto::auth::_ClientToHost_default_instance_;
    new (ptr) ::aspia::proto::auth::ClientToHost();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::auth::ClientToHost::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_ClientToHost =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsClientToHost}, {
      &protobuf_authorization_2eproto::scc_info_LogonRequest.base,
      &protobuf_authorization_2eproto::scc_info_ClientChallenge.base,}};

static void InitDefaultsHostToClient() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::aspia::proto::auth::_HostToClient_default_instance_;
    new (ptr) ::aspia::proto::auth::HostToClient();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::auth::HostToClient::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_HostToClient =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsHostToClient}, {
      &protobuf_authorization_2eproto::scc_info_ServerChallenge.base,
      &protobuf_authorization_2eproto::scc_info_LogonResult.base,}};

void InitDefaults() {
  ::google::protobuf::internal::InitSCC(&scc_info_LogonRequest.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ServerChallenge.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ClientChallenge.base);
  ::google::protobuf::internal::InitSCC(&scc_info_LogonResult.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ClientToHost.base);
  ::google::protobuf::internal::InitSCC(&scc_info_HostToClient.base);
}

}  // namespace protobuf_authorization_2eproto
namespace aspia {
namespace proto {
namespace auth {
bool Method_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

bool Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void LogonRequest::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LogonRequest::kMethodFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LogonRequest::LogonRequest()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_authorization_2eproto::scc_info_LogonRequest.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.auth.LogonRequest)
}
LogonRequest::LogonRequest(const LogonRequest& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  method_ = from.method_;
  // @@protoc_insertion_point(copy_constructor:aspia.proto.auth.LogonRequest)
}

void LogonRequest::SharedCtor() {
  method_ = 0;
}

LogonRequest::~LogonRequest() {
  // @@protoc_insertion_point(destructor:aspia.proto.auth.LogonRequest)
  SharedDtor();
}

void LogonRequest::SharedDtor() {
}

void LogonRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LogonRequest& LogonRequest::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_authorization_2eproto::scc_info_LogonRequest.base);
  return *internal_default_instance();
}


void LogonRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.auth.LogonRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  method_ = 0;
  _internal_metadata_.Clear();
}

bool LogonRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.auth.LogonRequest)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .aspia.proto.auth.Method method = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_method(static_cast< ::aspia::proto::auth::Method >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.auth.LogonRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.auth.LogonRequest)
  return false;
#undef DO_
}

void LogonRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.auth.LogonRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .aspia.proto.auth.Method method = 1;
  if (this->method() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->method(), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.auth.LogonRequest)
}

size_t LogonRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.auth.LogonRequest)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // .aspia.proto.auth.Method method = 1;
  if (this->method() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->method());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogonRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LogonRequest*>(&from));
}

void LogonRequest::MergeFrom(const LogonRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.auth.LogonRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.method() != 0) {
    set_method(from.method());
  }
}

void LogonRequest::CopyFrom(const LogonRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.auth.LogonRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogonRequest::IsInitialized() const {
  return true;
}

void LogonRequest::Swap(LogonRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LogonRequest::InternalSwap(LogonRequest* other) {
  using std::swap;
  swap(method_, other->method_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string LogonRequest::GetTypeName() const {
  return "aspia.proto.auth.LogonRequest";
}


// ===================================================================

void ServerChallenge::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ServerChallenge::kNonceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ServerChallenge::ServerChallenge()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_authorization_2eproto::scc_info_ServerChallenge.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.auth.ServerChallenge)
}
ServerChallenge::ServerChallenge(const ServerChallenge& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.nonce().size() > 0) {
    nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
  }
  // @@protoc_insertion_point(copy_constructor:aspia.proto.auth.ServerChallenge)
}

void ServerChallenge::SharedCtor() {
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

ServerChallenge::~ServerChallenge() {
  // @@protoc_insertion_point(destructor:aspia.proto.auth.ServerChallenge)
  SharedDtor();
}

void ServerChallenge::SharedDtor() {
  nonce_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ServerChallenge::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ServerChallenge& ServerChallenge::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_authorization_2eproto::scc_info_ServerChallenge.base);
  return *internal_default_instance();
}


void ServerChallenge::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.auth.ServerChallenge)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

bool ServerChallenge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.auth.ServerChallenge)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // bytes nonce = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.auth.ServerChallenge)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.auth.ServerChallenge)
  return false;
#undef DO_
}

void ServerChallenge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.auth.ServerChallenge)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes nonce = 1;
  if (this->nonce().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->nonce(), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.auth.ServerChallenge)
}

size_t ServerChallenge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.auth.ServerChallenge)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // bytes nonce = 1;
  if (this->nonce().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->nonce());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServerChallenge::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServerChallenge*>(&from));
}

void ServerChallenge::MergeFrom(const ServerChallenge& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.auth.ServerChallenge)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.nonce().size() > 0) {

    nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
  }
}

void ServerChallenge::CopyFrom(const ServerChallenge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.auth.ServerChallenge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerChallenge::IsInitialized() const {
  return true;
}

void ServerChallenge::Swap(ServerChallenge* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ServerChallenge::InternalSwap(ServerChallenge* other) {
  using std::swap;
  nonce_.Swap(&other->nonce_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string ServerChallenge::GetTypeName() const {
  return "aspia.proto.auth.ServerChallenge";
}


// ===================================================================

void ClientChallenge::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClientChallenge::kSessionTypeFieldNumber;
const int ClientChallenge::kUsernameFieldNumber;
const int ClientChallenge::kSessionKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClientChallenge::ClientChallenge()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_authorization_2eproto::scc_info_ClientChallenge.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.auth.ClientChallenge)
}
ClientChallenge::ClientChallenge(const ClientChallenge& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  username_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.username().size() > 0) {
    username_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.username_);
  }
  session_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.session_key().size() > 0) {
    session_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.session_key_);
  }
  session_type_ = from.session_type_;
  // @@protoc_insertion_point(copy_constructor:aspia.proto.auth.ClientChallenge)
}

void ClientChallenge::SharedCtor() {
  username_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  session_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  session_type_ = 0;
}

ClientChallenge::~ClientChallenge() {
  // @@protoc_insertion_point(destructor:aspia.proto.auth.ClientChallenge)
  SharedDtor();
}

void ClientChallenge::SharedDtor() {
  username_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  session_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ClientChallenge::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientChallenge& ClientChallenge::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_authorization_2eproto::scc_info_ClientChallenge.base);
  return *internal_default_instance();
}


void ClientChallenge::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.auth.ClientChallenge)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  session_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  session_type_ = 0;
  _internal_metadata_.Clear();
}

bool ClientChallenge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.auth.ClientChallenge)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .aspia.proto.SessionType session_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_session_type(static_cast< ::aspia::proto::SessionType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string username = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->username().data(), static_cast<int>(this->username().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.auth.ClientChallenge.username"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bytes session_key = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_session_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.auth.ClientChallenge)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.auth.ClientChallenge)
  return false;
#undef DO_
}

void ClientChallenge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.auth.ClientChallenge)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .aspia.proto.SessionType session_type = 1;
  if (this->session_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->session_type(), output);
  }

  // string username = 2;
  if (this->username().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->username().data(), static_cast<int>(this->username().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.auth.ClientChallenge.username");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->username(), output);
  }

  // bytes session_key = 3;
  if (this->session_key().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->session_key(), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.auth.ClientChallenge)
}

size_t ClientChallenge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.auth.ClientChallenge)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // string username = 2;
  if (this->username().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->username());
  }

  // bytes session_key = 3;
  if (this->session_key().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->session_key());
  }

  // .aspia.proto.SessionType session_type = 1;
  if (this->session_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientChallenge::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClientChallenge*>(&from));
}

void ClientChallenge::MergeFrom(const ClientChallenge& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.auth.ClientChallenge)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.username().size() > 0) {

    username_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.username_);
  }
  if (from.session_key().size() > 0) {

    session_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.session_key_);
  }
  if (from.session_type() != 0) {
    set_session_type(from.session_type());
  }
}

void ClientChallenge::CopyFrom(const ClientChallenge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.auth.ClientChallenge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientChallenge::IsInitialized() const {
  return true;
}

void ClientChallenge::Swap(ClientChallenge* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClientChallenge::InternalSwap(ClientChallenge* other) {
  using std::swap;
  username_.Swap(&other->username_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  session_key_.Swap(&other->session_key_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(session_type_, other->session_type_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string ClientChallenge::GetTypeName() const {
  return "aspia.proto.auth.ClientChallenge";
}


// ===================================================================

void LogonResult::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LogonResult::kStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LogonResult::LogonResult()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_authorization_2eproto::scc_info_LogonResult.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.auth.LogonResult)
}
LogonResult::LogonResult(const LogonResult& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:aspia.proto.auth.LogonResult)
}

void LogonResult::SharedCtor() {
  status_ = 0;
}

LogonResult::~LogonResult() {
  // @@protoc_insertion_point(destructor:aspia.proto.auth.LogonResult)
  SharedDtor();
}

void LogonResult::SharedDtor() {
}

void LogonResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LogonResult& LogonResult::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_authorization_2eproto::scc_info_LogonResult.base);
  return *internal_default_instance();
}


void LogonResult::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.auth.LogonResult)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_ = 0;
  _internal_metadata_.Clear();
}

bool LogonResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.auth.LogonResult)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .aspia.proto.auth.Status status = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_status(static_cast< ::aspia::proto::auth::Status >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.auth.LogonResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.auth.LogonResult)
  return false;
#undef DO_
}

void LogonResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.auth.LogonResult)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .aspia.proto.auth.Status status = 1;
  if (this->status() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->status(), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.auth.LogonResult)
}

size_t LogonResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.auth.LogonResult)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // .aspia.proto.auth.Status status = 1;
  if (this->status() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogonResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LogonResult*>(&from));
}

void LogonResult::MergeFrom(const LogonResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.auth.LogonResult)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.status() != 0) {
    set_status(from.status());
  }
}

void LogonResult::CopyFrom(const LogonResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.auth.LogonResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogonResult::IsInitialized() const {
  return true;
}

void LogonResult::Swap(LogonResult* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LogonResult::InternalSwap(LogonResult* other) {
  using std::swap;
  swap(status_, other->status_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string LogonResult::GetTypeName() const {
  return "aspia.proto.auth.LogonResult";
}


// ===================================================================

void ClientToHost::InitAsDefaultInstance() {
  ::aspia::proto::auth::_ClientToHost_default_instance_._instance.get_mutable()->logon_request_ = const_cast< ::aspia::proto::auth::LogonRequest*>(
      ::aspia::proto::auth::LogonRequest::internal_default_instance());
  ::aspia::proto::auth::_ClientToHost_default_instance_._instance.get_mutable()->client_challenge_ = const_cast< ::aspia::proto::auth::ClientChallenge*>(
      ::aspia::proto::auth::ClientChallenge::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClientToHost::kLogonRequestFieldNumber;
const int ClientToHost::kClientChallengeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClientToHost::ClientToHost()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_authorization_2eproto::scc_info_ClientToHost.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.auth.ClientToHost)
}
ClientToHost::ClientToHost(const ClientToHost& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_logon_request()) {
    logon_request_ = new ::aspia::proto::auth::LogonRequest(*from.logon_request_);
  } else {
    logon_request_ = NULL;
  }
  if (from.has_client_challenge()) {
    client_challenge_ = new ::aspia::proto::auth::ClientChallenge(*from.client_challenge_);
  } else {
    client_challenge_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:aspia.proto.auth.ClientToHost)
}

void ClientToHost::SharedCtor() {
  ::memset(&logon_request_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&client_challenge_) -
      reinterpret_cast<char*>(&logon_request_)) + sizeof(client_challenge_));
}

ClientToHost::~ClientToHost() {
  // @@protoc_insertion_point(destructor:aspia.proto.auth.ClientToHost)
  SharedDtor();
}

void ClientToHost::SharedDtor() {
  if (this != internal_default_instance()) delete logon_request_;
  if (this != internal_default_instance()) delete client_challenge_;
}

void ClientToHost::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ClientToHost& ClientToHost::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_authorization_2eproto::scc_info_ClientToHost.base);
  return *internal_default_instance();
}


void ClientToHost::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.auth.ClientToHost)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && logon_request_ != NULL) {
    delete logon_request_;
  }
  logon_request_ = NULL;
  if (GetArenaNoVirtual() == NULL && client_challenge_ != NULL) {
    delete client_challenge_;
  }
  client_challenge_ = NULL;
  _internal_metadata_.Clear();
}

bool ClientToHost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.auth.ClientToHost)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .aspia.proto.auth.LogonRequest logon_request = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_logon_request()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .aspia.proto.auth.ClientChallenge client_challenge = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_client_challenge()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.auth.ClientToHost)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.auth.ClientToHost)
  return false;
#undef DO_
}

void ClientToHost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.auth.ClientToHost)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .aspia.proto.auth.LogonRequest logon_request = 1;
  if (this->has_logon_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->_internal_logon_request(), output);
  }

  // .aspia.proto.auth.ClientChallenge client_challenge = 2;
  if (this->has_client_challenge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->_internal_client_challenge(), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.auth.ClientToHost)
}

size_t ClientToHost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.auth.ClientToHost)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // .aspia.proto.auth.LogonRequest logon_request = 1;
  if (this->has_logon_request()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *logon_request_);
  }

  // .aspia.proto.auth.ClientChallenge client_challenge = 2;
  if (this->has_client_challenge()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *client_challenge_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientToHost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClientToHost*>(&from));
}

void ClientToHost::MergeFrom(const ClientToHost& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.auth.ClientToHost)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_logon_request()) {
    mutable_logon_request()->::aspia::proto::auth::LogonRequest::MergeFrom(from.logon_request());
  }
  if (from.has_client_challenge()) {
    mutable_client_challenge()->::aspia::proto::auth::ClientChallenge::MergeFrom(from.client_challenge());
  }
}

void ClientToHost::CopyFrom(const ClientToHost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.auth.ClientToHost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientToHost::IsInitialized() const {
  return true;
}

void ClientToHost::Swap(ClientToHost* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClientToHost::InternalSwap(ClientToHost* other) {
  using std::swap;
  swap(logon_request_, other->logon_request_);
  swap(client_challenge_, other->client_challenge_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string ClientToHost::GetTypeName() const {
  return "aspia.proto.auth.ClientToHost";
}


// ===================================================================

void HostToClient::InitAsDefaultInstance() {
  ::aspia::proto::auth::_HostToClient_default_instance_._instance.get_mutable()->server_challenge_ = const_cast< ::aspia::proto::auth::ServerChallenge*>(
      ::aspia::proto::auth::ServerChallenge::internal_default_instance());
  ::aspia::proto::auth::_HostToClient_default_instance_._instance.get_mutable()->logon_result_ = const_cast< ::aspia::proto::auth::LogonResult*>(
      ::aspia::proto::auth::LogonResult::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HostToClient::kServerChallengeFieldNumber;
const int HostToClient::kLogonResultFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HostToClient::HostToClient()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_authorization_2eproto::scc_info_HostToClient.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.auth.HostToClient)
}
HostToClient::HostToClient(const HostToClient& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_server_challenge()) {
    server_challenge_ = new ::aspia::proto::auth::ServerChallenge(*from.server_challenge_);
  } else {
    server_challenge_ = NULL;
  }
  if (from.has_logon_result()) {
    logon_result_ = new ::aspia::proto::auth::LogonResult(*from.logon_result_);
  } else {
    logon_result_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:aspia.proto.auth.HostToClient)
}

void HostToClient::SharedCtor() {
  ::memset(&server_challenge_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&logon_result_) -
      reinterpret_cast<char*>(&server_challenge_)) + sizeof(logon_result_));
}

HostToClient::~HostToClient() {
  // @@protoc_insertion_point(destructor:aspia.proto.auth.HostToClient)
  SharedDtor();
}

void HostToClient::SharedDtor() {
  if (this != internal_default_instance()) delete server_challenge_;
  if (this != internal_default_instance()) delete logon_result_;
}

void HostToClient::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HostToClient& HostToClient::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_authorization_2eproto::scc_info_HostToClient.base);
  return *internal_default_instance();
}


void HostToClient::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.auth.HostToClient)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && server_challenge_ != NULL) {
    delete server_challenge_;
  }
  server_challenge_ = NULL;
  if (GetArenaNoVirtual() == NULL && logon_result_ != NULL) {
    delete logon_result_;
  }
  logon_result_ = NULL;
  _internal_metadata_.Clear();
}

bool HostToClient::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.auth.HostToClient)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .aspia.proto.auth.ServerChallenge server_challenge = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_server_challenge()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .aspia.proto.auth.LogonResult logon_result = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_logon_result()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.auth.HostToClient)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.auth.HostToClient)
  return false;
#undef DO_
}

void HostToClient::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.auth.HostToClient)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .aspia.proto.auth.ServerChallenge server_challenge = 1;
  if (this->has_server_challenge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->_internal_server_challenge(), output);
  }

  // .aspia.proto.auth.LogonResult logon_result = 2;
  if (this->has_logon_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->_internal_logon_result(), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.auth.HostToClient)
}

size_t HostToClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.auth.HostToClient)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // .aspia.proto.auth.ServerChallenge server_challenge = 1;
  if (this->has_server_challenge()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *server_challenge_);
  }

  // .aspia.proto.auth.LogonResult logon_result = 2;
  if (this->has_logon_result()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *logon_result_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HostToClient::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HostToClient*>(&from));
}

void HostToClient::MergeFrom(const HostToClient& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.auth.HostToClient)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_server_challenge()) {
    mutable_server_challenge()->::aspia::proto::auth::ServerChallenge::MergeFrom(from.server_challenge());
  }
  if (from.has_logon_result()) {
    mutable_logon_result()->::aspia::proto::auth::LogonResult::MergeFrom(from.logon_result());
  }
}

void HostToClient::CopyFrom(const HostToClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.auth.HostToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostToClient::IsInitialized() const {
  return true;
}

void HostToClient::Swap(HostToClient* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HostToClient::InternalSwap(HostToClient* other) {
  using std::swap;
  swap(server_challenge_, other->server_challenge_);
  swap(logon_result_, other->logon_result_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string HostToClient::GetTypeName() const {
  return "aspia.proto.auth.HostToClient";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace auth
}  // namespace proto
}  // namespace aspia
namespace google {
namespace protobuf {
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::aspia::proto::auth::LogonRequest* Arena::CreateMaybeMessage< ::aspia::proto::auth::LogonRequest >(Arena* arena) {
  return Arena::CreateInternal< ::aspia::proto::auth::LogonRequest >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::aspia::proto::auth::ServerChallenge* Arena::CreateMaybeMessage< ::aspia::proto::auth::ServerChallenge >(Arena* arena) {
  return Arena::CreateInternal< ::aspia::proto::auth::ServerChallenge >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::aspia::proto::auth::ClientChallenge* Arena::CreateMaybeMessage< ::aspia::proto::auth::ClientChallenge >(Arena* arena) {
  return Arena::CreateInternal< ::aspia::proto::auth::ClientChallenge >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::aspia::proto::auth::LogonResult* Arena::CreateMaybeMessage< ::aspia::proto::auth::LogonResult >(Arena* arena) {
  return Arena::CreateInternal< ::aspia::proto::auth::LogonResult >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::aspia::proto::auth::ClientToHost* Arena::CreateMaybeMessage< ::aspia::proto::auth::ClientToHost >(Arena* arena) {
  return Arena::CreateInternal< ::aspia::proto::auth::ClientToHost >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::aspia::proto::auth::HostToClient* Arena::CreateMaybeMessage< ::aspia::proto::auth::HostToClient >(Arena* arena) {
  return Arena::CreateInternal< ::aspia::proto::auth::HostToClient >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

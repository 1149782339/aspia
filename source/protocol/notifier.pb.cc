// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: notifier.proto

#include "notifier.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)
namespace aspia {
namespace proto {
namespace notifier {
class SessionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Session>
      _instance;
} _Session_default_instance_;
class SessionCloseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SessionClose>
      _instance;
} _SessionClose_default_instance_;
class KillSessionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<KillSession>
      _instance;
} _KillSession_default_instance_;
class NotifierToServiceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NotifierToService>
      _instance;
} _NotifierToService_default_instance_;
class ServiceToNotifierDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ServiceToNotifier>
      _instance;
} _ServiceToNotifier_default_instance_;
}  // namespace notifier
}  // namespace proto
}  // namespace aspia
namespace protobuf_notifier_2eproto {
void InitDefaultsSessionImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::aspia::proto::notifier::_Session_default_instance_;
    new (ptr) ::aspia::proto::notifier::Session();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::notifier::Session::InitAsDefaultInstance();
}

void InitDefaultsSession() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsSessionImpl);
}

void InitDefaultsSessionCloseImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::aspia::proto::notifier::_SessionClose_default_instance_;
    new (ptr) ::aspia::proto::notifier::SessionClose();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::notifier::SessionClose::InitAsDefaultInstance();
}

void InitDefaultsSessionClose() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsSessionCloseImpl);
}

void InitDefaultsKillSessionImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::aspia::proto::notifier::_KillSession_default_instance_;
    new (ptr) ::aspia::proto::notifier::KillSession();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::notifier::KillSession::InitAsDefaultInstance();
}

void InitDefaultsKillSession() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsKillSessionImpl);
}

void InitDefaultsNotifierToServiceImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_notifier_2eproto::InitDefaultsKillSession();
  {
    void* ptr = &::aspia::proto::notifier::_NotifierToService_default_instance_;
    new (ptr) ::aspia::proto::notifier::NotifierToService();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::notifier::NotifierToService::InitAsDefaultInstance();
}

void InitDefaultsNotifierToService() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsNotifierToServiceImpl);
}

void InitDefaultsServiceToNotifierImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_notifier_2eproto::InitDefaultsSession();
  protobuf_notifier_2eproto::InitDefaultsSessionClose();
  {
    void* ptr = &::aspia::proto::notifier::_ServiceToNotifier_default_instance_;
    new (ptr) ::aspia::proto::notifier::ServiceToNotifier();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::aspia::proto::notifier::ServiceToNotifier::InitAsDefaultInstance();
}

void InitDefaultsServiceToNotifier() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsServiceToNotifierImpl);
}

}  // namespace protobuf_notifier_2eproto
namespace aspia {
namespace proto {
namespace notifier {

// ===================================================================

void Session::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Session::kUuidFieldNumber;
const int Session::kRemoteAddressFieldNumber;
const int Session::kUsernameFieldNumber;
const int Session::kSessionTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Session::Session()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_notifier_2eproto::InitDefaultsSession();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.notifier.Session)
}
Session::Session(const Session& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.uuid().size() > 0) {
    uuid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uuid_);
  }
  remote_address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.remote_address().size() > 0) {
    remote_address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.remote_address_);
  }
  username_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.username().size() > 0) {
    username_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.username_);
  }
  session_type_ = from.session_type_;
  // @@protoc_insertion_point(copy_constructor:aspia.proto.notifier.Session)
}

void Session::SharedCtor() {
  uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  remote_address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  username_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  session_type_ = 0;
  _cached_size_ = 0;
}

Session::~Session() {
  // @@protoc_insertion_point(destructor:aspia.proto.notifier.Session)
  SharedDtor();
}

void Session::SharedDtor() {
  uuid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  remote_address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  username_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Session::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Session& Session::default_instance() {
  ::protobuf_notifier_2eproto::InitDefaultsSession();
  return *internal_default_instance();
}

Session* Session::New(::google::protobuf::Arena* arena) const {
  Session* n = new Session;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Session::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.notifier.Session)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  remote_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  session_type_ = 0;
  _internal_metadata_.Clear();
}

bool Session::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.notifier.Session)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string uuid = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->uuid().data(), static_cast<int>(this->uuid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.notifier.Session.uuid"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string remote_address = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_remote_address()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->remote_address().data(), static_cast<int>(this->remote_address().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.notifier.Session.remote_address"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string username = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->username().data(), static_cast<int>(this->username().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.notifier.Session.username"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .aspia.proto.auth.SessionType session_type = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_session_type(static_cast< ::aspia::proto::auth::SessionType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.notifier.Session)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.notifier.Session)
  return false;
#undef DO_
}

void Session::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.notifier.Session)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string uuid = 1;
  if (this->uuid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->uuid().data(), static_cast<int>(this->uuid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.notifier.Session.uuid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->uuid(), output);
  }

  // string remote_address = 2;
  if (this->remote_address().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->remote_address().data(), static_cast<int>(this->remote_address().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.notifier.Session.remote_address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->remote_address(), output);
  }

  // string username = 3;
  if (this->username().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->username().data(), static_cast<int>(this->username().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.notifier.Session.username");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->username(), output);
  }

  // .aspia.proto.auth.SessionType session_type = 4;
  if (this->session_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->session_type(), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.notifier.Session)
}

size_t Session::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.notifier.Session)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // string uuid = 1;
  if (this->uuid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->uuid());
  }

  // string remote_address = 2;
  if (this->remote_address().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->remote_address());
  }

  // string username = 3;
  if (this->username().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->username());
  }

  // .aspia.proto.auth.SessionType session_type = 4;
  if (this->session_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Session::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Session*>(&from));
}

void Session::MergeFrom(const Session& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.notifier.Session)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.uuid().size() > 0) {

    uuid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uuid_);
  }
  if (from.remote_address().size() > 0) {

    remote_address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.remote_address_);
  }
  if (from.username().size() > 0) {

    username_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.username_);
  }
  if (from.session_type() != 0) {
    set_session_type(from.session_type());
  }
}

void Session::CopyFrom(const Session& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.notifier.Session)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Session::IsInitialized() const {
  return true;
}

void Session::Swap(Session* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Session::InternalSwap(Session* other) {
  using std::swap;
  uuid_.Swap(&other->uuid_);
  remote_address_.Swap(&other->remote_address_);
  username_.Swap(&other->username_);
  swap(session_type_, other->session_type_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Session::GetTypeName() const {
  return "aspia.proto.notifier.Session";
}


// ===================================================================

void SessionClose::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SessionClose::kUuidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SessionClose::SessionClose()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_notifier_2eproto::InitDefaultsSessionClose();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.notifier.SessionClose)
}
SessionClose::SessionClose(const SessionClose& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.uuid().size() > 0) {
    uuid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uuid_);
  }
  // @@protoc_insertion_point(copy_constructor:aspia.proto.notifier.SessionClose)
}

void SessionClose::SharedCtor() {
  uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

SessionClose::~SessionClose() {
  // @@protoc_insertion_point(destructor:aspia.proto.notifier.SessionClose)
  SharedDtor();
}

void SessionClose::SharedDtor() {
  uuid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void SessionClose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SessionClose& SessionClose::default_instance() {
  ::protobuf_notifier_2eproto::InitDefaultsSessionClose();
  return *internal_default_instance();
}

SessionClose* SessionClose::New(::google::protobuf::Arena* arena) const {
  SessionClose* n = new SessionClose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SessionClose::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.notifier.SessionClose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

bool SessionClose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.notifier.SessionClose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string uuid = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->uuid().data(), static_cast<int>(this->uuid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.notifier.SessionClose.uuid"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.notifier.SessionClose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.notifier.SessionClose)
  return false;
#undef DO_
}

void SessionClose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.notifier.SessionClose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string uuid = 1;
  if (this->uuid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->uuid().data(), static_cast<int>(this->uuid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.notifier.SessionClose.uuid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->uuid(), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.notifier.SessionClose)
}

size_t SessionClose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.notifier.SessionClose)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // string uuid = 1;
  if (this->uuid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->uuid());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SessionClose::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SessionClose*>(&from));
}

void SessionClose::MergeFrom(const SessionClose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.notifier.SessionClose)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.uuid().size() > 0) {

    uuid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uuid_);
  }
}

void SessionClose::CopyFrom(const SessionClose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.notifier.SessionClose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionClose::IsInitialized() const {
  return true;
}

void SessionClose::Swap(SessionClose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SessionClose::InternalSwap(SessionClose* other) {
  using std::swap;
  uuid_.Swap(&other->uuid_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string SessionClose::GetTypeName() const {
  return "aspia.proto.notifier.SessionClose";
}


// ===================================================================

void KillSession::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int KillSession::kUuidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

KillSession::KillSession()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_notifier_2eproto::InitDefaultsKillSession();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.notifier.KillSession)
}
KillSession::KillSession(const KillSession& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.uuid().size() > 0) {
    uuid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uuid_);
  }
  // @@protoc_insertion_point(copy_constructor:aspia.proto.notifier.KillSession)
}

void KillSession::SharedCtor() {
  uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

KillSession::~KillSession() {
  // @@protoc_insertion_point(destructor:aspia.proto.notifier.KillSession)
  SharedDtor();
}

void KillSession::SharedDtor() {
  uuid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void KillSession::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const KillSession& KillSession::default_instance() {
  ::protobuf_notifier_2eproto::InitDefaultsKillSession();
  return *internal_default_instance();
}

KillSession* KillSession::New(::google::protobuf::Arena* arena) const {
  KillSession* n = new KillSession;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void KillSession::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.notifier.KillSession)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

bool KillSession::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.notifier.KillSession)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string uuid = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->uuid().data(), static_cast<int>(this->uuid().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "aspia.proto.notifier.KillSession.uuid"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.notifier.KillSession)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.notifier.KillSession)
  return false;
#undef DO_
}

void KillSession::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.notifier.KillSession)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string uuid = 1;
  if (this->uuid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->uuid().data(), static_cast<int>(this->uuid().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "aspia.proto.notifier.KillSession.uuid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->uuid(), output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.notifier.KillSession)
}

size_t KillSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.notifier.KillSession)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // string uuid = 1;
  if (this->uuid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->uuid());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KillSession::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const KillSession*>(&from));
}

void KillSession::MergeFrom(const KillSession& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.notifier.KillSession)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.uuid().size() > 0) {

    uuid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uuid_);
  }
}

void KillSession::CopyFrom(const KillSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.notifier.KillSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KillSession::IsInitialized() const {
  return true;
}

void KillSession::Swap(KillSession* other) {
  if (other == this) return;
  InternalSwap(other);
}
void KillSession::InternalSwap(KillSession* other) {
  using std::swap;
  uuid_.Swap(&other->uuid_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string KillSession::GetTypeName() const {
  return "aspia.proto.notifier.KillSession";
}


// ===================================================================

void NotifierToService::InitAsDefaultInstance() {
  ::aspia::proto::notifier::_NotifierToService_default_instance_._instance.get_mutable()->kill_session_ = const_cast< ::aspia::proto::notifier::KillSession*>(
      ::aspia::proto::notifier::KillSession::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NotifierToService::kKillSessionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NotifierToService::NotifierToService()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_notifier_2eproto::InitDefaultsNotifierToService();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.notifier.NotifierToService)
}
NotifierToService::NotifierToService(const NotifierToService& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_kill_session()) {
    kill_session_ = new ::aspia::proto::notifier::KillSession(*from.kill_session_);
  } else {
    kill_session_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:aspia.proto.notifier.NotifierToService)
}

void NotifierToService::SharedCtor() {
  kill_session_ = NULL;
  _cached_size_ = 0;
}

NotifierToService::~NotifierToService() {
  // @@protoc_insertion_point(destructor:aspia.proto.notifier.NotifierToService)
  SharedDtor();
}

void NotifierToService::SharedDtor() {
  if (this != internal_default_instance()) delete kill_session_;
}

void NotifierToService::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifierToService& NotifierToService::default_instance() {
  ::protobuf_notifier_2eproto::InitDefaultsNotifierToService();
  return *internal_default_instance();
}

NotifierToService* NotifierToService::New(::google::protobuf::Arena* arena) const {
  NotifierToService* n = new NotifierToService;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NotifierToService::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.notifier.NotifierToService)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && kill_session_ != NULL) {
    delete kill_session_;
  }
  kill_session_ = NULL;
  _internal_metadata_.Clear();
}

bool NotifierToService::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.notifier.NotifierToService)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .aspia.proto.notifier.KillSession kill_session = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_kill_session()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.notifier.NotifierToService)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.notifier.NotifierToService)
  return false;
#undef DO_
}

void NotifierToService::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.notifier.NotifierToService)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .aspia.proto.notifier.KillSession kill_session = 1;
  if (this->has_kill_session()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->kill_session_, output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.notifier.NotifierToService)
}

size_t NotifierToService::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.notifier.NotifierToService)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // .aspia.proto.notifier.KillSession kill_session = 1;
  if (this->has_kill_session()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->kill_session_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifierToService::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifierToService*>(&from));
}

void NotifierToService::MergeFrom(const NotifierToService& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.notifier.NotifierToService)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_kill_session()) {
    mutable_kill_session()->::aspia::proto::notifier::KillSession::MergeFrom(from.kill_session());
  }
}

void NotifierToService::CopyFrom(const NotifierToService& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.notifier.NotifierToService)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifierToService::IsInitialized() const {
  return true;
}

void NotifierToService::Swap(NotifierToService* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NotifierToService::InternalSwap(NotifierToService* other) {
  using std::swap;
  swap(kill_session_, other->kill_session_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string NotifierToService::GetTypeName() const {
  return "aspia.proto.notifier.NotifierToService";
}


// ===================================================================

void ServiceToNotifier::InitAsDefaultInstance() {
  ::aspia::proto::notifier::_ServiceToNotifier_default_instance_._instance.get_mutable()->session_ = const_cast< ::aspia::proto::notifier::Session*>(
      ::aspia::proto::notifier::Session::internal_default_instance());
  ::aspia::proto::notifier::_ServiceToNotifier_default_instance_._instance.get_mutable()->session_close_ = const_cast< ::aspia::proto::notifier::SessionClose*>(
      ::aspia::proto::notifier::SessionClose::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ServiceToNotifier::kSessionFieldNumber;
const int ServiceToNotifier::kSessionCloseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ServiceToNotifier::ServiceToNotifier()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_notifier_2eproto::InitDefaultsServiceToNotifier();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:aspia.proto.notifier.ServiceToNotifier)
}
ServiceToNotifier::ServiceToNotifier(const ServiceToNotifier& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_session()) {
    session_ = new ::aspia::proto::notifier::Session(*from.session_);
  } else {
    session_ = NULL;
  }
  if (from.has_session_close()) {
    session_close_ = new ::aspia::proto::notifier::SessionClose(*from.session_close_);
  } else {
    session_close_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:aspia.proto.notifier.ServiceToNotifier)
}

void ServiceToNotifier::SharedCtor() {
  ::memset(&session_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&session_close_) -
      reinterpret_cast<char*>(&session_)) + sizeof(session_close_));
  _cached_size_ = 0;
}

ServiceToNotifier::~ServiceToNotifier() {
  // @@protoc_insertion_point(destructor:aspia.proto.notifier.ServiceToNotifier)
  SharedDtor();
}

void ServiceToNotifier::SharedDtor() {
  if (this != internal_default_instance()) delete session_;
  if (this != internal_default_instance()) delete session_close_;
}

void ServiceToNotifier::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServiceToNotifier& ServiceToNotifier::default_instance() {
  ::protobuf_notifier_2eproto::InitDefaultsServiceToNotifier();
  return *internal_default_instance();
}

ServiceToNotifier* ServiceToNotifier::New(::google::protobuf::Arena* arena) const {
  ServiceToNotifier* n = new ServiceToNotifier;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ServiceToNotifier::Clear() {
// @@protoc_insertion_point(message_clear_start:aspia.proto.notifier.ServiceToNotifier)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && session_ != NULL) {
    delete session_;
  }
  session_ = NULL;
  if (GetArenaNoVirtual() == NULL && session_close_ != NULL) {
    delete session_close_;
  }
  session_close_ = NULL;
  _internal_metadata_.Clear();
}

bool ServiceToNotifier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:aspia.proto.notifier.ServiceToNotifier)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .aspia.proto.notifier.Session session = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_session()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .aspia.proto.notifier.SessionClose session_close = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_session_close()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:aspia.proto.notifier.ServiceToNotifier)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:aspia.proto.notifier.ServiceToNotifier)
  return false;
#undef DO_
}

void ServiceToNotifier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:aspia.proto.notifier.ServiceToNotifier)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .aspia.proto.notifier.Session session = 1;
  if (this->has_session()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->session_, output);
  }

  // .aspia.proto.notifier.SessionClose session_close = 2;
  if (this->has_session_close()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->session_close_, output);
  }

  output->WriteRaw((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).data(),
                   static_cast<int>((::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size()));
  // @@protoc_insertion_point(serialize_end:aspia.proto.notifier.ServiceToNotifier)
}

size_t ServiceToNotifier::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:aspia.proto.notifier.ServiceToNotifier)
  size_t total_size = 0;

  total_size += (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()).size();

  // .aspia.proto.notifier.Session session = 1;
  if (this->has_session()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->session_);
  }

  // .aspia.proto.notifier.SessionClose session_close = 2;
  if (this->has_session_close()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->session_close_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServiceToNotifier::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServiceToNotifier*>(&from));
}

void ServiceToNotifier::MergeFrom(const ServiceToNotifier& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:aspia.proto.notifier.ServiceToNotifier)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_session()) {
    mutable_session()->::aspia::proto::notifier::Session::MergeFrom(from.session());
  }
  if (from.has_session_close()) {
    mutable_session_close()->::aspia::proto::notifier::SessionClose::MergeFrom(from.session_close());
  }
}

void ServiceToNotifier::CopyFrom(const ServiceToNotifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aspia.proto.notifier.ServiceToNotifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceToNotifier::IsInitialized() const {
  return true;
}

void ServiceToNotifier::Swap(ServiceToNotifier* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ServiceToNotifier::InternalSwap(ServiceToNotifier* other) {
  using std::swap;
  swap(session_, other->session_);
  swap(session_close_, other->session_close_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ServiceToNotifier::GetTypeName() const {
  return "aspia.proto.notifier.ServiceToNotifier";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace notifier
}  // namespace proto
}  // namespace aspia

// @@protoc_insertion_point(global_scope)

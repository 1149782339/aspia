// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: notifier.proto

#ifndef PROTOBUF_INCLUDED_notifier_2eproto
#define PROTOBUF_INCLUDED_notifier_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "authorization.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_notifier_2eproto 

namespace protobuf_notifier_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_notifier_2eproto
namespace aspia {
namespace proto {
namespace notifier {
class KillSession;
class KillSessionDefaultTypeInternal;
extern KillSessionDefaultTypeInternal _KillSession_default_instance_;
class NotifierToService;
class NotifierToServiceDefaultTypeInternal;
extern NotifierToServiceDefaultTypeInternal _NotifierToService_default_instance_;
class ServiceToNotifier;
class ServiceToNotifierDefaultTypeInternal;
extern ServiceToNotifierDefaultTypeInternal _ServiceToNotifier_default_instance_;
class Session;
class SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
class SessionClose;
class SessionCloseDefaultTypeInternal;
extern SessionCloseDefaultTypeInternal _SessionClose_default_instance_;
}  // namespace notifier
}  // namespace proto
}  // namespace aspia
namespace google {
namespace protobuf {
template<> ::aspia::proto::notifier::KillSession* Arena::CreateMaybeMessage<::aspia::proto::notifier::KillSession>(Arena*);
template<> ::aspia::proto::notifier::NotifierToService* Arena::CreateMaybeMessage<::aspia::proto::notifier::NotifierToService>(Arena*);
template<> ::aspia::proto::notifier::ServiceToNotifier* Arena::CreateMaybeMessage<::aspia::proto::notifier::ServiceToNotifier>(Arena*);
template<> ::aspia::proto::notifier::Session* Arena::CreateMaybeMessage<::aspia::proto::notifier::Session>(Arena*);
template<> ::aspia::proto::notifier::SessionClose* Arena::CreateMaybeMessage<::aspia::proto::notifier::SessionClose>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace aspia {
namespace proto {
namespace notifier {

// ===================================================================

class Session : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.notifier.Session) */ {
 public:
  Session();
  virtual ~Session();

  Session(const Session& from);

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Session(Session&& from) noexcept
    : Session() {
    *this = ::std::move(from);
  }

  inline Session& operator=(Session&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Session& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Session* internal_default_instance() {
    return reinterpret_cast<const Session*>(
               &_Session_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Session* other);
  friend void swap(Session& a, Session& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Session* New() const final {
    return CreateMaybeMessage<Session>(NULL);
  }

  Session* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Session>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Session& from);
  void MergeFrom(const Session& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Session* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uuid = 1;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // string remote_address = 2;
  void clear_remote_address();
  static const int kRemoteAddressFieldNumber = 2;
  const ::std::string& remote_address() const;
  void set_remote_address(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_address(::std::string&& value);
  #endif
  void set_remote_address(const char* value);
  void set_remote_address(const char* value, size_t size);
  ::std::string* mutable_remote_address();
  ::std::string* release_remote_address();
  void set_allocated_remote_address(::std::string* remote_address);

  // string username = 3;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // .aspia.proto.auth.SessionType session_type = 4;
  void clear_session_type();
  static const int kSessionTypeFieldNumber = 4;
  ::aspia::proto::auth::SessionType session_type() const;
  void set_session_type(::aspia::proto::auth::SessionType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.notifier.Session)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr remote_address_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  int session_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_notifier_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SessionClose : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.notifier.SessionClose) */ {
 public:
  SessionClose();
  virtual ~SessionClose();

  SessionClose(const SessionClose& from);

  inline SessionClose& operator=(const SessionClose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SessionClose(SessionClose&& from) noexcept
    : SessionClose() {
    *this = ::std::move(from);
  }

  inline SessionClose& operator=(SessionClose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SessionClose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionClose* internal_default_instance() {
    return reinterpret_cast<const SessionClose*>(
               &_SessionClose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SessionClose* other);
  friend void swap(SessionClose& a, SessionClose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SessionClose* New() const final {
    return CreateMaybeMessage<SessionClose>(NULL);
  }

  SessionClose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SessionClose>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SessionClose& from);
  void MergeFrom(const SessionClose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionClose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uuid = 1;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:aspia.proto.notifier.SessionClose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_notifier_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KillSession : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.notifier.KillSession) */ {
 public:
  KillSession();
  virtual ~KillSession();

  KillSession(const KillSession& from);

  inline KillSession& operator=(const KillSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KillSession(KillSession&& from) noexcept
    : KillSession() {
    *this = ::std::move(from);
  }

  inline KillSession& operator=(KillSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const KillSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KillSession* internal_default_instance() {
    return reinterpret_cast<const KillSession*>(
               &_KillSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(KillSession* other);
  friend void swap(KillSession& a, KillSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KillSession* New() const final {
    return CreateMaybeMessage<KillSession>(NULL);
  }

  KillSession* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KillSession>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const KillSession& from);
  void MergeFrom(const KillSession& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KillSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uuid = 1;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:aspia.proto.notifier.KillSession)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_notifier_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NotifierToService : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.notifier.NotifierToService) */ {
 public:
  NotifierToService();
  virtual ~NotifierToService();

  NotifierToService(const NotifierToService& from);

  inline NotifierToService& operator=(const NotifierToService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NotifierToService(NotifierToService&& from) noexcept
    : NotifierToService() {
    *this = ::std::move(from);
  }

  inline NotifierToService& operator=(NotifierToService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const NotifierToService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NotifierToService* internal_default_instance() {
    return reinterpret_cast<const NotifierToService*>(
               &_NotifierToService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(NotifierToService* other);
  friend void swap(NotifierToService& a, NotifierToService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NotifierToService* New() const final {
    return CreateMaybeMessage<NotifierToService>(NULL);
  }

  NotifierToService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NotifierToService>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const NotifierToService& from);
  void MergeFrom(const NotifierToService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifierToService* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .aspia.proto.notifier.KillSession kill_session = 1;
  bool has_kill_session() const;
  void clear_kill_session();
  static const int kKillSessionFieldNumber = 1;
  private:
  const ::aspia::proto::notifier::KillSession& _internal_kill_session() const;
  public:
  const ::aspia::proto::notifier::KillSession& kill_session() const;
  ::aspia::proto::notifier::KillSession* release_kill_session();
  ::aspia::proto::notifier::KillSession* mutable_kill_session();
  void set_allocated_kill_session(::aspia::proto::notifier::KillSession* kill_session);

  // @@protoc_insertion_point(class_scope:aspia.proto.notifier.NotifierToService)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::aspia::proto::notifier::KillSession* kill_session_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_notifier_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServiceToNotifier : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.notifier.ServiceToNotifier) */ {
 public:
  ServiceToNotifier();
  virtual ~ServiceToNotifier();

  ServiceToNotifier(const ServiceToNotifier& from);

  inline ServiceToNotifier& operator=(const ServiceToNotifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServiceToNotifier(ServiceToNotifier&& from) noexcept
    : ServiceToNotifier() {
    *this = ::std::move(from);
  }

  inline ServiceToNotifier& operator=(ServiceToNotifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ServiceToNotifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceToNotifier* internal_default_instance() {
    return reinterpret_cast<const ServiceToNotifier*>(
               &_ServiceToNotifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ServiceToNotifier* other);
  friend void swap(ServiceToNotifier& a, ServiceToNotifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServiceToNotifier* New() const final {
    return CreateMaybeMessage<ServiceToNotifier>(NULL);
  }

  ServiceToNotifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServiceToNotifier>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ServiceToNotifier& from);
  void MergeFrom(const ServiceToNotifier& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServiceToNotifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .aspia.proto.notifier.Session session = 1;
  bool has_session() const;
  void clear_session();
  static const int kSessionFieldNumber = 1;
  private:
  const ::aspia::proto::notifier::Session& _internal_session() const;
  public:
  const ::aspia::proto::notifier::Session& session() const;
  ::aspia::proto::notifier::Session* release_session();
  ::aspia::proto::notifier::Session* mutable_session();
  void set_allocated_session(::aspia::proto::notifier::Session* session);

  // .aspia.proto.notifier.SessionClose session_close = 2;
  bool has_session_close() const;
  void clear_session_close();
  static const int kSessionCloseFieldNumber = 2;
  private:
  const ::aspia::proto::notifier::SessionClose& _internal_session_close() const;
  public:
  const ::aspia::proto::notifier::SessionClose& session_close() const;
  ::aspia::proto::notifier::SessionClose* release_session_close();
  ::aspia::proto::notifier::SessionClose* mutable_session_close();
  void set_allocated_session_close(::aspia::proto::notifier::SessionClose* session_close);

  // @@protoc_insertion_point(class_scope:aspia.proto.notifier.ServiceToNotifier)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::aspia::proto::notifier::Session* session_;
  ::aspia::proto::notifier::SessionClose* session_close_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_notifier_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Session

// string uuid = 1;
inline void Session::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Session::uuid() const {
  // @@protoc_insertion_point(field_get:aspia.proto.notifier.Session.uuid)
  return uuid_.GetNoArena();
}
inline void Session::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.notifier.Session.uuid)
}
#if LANG_CXX11
inline void Session::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.notifier.Session.uuid)
}
#endif
inline void Session::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.notifier.Session.uuid)
}
inline void Session::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.notifier.Session.uuid)
}
inline ::std::string* Session::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.notifier.Session.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_uuid() {
  // @@protoc_insertion_point(field_release:aspia.proto.notifier.Session.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.notifier.Session.uuid)
}

// string remote_address = 2;
inline void Session::clear_remote_address() {
  remote_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Session::remote_address() const {
  // @@protoc_insertion_point(field_get:aspia.proto.notifier.Session.remote_address)
  return remote_address_.GetNoArena();
}
inline void Session::set_remote_address(const ::std::string& value) {
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.notifier.Session.remote_address)
}
#if LANG_CXX11
inline void Session::set_remote_address(::std::string&& value) {
  
  remote_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.notifier.Session.remote_address)
}
#endif
inline void Session::set_remote_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.notifier.Session.remote_address)
}
inline void Session::set_remote_address(const char* value, size_t size) {
  
  remote_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.notifier.Session.remote_address)
}
inline ::std::string* Session::mutable_remote_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.notifier.Session.remote_address)
  return remote_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_remote_address() {
  // @@protoc_insertion_point(field_release:aspia.proto.notifier.Session.remote_address)
  
  return remote_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_remote_address(::std::string* remote_address) {
  if (remote_address != NULL) {
    
  } else {
    
  }
  remote_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_address);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.notifier.Session.remote_address)
}

// string username = 3;
inline void Session::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Session::username() const {
  // @@protoc_insertion_point(field_get:aspia.proto.notifier.Session.username)
  return username_.GetNoArena();
}
inline void Session::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.notifier.Session.username)
}
#if LANG_CXX11
inline void Session::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.notifier.Session.username)
}
#endif
inline void Session::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.notifier.Session.username)
}
inline void Session::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.notifier.Session.username)
}
inline ::std::string* Session::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.notifier.Session.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_username() {
  // @@protoc_insertion_point(field_release:aspia.proto.notifier.Session.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.notifier.Session.username)
}

// .aspia.proto.auth.SessionType session_type = 4;
inline void Session::clear_session_type() {
  session_type_ = 0;
}
inline ::aspia::proto::auth::SessionType Session::session_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.notifier.Session.session_type)
  return static_cast< ::aspia::proto::auth::SessionType >(session_type_);
}
inline void Session::set_session_type(::aspia::proto::auth::SessionType value) {
  
  session_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.notifier.Session.session_type)
}

// -------------------------------------------------------------------

// SessionClose

// string uuid = 1;
inline void SessionClose::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionClose::uuid() const {
  // @@protoc_insertion_point(field_get:aspia.proto.notifier.SessionClose.uuid)
  return uuid_.GetNoArena();
}
inline void SessionClose::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.notifier.SessionClose.uuid)
}
#if LANG_CXX11
inline void SessionClose::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.notifier.SessionClose.uuid)
}
#endif
inline void SessionClose::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.notifier.SessionClose.uuid)
}
inline void SessionClose::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.notifier.SessionClose.uuid)
}
inline ::std::string* SessionClose::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.notifier.SessionClose.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionClose::release_uuid() {
  // @@protoc_insertion_point(field_release:aspia.proto.notifier.SessionClose.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionClose::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.notifier.SessionClose.uuid)
}

// -------------------------------------------------------------------

// KillSession

// string uuid = 1;
inline void KillSession::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KillSession::uuid() const {
  // @@protoc_insertion_point(field_get:aspia.proto.notifier.KillSession.uuid)
  return uuid_.GetNoArena();
}
inline void KillSession::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.notifier.KillSession.uuid)
}
#if LANG_CXX11
inline void KillSession::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.notifier.KillSession.uuid)
}
#endif
inline void KillSession::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.notifier.KillSession.uuid)
}
inline void KillSession::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.notifier.KillSession.uuid)
}
inline ::std::string* KillSession::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.notifier.KillSession.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KillSession::release_uuid() {
  // @@protoc_insertion_point(field_release:aspia.proto.notifier.KillSession.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KillSession::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.notifier.KillSession.uuid)
}

// -------------------------------------------------------------------

// NotifierToService

// .aspia.proto.notifier.KillSession kill_session = 1;
inline bool NotifierToService::has_kill_session() const {
  return this != internal_default_instance() && kill_session_ != NULL;
}
inline void NotifierToService::clear_kill_session() {
  if (GetArenaNoVirtual() == NULL && kill_session_ != NULL) {
    delete kill_session_;
  }
  kill_session_ = NULL;
}
inline const ::aspia::proto::notifier::KillSession& NotifierToService::_internal_kill_session() const {
  return *kill_session_;
}
inline const ::aspia::proto::notifier::KillSession& NotifierToService::kill_session() const {
  const ::aspia::proto::notifier::KillSession* p = kill_session_;
  // @@protoc_insertion_point(field_get:aspia.proto.notifier.NotifierToService.kill_session)
  return p != NULL ? *p : *reinterpret_cast<const ::aspia::proto::notifier::KillSession*>(
      &::aspia::proto::notifier::_KillSession_default_instance_);
}
inline ::aspia::proto::notifier::KillSession* NotifierToService::release_kill_session() {
  // @@protoc_insertion_point(field_release:aspia.proto.notifier.NotifierToService.kill_session)
  
  ::aspia::proto::notifier::KillSession* temp = kill_session_;
  kill_session_ = NULL;
  return temp;
}
inline ::aspia::proto::notifier::KillSession* NotifierToService::mutable_kill_session() {
  
  if (kill_session_ == NULL) {
    auto* p = CreateMaybeMessage<::aspia::proto::notifier::KillSession>(GetArenaNoVirtual());
    kill_session_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.notifier.NotifierToService.kill_session)
  return kill_session_;
}
inline void NotifierToService::set_allocated_kill_session(::aspia::proto::notifier::KillSession* kill_session) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kill_session_;
  }
  if (kill_session) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kill_session = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kill_session, submessage_arena);
    }
    
  } else {
    
  }
  kill_session_ = kill_session;
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.notifier.NotifierToService.kill_session)
}

// -------------------------------------------------------------------

// ServiceToNotifier

// .aspia.proto.notifier.Session session = 1;
inline bool ServiceToNotifier::has_session() const {
  return this != internal_default_instance() && session_ != NULL;
}
inline void ServiceToNotifier::clear_session() {
  if (GetArenaNoVirtual() == NULL && session_ != NULL) {
    delete session_;
  }
  session_ = NULL;
}
inline const ::aspia::proto::notifier::Session& ServiceToNotifier::_internal_session() const {
  return *session_;
}
inline const ::aspia::proto::notifier::Session& ServiceToNotifier::session() const {
  const ::aspia::proto::notifier::Session* p = session_;
  // @@protoc_insertion_point(field_get:aspia.proto.notifier.ServiceToNotifier.session)
  return p != NULL ? *p : *reinterpret_cast<const ::aspia::proto::notifier::Session*>(
      &::aspia::proto::notifier::_Session_default_instance_);
}
inline ::aspia::proto::notifier::Session* ServiceToNotifier::release_session() {
  // @@protoc_insertion_point(field_release:aspia.proto.notifier.ServiceToNotifier.session)
  
  ::aspia::proto::notifier::Session* temp = session_;
  session_ = NULL;
  return temp;
}
inline ::aspia::proto::notifier::Session* ServiceToNotifier::mutable_session() {
  
  if (session_ == NULL) {
    auto* p = CreateMaybeMessage<::aspia::proto::notifier::Session>(GetArenaNoVirtual());
    session_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.notifier.ServiceToNotifier.session)
  return session_;
}
inline void ServiceToNotifier::set_allocated_session(::aspia::proto::notifier::Session* session) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete session_;
  }
  if (session) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      session = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, session, submessage_arena);
    }
    
  } else {
    
  }
  session_ = session;
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.notifier.ServiceToNotifier.session)
}

// .aspia.proto.notifier.SessionClose session_close = 2;
inline bool ServiceToNotifier::has_session_close() const {
  return this != internal_default_instance() && session_close_ != NULL;
}
inline void ServiceToNotifier::clear_session_close() {
  if (GetArenaNoVirtual() == NULL && session_close_ != NULL) {
    delete session_close_;
  }
  session_close_ = NULL;
}
inline const ::aspia::proto::notifier::SessionClose& ServiceToNotifier::_internal_session_close() const {
  return *session_close_;
}
inline const ::aspia::proto::notifier::SessionClose& ServiceToNotifier::session_close() const {
  const ::aspia::proto::notifier::SessionClose* p = session_close_;
  // @@protoc_insertion_point(field_get:aspia.proto.notifier.ServiceToNotifier.session_close)
  return p != NULL ? *p : *reinterpret_cast<const ::aspia::proto::notifier::SessionClose*>(
      &::aspia::proto::notifier::_SessionClose_default_instance_);
}
inline ::aspia::proto::notifier::SessionClose* ServiceToNotifier::release_session_close() {
  // @@protoc_insertion_point(field_release:aspia.proto.notifier.ServiceToNotifier.session_close)
  
  ::aspia::proto::notifier::SessionClose* temp = session_close_;
  session_close_ = NULL;
  return temp;
}
inline ::aspia::proto::notifier::SessionClose* ServiceToNotifier::mutable_session_close() {
  
  if (session_close_ == NULL) {
    auto* p = CreateMaybeMessage<::aspia::proto::notifier::SessionClose>(GetArenaNoVirtual());
    session_close_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aspia.proto.notifier.ServiceToNotifier.session_close)
  return session_close_;
}
inline void ServiceToNotifier::set_allocated_session_close(::aspia::proto::notifier::SessionClose* session_close) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete session_close_;
  }
  if (session_close) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      session_close = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, session_close, submessage_arena);
    }
    
  } else {
    
  }
  session_close_ = session_close;
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.notifier.ServiceToNotifier.session_close)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace notifier
}  // namespace proto
}  // namespace aspia

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_notifier_2eproto

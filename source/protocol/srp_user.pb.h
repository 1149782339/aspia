// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: srp_user.proto

#ifndef PROTOBUF_INCLUDED_srp_5fuser_2eproto
#define PROTOBUF_INCLUDED_srp_5fuser_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_srp_5fuser_2eproto 

namespace protobuf_srp_5fuser_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_srp_5fuser_2eproto
namespace aspia {
namespace proto {
class SrpUser;
class SrpUserDefaultTypeInternal;
extern SrpUserDefaultTypeInternal _SrpUser_default_instance_;
class SrpUserList;
class SrpUserListDefaultTypeInternal;
extern SrpUserListDefaultTypeInternal _SrpUserList_default_instance_;
}  // namespace proto
}  // namespace aspia
namespace google {
namespace protobuf {
template<> ::aspia::proto::SrpUser* Arena::CreateMaybeMessage<::aspia::proto::SrpUser>(Arena*);
template<> ::aspia::proto::SrpUserList* Arena::CreateMaybeMessage<::aspia::proto::SrpUserList>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace aspia {
namespace proto {

enum SrpUser_Flags {
  SrpUser_Flags_NO_FLAGS = 0,
  SrpUser_Flags_ENABLED = 1,
  SrpUser_Flags_SrpUser_Flags_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SrpUser_Flags_SrpUser_Flags_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SrpUser_Flags_IsValid(int value);
const SrpUser_Flags SrpUser_Flags_Flags_MIN = SrpUser_Flags_NO_FLAGS;
const SrpUser_Flags SrpUser_Flags_Flags_MAX = SrpUser_Flags_ENABLED;
const int SrpUser_Flags_Flags_ARRAYSIZE = SrpUser_Flags_Flags_MAX + 1;

// ===================================================================

class SrpUser : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.SrpUser) */ {
 public:
  SrpUser();
  virtual ~SrpUser();

  SrpUser(const SrpUser& from);

  inline SrpUser& operator=(const SrpUser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SrpUser(SrpUser&& from) noexcept
    : SrpUser() {
    *this = ::std::move(from);
  }

  inline SrpUser& operator=(SrpUser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SrpUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SrpUser* internal_default_instance() {
    return reinterpret_cast<const SrpUser*>(
               &_SrpUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SrpUser* other);
  friend void swap(SrpUser& a, SrpUser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SrpUser* New() const final {
    return CreateMaybeMessage<SrpUser>(NULL);
  }

  SrpUser* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SrpUser>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SrpUser& from);
  void MergeFrom(const SrpUser& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SrpUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SrpUser_Flags Flags;
  static const Flags NO_FLAGS =
    SrpUser_Flags_NO_FLAGS;
  static const Flags ENABLED =
    SrpUser_Flags_ENABLED;
  static inline bool Flags_IsValid(int value) {
    return SrpUser_Flags_IsValid(value);
  }
  static const Flags Flags_MIN =
    SrpUser_Flags_Flags_MIN;
  static const Flags Flags_MAX =
    SrpUser_Flags_Flags_MAX;
  static const int Flags_ARRAYSIZE =
    SrpUser_Flags_Flags_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // bytes salt = 2;
  void clear_salt();
  static const int kSaltFieldNumber = 2;
  const ::std::string& salt() const;
  void set_salt(const ::std::string& value);
  #if LANG_CXX11
  void set_salt(::std::string&& value);
  #endif
  void set_salt(const char* value);
  void set_salt(const void* value, size_t size);
  ::std::string* mutable_salt();
  ::std::string* release_salt();
  void set_allocated_salt(::std::string* salt);

  // bytes verifier = 3;
  void clear_verifier();
  static const int kVerifierFieldNumber = 3;
  const ::std::string& verifier() const;
  void set_verifier(const ::std::string& value);
  #if LANG_CXX11
  void set_verifier(::std::string&& value);
  #endif
  void set_verifier(const char* value);
  void set_verifier(const void* value, size_t size);
  ::std::string* mutable_verifier();
  ::std::string* release_verifier();
  void set_allocated_verifier(::std::string* verifier);

  // bytes number = 4;
  void clear_number();
  static const int kNumberFieldNumber = 4;
  const ::std::string& number() const;
  void set_number(const ::std::string& value);
  #if LANG_CXX11
  void set_number(::std::string&& value);
  #endif
  void set_number(const char* value);
  void set_number(const void* value, size_t size);
  ::std::string* mutable_number();
  ::std::string* release_number();
  void set_allocated_number(::std::string* number);

  // bytes generator = 5;
  void clear_generator();
  static const int kGeneratorFieldNumber = 5;
  const ::std::string& generator() const;
  void set_generator(const ::std::string& value);
  #if LANG_CXX11
  void set_generator(::std::string&& value);
  #endif
  void set_generator(const char* value);
  void set_generator(const void* value, size_t size);
  ::std::string* mutable_generator();
  ::std::string* release_generator();
  void set_allocated_generator(::std::string* generator);

  // uint32 sessions = 6;
  void clear_sessions();
  static const int kSessionsFieldNumber = 6;
  ::google::protobuf::uint32 sessions() const;
  void set_sessions(::google::protobuf::uint32 value);

  // uint32 flags = 7;
  void clear_flags();
  static const int kFlagsFieldNumber = 7;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.proto.SrpUser)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr salt_;
  ::google::protobuf::internal::ArenaStringPtr verifier_;
  ::google::protobuf::internal::ArenaStringPtr number_;
  ::google::protobuf::internal::ArenaStringPtr generator_;
  ::google::protobuf::uint32 sessions_;
  ::google::protobuf::uint32 flags_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_srp_5fuser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SrpUserList : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.SrpUserList) */ {
 public:
  SrpUserList();
  virtual ~SrpUserList();

  SrpUserList(const SrpUserList& from);

  inline SrpUserList& operator=(const SrpUserList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SrpUserList(SrpUserList&& from) noexcept
    : SrpUserList() {
    *this = ::std::move(from);
  }

  inline SrpUserList& operator=(SrpUserList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SrpUserList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SrpUserList* internal_default_instance() {
    return reinterpret_cast<const SrpUserList*>(
               &_SrpUserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SrpUserList* other);
  friend void swap(SrpUserList& a, SrpUserList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SrpUserList* New() const final {
    return CreateMaybeMessage<SrpUserList>(NULL);
  }

  SrpUserList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SrpUserList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SrpUserList& from);
  void MergeFrom(const SrpUserList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SrpUserList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.SrpUser user = 2;
  int user_size() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  ::aspia::proto::SrpUser* mutable_user(int index);
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::SrpUser >*
      mutable_user();
  const ::aspia::proto::SrpUser& user(int index) const;
  ::aspia::proto::SrpUser* add_user();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::SrpUser >&
      user() const;

  // bytes seed_key = 1;
  void clear_seed_key();
  static const int kSeedKeyFieldNumber = 1;
  const ::std::string& seed_key() const;
  void set_seed_key(const ::std::string& value);
  #if LANG_CXX11
  void set_seed_key(::std::string&& value);
  #endif
  void set_seed_key(const char* value);
  void set_seed_key(const void* value, size_t size);
  ::std::string* mutable_seed_key();
  ::std::string* release_seed_key();
  void set_allocated_seed_key(::std::string* seed_key);

  // @@protoc_insertion_point(class_scope:aspia.proto.SrpUserList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::SrpUser > user_;
  ::google::protobuf::internal::ArenaStringPtr seed_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_srp_5fuser_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SrpUser

// string username = 1;
inline void SrpUser::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpUser::username() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SrpUser.username)
  return username_.GetNoArena();
}
inline void SrpUser::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SrpUser.username)
}
#if LANG_CXX11
inline void SrpUser::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SrpUser.username)
}
#endif
inline void SrpUser::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SrpUser.username)
}
inline void SrpUser::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SrpUser.username)
}
inline ::std::string* SrpUser::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SrpUser.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpUser::release_username() {
  // @@protoc_insertion_point(field_release:aspia.proto.SrpUser.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpUser::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SrpUser.username)
}

// bytes salt = 2;
inline void SrpUser::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpUser::salt() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SrpUser.salt)
  return salt_.GetNoArena();
}
inline void SrpUser::set_salt(const ::std::string& value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SrpUser.salt)
}
#if LANG_CXX11
inline void SrpUser::set_salt(::std::string&& value) {
  
  salt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SrpUser.salt)
}
#endif
inline void SrpUser::set_salt(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SrpUser.salt)
}
inline void SrpUser::set_salt(const void* value, size_t size) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SrpUser.salt)
}
inline ::std::string* SrpUser::mutable_salt() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SrpUser.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpUser::release_salt() {
  // @@protoc_insertion_point(field_release:aspia.proto.SrpUser.salt)
  
  return salt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpUser::set_allocated_salt(::std::string* salt) {
  if (salt != NULL) {
    
  } else {
    
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SrpUser.salt)
}

// bytes verifier = 3;
inline void SrpUser::clear_verifier() {
  verifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpUser::verifier() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SrpUser.verifier)
  return verifier_.GetNoArena();
}
inline void SrpUser::set_verifier(const ::std::string& value) {
  
  verifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SrpUser.verifier)
}
#if LANG_CXX11
inline void SrpUser::set_verifier(::std::string&& value) {
  
  verifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SrpUser.verifier)
}
#endif
inline void SrpUser::set_verifier(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  verifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SrpUser.verifier)
}
inline void SrpUser::set_verifier(const void* value, size_t size) {
  
  verifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SrpUser.verifier)
}
inline ::std::string* SrpUser::mutable_verifier() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SrpUser.verifier)
  return verifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpUser::release_verifier() {
  // @@protoc_insertion_point(field_release:aspia.proto.SrpUser.verifier)
  
  return verifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpUser::set_allocated_verifier(::std::string* verifier) {
  if (verifier != NULL) {
    
  } else {
    
  }
  verifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifier);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SrpUser.verifier)
}

// bytes number = 4;
inline void SrpUser::clear_number() {
  number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpUser::number() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SrpUser.number)
  return number_.GetNoArena();
}
inline void SrpUser::set_number(const ::std::string& value) {
  
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SrpUser.number)
}
#if LANG_CXX11
inline void SrpUser::set_number(::std::string&& value) {
  
  number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SrpUser.number)
}
#endif
inline void SrpUser::set_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SrpUser.number)
}
inline void SrpUser::set_number(const void* value, size_t size) {
  
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SrpUser.number)
}
inline ::std::string* SrpUser::mutable_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SrpUser.number)
  return number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpUser::release_number() {
  // @@protoc_insertion_point(field_release:aspia.proto.SrpUser.number)
  
  return number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpUser::set_allocated_number(::std::string* number) {
  if (number != NULL) {
    
  } else {
    
  }
  number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), number);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SrpUser.number)
}

// bytes generator = 5;
inline void SrpUser::clear_generator() {
  generator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpUser::generator() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SrpUser.generator)
  return generator_.GetNoArena();
}
inline void SrpUser::set_generator(const ::std::string& value) {
  
  generator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SrpUser.generator)
}
#if LANG_CXX11
inline void SrpUser::set_generator(::std::string&& value) {
  
  generator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SrpUser.generator)
}
#endif
inline void SrpUser::set_generator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  generator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SrpUser.generator)
}
inline void SrpUser::set_generator(const void* value, size_t size) {
  
  generator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SrpUser.generator)
}
inline ::std::string* SrpUser::mutable_generator() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SrpUser.generator)
  return generator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpUser::release_generator() {
  // @@protoc_insertion_point(field_release:aspia.proto.SrpUser.generator)
  
  return generator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpUser::set_allocated_generator(::std::string* generator) {
  if (generator != NULL) {
    
  } else {
    
  }
  generator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), generator);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SrpUser.generator)
}

// uint32 sessions = 6;
inline void SrpUser::clear_sessions() {
  sessions_ = 0u;
}
inline ::google::protobuf::uint32 SrpUser::sessions() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SrpUser.sessions)
  return sessions_;
}
inline void SrpUser::set_sessions(::google::protobuf::uint32 value) {
  
  sessions_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SrpUser.sessions)
}

// uint32 flags = 7;
inline void SrpUser::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 SrpUser::flags() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SrpUser.flags)
  return flags_;
}
inline void SrpUser::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.SrpUser.flags)
}

// -------------------------------------------------------------------

// SrpUserList

// bytes seed_key = 1;
inline void SrpUserList::clear_seed_key() {
  seed_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpUserList::seed_key() const {
  // @@protoc_insertion_point(field_get:aspia.proto.SrpUserList.seed_key)
  return seed_key_.GetNoArena();
}
inline void SrpUserList::set_seed_key(const ::std::string& value) {
  
  seed_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.SrpUserList.seed_key)
}
#if LANG_CXX11
inline void SrpUserList::set_seed_key(::std::string&& value) {
  
  seed_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.SrpUserList.seed_key)
}
#endif
inline void SrpUserList::set_seed_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  seed_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.SrpUserList.seed_key)
}
inline void SrpUserList::set_seed_key(const void* value, size_t size) {
  
  seed_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.SrpUserList.seed_key)
}
inline ::std::string* SrpUserList::mutable_seed_key() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.SrpUserList.seed_key)
  return seed_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpUserList::release_seed_key() {
  // @@protoc_insertion_point(field_release:aspia.proto.SrpUserList.seed_key)
  
  return seed_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpUserList::set_allocated_seed_key(::std::string* seed_key) {
  if (seed_key != NULL) {
    
  } else {
    
  }
  seed_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seed_key);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.SrpUserList.seed_key)
}

// repeated .aspia.proto.SrpUser user = 2;
inline int SrpUserList::user_size() const {
  return user_.size();
}
inline void SrpUserList::clear_user() {
  user_.Clear();
}
inline ::aspia::proto::SrpUser* SrpUserList::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.SrpUserList.user)
  return user_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::SrpUser >*
SrpUserList::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.SrpUserList.user)
  return &user_;
}
inline const ::aspia::proto::SrpUser& SrpUserList::user(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.SrpUserList.user)
  return user_.Get(index);
}
inline ::aspia::proto::SrpUser* SrpUserList::add_user() {
  // @@protoc_insertion_point(field_add:aspia.proto.SrpUserList.user)
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::SrpUser >&
SrpUserList::user() const {
  // @@protoc_insertion_point(field_list:aspia.proto.SrpUserList.user)
  return user_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace aspia

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aspia::proto::SrpUser_Flags> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_srp_5fuser_2eproto

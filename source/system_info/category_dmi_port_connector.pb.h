// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: category_dmi_port_connector.proto

#ifndef PROTOBUF_category_5fdmi_5fport_5fconnector_2eproto__INCLUDED
#define PROTOBUF_category_5fdmi_5fport_5fconnector_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace protobuf_category_5fdmi_5fport_5fconnector_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsDmiPortConnector_ItemImpl();
void InitDefaultsDmiPortConnector_Item();
void InitDefaultsDmiPortConnectorImpl();
void InitDefaultsDmiPortConnector();
inline void InitDefaults() {
  InitDefaultsDmiPortConnector_Item();
  InitDefaultsDmiPortConnector();
}
}  // namespace protobuf_category_5fdmi_5fport_5fconnector_2eproto
namespace aspia {
namespace proto {
class DmiPortConnector;
class DmiPortConnectorDefaultTypeInternal;
extern DmiPortConnectorDefaultTypeInternal _DmiPortConnector_default_instance_;
class DmiPortConnector_Item;
class DmiPortConnector_ItemDefaultTypeInternal;
extern DmiPortConnector_ItemDefaultTypeInternal _DmiPortConnector_Item_default_instance_;
}  // namespace proto
}  // namespace aspia
namespace aspia {
namespace proto {

enum DmiPortConnector_Type {
  DmiPortConnector_Type_TYPE_UNKNOWN = 0,
  DmiPortConnector_Type_TYPE_NONE = 1,
  DmiPortConnector_Type_TYPE_PARALLEL_PORT_XT_AT_COMPATIBLE = 2,
  DmiPortConnector_Type_TYPE_PARALLEL_PORT_PS_2 = 3,
  DmiPortConnector_Type_TYPE_PARALLEL_PORT_ECP = 4,
  DmiPortConnector_Type_TYPE_PARALLEL_PORT_EPP = 5,
  DmiPortConnector_Type_TYPE_PARALLEL_PORT_ECP_EPP = 6,
  DmiPortConnector_Type_TYPE_SERIAL_PORT_XT_AT_COMPATIBLE = 7,
  DmiPortConnector_Type_TYPE_SERIAL_PORT_16450_COMPATIBLE = 8,
  DmiPortConnector_Type_TYPE_SERIAL_PORT_16550_COMPATIBLE = 9,
  DmiPortConnector_Type_TYPE_SERIAL_PORT_16550A_COMPATIBLE = 10,
  DmiPortConnector_Type_TYPE_SCSI_PORT = 11,
  DmiPortConnector_Type_TYPE_MIDI_PORT = 12,
  DmiPortConnector_Type_TYPE_JOYSTICK_PORT = 13,
  DmiPortConnector_Type_TYPE_KEYBOARD_PORT = 14,
  DmiPortConnector_Type_TYPE_MOUSE_PORT = 15,
  DmiPortConnector_Type_TYPE_SSA_SCSI = 16,
  DmiPortConnector_Type_TYPE_USB = 17,
  DmiPortConnector_Type_TYPE_FIREWIRE = 18,
  DmiPortConnector_Type_TYPE_PCMCIA_TYPE_I = 19,
  DmiPortConnector_Type_TYPE_PCMCIA_TYPE_II = 20,
  DmiPortConnector_Type_TYPE_PCMCIA_TYPE_III = 21,
  DmiPortConnector_Type_TYPE_CARDBUS = 22,
  DmiPortConnector_Type_TYPE_ACCESS_BUS_PORT = 23,
  DmiPortConnector_Type_TYPE_SCSI_II = 24,
  DmiPortConnector_Type_TYPE_SCSI_WIDE = 25,
  DmiPortConnector_Type_TYPE_PC_98 = 26,
  DmiPortConnector_Type_TYPE_PC_98_HIRESO = 27,
  DmiPortConnector_Type_TYPE_PC_H98 = 28,
  DmiPortConnector_Type_TYPE_VIDEO_PORT = 29,
  DmiPortConnector_Type_TYPE_AUDIO_PORT = 30,
  DmiPortConnector_Type_TYPE_MODEM_PORT = 31,
  DmiPortConnector_Type_TYPE_NETWORK_PORT = 32,
  DmiPortConnector_Type_TYPE_SATA = 33,
  DmiPortConnector_Type_TYPE_SAS = 34,
  DmiPortConnector_Type_TYPE_8251_COMPATIBLE = 35,
  DmiPortConnector_Type_TYPE_8251_FIFO_COMPATIBLE = 36,
  DmiPortConnector_Type_DmiPortConnector_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPortConnector_Type_DmiPortConnector_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPortConnector_Type_IsValid(int value);
const DmiPortConnector_Type DmiPortConnector_Type_Type_MIN = DmiPortConnector_Type_TYPE_UNKNOWN;
const DmiPortConnector_Type DmiPortConnector_Type_Type_MAX = DmiPortConnector_Type_TYPE_8251_FIFO_COMPATIBLE;
const int DmiPortConnector_Type_Type_ARRAYSIZE = DmiPortConnector_Type_Type_MAX + 1;

enum DmiPortConnector_ConnectorType {
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_UNKNOWN = 0,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_NONE = 1,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_OTHER = 2,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_CENTRONICS = 3,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS = 4,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PROPRIETARY = 5,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_DB_25_MALE = 6,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_DB_25_FEMALE = 7,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_DB_15_MALE = 8,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_DB_15_FEMALE = 9,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_DB_9_MALE = 10,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_DB_9_FEMALE = 11,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_RJ_11 = 12,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_RJ_45 = 13,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_50_PIN_MINISCSI = 14,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_MINI_DIN = 15,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_MICRO_DIN = 16,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PS_2 = 17,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_INFRARED = 18,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_HP_HIL = 19,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_ACCESS_BUS_USB = 20,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_SSA_SCSI = 21,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_MALE = 22,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_FEMALE = 23,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_ONBOARD_IDE = 24,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_ONBOARD_FLOPPY = 25,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_9_PIN_DUAL_INLINE = 26,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_25_PIN_DUAL_INLINE = 27,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_50_PIN_DUAL_INLINE = 28,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_68_PIN_DUAL_INLINE = 29,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_ONBOARD_SOUND_INPUT_FROM_CDROM = 30,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_14 = 31,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_26 = 32,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_MINI_JACK = 33,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_BNC = 34,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_IEEE_1394 = 35,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_SAS_SATE_PLUG_RECEPTACLE = 36,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PC_98 = 37,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PC_98_HIRESO = 38,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PC_H98 = 39,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PC_98_NOTE = 40,
  DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PC_98_FULL = 41,
  DmiPortConnector_ConnectorType_DmiPortConnector_ConnectorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DmiPortConnector_ConnectorType_DmiPortConnector_ConnectorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DmiPortConnector_ConnectorType_IsValid(int value);
const DmiPortConnector_ConnectorType DmiPortConnector_ConnectorType_ConnectorType_MIN = DmiPortConnector_ConnectorType_CONNECTOR_TYPE_UNKNOWN;
const DmiPortConnector_ConnectorType DmiPortConnector_ConnectorType_ConnectorType_MAX = DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PC_98_FULL;
const int DmiPortConnector_ConnectorType_ConnectorType_ARRAYSIZE = DmiPortConnector_ConnectorType_ConnectorType_MAX + 1;

// ===================================================================

class DmiPortConnector_Item : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortConnector.Item) */ {
 public:
  DmiPortConnector_Item();
  virtual ~DmiPortConnector_Item();

  DmiPortConnector_Item(const DmiPortConnector_Item& from);

  inline DmiPortConnector_Item& operator=(const DmiPortConnector_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortConnector_Item(DmiPortConnector_Item&& from) noexcept
    : DmiPortConnector_Item() {
    *this = ::std::move(from);
  }

  inline DmiPortConnector_Item& operator=(DmiPortConnector_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortConnector_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortConnector_Item* internal_default_instance() {
    return reinterpret_cast<const DmiPortConnector_Item*>(
               &_DmiPortConnector_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DmiPortConnector_Item* other);
  friend void swap(DmiPortConnector_Item& a, DmiPortConnector_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortConnector_Item* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortConnector_Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortConnector_Item& from);
  void MergeFrom(const DmiPortConnector_Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortConnector_Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string internal_designation = 1;
  void clear_internal_designation();
  static const int kInternalDesignationFieldNumber = 1;
  const ::std::string& internal_designation() const;
  void set_internal_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_internal_designation(::std::string&& value);
  #endif
  void set_internal_designation(const char* value);
  void set_internal_designation(const char* value, size_t size);
  ::std::string* mutable_internal_designation();
  ::std::string* release_internal_designation();
  void set_allocated_internal_designation(::std::string* internal_designation);

  // string external_designation = 2;
  void clear_external_designation();
  static const int kExternalDesignationFieldNumber = 2;
  const ::std::string& external_designation() const;
  void set_external_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_external_designation(::std::string&& value);
  #endif
  void set_external_designation(const char* value);
  void set_external_designation(const char* value, size_t size);
  ::std::string* mutable_external_designation();
  ::std::string* release_external_designation();
  void set_allocated_external_designation(::std::string* external_designation);

  // .aspia.proto.DmiPortConnector.Type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::aspia::proto::DmiPortConnector_Type type() const;
  void set_type(::aspia::proto::DmiPortConnector_Type value);

  // .aspia.proto.DmiPortConnector.ConnectorType internal_connector_type = 4;
  void clear_internal_connector_type();
  static const int kInternalConnectorTypeFieldNumber = 4;
  ::aspia::proto::DmiPortConnector_ConnectorType internal_connector_type() const;
  void set_internal_connector_type(::aspia::proto::DmiPortConnector_ConnectorType value);

  // .aspia.proto.DmiPortConnector.ConnectorType external_connector_type = 5;
  void clear_external_connector_type();
  static const int kExternalConnectorTypeFieldNumber = 5;
  ::aspia::proto::DmiPortConnector_ConnectorType external_connector_type() const;
  void set_external_connector_type(::aspia::proto::DmiPortConnector_ConnectorType value);

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortConnector.Item)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr internal_designation_;
  ::google::protobuf::internal::ArenaStringPtr external_designation_;
  int type_;
  int internal_connector_type_;
  int external_connector_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5fdmi_5fport_5fconnector_2eproto::TableStruct;
  friend void ::protobuf_category_5fdmi_5fport_5fconnector_2eproto::InitDefaultsDmiPortConnector_ItemImpl();
};
// -------------------------------------------------------------------

class DmiPortConnector : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.proto.DmiPortConnector) */ {
 public:
  DmiPortConnector();
  virtual ~DmiPortConnector();

  DmiPortConnector(const DmiPortConnector& from);

  inline DmiPortConnector& operator=(const DmiPortConnector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DmiPortConnector(DmiPortConnector&& from) noexcept
    : DmiPortConnector() {
    *this = ::std::move(from);
  }

  inline DmiPortConnector& operator=(DmiPortConnector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DmiPortConnector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DmiPortConnector* internal_default_instance() {
    return reinterpret_cast<const DmiPortConnector*>(
               &_DmiPortConnector_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DmiPortConnector* other);
  friend void swap(DmiPortConnector& a, DmiPortConnector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DmiPortConnector* New() const PROTOBUF_FINAL { return New(NULL); }

  DmiPortConnector* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DmiPortConnector& from);
  void MergeFrom(const DmiPortConnector& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DmiPortConnector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DmiPortConnector_Item Item;

  typedef DmiPortConnector_Type Type;
  static const Type TYPE_UNKNOWN =
    DmiPortConnector_Type_TYPE_UNKNOWN;
  static const Type TYPE_NONE =
    DmiPortConnector_Type_TYPE_NONE;
  static const Type TYPE_PARALLEL_PORT_XT_AT_COMPATIBLE =
    DmiPortConnector_Type_TYPE_PARALLEL_PORT_XT_AT_COMPATIBLE;
  static const Type TYPE_PARALLEL_PORT_PS_2 =
    DmiPortConnector_Type_TYPE_PARALLEL_PORT_PS_2;
  static const Type TYPE_PARALLEL_PORT_ECP =
    DmiPortConnector_Type_TYPE_PARALLEL_PORT_ECP;
  static const Type TYPE_PARALLEL_PORT_EPP =
    DmiPortConnector_Type_TYPE_PARALLEL_PORT_EPP;
  static const Type TYPE_PARALLEL_PORT_ECP_EPP =
    DmiPortConnector_Type_TYPE_PARALLEL_PORT_ECP_EPP;
  static const Type TYPE_SERIAL_PORT_XT_AT_COMPATIBLE =
    DmiPortConnector_Type_TYPE_SERIAL_PORT_XT_AT_COMPATIBLE;
  static const Type TYPE_SERIAL_PORT_16450_COMPATIBLE =
    DmiPortConnector_Type_TYPE_SERIAL_PORT_16450_COMPATIBLE;
  static const Type TYPE_SERIAL_PORT_16550_COMPATIBLE =
    DmiPortConnector_Type_TYPE_SERIAL_PORT_16550_COMPATIBLE;
  static const Type TYPE_SERIAL_PORT_16550A_COMPATIBLE =
    DmiPortConnector_Type_TYPE_SERIAL_PORT_16550A_COMPATIBLE;
  static const Type TYPE_SCSI_PORT =
    DmiPortConnector_Type_TYPE_SCSI_PORT;
  static const Type TYPE_MIDI_PORT =
    DmiPortConnector_Type_TYPE_MIDI_PORT;
  static const Type TYPE_JOYSTICK_PORT =
    DmiPortConnector_Type_TYPE_JOYSTICK_PORT;
  static const Type TYPE_KEYBOARD_PORT =
    DmiPortConnector_Type_TYPE_KEYBOARD_PORT;
  static const Type TYPE_MOUSE_PORT =
    DmiPortConnector_Type_TYPE_MOUSE_PORT;
  static const Type TYPE_SSA_SCSI =
    DmiPortConnector_Type_TYPE_SSA_SCSI;
  static const Type TYPE_USB =
    DmiPortConnector_Type_TYPE_USB;
  static const Type TYPE_FIREWIRE =
    DmiPortConnector_Type_TYPE_FIREWIRE;
  static const Type TYPE_PCMCIA_TYPE_I =
    DmiPortConnector_Type_TYPE_PCMCIA_TYPE_I;
  static const Type TYPE_PCMCIA_TYPE_II =
    DmiPortConnector_Type_TYPE_PCMCIA_TYPE_II;
  static const Type TYPE_PCMCIA_TYPE_III =
    DmiPortConnector_Type_TYPE_PCMCIA_TYPE_III;
  static const Type TYPE_CARDBUS =
    DmiPortConnector_Type_TYPE_CARDBUS;
  static const Type TYPE_ACCESS_BUS_PORT =
    DmiPortConnector_Type_TYPE_ACCESS_BUS_PORT;
  static const Type TYPE_SCSI_II =
    DmiPortConnector_Type_TYPE_SCSI_II;
  static const Type TYPE_SCSI_WIDE =
    DmiPortConnector_Type_TYPE_SCSI_WIDE;
  static const Type TYPE_PC_98 =
    DmiPortConnector_Type_TYPE_PC_98;
  static const Type TYPE_PC_98_HIRESO =
    DmiPortConnector_Type_TYPE_PC_98_HIRESO;
  static const Type TYPE_PC_H98 =
    DmiPortConnector_Type_TYPE_PC_H98;
  static const Type TYPE_VIDEO_PORT =
    DmiPortConnector_Type_TYPE_VIDEO_PORT;
  static const Type TYPE_AUDIO_PORT =
    DmiPortConnector_Type_TYPE_AUDIO_PORT;
  static const Type TYPE_MODEM_PORT =
    DmiPortConnector_Type_TYPE_MODEM_PORT;
  static const Type TYPE_NETWORK_PORT =
    DmiPortConnector_Type_TYPE_NETWORK_PORT;
  static const Type TYPE_SATA =
    DmiPortConnector_Type_TYPE_SATA;
  static const Type TYPE_SAS =
    DmiPortConnector_Type_TYPE_SAS;
  static const Type TYPE_8251_COMPATIBLE =
    DmiPortConnector_Type_TYPE_8251_COMPATIBLE;
  static const Type TYPE_8251_FIFO_COMPATIBLE =
    DmiPortConnector_Type_TYPE_8251_FIFO_COMPATIBLE;
  static inline bool Type_IsValid(int value) {
    return DmiPortConnector_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DmiPortConnector_Type_Type_MIN;
  static const Type Type_MAX =
    DmiPortConnector_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DmiPortConnector_Type_Type_ARRAYSIZE;

  typedef DmiPortConnector_ConnectorType ConnectorType;
  static const ConnectorType CONNECTOR_TYPE_UNKNOWN =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_UNKNOWN;
  static const ConnectorType CONNECTOR_TYPE_NONE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_NONE;
  static const ConnectorType CONNECTOR_TYPE_OTHER =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_OTHER;
  static const ConnectorType CONNECTOR_TYPE_CENTRONICS =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_CENTRONICS;
  static const ConnectorType CONNECTOR_TYPE_MINI_CENTRONICS =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS;
  static const ConnectorType CONNECTOR_TYPE_PROPRIETARY =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PROPRIETARY;
  static const ConnectorType CONNECTOR_TYPE_DB_25_MALE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_DB_25_MALE;
  static const ConnectorType CONNECTOR_TYPE_DB_25_FEMALE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_DB_25_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_DB_15_MALE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_DB_15_MALE;
  static const ConnectorType CONNECTOR_TYPE_DB_15_FEMALE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_DB_15_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_DB_9_MALE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_DB_9_MALE;
  static const ConnectorType CONNECTOR_TYPE_DB_9_FEMALE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_DB_9_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_RJ_11 =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_RJ_11;
  static const ConnectorType CONNECTOR_TYPE_RJ_45 =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_RJ_45;
  static const ConnectorType CONNECTOR_TYPE_50_PIN_MINISCSI =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_50_PIN_MINISCSI;
  static const ConnectorType CONNECTOR_TYPE_MINI_DIN =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_MINI_DIN;
  static const ConnectorType CONNECTOR_TYPE_MICRO_DIN =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_MICRO_DIN;
  static const ConnectorType CONNECTOR_TYPE_PS_2 =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PS_2;
  static const ConnectorType CONNECTOR_TYPE_INFRARED =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_INFRARED;
  static const ConnectorType CONNECTOR_TYPE_HP_HIL =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_HP_HIL;
  static const ConnectorType CONNECTOR_TYPE_ACCESS_BUS_USB =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_ACCESS_BUS_USB;
  static const ConnectorType CONNECTOR_TYPE_SSA_SCSI =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_SSA_SCSI;
  static const ConnectorType CONNECTOR_TYPE_CIRCULAR_DIN_8_MALE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_MALE;
  static const ConnectorType CONNECTOR_TYPE_CIRCULAR_DIN_8_FEMALE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_CIRCULAR_DIN_8_FEMALE;
  static const ConnectorType CONNECTOR_TYPE_ONBOARD_IDE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_ONBOARD_IDE;
  static const ConnectorType CONNECTOR_TYPE_ONBOARD_FLOPPY =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_ONBOARD_FLOPPY;
  static const ConnectorType CONNECTOR_TYPE_9_PIN_DUAL_INLINE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_9_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_25_PIN_DUAL_INLINE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_25_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_50_PIN_DUAL_INLINE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_50_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_68_PIN_DUAL_INLINE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_68_PIN_DUAL_INLINE;
  static const ConnectorType CONNECTOR_TYPE_ONBOARD_SOUND_INPUT_FROM_CDROM =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_ONBOARD_SOUND_INPUT_FROM_CDROM;
  static const ConnectorType CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_14 =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_14;
  static const ConnectorType CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_26 =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_MINI_CENTRONICS_TYPE_26;
  static const ConnectorType CONNECTOR_TYPE_MINI_JACK =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_MINI_JACK;
  static const ConnectorType CONNECTOR_TYPE_BNC =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_BNC;
  static const ConnectorType CONNECTOR_TYPE_IEEE_1394 =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_IEEE_1394;
  static const ConnectorType CONNECTOR_TYPE_SAS_SATE_PLUG_RECEPTACLE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_SAS_SATE_PLUG_RECEPTACLE;
  static const ConnectorType CONNECTOR_TYPE_PC_98 =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PC_98;
  static const ConnectorType CONNECTOR_TYPE_PC_98_HIRESO =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PC_98_HIRESO;
  static const ConnectorType CONNECTOR_TYPE_PC_H98 =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PC_H98;
  static const ConnectorType CONNECTOR_TYPE_PC_98_NOTE =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PC_98_NOTE;
  static const ConnectorType CONNECTOR_TYPE_PC_98_FULL =
    DmiPortConnector_ConnectorType_CONNECTOR_TYPE_PC_98_FULL;
  static inline bool ConnectorType_IsValid(int value) {
    return DmiPortConnector_ConnectorType_IsValid(value);
  }
  static const ConnectorType ConnectorType_MIN =
    DmiPortConnector_ConnectorType_ConnectorType_MIN;
  static const ConnectorType ConnectorType_MAX =
    DmiPortConnector_ConnectorType_ConnectorType_MAX;
  static const int ConnectorType_ARRAYSIZE =
    DmiPortConnector_ConnectorType_ConnectorType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .aspia.proto.DmiPortConnector.Item item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::aspia::proto::DmiPortConnector_Item& item(int index) const;
  ::aspia::proto::DmiPortConnector_Item* mutable_item(int index);
  ::aspia::proto::DmiPortConnector_Item* add_item();
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnector_Item >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnector_Item >&
      item() const;

  // @@protoc_insertion_point(class_scope:aspia.proto.DmiPortConnector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnector_Item > item_;
  mutable int _cached_size_;
  friend struct ::protobuf_category_5fdmi_5fport_5fconnector_2eproto::TableStruct;
  friend void ::protobuf_category_5fdmi_5fport_5fconnector_2eproto::InitDefaultsDmiPortConnectorImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DmiPortConnector_Item

// string internal_designation = 1;
inline void DmiPortConnector_Item::clear_internal_designation() {
  internal_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnector_Item::internal_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnector.Item.internal_designation)
  return internal_designation_.GetNoArena();
}
inline void DmiPortConnector_Item::set_internal_designation(const ::std::string& value) {
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnector.Item.internal_designation)
}
#if LANG_CXX11
inline void DmiPortConnector_Item::set_internal_designation(::std::string&& value) {
  
  internal_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnector.Item.internal_designation)
}
#endif
inline void DmiPortConnector_Item::set_internal_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnector.Item.internal_designation)
}
inline void DmiPortConnector_Item::set_internal_designation(const char* value, size_t size) {
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnector.Item.internal_designation)
}
inline ::std::string* DmiPortConnector_Item::mutable_internal_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnector.Item.internal_designation)
  return internal_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnector_Item::release_internal_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnector.Item.internal_designation)
  
  return internal_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnector_Item::set_allocated_internal_designation(::std::string* internal_designation) {
  if (internal_designation != NULL) {
    
  } else {
    
  }
  internal_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), internal_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnector.Item.internal_designation)
}

// string external_designation = 2;
inline void DmiPortConnector_Item::clear_external_designation() {
  external_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DmiPortConnector_Item::external_designation() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnector.Item.external_designation)
  return external_designation_.GetNoArena();
}
inline void DmiPortConnector_Item::set_external_designation(const ::std::string& value) {
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnector.Item.external_designation)
}
#if LANG_CXX11
inline void DmiPortConnector_Item::set_external_designation(::std::string&& value) {
  
  external_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.proto.DmiPortConnector.Item.external_designation)
}
#endif
inline void DmiPortConnector_Item::set_external_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.proto.DmiPortConnector.Item.external_designation)
}
inline void DmiPortConnector_Item::set_external_designation(const char* value, size_t size) {
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.proto.DmiPortConnector.Item.external_designation)
}
inline ::std::string* DmiPortConnector_Item::mutable_external_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnector.Item.external_designation)
  return external_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DmiPortConnector_Item::release_external_designation() {
  // @@protoc_insertion_point(field_release:aspia.proto.DmiPortConnector.Item.external_designation)
  
  return external_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DmiPortConnector_Item::set_allocated_external_designation(::std::string* external_designation) {
  if (external_designation != NULL) {
    
  } else {
    
  }
  external_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), external_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.proto.DmiPortConnector.Item.external_designation)
}

// .aspia.proto.DmiPortConnector.Type type = 3;
inline void DmiPortConnector_Item::clear_type() {
  type_ = 0;
}
inline ::aspia::proto::DmiPortConnector_Type DmiPortConnector_Item::type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnector.Item.type)
  return static_cast< ::aspia::proto::DmiPortConnector_Type >(type_);
}
inline void DmiPortConnector_Item::set_type(::aspia::proto::DmiPortConnector_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnector.Item.type)
}

// .aspia.proto.DmiPortConnector.ConnectorType internal_connector_type = 4;
inline void DmiPortConnector_Item::clear_internal_connector_type() {
  internal_connector_type_ = 0;
}
inline ::aspia::proto::DmiPortConnector_ConnectorType DmiPortConnector_Item::internal_connector_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnector.Item.internal_connector_type)
  return static_cast< ::aspia::proto::DmiPortConnector_ConnectorType >(internal_connector_type_);
}
inline void DmiPortConnector_Item::set_internal_connector_type(::aspia::proto::DmiPortConnector_ConnectorType value) {
  
  internal_connector_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnector.Item.internal_connector_type)
}

// .aspia.proto.DmiPortConnector.ConnectorType external_connector_type = 5;
inline void DmiPortConnector_Item::clear_external_connector_type() {
  external_connector_type_ = 0;
}
inline ::aspia::proto::DmiPortConnector_ConnectorType DmiPortConnector_Item::external_connector_type() const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnector.Item.external_connector_type)
  return static_cast< ::aspia::proto::DmiPortConnector_ConnectorType >(external_connector_type_);
}
inline void DmiPortConnector_Item::set_external_connector_type(::aspia::proto::DmiPortConnector_ConnectorType value) {
  
  external_connector_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.proto.DmiPortConnector.Item.external_connector_type)
}

// -------------------------------------------------------------------

// DmiPortConnector

// repeated .aspia.proto.DmiPortConnector.Item item = 1;
inline int DmiPortConnector::item_size() const {
  return item_.size();
}
inline void DmiPortConnector::clear_item() {
  item_.Clear();
}
inline const ::aspia::proto::DmiPortConnector_Item& DmiPortConnector::item(int index) const {
  // @@protoc_insertion_point(field_get:aspia.proto.DmiPortConnector.item)
  return item_.Get(index);
}
inline ::aspia::proto::DmiPortConnector_Item* DmiPortConnector::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.proto.DmiPortConnector.item)
  return item_.Mutable(index);
}
inline ::aspia::proto::DmiPortConnector_Item* DmiPortConnector::add_item() {
  // @@protoc_insertion_point(field_add:aspia.proto.DmiPortConnector.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnector_Item >*
DmiPortConnector::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:aspia.proto.DmiPortConnector.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::proto::DmiPortConnector_Item >&
DmiPortConnector::item() const {
  // @@protoc_insertion_point(field_list:aspia.proto.DmiPortConnector.item)
  return item_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace aspia

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aspia::proto::DmiPortConnector_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::aspia::proto::DmiPortConnector_ConnectorType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_category_5fdmi_5fport_5fconnector_2eproto__INCLUDED

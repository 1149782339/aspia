// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dmi.proto

#ifndef PROTOBUF_INCLUDED_dmi_2eproto
#define PROTOBUF_INCLUDED_dmi_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_dmi_2eproto 

namespace protobuf_dmi_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_dmi_2eproto
namespace aspia {
namespace system_info {
namespace dmi {
class Bios;
class BiosDefaultTypeInternal;
extern BiosDefaultTypeInternal _Bios_default_instance_;
class Bios_Characteristics;
class Bios_CharacteristicsDefaultTypeInternal;
extern Bios_CharacteristicsDefaultTypeInternal _Bios_Characteristics_default_instance_;
class Cache;
class CacheDefaultTypeInternal;
extern CacheDefaultTypeInternal _Cache_default_instance_;
class Chassis;
class ChassisDefaultTypeInternal;
extern ChassisDefaultTypeInternal _Chassis_default_instance_;
class Dmi;
class DmiDefaultTypeInternal;
extern DmiDefaultTypeInternal _Dmi_default_instance_;
class MemoryDevice;
class MemoryDeviceDefaultTypeInternal;
extern MemoryDeviceDefaultTypeInternal _MemoryDevice_default_instance_;
class OnBoardDevice;
class OnBoardDeviceDefaultTypeInternal;
extern OnBoardDeviceDefaultTypeInternal _OnBoardDevice_default_instance_;
class PointingDevice;
class PointingDeviceDefaultTypeInternal;
extern PointingDeviceDefaultTypeInternal _PointingDevice_default_instance_;
class PortConnector;
class PortConnectorDefaultTypeInternal;
extern PortConnectorDefaultTypeInternal _PortConnector_default_instance_;
class PortableBattery;
class PortableBatteryDefaultTypeInternal;
extern PortableBatteryDefaultTypeInternal _PortableBattery_default_instance_;
class Processor;
class ProcessorDefaultTypeInternal;
extern ProcessorDefaultTypeInternal _Processor_default_instance_;
class System;
class SystemDefaultTypeInternal;
extern SystemDefaultTypeInternal _System_default_instance_;
class SystemSlot;
class SystemSlotDefaultTypeInternal;
extern SystemSlotDefaultTypeInternal _SystemSlot_default_instance_;
}  // namespace dmi
}  // namespace system_info
}  // namespace aspia
namespace google {
namespace protobuf {
template<> ::aspia::system_info::dmi::Bios* Arena::CreateMaybeMessage<::aspia::system_info::dmi::Bios>(Arena*);
template<> ::aspia::system_info::dmi::Bios_Characteristics* Arena::CreateMaybeMessage<::aspia::system_info::dmi::Bios_Characteristics>(Arena*);
template<> ::aspia::system_info::dmi::Cache* Arena::CreateMaybeMessage<::aspia::system_info::dmi::Cache>(Arena*);
template<> ::aspia::system_info::dmi::Chassis* Arena::CreateMaybeMessage<::aspia::system_info::dmi::Chassis>(Arena*);
template<> ::aspia::system_info::dmi::Dmi* Arena::CreateMaybeMessage<::aspia::system_info::dmi::Dmi>(Arena*);
template<> ::aspia::system_info::dmi::MemoryDevice* Arena::CreateMaybeMessage<::aspia::system_info::dmi::MemoryDevice>(Arena*);
template<> ::aspia::system_info::dmi::OnBoardDevice* Arena::CreateMaybeMessage<::aspia::system_info::dmi::OnBoardDevice>(Arena*);
template<> ::aspia::system_info::dmi::PointingDevice* Arena::CreateMaybeMessage<::aspia::system_info::dmi::PointingDevice>(Arena*);
template<> ::aspia::system_info::dmi::PortConnector* Arena::CreateMaybeMessage<::aspia::system_info::dmi::PortConnector>(Arena*);
template<> ::aspia::system_info::dmi::PortableBattery* Arena::CreateMaybeMessage<::aspia::system_info::dmi::PortableBattery>(Arena*);
template<> ::aspia::system_info::dmi::Processor* Arena::CreateMaybeMessage<::aspia::system_info::dmi::Processor>(Arena*);
template<> ::aspia::system_info::dmi::System* Arena::CreateMaybeMessage<::aspia::system_info::dmi::System>(Arena*);
template<> ::aspia::system_info::dmi::SystemSlot* Arena::CreateMaybeMessage<::aspia::system_info::dmi::SystemSlot>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace aspia {
namespace system_info {
namespace dmi {

enum Cache_Location {
  Cache_Location_LOCATION_UNKNOWN = 0,
  Cache_Location_LOCATION_INTERNAL = 1,
  Cache_Location_LOCATION_EXTERNAL = 2,
  Cache_Location_LOCATION_RESERVED = 3,
  Cache_Location_Cache_Location_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Cache_Location_Cache_Location_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Cache_Location_IsValid(int value);
const Cache_Location Cache_Location_Location_MIN = Cache_Location_LOCATION_UNKNOWN;
const Cache_Location Cache_Location_Location_MAX = Cache_Location_LOCATION_RESERVED;
const int Cache_Location_Location_ARRAYSIZE = Cache_Location_Location_MAX + 1;

enum Cache_Status {
  Cache_Status_STATUS_UNKNOWN = 0,
  Cache_Status_STATUS_ENABLED = 1,
  Cache_Status_STATUS_DISABLED = 2,
  Cache_Status_Cache_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Cache_Status_Cache_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Cache_Status_IsValid(int value);
const Cache_Status Cache_Status_Status_MIN = Cache_Status_STATUS_UNKNOWN;
const Cache_Status Cache_Status_Status_MAX = Cache_Status_STATUS_DISABLED;
const int Cache_Status_Status_ARRAYSIZE = Cache_Status_Status_MAX + 1;

enum Cache_Mode {
  Cache_Mode_MODE_UNKNOWN = 0,
  Cache_Mode_MODE_WRITE_THRU = 1,
  Cache_Mode_MODE_WRITE_BACK = 2,
  Cache_Mode_MODE_WRITE_WITH_MEMORY_ADDRESS = 3,
  Cache_Mode_Cache_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Cache_Mode_Cache_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Cache_Mode_IsValid(int value);
const Cache_Mode Cache_Mode_Mode_MIN = Cache_Mode_MODE_UNKNOWN;
const Cache_Mode Cache_Mode_Mode_MAX = Cache_Mode_MODE_WRITE_WITH_MEMORY_ADDRESS;
const int Cache_Mode_Mode_ARRAYSIZE = Cache_Mode_Mode_MAX + 1;

enum Cache_SRAMType {
  Cache_SRAMType_SRAM_TYPE_BAD = 0,
  Cache_SRAMType_SRAM_TYPE_OTHER = 1,
  Cache_SRAMType_SRAM_TYPE_UNKNOWN = 2,
  Cache_SRAMType_SRAM_TYPE_NON_BURST = 4,
  Cache_SRAMType_SRAM_TYPE_BURST = 8,
  Cache_SRAMType_SRAM_TYPE_PIPELINE_BURST = 16,
  Cache_SRAMType_SRAM_TYPE_SYNCHRONOUS = 32,
  Cache_SRAMType_SRAM_TYPE_ASYNCHRONOUS = 64,
  Cache_SRAMType_Cache_SRAMType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Cache_SRAMType_Cache_SRAMType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Cache_SRAMType_IsValid(int value);
const Cache_SRAMType Cache_SRAMType_SRAMType_MIN = Cache_SRAMType_SRAM_TYPE_BAD;
const Cache_SRAMType Cache_SRAMType_SRAMType_MAX = Cache_SRAMType_SRAM_TYPE_ASYNCHRONOUS;
const int Cache_SRAMType_SRAMType_ARRAYSIZE = Cache_SRAMType_SRAMType_MAX + 1;

enum Cache_ErrorCorrectionType {
  Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_UNKNOWN = 0,
  Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_OTHER = 1,
  Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_NONE = 2,
  Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_PARITY = 3,
  Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_SINGLE_BIT_ECC = 4,
  Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_MULTI_BIT_ECC = 5,
  Cache_ErrorCorrectionType_Cache_ErrorCorrectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Cache_ErrorCorrectionType_Cache_ErrorCorrectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Cache_ErrorCorrectionType_IsValid(int value);
const Cache_ErrorCorrectionType Cache_ErrorCorrectionType_ErrorCorrectionType_MIN = Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_UNKNOWN;
const Cache_ErrorCorrectionType Cache_ErrorCorrectionType_ErrorCorrectionType_MAX = Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_MULTI_BIT_ECC;
const int Cache_ErrorCorrectionType_ErrorCorrectionType_ARRAYSIZE = Cache_ErrorCorrectionType_ErrorCorrectionType_MAX + 1;

enum Cache_Type {
  Cache_Type_TYPE_UNKNOWN = 0,
  Cache_Type_TYPE_OTHER = 1,
  Cache_Type_TYPE_INSTRUCTION = 2,
  Cache_Type_TYPE_DATA = 3,
  Cache_Type_TYPE_UNIFIED = 4,
  Cache_Type_Cache_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Cache_Type_Cache_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Cache_Type_IsValid(int value);
const Cache_Type Cache_Type_Type_MIN = Cache_Type_TYPE_UNKNOWN;
const Cache_Type Cache_Type_Type_MAX = Cache_Type_TYPE_UNIFIED;
const int Cache_Type_Type_ARRAYSIZE = Cache_Type_Type_MAX + 1;

enum Cache_Associativity {
  Cache_Associativity_ASSOCIATIVITY_UNKNOWN = 0,
  Cache_Associativity_ASSOCIATIVITY_OTHER = 1,
  Cache_Associativity_ASSOCIATIVITY_DIRECT_MAPPED = 2,
  Cache_Associativity_ASSOCIATIVITY_2_WAY = 3,
  Cache_Associativity_ASSOCIATIVITY_4_WAY = 4,
  Cache_Associativity_ASSOCIATIVITY_FULLY = 5,
  Cache_Associativity_ASSOCIATIVITY_8_WAY = 6,
  Cache_Associativity_ASSOCIATIVITY_16_WAY = 7,
  Cache_Associativity_ASSOCIATIVITY_12_WAY = 8,
  Cache_Associativity_ASSOCIATIVITY_24_WAY = 9,
  Cache_Associativity_ASSOCIATIVITY_32_WAY = 10,
  Cache_Associativity_ASSOCIATIVITY_48_WAY = 11,
  Cache_Associativity_ASSOCIATIVITY_64_WAY = 12,
  Cache_Associativity_ASSOCIATIVITY_20_WAY = 13,
  Cache_Associativity_Cache_Associativity_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Cache_Associativity_Cache_Associativity_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Cache_Associativity_IsValid(int value);
const Cache_Associativity Cache_Associativity_Associativity_MIN = Cache_Associativity_ASSOCIATIVITY_UNKNOWN;
const Cache_Associativity Cache_Associativity_Associativity_MAX = Cache_Associativity_ASSOCIATIVITY_20_WAY;
const int Cache_Associativity_Associativity_ARRAYSIZE = Cache_Associativity_Associativity_MAX + 1;

enum Chassis_Type {
  Chassis_Type_TYPE_UNKNOWN = 0,
  Chassis_Type_TYPE_OTHER = 1,
  Chassis_Type_TYPE_DESKTOP = 2,
  Chassis_Type_TYPE_LOW_PROFILE_DESKTOP = 3,
  Chassis_Type_TYPE_PIZZA_BOX = 4,
  Chassis_Type_TYPE_MINI_TOWER = 5,
  Chassis_Type_TYPE_TOWER = 6,
  Chassis_Type_TYPE_PORTABLE = 7,
  Chassis_Type_TYPE_LAPTOP = 8,
  Chassis_Type_TYPE_NOTEBOOK = 9,
  Chassis_Type_TYPE_HAND_HELD = 10,
  Chassis_Type_TYPE_DOCKING_STATION = 11,
  Chassis_Type_TYPE_ALL_IN_ONE = 12,
  Chassis_Type_TYPE_SUB_NOTEBOOK = 13,
  Chassis_Type_TYPE_SPACE_SAVING = 14,
  Chassis_Type_TYPE_LUNCH_BOX = 15,
  Chassis_Type_TYPE_MAIN_SERVER_CHASSIS = 16,
  Chassis_Type_TYPE_EXPANSION_CHASSIS = 17,
  Chassis_Type_TYPE_SUB_CHASSIS = 18,
  Chassis_Type_TYPE_BUS_EXPANSION_CHASSIS = 19,
  Chassis_Type_TYPE_PERIPHERIAL_CHASSIS = 20,
  Chassis_Type_TYPE_RAID_CHASSIS = 21,
  Chassis_Type_TYPE_RACK_MOUNT_CHASSIS = 22,
  Chassis_Type_TYPE_SEALED_CASE_PC = 23,
  Chassis_Type_TYPE_MULTI_SYSTEM_CHASSIS = 24,
  Chassis_Type_TYPE_COMPACT_PCI = 25,
  Chassis_Type_TYPE_ADVANCED_TCA = 26,
  Chassis_Type_TYPE_BLADE = 27,
  Chassis_Type_TYPE_BLADE_ENCLOSURE = 28,
  Chassis_Type_Chassis_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Chassis_Type_Chassis_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Chassis_Type_IsValid(int value);
const Chassis_Type Chassis_Type_Type_MIN = Chassis_Type_TYPE_UNKNOWN;
const Chassis_Type Chassis_Type_Type_MAX = Chassis_Type_TYPE_BLADE_ENCLOSURE;
const int Chassis_Type_Type_ARRAYSIZE = Chassis_Type_Type_MAX + 1;

enum Chassis_Status {
  Chassis_Status_STATUS_UNKNOWN = 0,
  Chassis_Status_STATUS_OTHER = 1,
  Chassis_Status_STATUS_SAFE = 2,
  Chassis_Status_STATUS_WARNING = 3,
  Chassis_Status_STATUS_CRITICAL = 4,
  Chassis_Status_STATUS_NON_RECOVERABLE = 5,
  Chassis_Status_Chassis_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Chassis_Status_Chassis_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Chassis_Status_IsValid(int value);
const Chassis_Status Chassis_Status_Status_MIN = Chassis_Status_STATUS_UNKNOWN;
const Chassis_Status Chassis_Status_Status_MAX = Chassis_Status_STATUS_NON_RECOVERABLE;
const int Chassis_Status_Status_ARRAYSIZE = Chassis_Status_Status_MAX + 1;

enum Chassis_SecurityStatus {
  Chassis_SecurityStatus_SECURITY_STATUS_UNKNOWN = 0,
  Chassis_SecurityStatus_SECURITY_STATUS_OTHER = 1,
  Chassis_SecurityStatus_SECURITY_STATUS_NONE = 2,
  Chassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_LOCKED_OUT = 3,
  Chassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED = 4,
  Chassis_SecurityStatus_Chassis_SecurityStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Chassis_SecurityStatus_Chassis_SecurityStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Chassis_SecurityStatus_IsValid(int value);
const Chassis_SecurityStatus Chassis_SecurityStatus_SecurityStatus_MIN = Chassis_SecurityStatus_SECURITY_STATUS_UNKNOWN;
const Chassis_SecurityStatus Chassis_SecurityStatus_SecurityStatus_MAX = Chassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED;
const int Chassis_SecurityStatus_SecurityStatus_ARRAYSIZE = Chassis_SecurityStatus_SecurityStatus_MAX + 1;

enum OnBoardDevice_Type {
  OnBoardDevice_Type_TYPE_UNKNOWN = 0,
  OnBoardDevice_Type_TYPE_OTHER = 1,
  OnBoardDevice_Type_TYPE_VIDEO = 2,
  OnBoardDevice_Type_TYPE_SCSI_CONTROLLER = 3,
  OnBoardDevice_Type_TYPE_ETHERNET = 4,
  OnBoardDevice_Type_TYPE_TOKEN_RING = 5,
  OnBoardDevice_Type_TYPE_SOUND = 6,
  OnBoardDevice_Type_TYPE_PATA_CONTROLLER = 7,
  OnBoardDevice_Type_TYPE_SATA_CONTROLLER = 8,
  OnBoardDevice_Type_TYPE_SAS_CONTROLLER = 9,
  OnBoardDevice_Type_OnBoardDevice_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OnBoardDevice_Type_OnBoardDevice_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OnBoardDevice_Type_IsValid(int value);
const OnBoardDevice_Type OnBoardDevice_Type_Type_MIN = OnBoardDevice_Type_TYPE_UNKNOWN;
const OnBoardDevice_Type OnBoardDevice_Type_Type_MAX = OnBoardDevice_Type_TYPE_SAS_CONTROLLER;
const int OnBoardDevice_Type_Type_ARRAYSIZE = OnBoardDevice_Type_Type_MAX + 1;

enum PointingDevice_Type {
  PointingDevice_Type_TYPE_UNKNOWN = 0,
  PointingDevice_Type_TYPE_OTHER = 1,
  PointingDevice_Type_TYPE_MOUSE = 2,
  PointingDevice_Type_TYPE_TRACK_BALL = 3,
  PointingDevice_Type_TYPE_TRACK_POINT = 4,
  PointingDevice_Type_TYPE_GLIDE_POINT = 5,
  PointingDevice_Type_TYPE_TOUCH_PAD = 6,
  PointingDevice_Type_TYPE_TOUCH_SCREEN = 7,
  PointingDevice_Type_TYPE_OPTICAL_SENSOR = 8,
  PointingDevice_Type_PointingDevice_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PointingDevice_Type_PointingDevice_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PointingDevice_Type_IsValid(int value);
const PointingDevice_Type PointingDevice_Type_Type_MIN = PointingDevice_Type_TYPE_UNKNOWN;
const PointingDevice_Type PointingDevice_Type_Type_MAX = PointingDevice_Type_TYPE_OPTICAL_SENSOR;
const int PointingDevice_Type_Type_ARRAYSIZE = PointingDevice_Type_Type_MAX + 1;

enum PointingDevice_Interface {
  PointingDevice_Interface_INTERFACE_UNKNOWN = 0,
  PointingDevice_Interface_INTERFACE_OTHER = 1,
  PointingDevice_Interface_INTERFACE_SERIAL = 2,
  PointingDevice_Interface_INTERFACE_PS_2 = 3,
  PointingDevice_Interface_INTERFACE_INFRARED = 4,
  PointingDevice_Interface_INTERFACE_HP_HIL = 5,
  PointingDevice_Interface_INTERFACE_BUS_MOUSE = 6,
  PointingDevice_Interface_INTERFACE_ADB = 7,
  PointingDevice_Interface_INTERFACE_BUS_MOUSE_DB_9 = 8,
  PointingDevice_Interface_INTERFACE_BUS_MOUSE_MICRO_DIN = 9,
  PointingDevice_Interface_INTERFACE_USB = 10,
  PointingDevice_Interface_PointingDevice_Interface_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PointingDevice_Interface_PointingDevice_Interface_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PointingDevice_Interface_IsValid(int value);
const PointingDevice_Interface PointingDevice_Interface_Interface_MIN = PointingDevice_Interface_INTERFACE_UNKNOWN;
const PointingDevice_Interface PointingDevice_Interface_Interface_MAX = PointingDevice_Interface_INTERFACE_USB;
const int PointingDevice_Interface_Interface_ARRAYSIZE = PointingDevice_Interface_Interface_MAX + 1;

enum PortableBattery_Chemistry {
  PortableBattery_Chemistry_CHEMISTRY_UNKNOWN = 0,
  PortableBattery_Chemistry_CHEMISTRY_OTHER = 1,
  PortableBattery_Chemistry_CHEMISTRY_LEAD_ACID = 2,
  PortableBattery_Chemistry_CHEMISTRY_NICKEL_CADMIUM = 3,
  PortableBattery_Chemistry_CHEMISTRY_NICKEL_METAL_HYDRIDE = 4,
  PortableBattery_Chemistry_CHEMISTRY_LITHIUM_ION = 5,
  PortableBattery_Chemistry_CHEMISTRY_ZINC_AIR = 6,
  PortableBattery_Chemistry_CHEMISTRY_LITHIUM_POLYMER = 7,
  PortableBattery_Chemistry_PortableBattery_Chemistry_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PortableBattery_Chemistry_PortableBattery_Chemistry_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PortableBattery_Chemistry_IsValid(int value);
const PortableBattery_Chemistry PortableBattery_Chemistry_Chemistry_MIN = PortableBattery_Chemistry_CHEMISTRY_UNKNOWN;
const PortableBattery_Chemistry PortableBattery_Chemistry_Chemistry_MAX = PortableBattery_Chemistry_CHEMISTRY_LITHIUM_POLYMER;
const int PortableBattery_Chemistry_Chemistry_ARRAYSIZE = PortableBattery_Chemistry_Chemistry_MAX + 1;

enum Processor_Type {
  Processor_Type_TYPE_UNKNOWN = 0,
  Processor_Type_TYPE_OTHER = 1,
  Processor_Type_TYPE_CENTRAL_PROCESSOR = 2,
  Processor_Type_TYPE_MATH_PROCESSOR = 3,
  Processor_Type_TYPE_DSP_PROCESSOR = 4,
  Processor_Type_TYPE_VIDEO_PROCESSOR = 5,
  Processor_Type_Processor_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Processor_Type_Processor_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Processor_Type_IsValid(int value);
const Processor_Type Processor_Type_Type_MIN = Processor_Type_TYPE_UNKNOWN;
const Processor_Type Processor_Type_Type_MAX = Processor_Type_TYPE_VIDEO_PROCESSOR;
const int Processor_Type_Type_ARRAYSIZE = Processor_Type_Type_MAX + 1;

enum Processor_Status {
  Processor_Status_STATUS_UNKNOWN = 0,
  Processor_Status_STATUS_ENABLED = 1,
  Processor_Status_STATUS_DISABLED_BY_USER = 2,
  Processor_Status_STATUS_DISABLED_BY_BIOS = 3,
  Processor_Status_STATUS_IDLE = 4,
  Processor_Status_STATUS_OTHER = 5,
  Processor_Status_Processor_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Processor_Status_Processor_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Processor_Status_IsValid(int value);
const Processor_Status Processor_Status_Status_MIN = Processor_Status_STATUS_UNKNOWN;
const Processor_Status Processor_Status_Status_MAX = Processor_Status_STATUS_OTHER;
const int Processor_Status_Status_ARRAYSIZE = Processor_Status_Status_MAX + 1;

enum Processor_Characteristics {
  Processor_Characteristics_CHARACTERISTIC_NONE = 0,
  Processor_Characteristics_CHARACTERISTIC_64BIT_CAPABLE = 1,
  Processor_Characteristics_CHARACTERISTIC_MULTI_CORE = 2,
  Processor_Characteristics_CHARACTERISTIC_HARDWARE_THREAD = 4,
  Processor_Characteristics_CHARACTERISTIC_EXECUTE_PROTECTION = 8,
  Processor_Characteristics_CHARACTERISTIC_ENHANCED_VIRTUALIZATION = 16,
  Processor_Characteristics_CHARACTERISTIC_POWER_CONTROL = 32,
  Processor_Characteristics_Processor_Characteristics_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Processor_Characteristics_Processor_Characteristics_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Processor_Characteristics_IsValid(int value);
const Processor_Characteristics Processor_Characteristics_Characteristics_MIN = Processor_Characteristics_CHARACTERISTIC_NONE;
const Processor_Characteristics Processor_Characteristics_Characteristics_MAX = Processor_Characteristics_CHARACTERISTIC_POWER_CONTROL;
const int Processor_Characteristics_Characteristics_ARRAYSIZE = Processor_Characteristics_Characteristics_MAX + 1;

enum System_WakeupType {
  System_WakeupType_WAKEUP_TYPE_UNKNOWN = 0,
  System_WakeupType_WAKEUP_TYPE_OTHER = 1,
  System_WakeupType_WAKEUP_TYPE_APM_TIMER = 2,
  System_WakeupType_WAKEUP_TYPE_MODEM_RING = 3,
  System_WakeupType_WAKEUP_TYPE_LAN_REMOTE = 4,
  System_WakeupType_WAKEUP_TYPE_POWER_SWITCH = 5,
  System_WakeupType_WAKEUP_TYPE_PCI_PME = 6,
  System_WakeupType_WAKEUP_TYPE_AC_POWER_RESTORED = 7,
  System_WakeupType_System_WakeupType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  System_WakeupType_System_WakeupType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool System_WakeupType_IsValid(int value);
const System_WakeupType System_WakeupType_WakeupType_MIN = System_WakeupType_WAKEUP_TYPE_UNKNOWN;
const System_WakeupType System_WakeupType_WakeupType_MAX = System_WakeupType_WAKEUP_TYPE_AC_POWER_RESTORED;
const int System_WakeupType_WakeupType_ARRAYSIZE = System_WakeupType_WakeupType_MAX + 1;

enum SystemSlot_Usage {
  SystemSlot_Usage_USAGE_UNKNOWN = 0,
  SystemSlot_Usage_USAGE_OTHER = 1,
  SystemSlot_Usage_USAGE_AVAILABLE = 2,
  SystemSlot_Usage_USAGE_IN_USE = 3,
  SystemSlot_Usage_SystemSlot_Usage_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SystemSlot_Usage_SystemSlot_Usage_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SystemSlot_Usage_IsValid(int value);
const SystemSlot_Usage SystemSlot_Usage_Usage_MIN = SystemSlot_Usage_USAGE_UNKNOWN;
const SystemSlot_Usage SystemSlot_Usage_Usage_MAX = SystemSlot_Usage_USAGE_IN_USE;
const int SystemSlot_Usage_Usage_ARRAYSIZE = SystemSlot_Usage_Usage_MAX + 1;

enum SystemSlot_BusWidth {
  SystemSlot_BusWidth_BUS_WIDTH_UNKNOWN = 0,
  SystemSlot_BusWidth_BUS_WIDTH_OTHER = 1,
  SystemSlot_BusWidth_BUS_WIDTH_8_BIT = 2,
  SystemSlot_BusWidth_BUS_WIDTH_16_BIT = 3,
  SystemSlot_BusWidth_BUS_WIDTH_32_BIT = 4,
  SystemSlot_BusWidth_BUS_WIDTH_64_BIT = 5,
  SystemSlot_BusWidth_BUS_WIDTH_128_BIT = 6,
  SystemSlot_BusWidth_BUS_WIDTH_X1 = 7,
  SystemSlot_BusWidth_BUS_WIDTH_X2 = 8,
  SystemSlot_BusWidth_BUS_WIDTH_X4 = 9,
  SystemSlot_BusWidth_BUS_WIDTH_X8 = 10,
  SystemSlot_BusWidth_BUS_WIDTH_X12 = 11,
  SystemSlot_BusWidth_BUS_WIDTH_X16 = 12,
  SystemSlot_BusWidth_BUS_WIDTH_X32 = 13,
  SystemSlot_BusWidth_SystemSlot_BusWidth_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SystemSlot_BusWidth_SystemSlot_BusWidth_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SystemSlot_BusWidth_IsValid(int value);
const SystemSlot_BusWidth SystemSlot_BusWidth_BusWidth_MIN = SystemSlot_BusWidth_BUS_WIDTH_UNKNOWN;
const SystemSlot_BusWidth SystemSlot_BusWidth_BusWidth_MAX = SystemSlot_BusWidth_BUS_WIDTH_X32;
const int SystemSlot_BusWidth_BusWidth_ARRAYSIZE = SystemSlot_BusWidth_BusWidth_MAX + 1;

enum SystemSlot_Length {
  SystemSlot_Length_LENGTH_UNKNOWN = 0,
  SystemSlot_Length_LENGTH_OTHER = 1,
  SystemSlot_Length_LENGTH_SHORT = 2,
  SystemSlot_Length_LENGTH_LONG = 3,
  SystemSlot_Length_SystemSlot_Length_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SystemSlot_Length_SystemSlot_Length_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SystemSlot_Length_IsValid(int value);
const SystemSlot_Length SystemSlot_Length_Length_MIN = SystemSlot_Length_LENGTH_UNKNOWN;
const SystemSlot_Length SystemSlot_Length_Length_MAX = SystemSlot_Length_LENGTH_LONG;
const int SystemSlot_Length_Length_ARRAYSIZE = SystemSlot_Length_Length_MAX + 1;

// ===================================================================

class Bios_Characteristics : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.Bios.Characteristics) */ {
 public:
  Bios_Characteristics();
  virtual ~Bios_Characteristics();

  Bios_Characteristics(const Bios_Characteristics& from);

  inline Bios_Characteristics& operator=(const Bios_Characteristics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bios_Characteristics(Bios_Characteristics&& from) noexcept
    : Bios_Characteristics() {
    *this = ::std::move(from);
  }

  inline Bios_Characteristics& operator=(Bios_Characteristics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Bios_Characteristics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bios_Characteristics* internal_default_instance() {
    return reinterpret_cast<const Bios_Characteristics*>(
               &_Bios_Characteristics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Bios_Characteristics* other);
  friend void swap(Bios_Characteristics& a, Bios_Characteristics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bios_Characteristics* New() const final {
    return CreateMaybeMessage<Bios_Characteristics>(NULL);
  }

  Bios_Characteristics* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Bios_Characteristics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Bios_Characteristics& from);
  void MergeFrom(const Bios_Characteristics& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Bios_Characteristics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool isa = 1;
  void clear_isa();
  static const int kIsaFieldNumber = 1;
  bool isa() const;
  void set_isa(bool value);

  // bool mca = 2;
  void clear_mca();
  static const int kMcaFieldNumber = 2;
  bool mca() const;
  void set_mca(bool value);

  // bool eisa = 3;
  void clear_eisa();
  static const int kEisaFieldNumber = 3;
  bool eisa() const;
  void set_eisa(bool value);

  // bool pci = 4;
  void clear_pci();
  static const int kPciFieldNumber = 4;
  bool pci() const;
  void set_pci(bool value);

  // bool pc_card = 5;
  void clear_pc_card();
  static const int kPcCardFieldNumber = 5;
  bool pc_card() const;
  void set_pc_card(bool value);

  // bool pnp = 6;
  void clear_pnp();
  static const int kPnpFieldNumber = 6;
  bool pnp() const;
  void set_pnp(bool value);

  // bool apm = 7;
  void clear_apm();
  static const int kApmFieldNumber = 7;
  bool apm() const;
  void set_apm(bool value);

  // bool bios_upgradeable = 8;
  void clear_bios_upgradeable();
  static const int kBiosUpgradeableFieldNumber = 8;
  bool bios_upgradeable() const;
  void set_bios_upgradeable(bool value);

  // bool bios_shadowing = 9;
  void clear_bios_shadowing();
  static const int kBiosShadowingFieldNumber = 9;
  bool bios_shadowing() const;
  void set_bios_shadowing(bool value);

  // bool vlb = 10;
  void clear_vlb();
  static const int kVlbFieldNumber = 10;
  bool vlb() const;
  void set_vlb(bool value);

  // bool escd = 11;
  void clear_escd();
  static const int kEscdFieldNumber = 11;
  bool escd() const;
  void set_escd(bool value);

  // bool boot_from_cd = 12;
  void clear_boot_from_cd();
  static const int kBootFromCdFieldNumber = 12;
  bool boot_from_cd() const;
  void set_boot_from_cd(bool value);

  // bool selectable_boot = 13;
  void clear_selectable_boot();
  static const int kSelectableBootFieldNumber = 13;
  bool selectable_boot() const;
  void set_selectable_boot(bool value);

  // bool socketed_boot_rom = 14;
  void clear_socketed_boot_rom();
  static const int kSocketedBootRomFieldNumber = 14;
  bool socketed_boot_rom() const;
  void set_socketed_boot_rom(bool value);

  // bool boot_from_pc_card = 15;
  void clear_boot_from_pc_card();
  static const int kBootFromPcCardFieldNumber = 15;
  bool boot_from_pc_card() const;
  void set_boot_from_pc_card(bool value);

  // bool edd = 16;
  void clear_edd();
  static const int kEddFieldNumber = 16;
  bool edd() const;
  void set_edd(bool value);

  // bool japanese_floppy_for_nec9800 = 17;
  void clear_japanese_floppy_for_nec9800();
  static const int kJapaneseFloppyForNec9800FieldNumber = 17;
  bool japanese_floppy_for_nec9800() const;
  void set_japanese_floppy_for_nec9800(bool value);

  // bool japanese_floppy_for_toshiba = 18;
  void clear_japanese_floppy_for_toshiba();
  static const int kJapaneseFloppyForToshibaFieldNumber = 18;
  bool japanese_floppy_for_toshiba() const;
  void set_japanese_floppy_for_toshiba(bool value);

  // bool floppy_525_360kb = 19;
  void clear_floppy_525_360kb();
  static const int kFloppy525360KbFieldNumber = 19;
  bool floppy_525_360kb() const;
  void set_floppy_525_360kb(bool value);

  // bool floppy_525_12mb = 20;
  void clear_floppy_525_12mb();
  static const int kFloppy52512MbFieldNumber = 20;
  bool floppy_525_12mb() const;
  void set_floppy_525_12mb(bool value);

  // bool floppy_35_720kb = 21;
  void clear_floppy_35_720kb();
  static const int kFloppy35720KbFieldNumber = 21;
  bool floppy_35_720kb() const;
  void set_floppy_35_720kb(bool value);

  // bool floppy_35_288mb = 22;
  void clear_floppy_35_288mb();
  static const int kFloppy35288MbFieldNumber = 22;
  bool floppy_35_288mb() const;
  void set_floppy_35_288mb(bool value);

  // bool print_screen = 23;
  void clear_print_screen();
  static const int kPrintScreenFieldNumber = 23;
  bool print_screen() const;
  void set_print_screen(bool value);

  // bool keyboard_8042 = 24;
  void clear_keyboard_8042();
  static const int kKeyboard8042FieldNumber = 24;
  bool keyboard_8042() const;
  void set_keyboard_8042(bool value);

  // bool serial = 25;
  void clear_serial();
  static const int kSerialFieldNumber = 25;
  bool serial() const;
  void set_serial(bool value);

  // bool printer = 26;
  void clear_printer();
  static const int kPrinterFieldNumber = 26;
  bool printer() const;
  void set_printer(bool value);

  // bool cga_video = 27;
  void clear_cga_video();
  static const int kCgaVideoFieldNumber = 27;
  bool cga_video() const;
  void set_cga_video(bool value);

  // bool nec_pc98 = 28;
  void clear_nec_pc98();
  static const int kNecPc98FieldNumber = 28;
  bool nec_pc98() const;
  void set_nec_pc98(bool value);

  // bool acpi = 29;
  void clear_acpi();
  static const int kAcpiFieldNumber = 29;
  bool acpi() const;
  void set_acpi(bool value);

  // bool usb_legacy = 30;
  void clear_usb_legacy();
  static const int kUsbLegacyFieldNumber = 30;
  bool usb_legacy() const;
  void set_usb_legacy(bool value);

  // bool agp = 31;
  void clear_agp();
  static const int kAgpFieldNumber = 31;
  bool agp() const;
  void set_agp(bool value);

  // bool i2o_boot = 32;
  void clear_i2o_boot();
  static const int kI2OBootFieldNumber = 32;
  bool i2o_boot() const;
  void set_i2o_boot(bool value);

  // bool ls120_boot = 33;
  void clear_ls120_boot();
  static const int kLs120BootFieldNumber = 33;
  bool ls120_boot() const;
  void set_ls120_boot(bool value);

  // bool atapi_zip_drive_boot = 34;
  void clear_atapi_zip_drive_boot();
  static const int kAtapiZipDriveBootFieldNumber = 34;
  bool atapi_zip_drive_boot() const;
  void set_atapi_zip_drive_boot(bool value);

  // bool ieee1394_boot = 35;
  void clear_ieee1394_boot();
  static const int kIeee1394BootFieldNumber = 35;
  bool ieee1394_boot() const;
  void set_ieee1394_boot(bool value);

  // bool smart_battery = 36;
  void clear_smart_battery();
  static const int kSmartBatteryFieldNumber = 36;
  bool smart_battery() const;
  void set_smart_battery(bool value);

  // bool bios_boot_specification = 37;
  void clear_bios_boot_specification();
  static const int kBiosBootSpecificationFieldNumber = 37;
  bool bios_boot_specification() const;
  void set_bios_boot_specification(bool value);

  // bool key_init_network_boot = 38;
  void clear_key_init_network_boot();
  static const int kKeyInitNetworkBootFieldNumber = 38;
  bool key_init_network_boot() const;
  void set_key_init_network_boot(bool value);

  // bool targeted_content_distrib = 39;
  void clear_targeted_content_distrib();
  static const int kTargetedContentDistribFieldNumber = 39;
  bool targeted_content_distrib() const;
  void set_targeted_content_distrib(bool value);

  // bool uefi = 40;
  void clear_uefi();
  static const int kUefiFieldNumber = 40;
  bool uefi() const;
  void set_uefi(bool value);

  // bool virtual_machine = 41;
  void clear_virtual_machine();
  static const int kVirtualMachineFieldNumber = 41;
  bool virtual_machine() const;
  void set_virtual_machine(bool value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.Bios.Characteristics)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool isa_;
  bool mca_;
  bool eisa_;
  bool pci_;
  bool pc_card_;
  bool pnp_;
  bool apm_;
  bool bios_upgradeable_;
  bool bios_shadowing_;
  bool vlb_;
  bool escd_;
  bool boot_from_cd_;
  bool selectable_boot_;
  bool socketed_boot_rom_;
  bool boot_from_pc_card_;
  bool edd_;
  bool japanese_floppy_for_nec9800_;
  bool japanese_floppy_for_toshiba_;
  bool floppy_525_360kb_;
  bool floppy_525_12mb_;
  bool floppy_35_720kb_;
  bool floppy_35_288mb_;
  bool print_screen_;
  bool keyboard_8042_;
  bool serial_;
  bool printer_;
  bool cga_video_;
  bool nec_pc98_;
  bool acpi_;
  bool usb_legacy_;
  bool agp_;
  bool i2o_boot_;
  bool ls120_boot_;
  bool atapi_zip_drive_boot_;
  bool ieee1394_boot_;
  bool smart_battery_;
  bool bios_boot_specification_;
  bool key_init_network_boot_;
  bool targeted_content_distrib_;
  bool uefi_;
  bool virtual_machine_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bios : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.Bios) */ {
 public:
  Bios();
  virtual ~Bios();

  Bios(const Bios& from);

  inline Bios& operator=(const Bios& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bios(Bios&& from) noexcept
    : Bios() {
    *this = ::std::move(from);
  }

  inline Bios& operator=(Bios&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Bios& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bios* internal_default_instance() {
    return reinterpret_cast<const Bios*>(
               &_Bios_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Bios* other);
  friend void swap(Bios& a, Bios& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bios* New() const final {
    return CreateMaybeMessage<Bios>(NULL);
  }

  Bios* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Bios>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Bios& from);
  void MergeFrom(const Bios& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Bios* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Bios_Characteristics Characteristics;

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string date = 3;
  void clear_date();
  static const int kDateFieldNumber = 3;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // string bios_revision = 5;
  void clear_bios_revision();
  static const int kBiosRevisionFieldNumber = 5;
  const ::std::string& bios_revision() const;
  void set_bios_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_bios_revision(::std::string&& value);
  #endif
  void set_bios_revision(const char* value);
  void set_bios_revision(const char* value, size_t size);
  ::std::string* mutable_bios_revision();
  ::std::string* release_bios_revision();
  void set_allocated_bios_revision(::std::string* bios_revision);

  // string firmware_revision = 6;
  void clear_firmware_revision();
  static const int kFirmwareRevisionFieldNumber = 6;
  const ::std::string& firmware_revision() const;
  void set_firmware_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_firmware_revision(::std::string&& value);
  #endif
  void set_firmware_revision(const char* value);
  void set_firmware_revision(const char* value, size_t size);
  ::std::string* mutable_firmware_revision();
  ::std::string* release_firmware_revision();
  void set_allocated_firmware_revision(::std::string* firmware_revision);

  // string address = 7;
  void clear_address();
  static const int kAddressFieldNumber = 7;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // .aspia.system_info.dmi.Bios.Characteristics characteristics = 9;
  bool has_characteristics() const;
  void clear_characteristics();
  static const int kCharacteristicsFieldNumber = 9;
  private:
  const ::aspia::system_info::dmi::Bios_Characteristics& _internal_characteristics() const;
  public:
  const ::aspia::system_info::dmi::Bios_Characteristics& characteristics() const;
  ::aspia::system_info::dmi::Bios_Characteristics* release_characteristics();
  ::aspia::system_info::dmi::Bios_Characteristics* mutable_characteristics();
  void set_allocated_characteristics(::aspia::system_info::dmi::Bios_Characteristics* characteristics);

  // uint64 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // uint64 runtime_size = 8;
  void clear_runtime_size();
  static const int kRuntimeSizeFieldNumber = 8;
  ::google::protobuf::uint64 runtime_size() const;
  void set_runtime_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.Bios)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr bios_revision_;
  ::google::protobuf::internal::ArenaStringPtr firmware_revision_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::aspia::system_info::dmi::Bios_Characteristics* characteristics_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 runtime_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Cache : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.Cache) */ {
 public:
  Cache();
  virtual ~Cache();

  Cache(const Cache& from);

  inline Cache& operator=(const Cache& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Cache(Cache&& from) noexcept
    : Cache() {
    *this = ::std::move(from);
  }

  inline Cache& operator=(Cache&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Cache& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cache* internal_default_instance() {
    return reinterpret_cast<const Cache*>(
               &_Cache_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Cache* other);
  friend void swap(Cache& a, Cache& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Cache* New() const final {
    return CreateMaybeMessage<Cache>(NULL);
  }

  Cache* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Cache>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Cache& from);
  void MergeFrom(const Cache& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Cache* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Cache_Location Location;
  static const Location LOCATION_UNKNOWN =
    Cache_Location_LOCATION_UNKNOWN;
  static const Location LOCATION_INTERNAL =
    Cache_Location_LOCATION_INTERNAL;
  static const Location LOCATION_EXTERNAL =
    Cache_Location_LOCATION_EXTERNAL;
  static const Location LOCATION_RESERVED =
    Cache_Location_LOCATION_RESERVED;
  static inline bool Location_IsValid(int value) {
    return Cache_Location_IsValid(value);
  }
  static const Location Location_MIN =
    Cache_Location_Location_MIN;
  static const Location Location_MAX =
    Cache_Location_Location_MAX;
  static const int Location_ARRAYSIZE =
    Cache_Location_Location_ARRAYSIZE;

  typedef Cache_Status Status;
  static const Status STATUS_UNKNOWN =
    Cache_Status_STATUS_UNKNOWN;
  static const Status STATUS_ENABLED =
    Cache_Status_STATUS_ENABLED;
  static const Status STATUS_DISABLED =
    Cache_Status_STATUS_DISABLED;
  static inline bool Status_IsValid(int value) {
    return Cache_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Cache_Status_Status_MIN;
  static const Status Status_MAX =
    Cache_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Cache_Status_Status_ARRAYSIZE;

  typedef Cache_Mode Mode;
  static const Mode MODE_UNKNOWN =
    Cache_Mode_MODE_UNKNOWN;
  static const Mode MODE_WRITE_THRU =
    Cache_Mode_MODE_WRITE_THRU;
  static const Mode MODE_WRITE_BACK =
    Cache_Mode_MODE_WRITE_BACK;
  static const Mode MODE_WRITE_WITH_MEMORY_ADDRESS =
    Cache_Mode_MODE_WRITE_WITH_MEMORY_ADDRESS;
  static inline bool Mode_IsValid(int value) {
    return Cache_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    Cache_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    Cache_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    Cache_Mode_Mode_ARRAYSIZE;

  typedef Cache_SRAMType SRAMType;
  static const SRAMType SRAM_TYPE_BAD =
    Cache_SRAMType_SRAM_TYPE_BAD;
  static const SRAMType SRAM_TYPE_OTHER =
    Cache_SRAMType_SRAM_TYPE_OTHER;
  static const SRAMType SRAM_TYPE_UNKNOWN =
    Cache_SRAMType_SRAM_TYPE_UNKNOWN;
  static const SRAMType SRAM_TYPE_NON_BURST =
    Cache_SRAMType_SRAM_TYPE_NON_BURST;
  static const SRAMType SRAM_TYPE_BURST =
    Cache_SRAMType_SRAM_TYPE_BURST;
  static const SRAMType SRAM_TYPE_PIPELINE_BURST =
    Cache_SRAMType_SRAM_TYPE_PIPELINE_BURST;
  static const SRAMType SRAM_TYPE_SYNCHRONOUS =
    Cache_SRAMType_SRAM_TYPE_SYNCHRONOUS;
  static const SRAMType SRAM_TYPE_ASYNCHRONOUS =
    Cache_SRAMType_SRAM_TYPE_ASYNCHRONOUS;
  static inline bool SRAMType_IsValid(int value) {
    return Cache_SRAMType_IsValid(value);
  }
  static const SRAMType SRAMType_MIN =
    Cache_SRAMType_SRAMType_MIN;
  static const SRAMType SRAMType_MAX =
    Cache_SRAMType_SRAMType_MAX;
  static const int SRAMType_ARRAYSIZE =
    Cache_SRAMType_SRAMType_ARRAYSIZE;

  typedef Cache_ErrorCorrectionType ErrorCorrectionType;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_UNKNOWN =
    Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_UNKNOWN;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_OTHER =
    Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_OTHER;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_NONE =
    Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_NONE;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_PARITY =
    Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_PARITY;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_SINGLE_BIT_ECC =
    Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_SINGLE_BIT_ECC;
  static const ErrorCorrectionType ERROR_CORRECTION_TYPE_MULTI_BIT_ECC =
    Cache_ErrorCorrectionType_ERROR_CORRECTION_TYPE_MULTI_BIT_ECC;
  static inline bool ErrorCorrectionType_IsValid(int value) {
    return Cache_ErrorCorrectionType_IsValid(value);
  }
  static const ErrorCorrectionType ErrorCorrectionType_MIN =
    Cache_ErrorCorrectionType_ErrorCorrectionType_MIN;
  static const ErrorCorrectionType ErrorCorrectionType_MAX =
    Cache_ErrorCorrectionType_ErrorCorrectionType_MAX;
  static const int ErrorCorrectionType_ARRAYSIZE =
    Cache_ErrorCorrectionType_ErrorCorrectionType_ARRAYSIZE;

  typedef Cache_Type Type;
  static const Type TYPE_UNKNOWN =
    Cache_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    Cache_Type_TYPE_OTHER;
  static const Type TYPE_INSTRUCTION =
    Cache_Type_TYPE_INSTRUCTION;
  static const Type TYPE_DATA =
    Cache_Type_TYPE_DATA;
  static const Type TYPE_UNIFIED =
    Cache_Type_TYPE_UNIFIED;
  static inline bool Type_IsValid(int value) {
    return Cache_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Cache_Type_Type_MIN;
  static const Type Type_MAX =
    Cache_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Cache_Type_Type_ARRAYSIZE;

  typedef Cache_Associativity Associativity;
  static const Associativity ASSOCIATIVITY_UNKNOWN =
    Cache_Associativity_ASSOCIATIVITY_UNKNOWN;
  static const Associativity ASSOCIATIVITY_OTHER =
    Cache_Associativity_ASSOCIATIVITY_OTHER;
  static const Associativity ASSOCIATIVITY_DIRECT_MAPPED =
    Cache_Associativity_ASSOCIATIVITY_DIRECT_MAPPED;
  static const Associativity ASSOCIATIVITY_2_WAY =
    Cache_Associativity_ASSOCIATIVITY_2_WAY;
  static const Associativity ASSOCIATIVITY_4_WAY =
    Cache_Associativity_ASSOCIATIVITY_4_WAY;
  static const Associativity ASSOCIATIVITY_FULLY =
    Cache_Associativity_ASSOCIATIVITY_FULLY;
  static const Associativity ASSOCIATIVITY_8_WAY =
    Cache_Associativity_ASSOCIATIVITY_8_WAY;
  static const Associativity ASSOCIATIVITY_16_WAY =
    Cache_Associativity_ASSOCIATIVITY_16_WAY;
  static const Associativity ASSOCIATIVITY_12_WAY =
    Cache_Associativity_ASSOCIATIVITY_12_WAY;
  static const Associativity ASSOCIATIVITY_24_WAY =
    Cache_Associativity_ASSOCIATIVITY_24_WAY;
  static const Associativity ASSOCIATIVITY_32_WAY =
    Cache_Associativity_ASSOCIATIVITY_32_WAY;
  static const Associativity ASSOCIATIVITY_48_WAY =
    Cache_Associativity_ASSOCIATIVITY_48_WAY;
  static const Associativity ASSOCIATIVITY_64_WAY =
    Cache_Associativity_ASSOCIATIVITY_64_WAY;
  static const Associativity ASSOCIATIVITY_20_WAY =
    Cache_Associativity_ASSOCIATIVITY_20_WAY;
  static inline bool Associativity_IsValid(int value) {
    return Cache_Associativity_IsValid(value);
  }
  static const Associativity Associativity_MIN =
    Cache_Associativity_Associativity_MIN;
  static const Associativity Associativity_MAX =
    Cache_Associativity_Associativity_MAX;
  static const int Associativity_ARRAYSIZE =
    Cache_Associativity_Associativity_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .aspia.system_info.dmi.Cache.Location location = 2;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  ::aspia::system_info::dmi::Cache_Location location() const;
  void set_location(::aspia::system_info::dmi::Cache_Location value);

  // .aspia.system_info.dmi.Cache.Status status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::aspia::system_info::dmi::Cache_Status status() const;
  void set_status(::aspia::system_info::dmi::Cache_Status value);

  // .aspia.system_info.dmi.Cache.Mode mode = 4;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::aspia::system_info::dmi::Cache_Mode mode() const;
  void set_mode(::aspia::system_info::dmi::Cache_Mode value);

  // int32 level = 5;
  void clear_level();
  static const int kLevelFieldNumber = 5;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // int32 maximum_size = 6;
  void clear_maximum_size();
  static const int kMaximumSizeFieldNumber = 6;
  ::google::protobuf::int32 maximum_size() const;
  void set_maximum_size(::google::protobuf::int32 value);

  // int32 current_size = 7;
  void clear_current_size();
  static const int kCurrentSizeFieldNumber = 7;
  ::google::protobuf::int32 current_size() const;
  void set_current_size(::google::protobuf::int32 value);

  // uint32 supported_sram_types = 8;
  void clear_supported_sram_types();
  static const int kSupportedSramTypesFieldNumber = 8;
  ::google::protobuf::uint32 supported_sram_types() const;
  void set_supported_sram_types(::google::protobuf::uint32 value);

  // .aspia.system_info.dmi.Cache.SRAMType current_sram_type = 9;
  void clear_current_sram_type();
  static const int kCurrentSramTypeFieldNumber = 9;
  ::aspia::system_info::dmi::Cache_SRAMType current_sram_type() const;
  void set_current_sram_type(::aspia::system_info::dmi::Cache_SRAMType value);

  // int32 speed = 10;
  void clear_speed();
  static const int kSpeedFieldNumber = 10;
  ::google::protobuf::int32 speed() const;
  void set_speed(::google::protobuf::int32 value);

  // .aspia.system_info.dmi.Cache.ErrorCorrectionType error_correction_type = 11;
  void clear_error_correction_type();
  static const int kErrorCorrectionTypeFieldNumber = 11;
  ::aspia::system_info::dmi::Cache_ErrorCorrectionType error_correction_type() const;
  void set_error_correction_type(::aspia::system_info::dmi::Cache_ErrorCorrectionType value);

  // .aspia.system_info.dmi.Cache.Type type = 12;
  void clear_type();
  static const int kTypeFieldNumber = 12;
  ::aspia::system_info::dmi::Cache_Type type() const;
  void set_type(::aspia::system_info::dmi::Cache_Type value);

  // .aspia.system_info.dmi.Cache.Associativity associativity = 13;
  void clear_associativity();
  static const int kAssociativityFieldNumber = 13;
  ::aspia::system_info::dmi::Cache_Associativity associativity() const;
  void set_associativity(::aspia::system_info::dmi::Cache_Associativity value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.Cache)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int location_;
  int status_;
  int mode_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 maximum_size_;
  ::google::protobuf::int32 current_size_;
  ::google::protobuf::uint32 supported_sram_types_;
  int current_sram_type_;
  ::google::protobuf::int32 speed_;
  int error_correction_type_;
  int type_;
  int associativity_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Chassis : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.Chassis) */ {
 public:
  Chassis();
  virtual ~Chassis();

  Chassis(const Chassis& from);

  inline Chassis& operator=(const Chassis& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Chassis(Chassis&& from) noexcept
    : Chassis() {
    *this = ::std::move(from);
  }

  inline Chassis& operator=(Chassis&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Chassis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chassis* internal_default_instance() {
    return reinterpret_cast<const Chassis*>(
               &_Chassis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Chassis* other);
  friend void swap(Chassis& a, Chassis& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Chassis* New() const final {
    return CreateMaybeMessage<Chassis>(NULL);
  }

  Chassis* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Chassis>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Chassis& from);
  void MergeFrom(const Chassis& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Chassis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Chassis_Type Type;
  static const Type TYPE_UNKNOWN =
    Chassis_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    Chassis_Type_TYPE_OTHER;
  static const Type TYPE_DESKTOP =
    Chassis_Type_TYPE_DESKTOP;
  static const Type TYPE_LOW_PROFILE_DESKTOP =
    Chassis_Type_TYPE_LOW_PROFILE_DESKTOP;
  static const Type TYPE_PIZZA_BOX =
    Chassis_Type_TYPE_PIZZA_BOX;
  static const Type TYPE_MINI_TOWER =
    Chassis_Type_TYPE_MINI_TOWER;
  static const Type TYPE_TOWER =
    Chassis_Type_TYPE_TOWER;
  static const Type TYPE_PORTABLE =
    Chassis_Type_TYPE_PORTABLE;
  static const Type TYPE_LAPTOP =
    Chassis_Type_TYPE_LAPTOP;
  static const Type TYPE_NOTEBOOK =
    Chassis_Type_TYPE_NOTEBOOK;
  static const Type TYPE_HAND_HELD =
    Chassis_Type_TYPE_HAND_HELD;
  static const Type TYPE_DOCKING_STATION =
    Chassis_Type_TYPE_DOCKING_STATION;
  static const Type TYPE_ALL_IN_ONE =
    Chassis_Type_TYPE_ALL_IN_ONE;
  static const Type TYPE_SUB_NOTEBOOK =
    Chassis_Type_TYPE_SUB_NOTEBOOK;
  static const Type TYPE_SPACE_SAVING =
    Chassis_Type_TYPE_SPACE_SAVING;
  static const Type TYPE_LUNCH_BOX =
    Chassis_Type_TYPE_LUNCH_BOX;
  static const Type TYPE_MAIN_SERVER_CHASSIS =
    Chassis_Type_TYPE_MAIN_SERVER_CHASSIS;
  static const Type TYPE_EXPANSION_CHASSIS =
    Chassis_Type_TYPE_EXPANSION_CHASSIS;
  static const Type TYPE_SUB_CHASSIS =
    Chassis_Type_TYPE_SUB_CHASSIS;
  static const Type TYPE_BUS_EXPANSION_CHASSIS =
    Chassis_Type_TYPE_BUS_EXPANSION_CHASSIS;
  static const Type TYPE_PERIPHERIAL_CHASSIS =
    Chassis_Type_TYPE_PERIPHERIAL_CHASSIS;
  static const Type TYPE_RAID_CHASSIS =
    Chassis_Type_TYPE_RAID_CHASSIS;
  static const Type TYPE_RACK_MOUNT_CHASSIS =
    Chassis_Type_TYPE_RACK_MOUNT_CHASSIS;
  static const Type TYPE_SEALED_CASE_PC =
    Chassis_Type_TYPE_SEALED_CASE_PC;
  static const Type TYPE_MULTI_SYSTEM_CHASSIS =
    Chassis_Type_TYPE_MULTI_SYSTEM_CHASSIS;
  static const Type TYPE_COMPACT_PCI =
    Chassis_Type_TYPE_COMPACT_PCI;
  static const Type TYPE_ADVANCED_TCA =
    Chassis_Type_TYPE_ADVANCED_TCA;
  static const Type TYPE_BLADE =
    Chassis_Type_TYPE_BLADE;
  static const Type TYPE_BLADE_ENCLOSURE =
    Chassis_Type_TYPE_BLADE_ENCLOSURE;
  static inline bool Type_IsValid(int value) {
    return Chassis_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Chassis_Type_Type_MIN;
  static const Type Type_MAX =
    Chassis_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Chassis_Type_Type_ARRAYSIZE;

  typedef Chassis_Status Status;
  static const Status STATUS_UNKNOWN =
    Chassis_Status_STATUS_UNKNOWN;
  static const Status STATUS_OTHER =
    Chassis_Status_STATUS_OTHER;
  static const Status STATUS_SAFE =
    Chassis_Status_STATUS_SAFE;
  static const Status STATUS_WARNING =
    Chassis_Status_STATUS_WARNING;
  static const Status STATUS_CRITICAL =
    Chassis_Status_STATUS_CRITICAL;
  static const Status STATUS_NON_RECOVERABLE =
    Chassis_Status_STATUS_NON_RECOVERABLE;
  static inline bool Status_IsValid(int value) {
    return Chassis_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Chassis_Status_Status_MIN;
  static const Status Status_MAX =
    Chassis_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Chassis_Status_Status_ARRAYSIZE;

  typedef Chassis_SecurityStatus SecurityStatus;
  static const SecurityStatus SECURITY_STATUS_UNKNOWN =
    Chassis_SecurityStatus_SECURITY_STATUS_UNKNOWN;
  static const SecurityStatus SECURITY_STATUS_OTHER =
    Chassis_SecurityStatus_SECURITY_STATUS_OTHER;
  static const SecurityStatus SECURITY_STATUS_NONE =
    Chassis_SecurityStatus_SECURITY_STATUS_NONE;
  static const SecurityStatus SECURITY_STATUS_EXTERNAL_INTERFACE_LOCKED_OUT =
    Chassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_LOCKED_OUT;
  static const SecurityStatus SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED =
    Chassis_SecurityStatus_SECURITY_STATUS_EXTERNAL_INTERFACE_ENABLED;
  static inline bool SecurityStatus_IsValid(int value) {
    return Chassis_SecurityStatus_IsValid(value);
  }
  static const SecurityStatus SecurityStatus_MIN =
    Chassis_SecurityStatus_SecurityStatus_MIN;
  static const SecurityStatus SecurityStatus_MAX =
    Chassis_SecurityStatus_SecurityStatus_MAX;
  static const int SecurityStatus_ARRAYSIZE =
    Chassis_SecurityStatus_SecurityStatus_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 3;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 3;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 4;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 4;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // .aspia.system_info.dmi.Chassis.Type type = 5;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::aspia::system_info::dmi::Chassis_Type type() const;
  void set_type(::aspia::system_info::dmi::Chassis_Type value);

  // .aspia.system_info.dmi.Chassis.Status os_load_status = 6;
  void clear_os_load_status();
  static const int kOsLoadStatusFieldNumber = 6;
  ::aspia::system_info::dmi::Chassis_Status os_load_status() const;
  void set_os_load_status(::aspia::system_info::dmi::Chassis_Status value);

  // .aspia.system_info.dmi.Chassis.Status power_source_status = 7;
  void clear_power_source_status();
  static const int kPowerSourceStatusFieldNumber = 7;
  ::aspia::system_info::dmi::Chassis_Status power_source_status() const;
  void set_power_source_status(::aspia::system_info::dmi::Chassis_Status value);

  // .aspia.system_info.dmi.Chassis.Status temparature_status = 8;
  void clear_temparature_status();
  static const int kTemparatureStatusFieldNumber = 8;
  ::aspia::system_info::dmi::Chassis_Status temparature_status() const;
  void set_temparature_status(::aspia::system_info::dmi::Chassis_Status value);

  // .aspia.system_info.dmi.Chassis.SecurityStatus security_status = 9;
  void clear_security_status();
  static const int kSecurityStatusFieldNumber = 9;
  ::aspia::system_info::dmi::Chassis_SecurityStatus security_status() const;
  void set_security_status(::aspia::system_info::dmi::Chassis_SecurityStatus value);

  // int32 height = 10;
  void clear_height();
  static const int kHeightFieldNumber = 10;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // int32 number_of_power_cords = 11;
  void clear_number_of_power_cords();
  static const int kNumberOfPowerCordsFieldNumber = 11;
  ::google::protobuf::int32 number_of_power_cords() const;
  void set_number_of_power_cords(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.Chassis)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  int type_;
  int os_load_status_;
  int power_source_status_;
  int temparature_status_;
  int security_status_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 number_of_power_cords_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemoryDevice : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.MemoryDevice) */ {
 public:
  MemoryDevice();
  virtual ~MemoryDevice();

  MemoryDevice(const MemoryDevice& from);

  inline MemoryDevice& operator=(const MemoryDevice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemoryDevice(MemoryDevice&& from) noexcept
    : MemoryDevice() {
    *this = ::std::move(from);
  }

  inline MemoryDevice& operator=(MemoryDevice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const MemoryDevice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemoryDevice* internal_default_instance() {
    return reinterpret_cast<const MemoryDevice*>(
               &_MemoryDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MemoryDevice* other);
  friend void swap(MemoryDevice& a, MemoryDevice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemoryDevice* New() const final {
    return CreateMaybeMessage<MemoryDevice>(NULL);
  }

  MemoryDevice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MemoryDevice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const MemoryDevice& from);
  void MergeFrom(const MemoryDevice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MemoryDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device_locator = 1;
  void clear_device_locator();
  static const int kDeviceLocatorFieldNumber = 1;
  const ::std::string& device_locator() const;
  void set_device_locator(const ::std::string& value);
  #if LANG_CXX11
  void set_device_locator(::std::string&& value);
  #endif
  void set_device_locator(const char* value);
  void set_device_locator(const char* value, size_t size);
  ::std::string* mutable_device_locator();
  ::std::string* release_device_locator();
  void set_allocated_device_locator(::std::string* device_locator);

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string form_factor = 5;
  void clear_form_factor();
  static const int kFormFactorFieldNumber = 5;
  const ::std::string& form_factor() const;
  void set_form_factor(const ::std::string& value);
  #if LANG_CXX11
  void set_form_factor(::std::string&& value);
  #endif
  void set_form_factor(const char* value);
  void set_form_factor(const char* value, size_t size);
  ::std::string* mutable_form_factor();
  ::std::string* release_form_factor();
  void set_allocated_form_factor(::std::string* form_factor);

  // string serial_number = 6;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 6;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string part_number = 7;
  void clear_part_number();
  static const int kPartNumberFieldNumber = 7;
  const ::std::string& part_number() const;
  void set_part_number(const ::std::string& value);
  #if LANG_CXX11
  void set_part_number(::std::string&& value);
  #endif
  void set_part_number(const char* value);
  void set_part_number(const char* value, size_t size);
  ::std::string* mutable_part_number();
  ::std::string* release_part_number();
  void set_allocated_part_number(::std::string* part_number);

  // string manufactorer = 8;
  void clear_manufactorer();
  static const int kManufactorerFieldNumber = 8;
  const ::std::string& manufactorer() const;
  void set_manufactorer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufactorer(::std::string&& value);
  #endif
  void set_manufactorer(const char* value);
  void set_manufactorer(const char* value, size_t size);
  ::std::string* mutable_manufactorer();
  ::std::string* release_manufactorer();
  void set_allocated_manufactorer(::std::string* manufactorer);

  // string bank = 9;
  void clear_bank();
  static const int kBankFieldNumber = 9;
  const ::std::string& bank() const;
  void set_bank(const ::std::string& value);
  #if LANG_CXX11
  void set_bank(::std::string&& value);
  #endif
  void set_bank(const char* value);
  void set_bank(const char* value, size_t size);
  ::std::string* mutable_bank();
  ::std::string* release_bank();
  void set_allocated_bank(::std::string* bank);

  // uint64 size = 2;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // int32 speed = 4;
  void clear_speed();
  static const int kSpeedFieldNumber = 4;
  ::google::protobuf::int32 speed() const;
  void set_speed(::google::protobuf::int32 value);

  // int32 total_width = 10;
  void clear_total_width();
  static const int kTotalWidthFieldNumber = 10;
  ::google::protobuf::int32 total_width() const;
  void set_total_width(::google::protobuf::int32 value);

  // int32 data_width = 11;
  void clear_data_width();
  static const int kDataWidthFieldNumber = 11;
  ::google::protobuf::int32 data_width() const;
  void set_data_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.MemoryDevice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_locator_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr form_factor_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr part_number_;
  ::google::protobuf::internal::ArenaStringPtr manufactorer_;
  ::google::protobuf::internal::ArenaStringPtr bank_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 total_width_;
  ::google::protobuf::int32 data_width_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OnBoardDevice : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.OnBoardDevice) */ {
 public:
  OnBoardDevice();
  virtual ~OnBoardDevice();

  OnBoardDevice(const OnBoardDevice& from);

  inline OnBoardDevice& operator=(const OnBoardDevice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnBoardDevice(OnBoardDevice&& from) noexcept
    : OnBoardDevice() {
    *this = ::std::move(from);
  }

  inline OnBoardDevice& operator=(OnBoardDevice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OnBoardDevice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnBoardDevice* internal_default_instance() {
    return reinterpret_cast<const OnBoardDevice*>(
               &_OnBoardDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(OnBoardDevice* other);
  friend void swap(OnBoardDevice& a, OnBoardDevice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnBoardDevice* New() const final {
    return CreateMaybeMessage<OnBoardDevice>(NULL);
  }

  OnBoardDevice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OnBoardDevice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const OnBoardDevice& from);
  void MergeFrom(const OnBoardDevice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OnBoardDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef OnBoardDevice_Type Type;
  static const Type TYPE_UNKNOWN =
    OnBoardDevice_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    OnBoardDevice_Type_TYPE_OTHER;
  static const Type TYPE_VIDEO =
    OnBoardDevice_Type_TYPE_VIDEO;
  static const Type TYPE_SCSI_CONTROLLER =
    OnBoardDevice_Type_TYPE_SCSI_CONTROLLER;
  static const Type TYPE_ETHERNET =
    OnBoardDevice_Type_TYPE_ETHERNET;
  static const Type TYPE_TOKEN_RING =
    OnBoardDevice_Type_TYPE_TOKEN_RING;
  static const Type TYPE_SOUND =
    OnBoardDevice_Type_TYPE_SOUND;
  static const Type TYPE_PATA_CONTROLLER =
    OnBoardDevice_Type_TYPE_PATA_CONTROLLER;
  static const Type TYPE_SATA_CONTROLLER =
    OnBoardDevice_Type_TYPE_SATA_CONTROLLER;
  static const Type TYPE_SAS_CONTROLLER =
    OnBoardDevice_Type_TYPE_SAS_CONTROLLER;
  static inline bool Type_IsValid(int value) {
    return OnBoardDevice_Type_IsValid(value);
  }
  static const Type Type_MIN =
    OnBoardDevice_Type_Type_MIN;
  static const Type Type_MAX =
    OnBoardDevice_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    OnBoardDevice_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string description = 1;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .aspia.system_info.dmi.OnBoardDevice.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::aspia::system_info::dmi::OnBoardDevice_Type type() const;
  void set_type(::aspia::system_info::dmi::OnBoardDevice_Type value);

  // bool enabled = 3;
  void clear_enabled();
  static const int kEnabledFieldNumber = 3;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.OnBoardDevice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  int type_;
  bool enabled_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PointingDevice : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.PointingDevice) */ {
 public:
  PointingDevice();
  virtual ~PointingDevice();

  PointingDevice(const PointingDevice& from);

  inline PointingDevice& operator=(const PointingDevice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointingDevice(PointingDevice&& from) noexcept
    : PointingDevice() {
    *this = ::std::move(from);
  }

  inline PointingDevice& operator=(PointingDevice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PointingDevice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointingDevice* internal_default_instance() {
    return reinterpret_cast<const PointingDevice*>(
               &_PointingDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PointingDevice* other);
  friend void swap(PointingDevice& a, PointingDevice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointingDevice* New() const final {
    return CreateMaybeMessage<PointingDevice>(NULL);
  }

  PointingDevice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointingDevice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PointingDevice& from);
  void MergeFrom(const PointingDevice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PointingDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PointingDevice_Type Type;
  static const Type TYPE_UNKNOWN =
    PointingDevice_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    PointingDevice_Type_TYPE_OTHER;
  static const Type TYPE_MOUSE =
    PointingDevice_Type_TYPE_MOUSE;
  static const Type TYPE_TRACK_BALL =
    PointingDevice_Type_TYPE_TRACK_BALL;
  static const Type TYPE_TRACK_POINT =
    PointingDevice_Type_TYPE_TRACK_POINT;
  static const Type TYPE_GLIDE_POINT =
    PointingDevice_Type_TYPE_GLIDE_POINT;
  static const Type TYPE_TOUCH_PAD =
    PointingDevice_Type_TYPE_TOUCH_PAD;
  static const Type TYPE_TOUCH_SCREEN =
    PointingDevice_Type_TYPE_TOUCH_SCREEN;
  static const Type TYPE_OPTICAL_SENSOR =
    PointingDevice_Type_TYPE_OPTICAL_SENSOR;
  static inline bool Type_IsValid(int value) {
    return PointingDevice_Type_IsValid(value);
  }
  static const Type Type_MIN =
    PointingDevice_Type_Type_MIN;
  static const Type Type_MAX =
    PointingDevice_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    PointingDevice_Type_Type_ARRAYSIZE;

  typedef PointingDevice_Interface Interface;
  static const Interface INTERFACE_UNKNOWN =
    PointingDevice_Interface_INTERFACE_UNKNOWN;
  static const Interface INTERFACE_OTHER =
    PointingDevice_Interface_INTERFACE_OTHER;
  static const Interface INTERFACE_SERIAL =
    PointingDevice_Interface_INTERFACE_SERIAL;
  static const Interface INTERFACE_PS_2 =
    PointingDevice_Interface_INTERFACE_PS_2;
  static const Interface INTERFACE_INFRARED =
    PointingDevice_Interface_INTERFACE_INFRARED;
  static const Interface INTERFACE_HP_HIL =
    PointingDevice_Interface_INTERFACE_HP_HIL;
  static const Interface INTERFACE_BUS_MOUSE =
    PointingDevice_Interface_INTERFACE_BUS_MOUSE;
  static const Interface INTERFACE_ADB =
    PointingDevice_Interface_INTERFACE_ADB;
  static const Interface INTERFACE_BUS_MOUSE_DB_9 =
    PointingDevice_Interface_INTERFACE_BUS_MOUSE_DB_9;
  static const Interface INTERFACE_BUS_MOUSE_MICRO_DIN =
    PointingDevice_Interface_INTERFACE_BUS_MOUSE_MICRO_DIN;
  static const Interface INTERFACE_USB =
    PointingDevice_Interface_INTERFACE_USB;
  static inline bool Interface_IsValid(int value) {
    return PointingDevice_Interface_IsValid(value);
  }
  static const Interface Interface_MIN =
    PointingDevice_Interface_Interface_MIN;
  static const Interface Interface_MAX =
    PointingDevice_Interface_Interface_MAX;
  static const int Interface_ARRAYSIZE =
    PointingDevice_Interface_Interface_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .aspia.system_info.dmi.PointingDevice.Type device_type = 1;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 1;
  ::aspia::system_info::dmi::PointingDevice_Type device_type() const;
  void set_device_type(::aspia::system_info::dmi::PointingDevice_Type value);

  // .aspia.system_info.dmi.PointingDevice.Interface device_interface = 2;
  void clear_device_interface();
  static const int kDeviceInterfaceFieldNumber = 2;
  ::aspia::system_info::dmi::PointingDevice_Interface device_interface() const;
  void set_device_interface(::aspia::system_info::dmi::PointingDevice_Interface value);

  // int32 button_count = 3;
  void clear_button_count();
  static const int kButtonCountFieldNumber = 3;
  ::google::protobuf::int32 button_count() const;
  void set_button_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.PointingDevice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int device_type_;
  int device_interface_;
  ::google::protobuf::int32 button_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PortConnector : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.PortConnector) */ {
 public:
  PortConnector();
  virtual ~PortConnector();

  PortConnector(const PortConnector& from);

  inline PortConnector& operator=(const PortConnector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PortConnector(PortConnector&& from) noexcept
    : PortConnector() {
    *this = ::std::move(from);
  }

  inline PortConnector& operator=(PortConnector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PortConnector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortConnector* internal_default_instance() {
    return reinterpret_cast<const PortConnector*>(
               &_PortConnector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(PortConnector* other);
  friend void swap(PortConnector& a, PortConnector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PortConnector* New() const final {
    return CreateMaybeMessage<PortConnector>(NULL);
  }

  PortConnector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PortConnector>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PortConnector& from);
  void MergeFrom(const PortConnector& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PortConnector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string internal_designation = 1;
  void clear_internal_designation();
  static const int kInternalDesignationFieldNumber = 1;
  const ::std::string& internal_designation() const;
  void set_internal_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_internal_designation(::std::string&& value);
  #endif
  void set_internal_designation(const char* value);
  void set_internal_designation(const char* value, size_t size);
  ::std::string* mutable_internal_designation();
  ::std::string* release_internal_designation();
  void set_allocated_internal_designation(::std::string* internal_designation);

  // string external_designation = 2;
  void clear_external_designation();
  static const int kExternalDesignationFieldNumber = 2;
  const ::std::string& external_designation() const;
  void set_external_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_external_designation(::std::string&& value);
  #endif
  void set_external_designation(const char* value);
  void set_external_designation(const char* value, size_t size);
  ::std::string* mutable_external_designation();
  ::std::string* release_external_designation();
  void set_allocated_external_designation(::std::string* external_designation);

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string internal_connector_type = 4;
  void clear_internal_connector_type();
  static const int kInternalConnectorTypeFieldNumber = 4;
  const ::std::string& internal_connector_type() const;
  void set_internal_connector_type(const ::std::string& value);
  #if LANG_CXX11
  void set_internal_connector_type(::std::string&& value);
  #endif
  void set_internal_connector_type(const char* value);
  void set_internal_connector_type(const char* value, size_t size);
  ::std::string* mutable_internal_connector_type();
  ::std::string* release_internal_connector_type();
  void set_allocated_internal_connector_type(::std::string* internal_connector_type);

  // string external_connector_type = 5;
  void clear_external_connector_type();
  static const int kExternalConnectorTypeFieldNumber = 5;
  const ::std::string& external_connector_type() const;
  void set_external_connector_type(const ::std::string& value);
  #if LANG_CXX11
  void set_external_connector_type(::std::string&& value);
  #endif
  void set_external_connector_type(const char* value);
  void set_external_connector_type(const char* value, size_t size);
  ::std::string* mutable_external_connector_type();
  ::std::string* release_external_connector_type();
  void set_allocated_external_connector_type(::std::string* external_connector_type);

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.PortConnector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr internal_designation_;
  ::google::protobuf::internal::ArenaStringPtr external_designation_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr internal_connector_type_;
  ::google::protobuf::internal::ArenaStringPtr external_connector_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PortableBattery : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.PortableBattery) */ {
 public:
  PortableBattery();
  virtual ~PortableBattery();

  PortableBattery(const PortableBattery& from);

  inline PortableBattery& operator=(const PortableBattery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PortableBattery(PortableBattery&& from) noexcept
    : PortableBattery() {
    *this = ::std::move(from);
  }

  inline PortableBattery& operator=(PortableBattery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PortableBattery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortableBattery* internal_default_instance() {
    return reinterpret_cast<const PortableBattery*>(
               &_PortableBattery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(PortableBattery* other);
  friend void swap(PortableBattery& a, PortableBattery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PortableBattery* New() const final {
    return CreateMaybeMessage<PortableBattery>(NULL);
  }

  PortableBattery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PortableBattery>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PortableBattery& from);
  void MergeFrom(const PortableBattery& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PortableBattery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PortableBattery_Chemistry Chemistry;
  static const Chemistry CHEMISTRY_UNKNOWN =
    PortableBattery_Chemistry_CHEMISTRY_UNKNOWN;
  static const Chemistry CHEMISTRY_OTHER =
    PortableBattery_Chemistry_CHEMISTRY_OTHER;
  static const Chemistry CHEMISTRY_LEAD_ACID =
    PortableBattery_Chemistry_CHEMISTRY_LEAD_ACID;
  static const Chemistry CHEMISTRY_NICKEL_CADMIUM =
    PortableBattery_Chemistry_CHEMISTRY_NICKEL_CADMIUM;
  static const Chemistry CHEMISTRY_NICKEL_METAL_HYDRIDE =
    PortableBattery_Chemistry_CHEMISTRY_NICKEL_METAL_HYDRIDE;
  static const Chemistry CHEMISTRY_LITHIUM_ION =
    PortableBattery_Chemistry_CHEMISTRY_LITHIUM_ION;
  static const Chemistry CHEMISTRY_ZINC_AIR =
    PortableBattery_Chemistry_CHEMISTRY_ZINC_AIR;
  static const Chemistry CHEMISTRY_LITHIUM_POLYMER =
    PortableBattery_Chemistry_CHEMISTRY_LITHIUM_POLYMER;
  static inline bool Chemistry_IsValid(int value) {
    return PortableBattery_Chemistry_IsValid(value);
  }
  static const Chemistry Chemistry_MIN =
    PortableBattery_Chemistry_Chemistry_MIN;
  static const Chemistry Chemistry_MAX =
    PortableBattery_Chemistry_Chemistry_MAX;
  static const int Chemistry_ARRAYSIZE =
    PortableBattery_Chemistry_Chemistry_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string location = 1;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // string manufacturer = 2;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 2;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string manufacture_date = 3;
  void clear_manufacture_date();
  static const int kManufactureDateFieldNumber = 3;
  const ::std::string& manufacture_date() const;
  void set_manufacture_date(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacture_date(::std::string&& value);
  #endif
  void set_manufacture_date(const char* value);
  void set_manufacture_date(const char* value, size_t size);
  ::std::string* mutable_manufacture_date();
  ::std::string* release_manufacture_date();
  void set_allocated_manufacture_date(::std::string* manufacture_date);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string device_name = 5;
  void clear_device_name();
  static const int kDeviceNameFieldNumber = 5;
  const ::std::string& device_name() const;
  void set_device_name(const ::std::string& value);
  #if LANG_CXX11
  void set_device_name(::std::string&& value);
  #endif
  void set_device_name(const char* value);
  void set_device_name(const char* value, size_t size);
  ::std::string* mutable_device_name();
  ::std::string* release_device_name();
  void set_allocated_device_name(::std::string* device_name);

  // string sbds_version_number = 9;
  void clear_sbds_version_number();
  static const int kSbdsVersionNumberFieldNumber = 9;
  const ::std::string& sbds_version_number() const;
  void set_sbds_version_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_version_number(::std::string&& value);
  #endif
  void set_sbds_version_number(const char* value);
  void set_sbds_version_number(const char* value, size_t size);
  ::std::string* mutable_sbds_version_number();
  ::std::string* release_sbds_version_number();
  void set_allocated_sbds_version_number(::std::string* sbds_version_number);

  // string sbds_serial_number = 11;
  void clear_sbds_serial_number();
  static const int kSbdsSerialNumberFieldNumber = 11;
  const ::std::string& sbds_serial_number() const;
  void set_sbds_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_serial_number(::std::string&& value);
  #endif
  void set_sbds_serial_number(const char* value);
  void set_sbds_serial_number(const char* value, size_t size);
  ::std::string* mutable_sbds_serial_number();
  ::std::string* release_sbds_serial_number();
  void set_allocated_sbds_serial_number(::std::string* sbds_serial_number);

  // string sbds_manufacture_date = 12;
  void clear_sbds_manufacture_date();
  static const int kSbdsManufactureDateFieldNumber = 12;
  const ::std::string& sbds_manufacture_date() const;
  void set_sbds_manufacture_date(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_manufacture_date(::std::string&& value);
  #endif
  void set_sbds_manufacture_date(const char* value);
  void set_sbds_manufacture_date(const char* value, size_t size);
  ::std::string* mutable_sbds_manufacture_date();
  ::std::string* release_sbds_manufacture_date();
  void set_allocated_sbds_manufacture_date(::std::string* sbds_manufacture_date);

  // string sbds_device_chemistry = 13;
  void clear_sbds_device_chemistry();
  static const int kSbdsDeviceChemistryFieldNumber = 13;
  const ::std::string& sbds_device_chemistry() const;
  void set_sbds_device_chemistry(const ::std::string& value);
  #if LANG_CXX11
  void set_sbds_device_chemistry(::std::string&& value);
  #endif
  void set_sbds_device_chemistry(const char* value);
  void set_sbds_device_chemistry(const char* value, size_t size);
  ::std::string* mutable_sbds_device_chemistry();
  ::std::string* release_sbds_device_chemistry();
  void set_allocated_sbds_device_chemistry(::std::string* sbds_device_chemistry);

  // .aspia.system_info.dmi.PortableBattery.Chemistry chemistry = 6;
  void clear_chemistry();
  static const int kChemistryFieldNumber = 6;
  ::aspia::system_info::dmi::PortableBattery_Chemistry chemistry() const;
  void set_chemistry(::aspia::system_info::dmi::PortableBattery_Chemistry value);

  // int32 design_capacity = 7;
  void clear_design_capacity();
  static const int kDesignCapacityFieldNumber = 7;
  ::google::protobuf::int32 design_capacity() const;
  void set_design_capacity(::google::protobuf::int32 value);

  // int32 design_voltage = 8;
  void clear_design_voltage();
  static const int kDesignVoltageFieldNumber = 8;
  ::google::protobuf::int32 design_voltage() const;
  void set_design_voltage(::google::protobuf::int32 value);

  // int32 max_error_in_battery_data = 10;
  void clear_max_error_in_battery_data();
  static const int kMaxErrorInBatteryDataFieldNumber = 10;
  ::google::protobuf::int32 max_error_in_battery_data() const;
  void set_max_error_in_battery_data(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.PortableBattery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr manufacture_date_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr device_name_;
  ::google::protobuf::internal::ArenaStringPtr sbds_version_number_;
  ::google::protobuf::internal::ArenaStringPtr sbds_serial_number_;
  ::google::protobuf::internal::ArenaStringPtr sbds_manufacture_date_;
  ::google::protobuf::internal::ArenaStringPtr sbds_device_chemistry_;
  int chemistry_;
  ::google::protobuf::int32 design_capacity_;
  ::google::protobuf::int32 design_voltage_;
  ::google::protobuf::int32 max_error_in_battery_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Processor : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.Processor) */ {
 public:
  Processor();
  virtual ~Processor();

  Processor(const Processor& from);

  inline Processor& operator=(const Processor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Processor(Processor&& from) noexcept
    : Processor() {
    *this = ::std::move(from);
  }

  inline Processor& operator=(Processor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Processor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Processor* internal_default_instance() {
    return reinterpret_cast<const Processor*>(
               &_Processor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Processor* other);
  friend void swap(Processor& a, Processor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Processor* New() const final {
    return CreateMaybeMessage<Processor>(NULL);
  }

  Processor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Processor>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Processor& from);
  void MergeFrom(const Processor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Processor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Processor_Type Type;
  static const Type TYPE_UNKNOWN =
    Processor_Type_TYPE_UNKNOWN;
  static const Type TYPE_OTHER =
    Processor_Type_TYPE_OTHER;
  static const Type TYPE_CENTRAL_PROCESSOR =
    Processor_Type_TYPE_CENTRAL_PROCESSOR;
  static const Type TYPE_MATH_PROCESSOR =
    Processor_Type_TYPE_MATH_PROCESSOR;
  static const Type TYPE_DSP_PROCESSOR =
    Processor_Type_TYPE_DSP_PROCESSOR;
  static const Type TYPE_VIDEO_PROCESSOR =
    Processor_Type_TYPE_VIDEO_PROCESSOR;
  static inline bool Type_IsValid(int value) {
    return Processor_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Processor_Type_Type_MIN;
  static const Type Type_MAX =
    Processor_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Processor_Type_Type_ARRAYSIZE;

  typedef Processor_Status Status;
  static const Status STATUS_UNKNOWN =
    Processor_Status_STATUS_UNKNOWN;
  static const Status STATUS_ENABLED =
    Processor_Status_STATUS_ENABLED;
  static const Status STATUS_DISABLED_BY_USER =
    Processor_Status_STATUS_DISABLED_BY_USER;
  static const Status STATUS_DISABLED_BY_BIOS =
    Processor_Status_STATUS_DISABLED_BY_BIOS;
  static const Status STATUS_IDLE =
    Processor_Status_STATUS_IDLE;
  static const Status STATUS_OTHER =
    Processor_Status_STATUS_OTHER;
  static inline bool Status_IsValid(int value) {
    return Processor_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Processor_Status_Status_MIN;
  static const Status Status_MAX =
    Processor_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Processor_Status_Status_ARRAYSIZE;

  typedef Processor_Characteristics Characteristics;
  static const Characteristics CHARACTERISTIC_NONE =
    Processor_Characteristics_CHARACTERISTIC_NONE;
  static const Characteristics CHARACTERISTIC_64BIT_CAPABLE =
    Processor_Characteristics_CHARACTERISTIC_64BIT_CAPABLE;
  static const Characteristics CHARACTERISTIC_MULTI_CORE =
    Processor_Characteristics_CHARACTERISTIC_MULTI_CORE;
  static const Characteristics CHARACTERISTIC_HARDWARE_THREAD =
    Processor_Characteristics_CHARACTERISTIC_HARDWARE_THREAD;
  static const Characteristics CHARACTERISTIC_EXECUTE_PROTECTION =
    Processor_Characteristics_CHARACTERISTIC_EXECUTE_PROTECTION;
  static const Characteristics CHARACTERISTIC_ENHANCED_VIRTUALIZATION =
    Processor_Characteristics_CHARACTERISTIC_ENHANCED_VIRTUALIZATION;
  static const Characteristics CHARACTERISTIC_POWER_CONTROL =
    Processor_Characteristics_CHARACTERISTIC_POWER_CONTROL;
  static inline bool Characteristics_IsValid(int value) {
    return Processor_Characteristics_IsValid(value);
  }
  static const Characteristics Characteristics_MIN =
    Processor_Characteristics_Characteristics_MIN;
  static const Characteristics Characteristics_MAX =
    Processor_Characteristics_Characteristics_MAX;
  static const int Characteristics_ARRAYSIZE =
    Processor_Characteristics_Characteristics_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string family = 3;
  void clear_family();
  static const int kFamilyFieldNumber = 3;
  const ::std::string& family() const;
  void set_family(const ::std::string& value);
  #if LANG_CXX11
  void set_family(::std::string&& value);
  #endif
  void set_family(const char* value);
  void set_family(const char* value, size_t size);
  ::std::string* mutable_family();
  ::std::string* release_family();
  void set_allocated_family(::std::string* family);

  // string socket = 6;
  void clear_socket();
  static const int kSocketFieldNumber = 6;
  const ::std::string& socket() const;
  void set_socket(const ::std::string& value);
  #if LANG_CXX11
  void set_socket(::std::string&& value);
  #endif
  void set_socket(const char* value);
  void set_socket(const char* value, size_t size);
  ::std::string* mutable_socket();
  ::std::string* release_socket();
  void set_allocated_socket(::std::string* socket);

  // string upgrade = 7;
  void clear_upgrade();
  static const int kUpgradeFieldNumber = 7;
  const ::std::string& upgrade() const;
  void set_upgrade(const ::std::string& value);
  #if LANG_CXX11
  void set_upgrade(::std::string&& value);
  #endif
  void set_upgrade(const char* value);
  void set_upgrade(const char* value, size_t size);
  ::std::string* mutable_upgrade();
  ::std::string* release_upgrade();
  void set_allocated_upgrade(::std::string* upgrade);

  // string serial_number = 12;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 12;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string asset_tag = 13;
  void clear_asset_tag();
  static const int kAssetTagFieldNumber = 13;
  const ::std::string& asset_tag() const;
  void set_asset_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_tag(::std::string&& value);
  #endif
  void set_asset_tag(const char* value);
  void set_asset_tag(const char* value, size_t size);
  ::std::string* mutable_asset_tag();
  ::std::string* release_asset_tag();
  void set_allocated_asset_tag(::std::string* asset_tag);

  // string part_number = 14;
  void clear_part_number();
  static const int kPartNumberFieldNumber = 14;
  const ::std::string& part_number() const;
  void set_part_number(const ::std::string& value);
  #if LANG_CXX11
  void set_part_number(::std::string&& value);
  #endif
  void set_part_number(const char* value);
  void set_part_number(const char* value, size_t size);
  ::std::string* mutable_part_number();
  ::std::string* release_part_number();
  void set_allocated_part_number(::std::string* part_number);

  // .aspia.system_info.dmi.Processor.Type type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::aspia::system_info::dmi::Processor_Type type() const;
  void set_type(::aspia::system_info::dmi::Processor_Type value);

  // .aspia.system_info.dmi.Processor.Status status = 5;
  void clear_status();
  static const int kStatusFieldNumber = 5;
  ::aspia::system_info::dmi::Processor_Status status() const;
  void set_status(::aspia::system_info::dmi::Processor_Status value);

  // int32 external_clock = 8;
  void clear_external_clock();
  static const int kExternalClockFieldNumber = 8;
  ::google::protobuf::int32 external_clock() const;
  void set_external_clock(::google::protobuf::int32 value);

  // int32 current_speed = 9;
  void clear_current_speed();
  static const int kCurrentSpeedFieldNumber = 9;
  ::google::protobuf::int32 current_speed() const;
  void set_current_speed(::google::protobuf::int32 value);

  // double voltage = 11;
  void clear_voltage();
  static const int kVoltageFieldNumber = 11;
  double voltage() const;
  void set_voltage(double value);

  // int32 maximum_speed = 10;
  void clear_maximum_speed();
  static const int kMaximumSpeedFieldNumber = 10;
  ::google::protobuf::int32 maximum_speed() const;
  void set_maximum_speed(::google::protobuf::int32 value);

  // int32 core_count = 15;
  void clear_core_count();
  static const int kCoreCountFieldNumber = 15;
  ::google::protobuf::int32 core_count() const;
  void set_core_count(::google::protobuf::int32 value);

  // int32 core_enabled = 16;
  void clear_core_enabled();
  static const int kCoreEnabledFieldNumber = 16;
  ::google::protobuf::int32 core_enabled() const;
  void set_core_enabled(::google::protobuf::int32 value);

  // int32 thread_count = 17;
  void clear_thread_count();
  static const int kThreadCountFieldNumber = 17;
  ::google::protobuf::int32 thread_count() const;
  void set_thread_count(::google::protobuf::int32 value);

  // uint32 characteristics = 18;
  void clear_characteristics();
  static const int kCharacteristicsFieldNumber = 18;
  ::google::protobuf::uint32 characteristics() const;
  void set_characteristics(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.Processor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr family_;
  ::google::protobuf::internal::ArenaStringPtr socket_;
  ::google::protobuf::internal::ArenaStringPtr upgrade_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr asset_tag_;
  ::google::protobuf::internal::ArenaStringPtr part_number_;
  int type_;
  int status_;
  ::google::protobuf::int32 external_clock_;
  ::google::protobuf::int32 current_speed_;
  double voltage_;
  ::google::protobuf::int32 maximum_speed_;
  ::google::protobuf::int32 core_count_;
  ::google::protobuf::int32 core_enabled_;
  ::google::protobuf::int32 thread_count_;
  ::google::protobuf::uint32 characteristics_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class System : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.System) */ {
 public:
  System();
  virtual ~System();

  System(const System& from);

  inline System& operator=(const System& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  System(System&& from) noexcept
    : System() {
    *this = ::std::move(from);
  }

  inline System& operator=(System&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const System& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const System* internal_default_instance() {
    return reinterpret_cast<const System*>(
               &_System_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(System* other);
  friend void swap(System& a, System& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline System* New() const final {
    return CreateMaybeMessage<System>(NULL);
  }

  System* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<System>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const System& from);
  void MergeFrom(const System& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(System* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef System_WakeupType WakeupType;
  static const WakeupType WAKEUP_TYPE_UNKNOWN =
    System_WakeupType_WAKEUP_TYPE_UNKNOWN;
  static const WakeupType WAKEUP_TYPE_OTHER =
    System_WakeupType_WAKEUP_TYPE_OTHER;
  static const WakeupType WAKEUP_TYPE_APM_TIMER =
    System_WakeupType_WAKEUP_TYPE_APM_TIMER;
  static const WakeupType WAKEUP_TYPE_MODEM_RING =
    System_WakeupType_WAKEUP_TYPE_MODEM_RING;
  static const WakeupType WAKEUP_TYPE_LAN_REMOTE =
    System_WakeupType_WAKEUP_TYPE_LAN_REMOTE;
  static const WakeupType WAKEUP_TYPE_POWER_SWITCH =
    System_WakeupType_WAKEUP_TYPE_POWER_SWITCH;
  static const WakeupType WAKEUP_TYPE_PCI_PME =
    System_WakeupType_WAKEUP_TYPE_PCI_PME;
  static const WakeupType WAKEUP_TYPE_AC_POWER_RESTORED =
    System_WakeupType_WAKEUP_TYPE_AC_POWER_RESTORED;
  static inline bool WakeupType_IsValid(int value) {
    return System_WakeupType_IsValid(value);
  }
  static const WakeupType WakeupType_MIN =
    System_WakeupType_WakeupType_MIN;
  static const WakeupType WakeupType_MAX =
    System_WakeupType_WakeupType_MAX;
  static const int WakeupType_ARRAYSIZE =
    System_WakeupType_WakeupType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string manufacturer = 1;
  void clear_manufacturer();
  static const int kManufacturerFieldNumber = 1;
  const ::std::string& manufacturer() const;
  void set_manufacturer(const ::std::string& value);
  #if LANG_CXX11
  void set_manufacturer(::std::string&& value);
  #endif
  void set_manufacturer(const char* value);
  void set_manufacturer(const char* value, size_t size);
  ::std::string* mutable_manufacturer();
  ::std::string* release_manufacturer();
  void set_allocated_manufacturer(::std::string* manufacturer);

  // string product_name = 2;
  void clear_product_name();
  static const int kProductNameFieldNumber = 2;
  const ::std::string& product_name() const;
  void set_product_name(const ::std::string& value);
  #if LANG_CXX11
  void set_product_name(::std::string&& value);
  #endif
  void set_product_name(const char* value);
  void set_product_name(const char* value, size_t size);
  ::std::string* mutable_product_name();
  ::std::string* release_product_name();
  void set_allocated_product_name(::std::string* product_name);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string serial_number = 4;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // string uuid = 5;
  void clear_uuid();
  static const int kUuidFieldNumber = 5;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // string sku_number = 7;
  void clear_sku_number();
  static const int kSkuNumberFieldNumber = 7;
  const ::std::string& sku_number() const;
  void set_sku_number(const ::std::string& value);
  #if LANG_CXX11
  void set_sku_number(::std::string&& value);
  #endif
  void set_sku_number(const char* value);
  void set_sku_number(const char* value, size_t size);
  ::std::string* mutable_sku_number();
  ::std::string* release_sku_number();
  void set_allocated_sku_number(::std::string* sku_number);

  // string family = 8;
  void clear_family();
  static const int kFamilyFieldNumber = 8;
  const ::std::string& family() const;
  void set_family(const ::std::string& value);
  #if LANG_CXX11
  void set_family(::std::string&& value);
  #endif
  void set_family(const char* value);
  void set_family(const char* value, size_t size);
  ::std::string* mutable_family();
  ::std::string* release_family();
  void set_allocated_family(::std::string* family);

  // .aspia.system_info.dmi.System.WakeupType wakeup_type = 6;
  void clear_wakeup_type();
  static const int kWakeupTypeFieldNumber = 6;
  ::aspia::system_info::dmi::System_WakeupType wakeup_type() const;
  void set_wakeup_type(::aspia::system_info::dmi::System_WakeupType value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.System)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr product_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr sku_number_;
  ::google::protobuf::internal::ArenaStringPtr family_;
  int wakeup_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SystemSlot : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.SystemSlot) */ {
 public:
  SystemSlot();
  virtual ~SystemSlot();

  SystemSlot(const SystemSlot& from);

  inline SystemSlot& operator=(const SystemSlot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SystemSlot(SystemSlot&& from) noexcept
    : SystemSlot() {
    *this = ::std::move(from);
  }

  inline SystemSlot& operator=(SystemSlot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const SystemSlot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SystemSlot* internal_default_instance() {
    return reinterpret_cast<const SystemSlot*>(
               &_SystemSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SystemSlot* other);
  friend void swap(SystemSlot& a, SystemSlot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SystemSlot* New() const final {
    return CreateMaybeMessage<SystemSlot>(NULL);
  }

  SystemSlot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SystemSlot>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SystemSlot& from);
  void MergeFrom(const SystemSlot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemSlot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SystemSlot_Usage Usage;
  static const Usage USAGE_UNKNOWN =
    SystemSlot_Usage_USAGE_UNKNOWN;
  static const Usage USAGE_OTHER =
    SystemSlot_Usage_USAGE_OTHER;
  static const Usage USAGE_AVAILABLE =
    SystemSlot_Usage_USAGE_AVAILABLE;
  static const Usage USAGE_IN_USE =
    SystemSlot_Usage_USAGE_IN_USE;
  static inline bool Usage_IsValid(int value) {
    return SystemSlot_Usage_IsValid(value);
  }
  static const Usage Usage_MIN =
    SystemSlot_Usage_Usage_MIN;
  static const Usage Usage_MAX =
    SystemSlot_Usage_Usage_MAX;
  static const int Usage_ARRAYSIZE =
    SystemSlot_Usage_Usage_ARRAYSIZE;

  typedef SystemSlot_BusWidth BusWidth;
  static const BusWidth BUS_WIDTH_UNKNOWN =
    SystemSlot_BusWidth_BUS_WIDTH_UNKNOWN;
  static const BusWidth BUS_WIDTH_OTHER =
    SystemSlot_BusWidth_BUS_WIDTH_OTHER;
  static const BusWidth BUS_WIDTH_8_BIT =
    SystemSlot_BusWidth_BUS_WIDTH_8_BIT;
  static const BusWidth BUS_WIDTH_16_BIT =
    SystemSlot_BusWidth_BUS_WIDTH_16_BIT;
  static const BusWidth BUS_WIDTH_32_BIT =
    SystemSlot_BusWidth_BUS_WIDTH_32_BIT;
  static const BusWidth BUS_WIDTH_64_BIT =
    SystemSlot_BusWidth_BUS_WIDTH_64_BIT;
  static const BusWidth BUS_WIDTH_128_BIT =
    SystemSlot_BusWidth_BUS_WIDTH_128_BIT;
  static const BusWidth BUS_WIDTH_X1 =
    SystemSlot_BusWidth_BUS_WIDTH_X1;
  static const BusWidth BUS_WIDTH_X2 =
    SystemSlot_BusWidth_BUS_WIDTH_X2;
  static const BusWidth BUS_WIDTH_X4 =
    SystemSlot_BusWidth_BUS_WIDTH_X4;
  static const BusWidth BUS_WIDTH_X8 =
    SystemSlot_BusWidth_BUS_WIDTH_X8;
  static const BusWidth BUS_WIDTH_X12 =
    SystemSlot_BusWidth_BUS_WIDTH_X12;
  static const BusWidth BUS_WIDTH_X16 =
    SystemSlot_BusWidth_BUS_WIDTH_X16;
  static const BusWidth BUS_WIDTH_X32 =
    SystemSlot_BusWidth_BUS_WIDTH_X32;
  static inline bool BusWidth_IsValid(int value) {
    return SystemSlot_BusWidth_IsValid(value);
  }
  static const BusWidth BusWidth_MIN =
    SystemSlot_BusWidth_BusWidth_MIN;
  static const BusWidth BusWidth_MAX =
    SystemSlot_BusWidth_BusWidth_MAX;
  static const int BusWidth_ARRAYSIZE =
    SystemSlot_BusWidth_BusWidth_ARRAYSIZE;

  typedef SystemSlot_Length Length;
  static const Length LENGTH_UNKNOWN =
    SystemSlot_Length_LENGTH_UNKNOWN;
  static const Length LENGTH_OTHER =
    SystemSlot_Length_LENGTH_OTHER;
  static const Length LENGTH_SHORT =
    SystemSlot_Length_LENGTH_SHORT;
  static const Length LENGTH_LONG =
    SystemSlot_Length_LENGTH_LONG;
  static inline bool Length_IsValid(int value) {
    return SystemSlot_Length_IsValid(value);
  }
  static const Length Length_MIN =
    SystemSlot_Length_Length_MIN;
  static const Length Length_MAX =
    SystemSlot_Length_Length_MAX;
  static const int Length_ARRAYSIZE =
    SystemSlot_Length_Length_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // string slot_designation = 1;
  void clear_slot_designation();
  static const int kSlotDesignationFieldNumber = 1;
  const ::std::string& slot_designation() const;
  void set_slot_designation(const ::std::string& value);
  #if LANG_CXX11
  void set_slot_designation(::std::string&& value);
  #endif
  void set_slot_designation(const char* value);
  void set_slot_designation(const char* value, size_t size);
  ::std::string* mutable_slot_designation();
  ::std::string* release_slot_designation();
  void set_allocated_slot_designation(::std::string* slot_designation);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .aspia.system_info.dmi.SystemSlot.Usage usage = 3;
  void clear_usage();
  static const int kUsageFieldNumber = 3;
  ::aspia::system_info::dmi::SystemSlot_Usage usage() const;
  void set_usage(::aspia::system_info::dmi::SystemSlot_Usage value);

  // .aspia.system_info.dmi.SystemSlot.BusWidth bus_width = 4;
  void clear_bus_width();
  static const int kBusWidthFieldNumber = 4;
  ::aspia::system_info::dmi::SystemSlot_BusWidth bus_width() const;
  void set_bus_width(::aspia::system_info::dmi::SystemSlot_BusWidth value);

  // .aspia.system_info.dmi.SystemSlot.Length length = 5;
  void clear_length();
  static const int kLengthFieldNumber = 5;
  ::aspia::system_info::dmi::SystemSlot_Length length() const;
  void set_length(::aspia::system_info::dmi::SystemSlot_Length value);

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.SystemSlot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr slot_designation_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  int usage_;
  int bus_width_;
  int length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Dmi : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:aspia.system_info.dmi.Dmi) */ {
 public:
  Dmi();
  virtual ~Dmi();

  Dmi(const Dmi& from);

  inline Dmi& operator=(const Dmi& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Dmi(Dmi&& from) noexcept
    : Dmi() {
    *this = ::std::move(from);
  }

  inline Dmi& operator=(Dmi&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const Dmi& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dmi* internal_default_instance() {
    return reinterpret_cast<const Dmi*>(
               &_Dmi_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Dmi* other);
  friend void swap(Dmi& a, Dmi& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Dmi* New() const final {
    return CreateMaybeMessage<Dmi>(NULL);
  }

  Dmi* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Dmi>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Dmi& from);
  void MergeFrom(const Dmi& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Dmi* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aspia.system_info.dmi.Bios bios = 1;
  int bios_size() const;
  void clear_bios();
  static const int kBiosFieldNumber = 1;
  ::aspia::system_info::dmi::Bios* mutable_bios(int index);
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Bios >*
      mutable_bios();
  const ::aspia::system_info::dmi::Bios& bios(int index) const;
  ::aspia::system_info::dmi::Bios* add_bios();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Bios >&
      bios() const;

  // repeated .aspia.system_info.dmi.Cache cache = 2;
  int cache_size() const;
  void clear_cache();
  static const int kCacheFieldNumber = 2;
  ::aspia::system_info::dmi::Cache* mutable_cache(int index);
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Cache >*
      mutable_cache();
  const ::aspia::system_info::dmi::Cache& cache(int index) const;
  ::aspia::system_info::dmi::Cache* add_cache();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Cache >&
      cache() const;

  // repeated .aspia.system_info.dmi.Chassis chassis = 3;
  int chassis_size() const;
  void clear_chassis();
  static const int kChassisFieldNumber = 3;
  ::aspia::system_info::dmi::Chassis* mutable_chassis(int index);
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Chassis >*
      mutable_chassis();
  const ::aspia::system_info::dmi::Chassis& chassis(int index) const;
  ::aspia::system_info::dmi::Chassis* add_chassis();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Chassis >&
      chassis() const;

  // repeated .aspia.system_info.dmi.MemoryDevice memory_device = 4;
  int memory_device_size() const;
  void clear_memory_device();
  static const int kMemoryDeviceFieldNumber = 4;
  ::aspia::system_info::dmi::MemoryDevice* mutable_memory_device(int index);
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::MemoryDevice >*
      mutable_memory_device();
  const ::aspia::system_info::dmi::MemoryDevice& memory_device(int index) const;
  ::aspia::system_info::dmi::MemoryDevice* add_memory_device();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::MemoryDevice >&
      memory_device() const;

  // repeated .aspia.system_info.dmi.OnBoardDevice onboard_device = 5;
  int onboard_device_size() const;
  void clear_onboard_device();
  static const int kOnboardDeviceFieldNumber = 5;
  ::aspia::system_info::dmi::OnBoardDevice* mutable_onboard_device(int index);
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::OnBoardDevice >*
      mutable_onboard_device();
  const ::aspia::system_info::dmi::OnBoardDevice& onboard_device(int index) const;
  ::aspia::system_info::dmi::OnBoardDevice* add_onboard_device();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::OnBoardDevice >&
      onboard_device() const;

  // repeated .aspia.system_info.dmi.PointingDevice pointing_device = 6;
  int pointing_device_size() const;
  void clear_pointing_device();
  static const int kPointingDeviceFieldNumber = 6;
  ::aspia::system_info::dmi::PointingDevice* mutable_pointing_device(int index);
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PointingDevice >*
      mutable_pointing_device();
  const ::aspia::system_info::dmi::PointingDevice& pointing_device(int index) const;
  ::aspia::system_info::dmi::PointingDevice* add_pointing_device();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PointingDevice >&
      pointing_device() const;

  // repeated .aspia.system_info.dmi.PortConnector port_connector = 7;
  int port_connector_size() const;
  void clear_port_connector();
  static const int kPortConnectorFieldNumber = 7;
  ::aspia::system_info::dmi::PortConnector* mutable_port_connector(int index);
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PortConnector >*
      mutable_port_connector();
  const ::aspia::system_info::dmi::PortConnector& port_connector(int index) const;
  ::aspia::system_info::dmi::PortConnector* add_port_connector();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PortConnector >&
      port_connector() const;

  // repeated .aspia.system_info.dmi.PortableBattery portable_battery = 8;
  int portable_battery_size() const;
  void clear_portable_battery();
  static const int kPortableBatteryFieldNumber = 8;
  ::aspia::system_info::dmi::PortableBattery* mutable_portable_battery(int index);
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PortableBattery >*
      mutable_portable_battery();
  const ::aspia::system_info::dmi::PortableBattery& portable_battery(int index) const;
  ::aspia::system_info::dmi::PortableBattery* add_portable_battery();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PortableBattery >&
      portable_battery() const;

  // repeated .aspia.system_info.dmi.Processor processor = 9;
  int processor_size() const;
  void clear_processor();
  static const int kProcessorFieldNumber = 9;
  ::aspia::system_info::dmi::Processor* mutable_processor(int index);
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Processor >*
      mutable_processor();
  const ::aspia::system_info::dmi::Processor& processor(int index) const;
  ::aspia::system_info::dmi::Processor* add_processor();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Processor >&
      processor() const;

  // repeated .aspia.system_info.dmi.System system = 10;
  int system_size() const;
  void clear_system();
  static const int kSystemFieldNumber = 10;
  ::aspia::system_info::dmi::System* mutable_system(int index);
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::System >*
      mutable_system();
  const ::aspia::system_info::dmi::System& system(int index) const;
  ::aspia::system_info::dmi::System* add_system();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::System >&
      system() const;

  // repeated .aspia.system_info.dmi.SystemSlot system_slot = 11;
  int system_slot_size() const;
  void clear_system_slot();
  static const int kSystemSlotFieldNumber = 11;
  ::aspia::system_info::dmi::SystemSlot* mutable_system_slot(int index);
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::SystemSlot >*
      mutable_system_slot();
  const ::aspia::system_info::dmi::SystemSlot& system_slot(int index) const;
  ::aspia::system_info::dmi::SystemSlot* add_system_slot();
  const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::SystemSlot >&
      system_slot() const;

  // @@protoc_insertion_point(class_scope:aspia.system_info.dmi.Dmi)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Bios > bios_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Cache > cache_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Chassis > chassis_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::MemoryDevice > memory_device_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::OnBoardDevice > onboard_device_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PointingDevice > pointing_device_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PortConnector > port_connector_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PortableBattery > portable_battery_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Processor > processor_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::System > system_;
  ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::SystemSlot > system_slot_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dmi_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Bios_Characteristics

// bool isa = 1;
inline void Bios_Characteristics::clear_isa() {
  isa_ = false;
}
inline bool Bios_Characteristics::isa() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.isa)
  return isa_;
}
inline void Bios_Characteristics::set_isa(bool value) {
  
  isa_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.isa)
}

// bool mca = 2;
inline void Bios_Characteristics::clear_mca() {
  mca_ = false;
}
inline bool Bios_Characteristics::mca() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.mca)
  return mca_;
}
inline void Bios_Characteristics::set_mca(bool value) {
  
  mca_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.mca)
}

// bool eisa = 3;
inline void Bios_Characteristics::clear_eisa() {
  eisa_ = false;
}
inline bool Bios_Characteristics::eisa() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.eisa)
  return eisa_;
}
inline void Bios_Characteristics::set_eisa(bool value) {
  
  eisa_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.eisa)
}

// bool pci = 4;
inline void Bios_Characteristics::clear_pci() {
  pci_ = false;
}
inline bool Bios_Characteristics::pci() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.pci)
  return pci_;
}
inline void Bios_Characteristics::set_pci(bool value) {
  
  pci_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.pci)
}

// bool pc_card = 5;
inline void Bios_Characteristics::clear_pc_card() {
  pc_card_ = false;
}
inline bool Bios_Characteristics::pc_card() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.pc_card)
  return pc_card_;
}
inline void Bios_Characteristics::set_pc_card(bool value) {
  
  pc_card_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.pc_card)
}

// bool pnp = 6;
inline void Bios_Characteristics::clear_pnp() {
  pnp_ = false;
}
inline bool Bios_Characteristics::pnp() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.pnp)
  return pnp_;
}
inline void Bios_Characteristics::set_pnp(bool value) {
  
  pnp_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.pnp)
}

// bool apm = 7;
inline void Bios_Characteristics::clear_apm() {
  apm_ = false;
}
inline bool Bios_Characteristics::apm() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.apm)
  return apm_;
}
inline void Bios_Characteristics::set_apm(bool value) {
  
  apm_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.apm)
}

// bool bios_upgradeable = 8;
inline void Bios_Characteristics::clear_bios_upgradeable() {
  bios_upgradeable_ = false;
}
inline bool Bios_Characteristics::bios_upgradeable() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.bios_upgradeable)
  return bios_upgradeable_;
}
inline void Bios_Characteristics::set_bios_upgradeable(bool value) {
  
  bios_upgradeable_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.bios_upgradeable)
}

// bool bios_shadowing = 9;
inline void Bios_Characteristics::clear_bios_shadowing() {
  bios_shadowing_ = false;
}
inline bool Bios_Characteristics::bios_shadowing() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.bios_shadowing)
  return bios_shadowing_;
}
inline void Bios_Characteristics::set_bios_shadowing(bool value) {
  
  bios_shadowing_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.bios_shadowing)
}

// bool vlb = 10;
inline void Bios_Characteristics::clear_vlb() {
  vlb_ = false;
}
inline bool Bios_Characteristics::vlb() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.vlb)
  return vlb_;
}
inline void Bios_Characteristics::set_vlb(bool value) {
  
  vlb_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.vlb)
}

// bool escd = 11;
inline void Bios_Characteristics::clear_escd() {
  escd_ = false;
}
inline bool Bios_Characteristics::escd() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.escd)
  return escd_;
}
inline void Bios_Characteristics::set_escd(bool value) {
  
  escd_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.escd)
}

// bool boot_from_cd = 12;
inline void Bios_Characteristics::clear_boot_from_cd() {
  boot_from_cd_ = false;
}
inline bool Bios_Characteristics::boot_from_cd() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.boot_from_cd)
  return boot_from_cd_;
}
inline void Bios_Characteristics::set_boot_from_cd(bool value) {
  
  boot_from_cd_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.boot_from_cd)
}

// bool selectable_boot = 13;
inline void Bios_Characteristics::clear_selectable_boot() {
  selectable_boot_ = false;
}
inline bool Bios_Characteristics::selectable_boot() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.selectable_boot)
  return selectable_boot_;
}
inline void Bios_Characteristics::set_selectable_boot(bool value) {
  
  selectable_boot_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.selectable_boot)
}

// bool socketed_boot_rom = 14;
inline void Bios_Characteristics::clear_socketed_boot_rom() {
  socketed_boot_rom_ = false;
}
inline bool Bios_Characteristics::socketed_boot_rom() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.socketed_boot_rom)
  return socketed_boot_rom_;
}
inline void Bios_Characteristics::set_socketed_boot_rom(bool value) {
  
  socketed_boot_rom_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.socketed_boot_rom)
}

// bool boot_from_pc_card = 15;
inline void Bios_Characteristics::clear_boot_from_pc_card() {
  boot_from_pc_card_ = false;
}
inline bool Bios_Characteristics::boot_from_pc_card() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.boot_from_pc_card)
  return boot_from_pc_card_;
}
inline void Bios_Characteristics::set_boot_from_pc_card(bool value) {
  
  boot_from_pc_card_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.boot_from_pc_card)
}

// bool edd = 16;
inline void Bios_Characteristics::clear_edd() {
  edd_ = false;
}
inline bool Bios_Characteristics::edd() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.edd)
  return edd_;
}
inline void Bios_Characteristics::set_edd(bool value) {
  
  edd_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.edd)
}

// bool japanese_floppy_for_nec9800 = 17;
inline void Bios_Characteristics::clear_japanese_floppy_for_nec9800() {
  japanese_floppy_for_nec9800_ = false;
}
inline bool Bios_Characteristics::japanese_floppy_for_nec9800() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.japanese_floppy_for_nec9800)
  return japanese_floppy_for_nec9800_;
}
inline void Bios_Characteristics::set_japanese_floppy_for_nec9800(bool value) {
  
  japanese_floppy_for_nec9800_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.japanese_floppy_for_nec9800)
}

// bool japanese_floppy_for_toshiba = 18;
inline void Bios_Characteristics::clear_japanese_floppy_for_toshiba() {
  japanese_floppy_for_toshiba_ = false;
}
inline bool Bios_Characteristics::japanese_floppy_for_toshiba() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.japanese_floppy_for_toshiba)
  return japanese_floppy_for_toshiba_;
}
inline void Bios_Characteristics::set_japanese_floppy_for_toshiba(bool value) {
  
  japanese_floppy_for_toshiba_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.japanese_floppy_for_toshiba)
}

// bool floppy_525_360kb = 19;
inline void Bios_Characteristics::clear_floppy_525_360kb() {
  floppy_525_360kb_ = false;
}
inline bool Bios_Characteristics::floppy_525_360kb() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.floppy_525_360kb)
  return floppy_525_360kb_;
}
inline void Bios_Characteristics::set_floppy_525_360kb(bool value) {
  
  floppy_525_360kb_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.floppy_525_360kb)
}

// bool floppy_525_12mb = 20;
inline void Bios_Characteristics::clear_floppy_525_12mb() {
  floppy_525_12mb_ = false;
}
inline bool Bios_Characteristics::floppy_525_12mb() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.floppy_525_12mb)
  return floppy_525_12mb_;
}
inline void Bios_Characteristics::set_floppy_525_12mb(bool value) {
  
  floppy_525_12mb_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.floppy_525_12mb)
}

// bool floppy_35_720kb = 21;
inline void Bios_Characteristics::clear_floppy_35_720kb() {
  floppy_35_720kb_ = false;
}
inline bool Bios_Characteristics::floppy_35_720kb() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.floppy_35_720kb)
  return floppy_35_720kb_;
}
inline void Bios_Characteristics::set_floppy_35_720kb(bool value) {
  
  floppy_35_720kb_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.floppy_35_720kb)
}

// bool floppy_35_288mb = 22;
inline void Bios_Characteristics::clear_floppy_35_288mb() {
  floppy_35_288mb_ = false;
}
inline bool Bios_Characteristics::floppy_35_288mb() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.floppy_35_288mb)
  return floppy_35_288mb_;
}
inline void Bios_Characteristics::set_floppy_35_288mb(bool value) {
  
  floppy_35_288mb_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.floppy_35_288mb)
}

// bool print_screen = 23;
inline void Bios_Characteristics::clear_print_screen() {
  print_screen_ = false;
}
inline bool Bios_Characteristics::print_screen() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.print_screen)
  return print_screen_;
}
inline void Bios_Characteristics::set_print_screen(bool value) {
  
  print_screen_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.print_screen)
}

// bool keyboard_8042 = 24;
inline void Bios_Characteristics::clear_keyboard_8042() {
  keyboard_8042_ = false;
}
inline bool Bios_Characteristics::keyboard_8042() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.keyboard_8042)
  return keyboard_8042_;
}
inline void Bios_Characteristics::set_keyboard_8042(bool value) {
  
  keyboard_8042_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.keyboard_8042)
}

// bool serial = 25;
inline void Bios_Characteristics::clear_serial() {
  serial_ = false;
}
inline bool Bios_Characteristics::serial() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.serial)
  return serial_;
}
inline void Bios_Characteristics::set_serial(bool value) {
  
  serial_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.serial)
}

// bool printer = 26;
inline void Bios_Characteristics::clear_printer() {
  printer_ = false;
}
inline bool Bios_Characteristics::printer() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.printer)
  return printer_;
}
inline void Bios_Characteristics::set_printer(bool value) {
  
  printer_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.printer)
}

// bool cga_video = 27;
inline void Bios_Characteristics::clear_cga_video() {
  cga_video_ = false;
}
inline bool Bios_Characteristics::cga_video() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.cga_video)
  return cga_video_;
}
inline void Bios_Characteristics::set_cga_video(bool value) {
  
  cga_video_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.cga_video)
}

// bool nec_pc98 = 28;
inline void Bios_Characteristics::clear_nec_pc98() {
  nec_pc98_ = false;
}
inline bool Bios_Characteristics::nec_pc98() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.nec_pc98)
  return nec_pc98_;
}
inline void Bios_Characteristics::set_nec_pc98(bool value) {
  
  nec_pc98_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.nec_pc98)
}

// bool acpi = 29;
inline void Bios_Characteristics::clear_acpi() {
  acpi_ = false;
}
inline bool Bios_Characteristics::acpi() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.acpi)
  return acpi_;
}
inline void Bios_Characteristics::set_acpi(bool value) {
  
  acpi_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.acpi)
}

// bool usb_legacy = 30;
inline void Bios_Characteristics::clear_usb_legacy() {
  usb_legacy_ = false;
}
inline bool Bios_Characteristics::usb_legacy() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.usb_legacy)
  return usb_legacy_;
}
inline void Bios_Characteristics::set_usb_legacy(bool value) {
  
  usb_legacy_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.usb_legacy)
}

// bool agp = 31;
inline void Bios_Characteristics::clear_agp() {
  agp_ = false;
}
inline bool Bios_Characteristics::agp() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.agp)
  return agp_;
}
inline void Bios_Characteristics::set_agp(bool value) {
  
  agp_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.agp)
}

// bool i2o_boot = 32;
inline void Bios_Characteristics::clear_i2o_boot() {
  i2o_boot_ = false;
}
inline bool Bios_Characteristics::i2o_boot() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.i2o_boot)
  return i2o_boot_;
}
inline void Bios_Characteristics::set_i2o_boot(bool value) {
  
  i2o_boot_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.i2o_boot)
}

// bool ls120_boot = 33;
inline void Bios_Characteristics::clear_ls120_boot() {
  ls120_boot_ = false;
}
inline bool Bios_Characteristics::ls120_boot() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.ls120_boot)
  return ls120_boot_;
}
inline void Bios_Characteristics::set_ls120_boot(bool value) {
  
  ls120_boot_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.ls120_boot)
}

// bool atapi_zip_drive_boot = 34;
inline void Bios_Characteristics::clear_atapi_zip_drive_boot() {
  atapi_zip_drive_boot_ = false;
}
inline bool Bios_Characteristics::atapi_zip_drive_boot() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.atapi_zip_drive_boot)
  return atapi_zip_drive_boot_;
}
inline void Bios_Characteristics::set_atapi_zip_drive_boot(bool value) {
  
  atapi_zip_drive_boot_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.atapi_zip_drive_boot)
}

// bool ieee1394_boot = 35;
inline void Bios_Characteristics::clear_ieee1394_boot() {
  ieee1394_boot_ = false;
}
inline bool Bios_Characteristics::ieee1394_boot() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.ieee1394_boot)
  return ieee1394_boot_;
}
inline void Bios_Characteristics::set_ieee1394_boot(bool value) {
  
  ieee1394_boot_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.ieee1394_boot)
}

// bool smart_battery = 36;
inline void Bios_Characteristics::clear_smart_battery() {
  smart_battery_ = false;
}
inline bool Bios_Characteristics::smart_battery() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.smart_battery)
  return smart_battery_;
}
inline void Bios_Characteristics::set_smart_battery(bool value) {
  
  smart_battery_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.smart_battery)
}

// bool bios_boot_specification = 37;
inline void Bios_Characteristics::clear_bios_boot_specification() {
  bios_boot_specification_ = false;
}
inline bool Bios_Characteristics::bios_boot_specification() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.bios_boot_specification)
  return bios_boot_specification_;
}
inline void Bios_Characteristics::set_bios_boot_specification(bool value) {
  
  bios_boot_specification_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.bios_boot_specification)
}

// bool key_init_network_boot = 38;
inline void Bios_Characteristics::clear_key_init_network_boot() {
  key_init_network_boot_ = false;
}
inline bool Bios_Characteristics::key_init_network_boot() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.key_init_network_boot)
  return key_init_network_boot_;
}
inline void Bios_Characteristics::set_key_init_network_boot(bool value) {
  
  key_init_network_boot_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.key_init_network_boot)
}

// bool targeted_content_distrib = 39;
inline void Bios_Characteristics::clear_targeted_content_distrib() {
  targeted_content_distrib_ = false;
}
inline bool Bios_Characteristics::targeted_content_distrib() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.targeted_content_distrib)
  return targeted_content_distrib_;
}
inline void Bios_Characteristics::set_targeted_content_distrib(bool value) {
  
  targeted_content_distrib_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.targeted_content_distrib)
}

// bool uefi = 40;
inline void Bios_Characteristics::clear_uefi() {
  uefi_ = false;
}
inline bool Bios_Characteristics::uefi() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.uefi)
  return uefi_;
}
inline void Bios_Characteristics::set_uefi(bool value) {
  
  uefi_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.uefi)
}

// bool virtual_machine = 41;
inline void Bios_Characteristics::clear_virtual_machine() {
  virtual_machine_ = false;
}
inline bool Bios_Characteristics::virtual_machine() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.Characteristics.virtual_machine)
  return virtual_machine_;
}
inline void Bios_Characteristics::set_virtual_machine(bool value) {
  
  virtual_machine_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.Characteristics.virtual_machine)
}

// -------------------------------------------------------------------

// Bios

// string manufacturer = 1;
inline void Bios::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Bios::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void Bios::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.manufacturer)
}
#if LANG_CXX11
inline void Bios::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Bios.manufacturer)
}
#endif
inline void Bios::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Bios.manufacturer)
}
inline void Bios::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Bios.manufacturer)
}
inline ::std::string* Bios::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Bios.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Bios::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Bios.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Bios::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Bios.manufacturer)
}

// string version = 2;
inline void Bios::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Bios::version() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.version)
  return version_.GetNoArena();
}
inline void Bios::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.version)
}
#if LANG_CXX11
inline void Bios::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Bios.version)
}
#endif
inline void Bios::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Bios.version)
}
inline void Bios::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Bios.version)
}
inline ::std::string* Bios::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Bios.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Bios::release_version() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Bios.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Bios::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Bios.version)
}

// string date = 3;
inline void Bios::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Bios::date() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.date)
  return date_.GetNoArena();
}
inline void Bios::set_date(const ::std::string& value) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.date)
}
#if LANG_CXX11
inline void Bios::set_date(::std::string&& value) {
  
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Bios.date)
}
#endif
inline void Bios::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Bios.date)
}
inline void Bios::set_date(const char* value, size_t size) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Bios.date)
}
inline ::std::string* Bios::mutable_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Bios.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Bios::release_date() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Bios.date)
  
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Bios::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    
  } else {
    
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Bios.date)
}

// uint64 size = 4;
inline void Bios::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Bios::size() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.size)
  return size_;
}
inline void Bios::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.size)
}

// string bios_revision = 5;
inline void Bios::clear_bios_revision() {
  bios_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Bios::bios_revision() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.bios_revision)
  return bios_revision_.GetNoArena();
}
inline void Bios::set_bios_revision(const ::std::string& value) {
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.bios_revision)
}
#if LANG_CXX11
inline void Bios::set_bios_revision(::std::string&& value) {
  
  bios_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Bios.bios_revision)
}
#endif
inline void Bios::set_bios_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Bios.bios_revision)
}
inline void Bios::set_bios_revision(const char* value, size_t size) {
  
  bios_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Bios.bios_revision)
}
inline ::std::string* Bios::mutable_bios_revision() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Bios.bios_revision)
  return bios_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Bios::release_bios_revision() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Bios.bios_revision)
  
  return bios_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Bios::set_allocated_bios_revision(::std::string* bios_revision) {
  if (bios_revision != NULL) {
    
  } else {
    
  }
  bios_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bios_revision);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Bios.bios_revision)
}

// string firmware_revision = 6;
inline void Bios::clear_firmware_revision() {
  firmware_revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Bios::firmware_revision() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.firmware_revision)
  return firmware_revision_.GetNoArena();
}
inline void Bios::set_firmware_revision(const ::std::string& value) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.firmware_revision)
}
#if LANG_CXX11
inline void Bios::set_firmware_revision(::std::string&& value) {
  
  firmware_revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Bios.firmware_revision)
}
#endif
inline void Bios::set_firmware_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Bios.firmware_revision)
}
inline void Bios::set_firmware_revision(const char* value, size_t size) {
  
  firmware_revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Bios.firmware_revision)
}
inline ::std::string* Bios::mutable_firmware_revision() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Bios.firmware_revision)
  return firmware_revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Bios::release_firmware_revision() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Bios.firmware_revision)
  
  return firmware_revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Bios::set_allocated_firmware_revision(::std::string* firmware_revision) {
  if (firmware_revision != NULL) {
    
  } else {
    
  }
  firmware_revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware_revision);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Bios.firmware_revision)
}

// string address = 7;
inline void Bios::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Bios::address() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.address)
  return address_.GetNoArena();
}
inline void Bios::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.address)
}
#if LANG_CXX11
inline void Bios::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Bios.address)
}
#endif
inline void Bios::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Bios.address)
}
inline void Bios::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Bios.address)
}
inline ::std::string* Bios::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Bios.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Bios::release_address() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Bios.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Bios::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Bios.address)
}

// uint64 runtime_size = 8;
inline void Bios::clear_runtime_size() {
  runtime_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Bios::runtime_size() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.runtime_size)
  return runtime_size_;
}
inline void Bios::set_runtime_size(::google::protobuf::uint64 value) {
  
  runtime_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Bios.runtime_size)
}

// .aspia.system_info.dmi.Bios.Characteristics characteristics = 9;
inline bool Bios::has_characteristics() const {
  return this != internal_default_instance() && characteristics_ != NULL;
}
inline void Bios::clear_characteristics() {
  if (GetArenaNoVirtual() == NULL && characteristics_ != NULL) {
    delete characteristics_;
  }
  characteristics_ = NULL;
}
inline const ::aspia::system_info::dmi::Bios_Characteristics& Bios::_internal_characteristics() const {
  return *characteristics_;
}
inline const ::aspia::system_info::dmi::Bios_Characteristics& Bios::characteristics() const {
  const ::aspia::system_info::dmi::Bios_Characteristics* p = characteristics_;
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Bios.characteristics)
  return p != NULL ? *p : *reinterpret_cast<const ::aspia::system_info::dmi::Bios_Characteristics*>(
      &::aspia::system_info::dmi::_Bios_Characteristics_default_instance_);
}
inline ::aspia::system_info::dmi::Bios_Characteristics* Bios::release_characteristics() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Bios.characteristics)
  
  ::aspia::system_info::dmi::Bios_Characteristics* temp = characteristics_;
  characteristics_ = NULL;
  return temp;
}
inline ::aspia::system_info::dmi::Bios_Characteristics* Bios::mutable_characteristics() {
  
  if (characteristics_ == NULL) {
    auto* p = CreateMaybeMessage<::aspia::system_info::dmi::Bios_Characteristics>(GetArenaNoVirtual());
    characteristics_ = p;
  }
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Bios.characteristics)
  return characteristics_;
}
inline void Bios::set_allocated_characteristics(::aspia::system_info::dmi::Bios_Characteristics* characteristics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete characteristics_;
  }
  if (characteristics) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      characteristics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, characteristics, submessage_arena);
    }
    
  } else {
    
  }
  characteristics_ = characteristics;
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Bios.characteristics)
}

// -------------------------------------------------------------------

// Cache

// string name = 1;
inline void Cache::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Cache::name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.name)
  return name_.GetNoArena();
}
inline void Cache::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.name)
}
#if LANG_CXX11
inline void Cache::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Cache.name)
}
#endif
inline void Cache::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Cache.name)
}
inline void Cache::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Cache.name)
}
inline ::std::string* Cache::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Cache.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Cache::release_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Cache.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Cache::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Cache.name)
}

// .aspia.system_info.dmi.Cache.Location location = 2;
inline void Cache::clear_location() {
  location_ = 0;
}
inline ::aspia::system_info::dmi::Cache_Location Cache::location() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.location)
  return static_cast< ::aspia::system_info::dmi::Cache_Location >(location_);
}
inline void Cache::set_location(::aspia::system_info::dmi::Cache_Location value) {
  
  location_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.location)
}

// .aspia.system_info.dmi.Cache.Status status = 3;
inline void Cache::clear_status() {
  status_ = 0;
}
inline ::aspia::system_info::dmi::Cache_Status Cache::status() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.status)
  return static_cast< ::aspia::system_info::dmi::Cache_Status >(status_);
}
inline void Cache::set_status(::aspia::system_info::dmi::Cache_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.status)
}

// .aspia.system_info.dmi.Cache.Mode mode = 4;
inline void Cache::clear_mode() {
  mode_ = 0;
}
inline ::aspia::system_info::dmi::Cache_Mode Cache::mode() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.mode)
  return static_cast< ::aspia::system_info::dmi::Cache_Mode >(mode_);
}
inline void Cache::set_mode(::aspia::system_info::dmi::Cache_Mode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.mode)
}

// int32 level = 5;
inline void Cache::clear_level() {
  level_ = 0;
}
inline ::google::protobuf::int32 Cache::level() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.level)
  return level_;
}
inline void Cache::set_level(::google::protobuf::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.level)
}

// int32 maximum_size = 6;
inline void Cache::clear_maximum_size() {
  maximum_size_ = 0;
}
inline ::google::protobuf::int32 Cache::maximum_size() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.maximum_size)
  return maximum_size_;
}
inline void Cache::set_maximum_size(::google::protobuf::int32 value) {
  
  maximum_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.maximum_size)
}

// int32 current_size = 7;
inline void Cache::clear_current_size() {
  current_size_ = 0;
}
inline ::google::protobuf::int32 Cache::current_size() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.current_size)
  return current_size_;
}
inline void Cache::set_current_size(::google::protobuf::int32 value) {
  
  current_size_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.current_size)
}

// uint32 supported_sram_types = 8;
inline void Cache::clear_supported_sram_types() {
  supported_sram_types_ = 0u;
}
inline ::google::protobuf::uint32 Cache::supported_sram_types() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.supported_sram_types)
  return supported_sram_types_;
}
inline void Cache::set_supported_sram_types(::google::protobuf::uint32 value) {
  
  supported_sram_types_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.supported_sram_types)
}

// .aspia.system_info.dmi.Cache.SRAMType current_sram_type = 9;
inline void Cache::clear_current_sram_type() {
  current_sram_type_ = 0;
}
inline ::aspia::system_info::dmi::Cache_SRAMType Cache::current_sram_type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.current_sram_type)
  return static_cast< ::aspia::system_info::dmi::Cache_SRAMType >(current_sram_type_);
}
inline void Cache::set_current_sram_type(::aspia::system_info::dmi::Cache_SRAMType value) {
  
  current_sram_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.current_sram_type)
}

// int32 speed = 10;
inline void Cache::clear_speed() {
  speed_ = 0;
}
inline ::google::protobuf::int32 Cache::speed() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.speed)
  return speed_;
}
inline void Cache::set_speed(::google::protobuf::int32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.speed)
}

// .aspia.system_info.dmi.Cache.ErrorCorrectionType error_correction_type = 11;
inline void Cache::clear_error_correction_type() {
  error_correction_type_ = 0;
}
inline ::aspia::system_info::dmi::Cache_ErrorCorrectionType Cache::error_correction_type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.error_correction_type)
  return static_cast< ::aspia::system_info::dmi::Cache_ErrorCorrectionType >(error_correction_type_);
}
inline void Cache::set_error_correction_type(::aspia::system_info::dmi::Cache_ErrorCorrectionType value) {
  
  error_correction_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.error_correction_type)
}

// .aspia.system_info.dmi.Cache.Type type = 12;
inline void Cache::clear_type() {
  type_ = 0;
}
inline ::aspia::system_info::dmi::Cache_Type Cache::type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.type)
  return static_cast< ::aspia::system_info::dmi::Cache_Type >(type_);
}
inline void Cache::set_type(::aspia::system_info::dmi::Cache_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.type)
}

// .aspia.system_info.dmi.Cache.Associativity associativity = 13;
inline void Cache::clear_associativity() {
  associativity_ = 0;
}
inline ::aspia::system_info::dmi::Cache_Associativity Cache::associativity() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Cache.associativity)
  return static_cast< ::aspia::system_info::dmi::Cache_Associativity >(associativity_);
}
inline void Cache::set_associativity(::aspia::system_info::dmi::Cache_Associativity value) {
  
  associativity_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Cache.associativity)
}

// -------------------------------------------------------------------

// Chassis

// string manufacturer = 1;
inline void Chassis::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chassis::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Chassis.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void Chassis::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Chassis.manufacturer)
}
#if LANG_CXX11
inline void Chassis::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Chassis.manufacturer)
}
#endif
inline void Chassis::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Chassis.manufacturer)
}
inline void Chassis::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Chassis.manufacturer)
}
inline ::std::string* Chassis::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Chassis.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chassis::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Chassis.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chassis::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Chassis.manufacturer)
}

// string version = 2;
inline void Chassis::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chassis::version() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Chassis.version)
  return version_.GetNoArena();
}
inline void Chassis::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Chassis.version)
}
#if LANG_CXX11
inline void Chassis::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Chassis.version)
}
#endif
inline void Chassis::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Chassis.version)
}
inline void Chassis::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Chassis.version)
}
inline ::std::string* Chassis::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Chassis.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chassis::release_version() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Chassis.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chassis::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Chassis.version)
}

// string serial_number = 3;
inline void Chassis::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chassis::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Chassis.serial_number)
  return serial_number_.GetNoArena();
}
inline void Chassis::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Chassis.serial_number)
}
#if LANG_CXX11
inline void Chassis::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Chassis.serial_number)
}
#endif
inline void Chassis::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Chassis.serial_number)
}
inline void Chassis::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Chassis.serial_number)
}
inline ::std::string* Chassis::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Chassis.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chassis::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Chassis.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chassis::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Chassis.serial_number)
}

// string asset_tag = 4;
inline void Chassis::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Chassis::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Chassis.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void Chassis::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Chassis.asset_tag)
}
#if LANG_CXX11
inline void Chassis::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Chassis.asset_tag)
}
#endif
inline void Chassis::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Chassis.asset_tag)
}
inline void Chassis::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Chassis.asset_tag)
}
inline ::std::string* Chassis::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Chassis.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Chassis::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Chassis.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Chassis::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Chassis.asset_tag)
}

// .aspia.system_info.dmi.Chassis.Type type = 5;
inline void Chassis::clear_type() {
  type_ = 0;
}
inline ::aspia::system_info::dmi::Chassis_Type Chassis::type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Chassis.type)
  return static_cast< ::aspia::system_info::dmi::Chassis_Type >(type_);
}
inline void Chassis::set_type(::aspia::system_info::dmi::Chassis_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Chassis.type)
}

// .aspia.system_info.dmi.Chassis.Status os_load_status = 6;
inline void Chassis::clear_os_load_status() {
  os_load_status_ = 0;
}
inline ::aspia::system_info::dmi::Chassis_Status Chassis::os_load_status() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Chassis.os_load_status)
  return static_cast< ::aspia::system_info::dmi::Chassis_Status >(os_load_status_);
}
inline void Chassis::set_os_load_status(::aspia::system_info::dmi::Chassis_Status value) {
  
  os_load_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Chassis.os_load_status)
}

// .aspia.system_info.dmi.Chassis.Status power_source_status = 7;
inline void Chassis::clear_power_source_status() {
  power_source_status_ = 0;
}
inline ::aspia::system_info::dmi::Chassis_Status Chassis::power_source_status() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Chassis.power_source_status)
  return static_cast< ::aspia::system_info::dmi::Chassis_Status >(power_source_status_);
}
inline void Chassis::set_power_source_status(::aspia::system_info::dmi::Chassis_Status value) {
  
  power_source_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Chassis.power_source_status)
}

// .aspia.system_info.dmi.Chassis.Status temparature_status = 8;
inline void Chassis::clear_temparature_status() {
  temparature_status_ = 0;
}
inline ::aspia::system_info::dmi::Chassis_Status Chassis::temparature_status() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Chassis.temparature_status)
  return static_cast< ::aspia::system_info::dmi::Chassis_Status >(temparature_status_);
}
inline void Chassis::set_temparature_status(::aspia::system_info::dmi::Chassis_Status value) {
  
  temparature_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Chassis.temparature_status)
}

// .aspia.system_info.dmi.Chassis.SecurityStatus security_status = 9;
inline void Chassis::clear_security_status() {
  security_status_ = 0;
}
inline ::aspia::system_info::dmi::Chassis_SecurityStatus Chassis::security_status() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Chassis.security_status)
  return static_cast< ::aspia::system_info::dmi::Chassis_SecurityStatus >(security_status_);
}
inline void Chassis::set_security_status(::aspia::system_info::dmi::Chassis_SecurityStatus value) {
  
  security_status_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Chassis.security_status)
}

// int32 height = 10;
inline void Chassis::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 Chassis::height() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Chassis.height)
  return height_;
}
inline void Chassis::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Chassis.height)
}

// int32 number_of_power_cords = 11;
inline void Chassis::clear_number_of_power_cords() {
  number_of_power_cords_ = 0;
}
inline ::google::protobuf::int32 Chassis::number_of_power_cords() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Chassis.number_of_power_cords)
  return number_of_power_cords_;
}
inline void Chassis::set_number_of_power_cords(::google::protobuf::int32 value) {
  
  number_of_power_cords_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Chassis.number_of_power_cords)
}

// -------------------------------------------------------------------

// MemoryDevice

// string device_locator = 1;
inline void MemoryDevice::clear_device_locator() {
  device_locator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MemoryDevice::device_locator() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.MemoryDevice.device_locator)
  return device_locator_.GetNoArena();
}
inline void MemoryDevice::set_device_locator(const ::std::string& value) {
  
  device_locator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.MemoryDevice.device_locator)
}
#if LANG_CXX11
inline void MemoryDevice::set_device_locator(::std::string&& value) {
  
  device_locator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.MemoryDevice.device_locator)
}
#endif
inline void MemoryDevice::set_device_locator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_locator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.MemoryDevice.device_locator)
}
inline void MemoryDevice::set_device_locator(const char* value, size_t size) {
  
  device_locator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.MemoryDevice.device_locator)
}
inline ::std::string* MemoryDevice::mutable_device_locator() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.MemoryDevice.device_locator)
  return device_locator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemoryDevice::release_device_locator() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.MemoryDevice.device_locator)
  
  return device_locator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemoryDevice::set_allocated_device_locator(::std::string* device_locator) {
  if (device_locator != NULL) {
    
  } else {
    
  }
  device_locator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_locator);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.MemoryDevice.device_locator)
}

// uint64 size = 2;
inline void MemoryDevice::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 MemoryDevice::size() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.MemoryDevice.size)
  return size_;
}
inline void MemoryDevice::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.MemoryDevice.size)
}

// string type = 3;
inline void MemoryDevice::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MemoryDevice::type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.MemoryDevice.type)
  return type_.GetNoArena();
}
inline void MemoryDevice::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.MemoryDevice.type)
}
#if LANG_CXX11
inline void MemoryDevice::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.MemoryDevice.type)
}
#endif
inline void MemoryDevice::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.MemoryDevice.type)
}
inline void MemoryDevice::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.MemoryDevice.type)
}
inline ::std::string* MemoryDevice::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.MemoryDevice.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemoryDevice::release_type() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.MemoryDevice.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemoryDevice::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.MemoryDevice.type)
}

// int32 speed = 4;
inline void MemoryDevice::clear_speed() {
  speed_ = 0;
}
inline ::google::protobuf::int32 MemoryDevice::speed() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.MemoryDevice.speed)
  return speed_;
}
inline void MemoryDevice::set_speed(::google::protobuf::int32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.MemoryDevice.speed)
}

// string form_factor = 5;
inline void MemoryDevice::clear_form_factor() {
  form_factor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MemoryDevice::form_factor() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.MemoryDevice.form_factor)
  return form_factor_.GetNoArena();
}
inline void MemoryDevice::set_form_factor(const ::std::string& value) {
  
  form_factor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.MemoryDevice.form_factor)
}
#if LANG_CXX11
inline void MemoryDevice::set_form_factor(::std::string&& value) {
  
  form_factor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.MemoryDevice.form_factor)
}
#endif
inline void MemoryDevice::set_form_factor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  form_factor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.MemoryDevice.form_factor)
}
inline void MemoryDevice::set_form_factor(const char* value, size_t size) {
  
  form_factor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.MemoryDevice.form_factor)
}
inline ::std::string* MemoryDevice::mutable_form_factor() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.MemoryDevice.form_factor)
  return form_factor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemoryDevice::release_form_factor() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.MemoryDevice.form_factor)
  
  return form_factor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemoryDevice::set_allocated_form_factor(::std::string* form_factor) {
  if (form_factor != NULL) {
    
  } else {
    
  }
  form_factor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), form_factor);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.MemoryDevice.form_factor)
}

// string serial_number = 6;
inline void MemoryDevice::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MemoryDevice::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.MemoryDevice.serial_number)
  return serial_number_.GetNoArena();
}
inline void MemoryDevice::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.MemoryDevice.serial_number)
}
#if LANG_CXX11
inline void MemoryDevice::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.MemoryDevice.serial_number)
}
#endif
inline void MemoryDevice::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.MemoryDevice.serial_number)
}
inline void MemoryDevice::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.MemoryDevice.serial_number)
}
inline ::std::string* MemoryDevice::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.MemoryDevice.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemoryDevice::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.MemoryDevice.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemoryDevice::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.MemoryDevice.serial_number)
}

// string part_number = 7;
inline void MemoryDevice::clear_part_number() {
  part_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MemoryDevice::part_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.MemoryDevice.part_number)
  return part_number_.GetNoArena();
}
inline void MemoryDevice::set_part_number(const ::std::string& value) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.MemoryDevice.part_number)
}
#if LANG_CXX11
inline void MemoryDevice::set_part_number(::std::string&& value) {
  
  part_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.MemoryDevice.part_number)
}
#endif
inline void MemoryDevice::set_part_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.MemoryDevice.part_number)
}
inline void MemoryDevice::set_part_number(const char* value, size_t size) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.MemoryDevice.part_number)
}
inline ::std::string* MemoryDevice::mutable_part_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.MemoryDevice.part_number)
  return part_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemoryDevice::release_part_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.MemoryDevice.part_number)
  
  return part_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemoryDevice::set_allocated_part_number(::std::string* part_number) {
  if (part_number != NULL) {
    
  } else {
    
  }
  part_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), part_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.MemoryDevice.part_number)
}

// string manufactorer = 8;
inline void MemoryDevice::clear_manufactorer() {
  manufactorer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MemoryDevice::manufactorer() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.MemoryDevice.manufactorer)
  return manufactorer_.GetNoArena();
}
inline void MemoryDevice::set_manufactorer(const ::std::string& value) {
  
  manufactorer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.MemoryDevice.manufactorer)
}
#if LANG_CXX11
inline void MemoryDevice::set_manufactorer(::std::string&& value) {
  
  manufactorer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.MemoryDevice.manufactorer)
}
#endif
inline void MemoryDevice::set_manufactorer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufactorer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.MemoryDevice.manufactorer)
}
inline void MemoryDevice::set_manufactorer(const char* value, size_t size) {
  
  manufactorer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.MemoryDevice.manufactorer)
}
inline ::std::string* MemoryDevice::mutable_manufactorer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.MemoryDevice.manufactorer)
  return manufactorer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemoryDevice::release_manufactorer() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.MemoryDevice.manufactorer)
  
  return manufactorer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemoryDevice::set_allocated_manufactorer(::std::string* manufactorer) {
  if (manufactorer != NULL) {
    
  } else {
    
  }
  manufactorer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufactorer);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.MemoryDevice.manufactorer)
}

// string bank = 9;
inline void MemoryDevice::clear_bank() {
  bank_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MemoryDevice::bank() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.MemoryDevice.bank)
  return bank_.GetNoArena();
}
inline void MemoryDevice::set_bank(const ::std::string& value) {
  
  bank_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.MemoryDevice.bank)
}
#if LANG_CXX11
inline void MemoryDevice::set_bank(::std::string&& value) {
  
  bank_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.MemoryDevice.bank)
}
#endif
inline void MemoryDevice::set_bank(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bank_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.MemoryDevice.bank)
}
inline void MemoryDevice::set_bank(const char* value, size_t size) {
  
  bank_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.MemoryDevice.bank)
}
inline ::std::string* MemoryDevice::mutable_bank() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.MemoryDevice.bank)
  return bank_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemoryDevice::release_bank() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.MemoryDevice.bank)
  
  return bank_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemoryDevice::set_allocated_bank(::std::string* bank) {
  if (bank != NULL) {
    
  } else {
    
  }
  bank_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bank);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.MemoryDevice.bank)
}

// int32 total_width = 10;
inline void MemoryDevice::clear_total_width() {
  total_width_ = 0;
}
inline ::google::protobuf::int32 MemoryDevice::total_width() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.MemoryDevice.total_width)
  return total_width_;
}
inline void MemoryDevice::set_total_width(::google::protobuf::int32 value) {
  
  total_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.MemoryDevice.total_width)
}

// int32 data_width = 11;
inline void MemoryDevice::clear_data_width() {
  data_width_ = 0;
}
inline ::google::protobuf::int32 MemoryDevice::data_width() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.MemoryDevice.data_width)
  return data_width_;
}
inline void MemoryDevice::set_data_width(::google::protobuf::int32 value) {
  
  data_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.MemoryDevice.data_width)
}

// -------------------------------------------------------------------

// OnBoardDevice

// string description = 1;
inline void OnBoardDevice::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OnBoardDevice::description() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.OnBoardDevice.description)
  return description_.GetNoArena();
}
inline void OnBoardDevice::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.OnBoardDevice.description)
}
#if LANG_CXX11
inline void OnBoardDevice::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.OnBoardDevice.description)
}
#endif
inline void OnBoardDevice::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.OnBoardDevice.description)
}
inline void OnBoardDevice::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.OnBoardDevice.description)
}
inline ::std::string* OnBoardDevice::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.OnBoardDevice.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OnBoardDevice::release_description() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.OnBoardDevice.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OnBoardDevice::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.OnBoardDevice.description)
}

// .aspia.system_info.dmi.OnBoardDevice.Type type = 2;
inline void OnBoardDevice::clear_type() {
  type_ = 0;
}
inline ::aspia::system_info::dmi::OnBoardDevice_Type OnBoardDevice::type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.OnBoardDevice.type)
  return static_cast< ::aspia::system_info::dmi::OnBoardDevice_Type >(type_);
}
inline void OnBoardDevice::set_type(::aspia::system_info::dmi::OnBoardDevice_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.OnBoardDevice.type)
}

// bool enabled = 3;
inline void OnBoardDevice::clear_enabled() {
  enabled_ = false;
}
inline bool OnBoardDevice::enabled() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.OnBoardDevice.enabled)
  return enabled_;
}
inline void OnBoardDevice::set_enabled(bool value) {
  
  enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.OnBoardDevice.enabled)
}

// -------------------------------------------------------------------

// PointingDevice

// .aspia.system_info.dmi.PointingDevice.Type device_type = 1;
inline void PointingDevice::clear_device_type() {
  device_type_ = 0;
}
inline ::aspia::system_info::dmi::PointingDevice_Type PointingDevice::device_type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PointingDevice.device_type)
  return static_cast< ::aspia::system_info::dmi::PointingDevice_Type >(device_type_);
}
inline void PointingDevice::set_device_type(::aspia::system_info::dmi::PointingDevice_Type value) {
  
  device_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PointingDevice.device_type)
}

// .aspia.system_info.dmi.PointingDevice.Interface device_interface = 2;
inline void PointingDevice::clear_device_interface() {
  device_interface_ = 0;
}
inline ::aspia::system_info::dmi::PointingDevice_Interface PointingDevice::device_interface() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PointingDevice.device_interface)
  return static_cast< ::aspia::system_info::dmi::PointingDevice_Interface >(device_interface_);
}
inline void PointingDevice::set_device_interface(::aspia::system_info::dmi::PointingDevice_Interface value) {
  
  device_interface_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PointingDevice.device_interface)
}

// int32 button_count = 3;
inline void PointingDevice::clear_button_count() {
  button_count_ = 0;
}
inline ::google::protobuf::int32 PointingDevice::button_count() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PointingDevice.button_count)
  return button_count_;
}
inline void PointingDevice::set_button_count(::google::protobuf::int32 value) {
  
  button_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PointingDevice.button_count)
}

// -------------------------------------------------------------------

// PortConnector

// string internal_designation = 1;
inline void PortConnector::clear_internal_designation() {
  internal_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortConnector::internal_designation() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortConnector.internal_designation)
  return internal_designation_.GetNoArena();
}
inline void PortConnector::set_internal_designation(const ::std::string& value) {
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortConnector.internal_designation)
}
#if LANG_CXX11
inline void PortConnector::set_internal_designation(::std::string&& value) {
  
  internal_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortConnector.internal_designation)
}
#endif
inline void PortConnector::set_internal_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortConnector.internal_designation)
}
inline void PortConnector::set_internal_designation(const char* value, size_t size) {
  
  internal_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortConnector.internal_designation)
}
inline ::std::string* PortConnector::mutable_internal_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortConnector.internal_designation)
  return internal_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortConnector::release_internal_designation() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortConnector.internal_designation)
  
  return internal_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortConnector::set_allocated_internal_designation(::std::string* internal_designation) {
  if (internal_designation != NULL) {
    
  } else {
    
  }
  internal_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), internal_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortConnector.internal_designation)
}

// string external_designation = 2;
inline void PortConnector::clear_external_designation() {
  external_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortConnector::external_designation() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortConnector.external_designation)
  return external_designation_.GetNoArena();
}
inline void PortConnector::set_external_designation(const ::std::string& value) {
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortConnector.external_designation)
}
#if LANG_CXX11
inline void PortConnector::set_external_designation(::std::string&& value) {
  
  external_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortConnector.external_designation)
}
#endif
inline void PortConnector::set_external_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortConnector.external_designation)
}
inline void PortConnector::set_external_designation(const char* value, size_t size) {
  
  external_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortConnector.external_designation)
}
inline ::std::string* PortConnector::mutable_external_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortConnector.external_designation)
  return external_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortConnector::release_external_designation() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortConnector.external_designation)
  
  return external_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortConnector::set_allocated_external_designation(::std::string* external_designation) {
  if (external_designation != NULL) {
    
  } else {
    
  }
  external_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), external_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortConnector.external_designation)
}

// string type = 3;
inline void PortConnector::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortConnector::type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortConnector.type)
  return type_.GetNoArena();
}
inline void PortConnector::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortConnector.type)
}
#if LANG_CXX11
inline void PortConnector::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortConnector.type)
}
#endif
inline void PortConnector::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortConnector.type)
}
inline void PortConnector::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortConnector.type)
}
inline ::std::string* PortConnector::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortConnector.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortConnector::release_type() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortConnector.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortConnector::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortConnector.type)
}

// string internal_connector_type = 4;
inline void PortConnector::clear_internal_connector_type() {
  internal_connector_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortConnector::internal_connector_type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortConnector.internal_connector_type)
  return internal_connector_type_.GetNoArena();
}
inline void PortConnector::set_internal_connector_type(const ::std::string& value) {
  
  internal_connector_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortConnector.internal_connector_type)
}
#if LANG_CXX11
inline void PortConnector::set_internal_connector_type(::std::string&& value) {
  
  internal_connector_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortConnector.internal_connector_type)
}
#endif
inline void PortConnector::set_internal_connector_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  internal_connector_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortConnector.internal_connector_type)
}
inline void PortConnector::set_internal_connector_type(const char* value, size_t size) {
  
  internal_connector_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortConnector.internal_connector_type)
}
inline ::std::string* PortConnector::mutable_internal_connector_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortConnector.internal_connector_type)
  return internal_connector_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortConnector::release_internal_connector_type() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortConnector.internal_connector_type)
  
  return internal_connector_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortConnector::set_allocated_internal_connector_type(::std::string* internal_connector_type) {
  if (internal_connector_type != NULL) {
    
  } else {
    
  }
  internal_connector_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), internal_connector_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortConnector.internal_connector_type)
}

// string external_connector_type = 5;
inline void PortConnector::clear_external_connector_type() {
  external_connector_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortConnector::external_connector_type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortConnector.external_connector_type)
  return external_connector_type_.GetNoArena();
}
inline void PortConnector::set_external_connector_type(const ::std::string& value) {
  
  external_connector_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortConnector.external_connector_type)
}
#if LANG_CXX11
inline void PortConnector::set_external_connector_type(::std::string&& value) {
  
  external_connector_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortConnector.external_connector_type)
}
#endif
inline void PortConnector::set_external_connector_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  external_connector_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortConnector.external_connector_type)
}
inline void PortConnector::set_external_connector_type(const char* value, size_t size) {
  
  external_connector_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortConnector.external_connector_type)
}
inline ::std::string* PortConnector::mutable_external_connector_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortConnector.external_connector_type)
  return external_connector_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortConnector::release_external_connector_type() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortConnector.external_connector_type)
  
  return external_connector_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortConnector::set_allocated_external_connector_type(::std::string* external_connector_type) {
  if (external_connector_type != NULL) {
    
  } else {
    
  }
  external_connector_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), external_connector_type);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortConnector.external_connector_type)
}

// -------------------------------------------------------------------

// PortableBattery

// string location = 1;
inline void PortableBattery::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortableBattery::location() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.location)
  return location_.GetNoArena();
}
inline void PortableBattery::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.location)
}
#if LANG_CXX11
inline void PortableBattery::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortableBattery.location)
}
#endif
inline void PortableBattery::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortableBattery.location)
}
inline void PortableBattery::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortableBattery.location)
}
inline ::std::string* PortableBattery::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortableBattery.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortableBattery::release_location() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortableBattery.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortableBattery::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortableBattery.location)
}

// string manufacturer = 2;
inline void PortableBattery::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortableBattery::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void PortableBattery::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.manufacturer)
}
#if LANG_CXX11
inline void PortableBattery::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortableBattery.manufacturer)
}
#endif
inline void PortableBattery::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortableBattery.manufacturer)
}
inline void PortableBattery::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortableBattery.manufacturer)
}
inline ::std::string* PortableBattery::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortableBattery.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortableBattery::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortableBattery.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortableBattery::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortableBattery.manufacturer)
}

// string manufacture_date = 3;
inline void PortableBattery::clear_manufacture_date() {
  manufacture_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortableBattery::manufacture_date() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.manufacture_date)
  return manufacture_date_.GetNoArena();
}
inline void PortableBattery::set_manufacture_date(const ::std::string& value) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.manufacture_date)
}
#if LANG_CXX11
inline void PortableBattery::set_manufacture_date(::std::string&& value) {
  
  manufacture_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortableBattery.manufacture_date)
}
#endif
inline void PortableBattery::set_manufacture_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortableBattery.manufacture_date)
}
inline void PortableBattery::set_manufacture_date(const char* value, size_t size) {
  
  manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortableBattery.manufacture_date)
}
inline ::std::string* PortableBattery::mutable_manufacture_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortableBattery.manufacture_date)
  return manufacture_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortableBattery::release_manufacture_date() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortableBattery.manufacture_date)
  
  return manufacture_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortableBattery::set_allocated_manufacture_date(::std::string* manufacture_date) {
  if (manufacture_date != NULL) {
    
  } else {
    
  }
  manufacture_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacture_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortableBattery.manufacture_date)
}

// string serial_number = 4;
inline void PortableBattery::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortableBattery::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.serial_number)
  return serial_number_.GetNoArena();
}
inline void PortableBattery::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.serial_number)
}
#if LANG_CXX11
inline void PortableBattery::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortableBattery.serial_number)
}
#endif
inline void PortableBattery::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortableBattery.serial_number)
}
inline void PortableBattery::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortableBattery.serial_number)
}
inline ::std::string* PortableBattery::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortableBattery.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortableBattery::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortableBattery.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortableBattery::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortableBattery.serial_number)
}

// string device_name = 5;
inline void PortableBattery::clear_device_name() {
  device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortableBattery::device_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.device_name)
  return device_name_.GetNoArena();
}
inline void PortableBattery::set_device_name(const ::std::string& value) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.device_name)
}
#if LANG_CXX11
inline void PortableBattery::set_device_name(::std::string&& value) {
  
  device_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortableBattery.device_name)
}
#endif
inline void PortableBattery::set_device_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortableBattery.device_name)
}
inline void PortableBattery::set_device_name(const char* value, size_t size) {
  
  device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortableBattery.device_name)
}
inline ::std::string* PortableBattery::mutable_device_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortableBattery.device_name)
  return device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortableBattery::release_device_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortableBattery.device_name)
  
  return device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortableBattery::set_allocated_device_name(::std::string* device_name) {
  if (device_name != NULL) {
    
  } else {
    
  }
  device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortableBattery.device_name)
}

// .aspia.system_info.dmi.PortableBattery.Chemistry chemistry = 6;
inline void PortableBattery::clear_chemistry() {
  chemistry_ = 0;
}
inline ::aspia::system_info::dmi::PortableBattery_Chemistry PortableBattery::chemistry() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.chemistry)
  return static_cast< ::aspia::system_info::dmi::PortableBattery_Chemistry >(chemistry_);
}
inline void PortableBattery::set_chemistry(::aspia::system_info::dmi::PortableBattery_Chemistry value) {
  
  chemistry_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.chemistry)
}

// int32 design_capacity = 7;
inline void PortableBattery::clear_design_capacity() {
  design_capacity_ = 0;
}
inline ::google::protobuf::int32 PortableBattery::design_capacity() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.design_capacity)
  return design_capacity_;
}
inline void PortableBattery::set_design_capacity(::google::protobuf::int32 value) {
  
  design_capacity_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.design_capacity)
}

// int32 design_voltage = 8;
inline void PortableBattery::clear_design_voltage() {
  design_voltage_ = 0;
}
inline ::google::protobuf::int32 PortableBattery::design_voltage() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.design_voltage)
  return design_voltage_;
}
inline void PortableBattery::set_design_voltage(::google::protobuf::int32 value) {
  
  design_voltage_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.design_voltage)
}

// string sbds_version_number = 9;
inline void PortableBattery::clear_sbds_version_number() {
  sbds_version_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortableBattery::sbds_version_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.sbds_version_number)
  return sbds_version_number_.GetNoArena();
}
inline void PortableBattery::set_sbds_version_number(const ::std::string& value) {
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.sbds_version_number)
}
#if LANG_CXX11
inline void PortableBattery::set_sbds_version_number(::std::string&& value) {
  
  sbds_version_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortableBattery.sbds_version_number)
}
#endif
inline void PortableBattery::set_sbds_version_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortableBattery.sbds_version_number)
}
inline void PortableBattery::set_sbds_version_number(const char* value, size_t size) {
  
  sbds_version_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortableBattery.sbds_version_number)
}
inline ::std::string* PortableBattery::mutable_sbds_version_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortableBattery.sbds_version_number)
  return sbds_version_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortableBattery::release_sbds_version_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortableBattery.sbds_version_number)
  
  return sbds_version_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortableBattery::set_allocated_sbds_version_number(::std::string* sbds_version_number) {
  if (sbds_version_number != NULL) {
    
  } else {
    
  }
  sbds_version_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_version_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortableBattery.sbds_version_number)
}

// int32 max_error_in_battery_data = 10;
inline void PortableBattery::clear_max_error_in_battery_data() {
  max_error_in_battery_data_ = 0;
}
inline ::google::protobuf::int32 PortableBattery::max_error_in_battery_data() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.max_error_in_battery_data)
  return max_error_in_battery_data_;
}
inline void PortableBattery::set_max_error_in_battery_data(::google::protobuf::int32 value) {
  
  max_error_in_battery_data_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.max_error_in_battery_data)
}

// string sbds_serial_number = 11;
inline void PortableBattery::clear_sbds_serial_number() {
  sbds_serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortableBattery::sbds_serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.sbds_serial_number)
  return sbds_serial_number_.GetNoArena();
}
inline void PortableBattery::set_sbds_serial_number(const ::std::string& value) {
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.sbds_serial_number)
}
#if LANG_CXX11
inline void PortableBattery::set_sbds_serial_number(::std::string&& value) {
  
  sbds_serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortableBattery.sbds_serial_number)
}
#endif
inline void PortableBattery::set_sbds_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortableBattery.sbds_serial_number)
}
inline void PortableBattery::set_sbds_serial_number(const char* value, size_t size) {
  
  sbds_serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortableBattery.sbds_serial_number)
}
inline ::std::string* PortableBattery::mutable_sbds_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortableBattery.sbds_serial_number)
  return sbds_serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortableBattery::release_sbds_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortableBattery.sbds_serial_number)
  
  return sbds_serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortableBattery::set_allocated_sbds_serial_number(::std::string* sbds_serial_number) {
  if (sbds_serial_number != NULL) {
    
  } else {
    
  }
  sbds_serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortableBattery.sbds_serial_number)
}

// string sbds_manufacture_date = 12;
inline void PortableBattery::clear_sbds_manufacture_date() {
  sbds_manufacture_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortableBattery::sbds_manufacture_date() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.sbds_manufacture_date)
  return sbds_manufacture_date_.GetNoArena();
}
inline void PortableBattery::set_sbds_manufacture_date(const ::std::string& value) {
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.sbds_manufacture_date)
}
#if LANG_CXX11
inline void PortableBattery::set_sbds_manufacture_date(::std::string&& value) {
  
  sbds_manufacture_date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortableBattery.sbds_manufacture_date)
}
#endif
inline void PortableBattery::set_sbds_manufacture_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortableBattery.sbds_manufacture_date)
}
inline void PortableBattery::set_sbds_manufacture_date(const char* value, size_t size) {
  
  sbds_manufacture_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortableBattery.sbds_manufacture_date)
}
inline ::std::string* PortableBattery::mutable_sbds_manufacture_date() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortableBattery.sbds_manufacture_date)
  return sbds_manufacture_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortableBattery::release_sbds_manufacture_date() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortableBattery.sbds_manufacture_date)
  
  return sbds_manufacture_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortableBattery::set_allocated_sbds_manufacture_date(::std::string* sbds_manufacture_date) {
  if (sbds_manufacture_date != NULL) {
    
  } else {
    
  }
  sbds_manufacture_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_manufacture_date);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortableBattery.sbds_manufacture_date)
}

// string sbds_device_chemistry = 13;
inline void PortableBattery::clear_sbds_device_chemistry() {
  sbds_device_chemistry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PortableBattery::sbds_device_chemistry() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.PortableBattery.sbds_device_chemistry)
  return sbds_device_chemistry_.GetNoArena();
}
inline void PortableBattery::set_sbds_device_chemistry(const ::std::string& value) {
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.PortableBattery.sbds_device_chemistry)
}
#if LANG_CXX11
inline void PortableBattery::set_sbds_device_chemistry(::std::string&& value) {
  
  sbds_device_chemistry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.PortableBattery.sbds_device_chemistry)
}
#endif
inline void PortableBattery::set_sbds_device_chemistry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.PortableBattery.sbds_device_chemistry)
}
inline void PortableBattery::set_sbds_device_chemistry(const char* value, size_t size) {
  
  sbds_device_chemistry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.PortableBattery.sbds_device_chemistry)
}
inline ::std::string* PortableBattery::mutable_sbds_device_chemistry() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.PortableBattery.sbds_device_chemistry)
  return sbds_device_chemistry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PortableBattery::release_sbds_device_chemistry() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.PortableBattery.sbds_device_chemistry)
  
  return sbds_device_chemistry_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PortableBattery::set_allocated_sbds_device_chemistry(::std::string* sbds_device_chemistry) {
  if (sbds_device_chemistry != NULL) {
    
  } else {
    
  }
  sbds_device_chemistry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sbds_device_chemistry);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.PortableBattery.sbds_device_chemistry)
}

// -------------------------------------------------------------------

// Processor

// string manufacturer = 1;
inline void Processor::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processor::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void Processor::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.manufacturer)
}
#if LANG_CXX11
inline void Processor::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Processor.manufacturer)
}
#endif
inline void Processor::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Processor.manufacturer)
}
inline void Processor::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Processor.manufacturer)
}
inline ::std::string* Processor::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Processor.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processor::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Processor.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processor::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Processor.manufacturer)
}

// string version = 2;
inline void Processor::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processor::version() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.version)
  return version_.GetNoArena();
}
inline void Processor::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.version)
}
#if LANG_CXX11
inline void Processor::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Processor.version)
}
#endif
inline void Processor::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Processor.version)
}
inline void Processor::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Processor.version)
}
inline ::std::string* Processor::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Processor.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processor::release_version() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Processor.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processor::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Processor.version)
}

// string family = 3;
inline void Processor::clear_family() {
  family_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processor::family() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.family)
  return family_.GetNoArena();
}
inline void Processor::set_family(const ::std::string& value) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.family)
}
#if LANG_CXX11
inline void Processor::set_family(::std::string&& value) {
  
  family_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Processor.family)
}
#endif
inline void Processor::set_family(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Processor.family)
}
inline void Processor::set_family(const char* value, size_t size) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Processor.family)
}
inline ::std::string* Processor::mutable_family() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Processor.family)
  return family_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processor::release_family() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Processor.family)
  
  return family_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processor::set_allocated_family(::std::string* family) {
  if (family != NULL) {
    
  } else {
    
  }
  family_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Processor.family)
}

// .aspia.system_info.dmi.Processor.Type type = 4;
inline void Processor::clear_type() {
  type_ = 0;
}
inline ::aspia::system_info::dmi::Processor_Type Processor::type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.type)
  return static_cast< ::aspia::system_info::dmi::Processor_Type >(type_);
}
inline void Processor::set_type(::aspia::system_info::dmi::Processor_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.type)
}

// .aspia.system_info.dmi.Processor.Status status = 5;
inline void Processor::clear_status() {
  status_ = 0;
}
inline ::aspia::system_info::dmi::Processor_Status Processor::status() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.status)
  return static_cast< ::aspia::system_info::dmi::Processor_Status >(status_);
}
inline void Processor::set_status(::aspia::system_info::dmi::Processor_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.status)
}

// string socket = 6;
inline void Processor::clear_socket() {
  socket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processor::socket() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.socket)
  return socket_.GetNoArena();
}
inline void Processor::set_socket(const ::std::string& value) {
  
  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.socket)
}
#if LANG_CXX11
inline void Processor::set_socket(::std::string&& value) {
  
  socket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Processor.socket)
}
#endif
inline void Processor::set_socket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Processor.socket)
}
inline void Processor::set_socket(const char* value, size_t size) {
  
  socket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Processor.socket)
}
inline ::std::string* Processor::mutable_socket() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Processor.socket)
  return socket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processor::release_socket() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Processor.socket)
  
  return socket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processor::set_allocated_socket(::std::string* socket) {
  if (socket != NULL) {
    
  } else {
    
  }
  socket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), socket);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Processor.socket)
}

// string upgrade = 7;
inline void Processor::clear_upgrade() {
  upgrade_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processor::upgrade() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.upgrade)
  return upgrade_.GetNoArena();
}
inline void Processor::set_upgrade(const ::std::string& value) {
  
  upgrade_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.upgrade)
}
#if LANG_CXX11
inline void Processor::set_upgrade(::std::string&& value) {
  
  upgrade_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Processor.upgrade)
}
#endif
inline void Processor::set_upgrade(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  upgrade_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Processor.upgrade)
}
inline void Processor::set_upgrade(const char* value, size_t size) {
  
  upgrade_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Processor.upgrade)
}
inline ::std::string* Processor::mutable_upgrade() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Processor.upgrade)
  return upgrade_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processor::release_upgrade() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Processor.upgrade)
  
  return upgrade_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processor::set_allocated_upgrade(::std::string* upgrade) {
  if (upgrade != NULL) {
    
  } else {
    
  }
  upgrade_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), upgrade);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Processor.upgrade)
}

// int32 external_clock = 8;
inline void Processor::clear_external_clock() {
  external_clock_ = 0;
}
inline ::google::protobuf::int32 Processor::external_clock() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.external_clock)
  return external_clock_;
}
inline void Processor::set_external_clock(::google::protobuf::int32 value) {
  
  external_clock_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.external_clock)
}

// int32 current_speed = 9;
inline void Processor::clear_current_speed() {
  current_speed_ = 0;
}
inline ::google::protobuf::int32 Processor::current_speed() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.current_speed)
  return current_speed_;
}
inline void Processor::set_current_speed(::google::protobuf::int32 value) {
  
  current_speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.current_speed)
}

// int32 maximum_speed = 10;
inline void Processor::clear_maximum_speed() {
  maximum_speed_ = 0;
}
inline ::google::protobuf::int32 Processor::maximum_speed() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.maximum_speed)
  return maximum_speed_;
}
inline void Processor::set_maximum_speed(::google::protobuf::int32 value) {
  
  maximum_speed_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.maximum_speed)
}

// double voltage = 11;
inline void Processor::clear_voltage() {
  voltage_ = 0;
}
inline double Processor::voltage() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.voltage)
  return voltage_;
}
inline void Processor::set_voltage(double value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.voltage)
}

// string serial_number = 12;
inline void Processor::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processor::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.serial_number)
  return serial_number_.GetNoArena();
}
inline void Processor::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.serial_number)
}
#if LANG_CXX11
inline void Processor::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Processor.serial_number)
}
#endif
inline void Processor::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Processor.serial_number)
}
inline void Processor::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Processor.serial_number)
}
inline ::std::string* Processor::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Processor.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processor::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Processor.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processor::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Processor.serial_number)
}

// string asset_tag = 13;
inline void Processor::clear_asset_tag() {
  asset_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processor::asset_tag() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.asset_tag)
  return asset_tag_.GetNoArena();
}
inline void Processor::set_asset_tag(const ::std::string& value) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.asset_tag)
}
#if LANG_CXX11
inline void Processor::set_asset_tag(::std::string&& value) {
  
  asset_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Processor.asset_tag)
}
#endif
inline void Processor::set_asset_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Processor.asset_tag)
}
inline void Processor::set_asset_tag(const char* value, size_t size) {
  
  asset_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Processor.asset_tag)
}
inline ::std::string* Processor::mutable_asset_tag() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Processor.asset_tag)
  return asset_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processor::release_asset_tag() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Processor.asset_tag)
  
  return asset_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processor::set_allocated_asset_tag(::std::string* asset_tag) {
  if (asset_tag != NULL) {
    
  } else {
    
  }
  asset_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_tag);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Processor.asset_tag)
}

// string part_number = 14;
inline void Processor::clear_part_number() {
  part_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Processor::part_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.part_number)
  return part_number_.GetNoArena();
}
inline void Processor::set_part_number(const ::std::string& value) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.part_number)
}
#if LANG_CXX11
inline void Processor::set_part_number(::std::string&& value) {
  
  part_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.Processor.part_number)
}
#endif
inline void Processor::set_part_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.Processor.part_number)
}
inline void Processor::set_part_number(const char* value, size_t size) {
  
  part_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.Processor.part_number)
}
inline ::std::string* Processor::mutable_part_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Processor.part_number)
  return part_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Processor::release_part_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.Processor.part_number)
  
  return part_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Processor::set_allocated_part_number(::std::string* part_number) {
  if (part_number != NULL) {
    
  } else {
    
  }
  part_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), part_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.Processor.part_number)
}

// int32 core_count = 15;
inline void Processor::clear_core_count() {
  core_count_ = 0;
}
inline ::google::protobuf::int32 Processor::core_count() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.core_count)
  return core_count_;
}
inline void Processor::set_core_count(::google::protobuf::int32 value) {
  
  core_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.core_count)
}

// int32 core_enabled = 16;
inline void Processor::clear_core_enabled() {
  core_enabled_ = 0;
}
inline ::google::protobuf::int32 Processor::core_enabled() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.core_enabled)
  return core_enabled_;
}
inline void Processor::set_core_enabled(::google::protobuf::int32 value) {
  
  core_enabled_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.core_enabled)
}

// int32 thread_count = 17;
inline void Processor::clear_thread_count() {
  thread_count_ = 0;
}
inline ::google::protobuf::int32 Processor::thread_count() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.thread_count)
  return thread_count_;
}
inline void Processor::set_thread_count(::google::protobuf::int32 value) {
  
  thread_count_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.thread_count)
}

// uint32 characteristics = 18;
inline void Processor::clear_characteristics() {
  characteristics_ = 0u;
}
inline ::google::protobuf::uint32 Processor::characteristics() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Processor.characteristics)
  return characteristics_;
}
inline void Processor::set_characteristics(::google::protobuf::uint32 value) {
  
  characteristics_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.Processor.characteristics)
}

// -------------------------------------------------------------------

// System

// string manufacturer = 1;
inline void System::clear_manufacturer() {
  manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& System::manufacturer() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.System.manufacturer)
  return manufacturer_.GetNoArena();
}
inline void System::set_manufacturer(const ::std::string& value) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.System.manufacturer)
}
#if LANG_CXX11
inline void System::set_manufacturer(::std::string&& value) {
  
  manufacturer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.System.manufacturer)
}
#endif
inline void System::set_manufacturer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.System.manufacturer)
}
inline void System::set_manufacturer(const char* value, size_t size) {
  
  manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.System.manufacturer)
}
inline ::std::string* System::mutable_manufacturer() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.System.manufacturer)
  return manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* System::release_manufacturer() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.System.manufacturer)
  
  return manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void System::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer != NULL) {
    
  } else {
    
  }
  manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), manufacturer);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.System.manufacturer)
}

// string product_name = 2;
inline void System::clear_product_name() {
  product_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& System::product_name() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.System.product_name)
  return product_name_.GetNoArena();
}
inline void System::set_product_name(const ::std::string& value) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.System.product_name)
}
#if LANG_CXX11
inline void System::set_product_name(::std::string&& value) {
  
  product_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.System.product_name)
}
#endif
inline void System::set_product_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.System.product_name)
}
inline void System::set_product_name(const char* value, size_t size) {
  
  product_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.System.product_name)
}
inline ::std::string* System::mutable_product_name() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.System.product_name)
  return product_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* System::release_product_name() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.System.product_name)
  
  return product_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void System::set_allocated_product_name(::std::string* product_name) {
  if (product_name != NULL) {
    
  } else {
    
  }
  product_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), product_name);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.System.product_name)
}

// string version = 3;
inline void System::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& System::version() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.System.version)
  return version_.GetNoArena();
}
inline void System::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.System.version)
}
#if LANG_CXX11
inline void System::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.System.version)
}
#endif
inline void System::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.System.version)
}
inline void System::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.System.version)
}
inline ::std::string* System::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.System.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* System::release_version() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.System.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void System::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.System.version)
}

// string serial_number = 4;
inline void System::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& System::serial_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.System.serial_number)
  return serial_number_.GetNoArena();
}
inline void System::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.System.serial_number)
}
#if LANG_CXX11
inline void System::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.System.serial_number)
}
#endif
inline void System::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.System.serial_number)
}
inline void System::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.System.serial_number)
}
inline ::std::string* System::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.System.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* System::release_serial_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.System.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void System::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.System.serial_number)
}

// string uuid = 5;
inline void System::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& System::uuid() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.System.uuid)
  return uuid_.GetNoArena();
}
inline void System::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.System.uuid)
}
#if LANG_CXX11
inline void System::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.System.uuid)
}
#endif
inline void System::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.System.uuid)
}
inline void System::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.System.uuid)
}
inline ::std::string* System::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.System.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* System::release_uuid() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.System.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void System::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.System.uuid)
}

// .aspia.system_info.dmi.System.WakeupType wakeup_type = 6;
inline void System::clear_wakeup_type() {
  wakeup_type_ = 0;
}
inline ::aspia::system_info::dmi::System_WakeupType System::wakeup_type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.System.wakeup_type)
  return static_cast< ::aspia::system_info::dmi::System_WakeupType >(wakeup_type_);
}
inline void System::set_wakeup_type(::aspia::system_info::dmi::System_WakeupType value) {
  
  wakeup_type_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.System.wakeup_type)
}

// string sku_number = 7;
inline void System::clear_sku_number() {
  sku_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& System::sku_number() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.System.sku_number)
  return sku_number_.GetNoArena();
}
inline void System::set_sku_number(const ::std::string& value) {
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.System.sku_number)
}
#if LANG_CXX11
inline void System::set_sku_number(::std::string&& value) {
  
  sku_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.System.sku_number)
}
#endif
inline void System::set_sku_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.System.sku_number)
}
inline void System::set_sku_number(const char* value, size_t size) {
  
  sku_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.System.sku_number)
}
inline ::std::string* System::mutable_sku_number() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.System.sku_number)
  return sku_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* System::release_sku_number() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.System.sku_number)
  
  return sku_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void System::set_allocated_sku_number(::std::string* sku_number) {
  if (sku_number != NULL) {
    
  } else {
    
  }
  sku_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sku_number);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.System.sku_number)
}

// string family = 8;
inline void System::clear_family() {
  family_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& System::family() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.System.family)
  return family_.GetNoArena();
}
inline void System::set_family(const ::std::string& value) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.System.family)
}
#if LANG_CXX11
inline void System::set_family(::std::string&& value) {
  
  family_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.System.family)
}
#endif
inline void System::set_family(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.System.family)
}
inline void System::set_family(const char* value, size_t size) {
  
  family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.System.family)
}
inline ::std::string* System::mutable_family() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.System.family)
  return family_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* System::release_family() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.System.family)
  
  return family_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void System::set_allocated_family(::std::string* family) {
  if (family != NULL) {
    
  } else {
    
  }
  family_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.System.family)
}

// -------------------------------------------------------------------

// SystemSlot

// string slot_designation = 1;
inline void SystemSlot::clear_slot_designation() {
  slot_designation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SystemSlot::slot_designation() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.SystemSlot.slot_designation)
  return slot_designation_.GetNoArena();
}
inline void SystemSlot::set_slot_designation(const ::std::string& value) {
  
  slot_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.SystemSlot.slot_designation)
}
#if LANG_CXX11
inline void SystemSlot::set_slot_designation(::std::string&& value) {
  
  slot_designation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.SystemSlot.slot_designation)
}
#endif
inline void SystemSlot::set_slot_designation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  slot_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.SystemSlot.slot_designation)
}
inline void SystemSlot::set_slot_designation(const char* value, size_t size) {
  
  slot_designation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.SystemSlot.slot_designation)
}
inline ::std::string* SystemSlot::mutable_slot_designation() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.SystemSlot.slot_designation)
  return slot_designation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemSlot::release_slot_designation() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.SystemSlot.slot_designation)
  
  return slot_designation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemSlot::set_allocated_slot_designation(::std::string* slot_designation) {
  if (slot_designation != NULL) {
    
  } else {
    
  }
  slot_designation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), slot_designation);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.SystemSlot.slot_designation)
}

// string type = 2;
inline void SystemSlot::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SystemSlot::type() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.SystemSlot.type)
  return type_.GetNoArena();
}
inline void SystemSlot::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.SystemSlot.type)
}
#if LANG_CXX11
inline void SystemSlot::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:aspia.system_info.dmi.SystemSlot.type)
}
#endif
inline void SystemSlot::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:aspia.system_info.dmi.SystemSlot.type)
}
inline void SystemSlot::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:aspia.system_info.dmi.SystemSlot.type)
}
inline ::std::string* SystemSlot::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.SystemSlot.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemSlot::release_type() {
  // @@protoc_insertion_point(field_release:aspia.system_info.dmi.SystemSlot.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemSlot::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:aspia.system_info.dmi.SystemSlot.type)
}

// .aspia.system_info.dmi.SystemSlot.Usage usage = 3;
inline void SystemSlot::clear_usage() {
  usage_ = 0;
}
inline ::aspia::system_info::dmi::SystemSlot_Usage SystemSlot::usage() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.SystemSlot.usage)
  return static_cast< ::aspia::system_info::dmi::SystemSlot_Usage >(usage_);
}
inline void SystemSlot::set_usage(::aspia::system_info::dmi::SystemSlot_Usage value) {
  
  usage_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.SystemSlot.usage)
}

// .aspia.system_info.dmi.SystemSlot.BusWidth bus_width = 4;
inline void SystemSlot::clear_bus_width() {
  bus_width_ = 0;
}
inline ::aspia::system_info::dmi::SystemSlot_BusWidth SystemSlot::bus_width() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.SystemSlot.bus_width)
  return static_cast< ::aspia::system_info::dmi::SystemSlot_BusWidth >(bus_width_);
}
inline void SystemSlot::set_bus_width(::aspia::system_info::dmi::SystemSlot_BusWidth value) {
  
  bus_width_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.SystemSlot.bus_width)
}

// .aspia.system_info.dmi.SystemSlot.Length length = 5;
inline void SystemSlot::clear_length() {
  length_ = 0;
}
inline ::aspia::system_info::dmi::SystemSlot_Length SystemSlot::length() const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.SystemSlot.length)
  return static_cast< ::aspia::system_info::dmi::SystemSlot_Length >(length_);
}
inline void SystemSlot::set_length(::aspia::system_info::dmi::SystemSlot_Length value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:aspia.system_info.dmi.SystemSlot.length)
}

// -------------------------------------------------------------------

// Dmi

// repeated .aspia.system_info.dmi.Bios bios = 1;
inline int Dmi::bios_size() const {
  return bios_.size();
}
inline void Dmi::clear_bios() {
  bios_.Clear();
}
inline ::aspia::system_info::dmi::Bios* Dmi::mutable_bios(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Dmi.bios)
  return bios_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Bios >*
Dmi::mutable_bios() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.dmi.Dmi.bios)
  return &bios_;
}
inline const ::aspia::system_info::dmi::Bios& Dmi::bios(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Dmi.bios)
  return bios_.Get(index);
}
inline ::aspia::system_info::dmi::Bios* Dmi::add_bios() {
  // @@protoc_insertion_point(field_add:aspia.system_info.dmi.Dmi.bios)
  return bios_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Bios >&
Dmi::bios() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.dmi.Dmi.bios)
  return bios_;
}

// repeated .aspia.system_info.dmi.Cache cache = 2;
inline int Dmi::cache_size() const {
  return cache_.size();
}
inline void Dmi::clear_cache() {
  cache_.Clear();
}
inline ::aspia::system_info::dmi::Cache* Dmi::mutable_cache(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Dmi.cache)
  return cache_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Cache >*
Dmi::mutable_cache() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.dmi.Dmi.cache)
  return &cache_;
}
inline const ::aspia::system_info::dmi::Cache& Dmi::cache(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Dmi.cache)
  return cache_.Get(index);
}
inline ::aspia::system_info::dmi::Cache* Dmi::add_cache() {
  // @@protoc_insertion_point(field_add:aspia.system_info.dmi.Dmi.cache)
  return cache_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Cache >&
Dmi::cache() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.dmi.Dmi.cache)
  return cache_;
}

// repeated .aspia.system_info.dmi.Chassis chassis = 3;
inline int Dmi::chassis_size() const {
  return chassis_.size();
}
inline void Dmi::clear_chassis() {
  chassis_.Clear();
}
inline ::aspia::system_info::dmi::Chassis* Dmi::mutable_chassis(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Dmi.chassis)
  return chassis_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Chassis >*
Dmi::mutable_chassis() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.dmi.Dmi.chassis)
  return &chassis_;
}
inline const ::aspia::system_info::dmi::Chassis& Dmi::chassis(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Dmi.chassis)
  return chassis_.Get(index);
}
inline ::aspia::system_info::dmi::Chassis* Dmi::add_chassis() {
  // @@protoc_insertion_point(field_add:aspia.system_info.dmi.Dmi.chassis)
  return chassis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Chassis >&
Dmi::chassis() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.dmi.Dmi.chassis)
  return chassis_;
}

// repeated .aspia.system_info.dmi.MemoryDevice memory_device = 4;
inline int Dmi::memory_device_size() const {
  return memory_device_.size();
}
inline void Dmi::clear_memory_device() {
  memory_device_.Clear();
}
inline ::aspia::system_info::dmi::MemoryDevice* Dmi::mutable_memory_device(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Dmi.memory_device)
  return memory_device_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::MemoryDevice >*
Dmi::mutable_memory_device() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.dmi.Dmi.memory_device)
  return &memory_device_;
}
inline const ::aspia::system_info::dmi::MemoryDevice& Dmi::memory_device(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Dmi.memory_device)
  return memory_device_.Get(index);
}
inline ::aspia::system_info::dmi::MemoryDevice* Dmi::add_memory_device() {
  // @@protoc_insertion_point(field_add:aspia.system_info.dmi.Dmi.memory_device)
  return memory_device_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::MemoryDevice >&
Dmi::memory_device() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.dmi.Dmi.memory_device)
  return memory_device_;
}

// repeated .aspia.system_info.dmi.OnBoardDevice onboard_device = 5;
inline int Dmi::onboard_device_size() const {
  return onboard_device_.size();
}
inline void Dmi::clear_onboard_device() {
  onboard_device_.Clear();
}
inline ::aspia::system_info::dmi::OnBoardDevice* Dmi::mutable_onboard_device(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Dmi.onboard_device)
  return onboard_device_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::OnBoardDevice >*
Dmi::mutable_onboard_device() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.dmi.Dmi.onboard_device)
  return &onboard_device_;
}
inline const ::aspia::system_info::dmi::OnBoardDevice& Dmi::onboard_device(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Dmi.onboard_device)
  return onboard_device_.Get(index);
}
inline ::aspia::system_info::dmi::OnBoardDevice* Dmi::add_onboard_device() {
  // @@protoc_insertion_point(field_add:aspia.system_info.dmi.Dmi.onboard_device)
  return onboard_device_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::OnBoardDevice >&
Dmi::onboard_device() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.dmi.Dmi.onboard_device)
  return onboard_device_;
}

// repeated .aspia.system_info.dmi.PointingDevice pointing_device = 6;
inline int Dmi::pointing_device_size() const {
  return pointing_device_.size();
}
inline void Dmi::clear_pointing_device() {
  pointing_device_.Clear();
}
inline ::aspia::system_info::dmi::PointingDevice* Dmi::mutable_pointing_device(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Dmi.pointing_device)
  return pointing_device_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PointingDevice >*
Dmi::mutable_pointing_device() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.dmi.Dmi.pointing_device)
  return &pointing_device_;
}
inline const ::aspia::system_info::dmi::PointingDevice& Dmi::pointing_device(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Dmi.pointing_device)
  return pointing_device_.Get(index);
}
inline ::aspia::system_info::dmi::PointingDevice* Dmi::add_pointing_device() {
  // @@protoc_insertion_point(field_add:aspia.system_info.dmi.Dmi.pointing_device)
  return pointing_device_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PointingDevice >&
Dmi::pointing_device() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.dmi.Dmi.pointing_device)
  return pointing_device_;
}

// repeated .aspia.system_info.dmi.PortConnector port_connector = 7;
inline int Dmi::port_connector_size() const {
  return port_connector_.size();
}
inline void Dmi::clear_port_connector() {
  port_connector_.Clear();
}
inline ::aspia::system_info::dmi::PortConnector* Dmi::mutable_port_connector(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Dmi.port_connector)
  return port_connector_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PortConnector >*
Dmi::mutable_port_connector() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.dmi.Dmi.port_connector)
  return &port_connector_;
}
inline const ::aspia::system_info::dmi::PortConnector& Dmi::port_connector(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Dmi.port_connector)
  return port_connector_.Get(index);
}
inline ::aspia::system_info::dmi::PortConnector* Dmi::add_port_connector() {
  // @@protoc_insertion_point(field_add:aspia.system_info.dmi.Dmi.port_connector)
  return port_connector_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PortConnector >&
Dmi::port_connector() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.dmi.Dmi.port_connector)
  return port_connector_;
}

// repeated .aspia.system_info.dmi.PortableBattery portable_battery = 8;
inline int Dmi::portable_battery_size() const {
  return portable_battery_.size();
}
inline void Dmi::clear_portable_battery() {
  portable_battery_.Clear();
}
inline ::aspia::system_info::dmi::PortableBattery* Dmi::mutable_portable_battery(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Dmi.portable_battery)
  return portable_battery_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PortableBattery >*
Dmi::mutable_portable_battery() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.dmi.Dmi.portable_battery)
  return &portable_battery_;
}
inline const ::aspia::system_info::dmi::PortableBattery& Dmi::portable_battery(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Dmi.portable_battery)
  return portable_battery_.Get(index);
}
inline ::aspia::system_info::dmi::PortableBattery* Dmi::add_portable_battery() {
  // @@protoc_insertion_point(field_add:aspia.system_info.dmi.Dmi.portable_battery)
  return portable_battery_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::PortableBattery >&
Dmi::portable_battery() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.dmi.Dmi.portable_battery)
  return portable_battery_;
}

// repeated .aspia.system_info.dmi.Processor processor = 9;
inline int Dmi::processor_size() const {
  return processor_.size();
}
inline void Dmi::clear_processor() {
  processor_.Clear();
}
inline ::aspia::system_info::dmi::Processor* Dmi::mutable_processor(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Dmi.processor)
  return processor_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Processor >*
Dmi::mutable_processor() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.dmi.Dmi.processor)
  return &processor_;
}
inline const ::aspia::system_info::dmi::Processor& Dmi::processor(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Dmi.processor)
  return processor_.Get(index);
}
inline ::aspia::system_info::dmi::Processor* Dmi::add_processor() {
  // @@protoc_insertion_point(field_add:aspia.system_info.dmi.Dmi.processor)
  return processor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::Processor >&
Dmi::processor() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.dmi.Dmi.processor)
  return processor_;
}

// repeated .aspia.system_info.dmi.System system = 10;
inline int Dmi::system_size() const {
  return system_.size();
}
inline void Dmi::clear_system() {
  system_.Clear();
}
inline ::aspia::system_info::dmi::System* Dmi::mutable_system(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Dmi.system)
  return system_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::System >*
Dmi::mutable_system() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.dmi.Dmi.system)
  return &system_;
}
inline const ::aspia::system_info::dmi::System& Dmi::system(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Dmi.system)
  return system_.Get(index);
}
inline ::aspia::system_info::dmi::System* Dmi::add_system() {
  // @@protoc_insertion_point(field_add:aspia.system_info.dmi.Dmi.system)
  return system_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::System >&
Dmi::system() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.dmi.Dmi.system)
  return system_;
}

// repeated .aspia.system_info.dmi.SystemSlot system_slot = 11;
inline int Dmi::system_slot_size() const {
  return system_slot_.size();
}
inline void Dmi::clear_system_slot() {
  system_slot_.Clear();
}
inline ::aspia::system_info::dmi::SystemSlot* Dmi::mutable_system_slot(int index) {
  // @@protoc_insertion_point(field_mutable:aspia.system_info.dmi.Dmi.system_slot)
  return system_slot_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::SystemSlot >*
Dmi::mutable_system_slot() {
  // @@protoc_insertion_point(field_mutable_list:aspia.system_info.dmi.Dmi.system_slot)
  return &system_slot_;
}
inline const ::aspia::system_info::dmi::SystemSlot& Dmi::system_slot(int index) const {
  // @@protoc_insertion_point(field_get:aspia.system_info.dmi.Dmi.system_slot)
  return system_slot_.Get(index);
}
inline ::aspia::system_info::dmi::SystemSlot* Dmi::add_system_slot() {
  // @@protoc_insertion_point(field_add:aspia.system_info.dmi.Dmi.system_slot)
  return system_slot_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::aspia::system_info::dmi::SystemSlot >&
Dmi::system_slot() const {
  // @@protoc_insertion_point(field_list:aspia.system_info.dmi.Dmi.system_slot)
  return system_slot_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dmi
}  // namespace system_info
}  // namespace aspia

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aspia::system_info::dmi::Cache_Location> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::Cache_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::Cache_Mode> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::Cache_SRAMType> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::Cache_ErrorCorrectionType> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::Cache_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::Cache_Associativity> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::Chassis_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::Chassis_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::Chassis_SecurityStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::OnBoardDevice_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::PointingDevice_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::PointingDevice_Interface> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::PortableBattery_Chemistry> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::Processor_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::Processor_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::Processor_Characteristics> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::System_WakeupType> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::SystemSlot_Usage> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::SystemSlot_BusWidth> : ::std::true_type {};
template <> struct is_proto_enum< ::aspia::system_info::dmi::SystemSlot_Length> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_dmi_2eproto
